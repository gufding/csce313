
vga.elf:     file format elf32-littlenios2
vga.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000244

Program Header:
    LOAD off    0x00001000 vaddr 0x08000000 paddr 0x08000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x08000020 paddr 0x08000020 align 2**12
         filesz 0x00040b38 memsz 0x00040b38 flags r-x
    LOAD off    0x00041b58 vaddr 0x08040b58 paddr 0x080426a4 align 2**12
         filesz 0x00001b4c memsz 0x00001b4c flags rw-
    LOAD off    0x000441f0 vaddr 0x080441f0 paddr 0x080441f0 align 2**12
         filesz 0x00000000 memsz 0x00000160 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  08000000  08000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000224  08000020  08000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000083e0  08000244  08000244  00001244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00038534  08008624  08008624  00009624  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b4c  08040b58  080426a4  00041b58  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000160  080441f0  080441f0  000441f0  2**2
                  ALLOC, SMALL_DATA
  6 .sdram_controller_0 00000000  08044350  08044350  000436a4  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000436a4  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000a30  00000000  00000000  000436c8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00015da2  00000000  00000000  000440f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00005828  00000000  00000000  00059e9a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00006b41  00000000  00000000  0005f6c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  0000193c  00000000  00000000  00066204  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003061  00000000  00000000  00067b40  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000004ce  00000000  00000000  0006aba1  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000030  00000000  00000000  0006b070  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000418  00000000  00000000  0006b0a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0006dd62  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  0006dd65  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0006dd71  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0006dd72  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   00000004  00000000  00000000  0006dd73  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    00000004  00000000  00000000  0006dd77  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   00000004  00000000  00000000  0006dd7b  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000b  00000000  00000000  0006dd7f  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000001a  00000000  00000000  0006dd8a  2**0
                  CONTENTS, READONLY
 26 .jdi          00005174  00000000  00000000  0006dda4  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0006f578  00000000  00000000  00072f18  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
08000000 l    d  .entry	00000000 .entry
08000020 l    d  .exceptions	00000000 .exceptions
08000244 l    d  .text	00000000 .text
08008624 l    d  .rodata	00000000 .rodata
08040b58 l    d  .rwdata	00000000 .rwdata
080441f0 l    d  .bss	00000000 .bss
08044350 l    d  .sdram_controller_0	00000000 .sdram_controller_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../vga_bsp//obj/HAL/src/crt0.o
0800028c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 myfile.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 findfp.c
08000624 l     F .text	000000f4 std
080441f0 l     O .bss	00000004 __sfp_lock
080441f4 l     O .bss	00000004 __sinit_lock
08000b20 l     F .text	00000024 __fp_lock
08000b44 l     F .text	00000024 __fp_unlock
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
08040b58 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
08001378 l     F .text	000003b4 malloc_extend_top
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_close.c
08004ce4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
08004df0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
08004e1c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
08004f08 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
08004fe8 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
080050d4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0800528c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
08042694 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_write.c
0800567c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
080057b0 l     F .text	00000034 alt_dev_reg
0804152c l     O .rwdata	00001060 jtag_uart_0
0804258c l     O .rwdata	00000048 video_character_buffer_with_dma_0
080425d4 l     O .rwdata	00000054 video_pixel_buffer_dma_0
08042628 l     O .rwdata	00000044 video_rgb_resampler_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
08005dfc l     F .text	0000020c altera_avalon_jtag_uart_irq
08006008 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_character_buffer_with_dma.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_pixel_buffer_dma.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
08007948 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
08044224 l     O .bss	00000004 __atexit_lock
00000000 l    df *ABS*	00000000 alt_exit.c
08044220 g     O .bss	00000004 alt_instruction_exception_handler
08004ad0 g     F .text	00000060 _isatty_r
080051e4 g     F .text	00000060 alt_main
080071f4 g     F .text	0000024c alt_up_pixel_buffer_dma_draw_vline
080003e0 g     F .text	00000118 _puts_r
08044250 g     O .bss	00000100 alt_irq
0800475c g     F .text	00000070 _lseek_r
080426a4 g       *ABS*	00000000 __flash_rwdata_start
08000290 g     F .text	00000034 measuringFrameRate
08044350 g       *ABS*	00000000 __alt_heap_start
08003788 g     F .text	000000a0 __sseek
080009c8 g     F .text	000000d8 __sinit
080067c8 g     F .text	000000fc alt_up_char_buffer_string
08000718 g     F .text	000000a4 __sfmoreglue
08005268 g     F .text	00000024 __malloc_unlock
080066fc g     F .text	000000cc alt_up_char_buffer_draw
080025ec g     F .text	00000208 memmove
08000994 g     F .text	00000034 _cleanup
0800695c g     F .text	00000194 alt_up_pixel_buffer_dma_draw
08007e4c g     F .text	00000024 altera_nios2_gen2_irq_init
08006920 g     F .text	0000003c alt_up_pixel_buffer_dma_open_dev
08000000 g     F .entry	0000001c __reset
08000020 g       *ABS*	00000000 __flash_exceptions_start
08004a68 g     F .text	00000068 _fstat_r
08044204 g     O .bss	00000004 errno
080036a4 g     F .text	00000030 __seofread
0804420c g     O .bss	00000004 alt_argv
0804a66c g       *ABS*	00000000 _gp
08006af0 g     F .text	0000005c alt_up_pixel_buffer_dma_change_back_buffer_address
080413ac g     O .rwdata	00000180 alt_fd_list
08007ae8 g     F .text	00000090 alt_find_dev
08002464 g     F .text	00000188 memcpy
080068c4 g     F .text	0000005c alt_up_char_buffer_clear
08000950 g     F .text	00000044 _cleanup_r
08008624 g       *ABS*	00000000 __DTOR_END__
080004f8 g     F .text	00000038 puts
08007f00 g     F .text	0000009c alt_exception_cause_generated_bad_addr
08006bac g     F .text	00000034 alt_up_pixel_buffer_dma_check_swap_buffers_status
08006200 g     F .text	0000021c altera_avalon_jtag_uart_read
08004c28 g     F .text	00000064 .hidden __udivsi3
08004f44 g     F .text	000000a4 isatty
08006fe4 g     F .text	00000210 alt_up_pixel_buffer_dma_draw_hline
08007e70 g     F .text	00000090 alt_icache_flush
080441f8 g     O .bss	00000004 __malloc_top_pad
08000be8 g     F .text	000005dc __sfvwrite_r
080035a8 g     F .text	00000060 _sbrk_r
08007508 g     F .text	00000084 helper_plot_pixel
080049f8 g     F .text	00000070 _read_r
0804268c g     O .rwdata	00000004 alt_max_fd
08003aec g     F .text	0000012c _fclose_r
08003fdc g     F .text	00000054 fflush
080441fc g     O .bss	00000004 __malloc_max_sbrked_mem
08006be0 g     F .text	00000128 alt_up_pixel_buffer_dma_clear_screen
08005110 g     F .text	000000d4 lseek
08000000 g       *ABS*	00000000 __alt_mem_sdram_controller_0
08042670 g     O .rwdata	00000004 _global_impure_ptr
080029b8 g     F .text	00000bf0 _realloc_r
08044350 g       *ABS*	00000000 __bss_end
08007d5c g     F .text	000000f0 alt_iic_isr_register
08006d08 g     F .text	000002dc alt_up_pixel_buffer_dma_draw_box
08005574 g     F .text	00000108 alt_tick
08000b68 g     F .text	00000040 __fp_lock_all
08007d10 g     F .text	0000004c alt_ic_irq_enabled
080054d8 g     F .text	0000009c alt_alarm_stop
08008696 g     O .rodata	00038401 myimage
0804421c g     O .bss	00000004 alt_irq_active
080000fc g     F .exceptions	000000d4 alt_irq_handler
08041384 g     O .rwdata	00000028 alt_dev_null
08007900 g     F .text	00000048 alt_dcache_flush_all
08007440 g     F .text	000000c8 alt_up_pixel_buffer_dma_draw_rectangle
080426a4 g       *ABS*	00000000 __ram_rwdata_end
08042684 g     O .rwdata	00000008 alt_dev_list
080056b8 g     F .text	000000f8 write
0800758c g     F .text	00000248 alt_up_pixel_buffer_dma_draw_line
08040b58 g       *ABS*	00000000 __ram_rodata_end
08004e58 g     F .text	000000b0 fstat
08004c8c g     F .text	00000058 .hidden __umodsi3
08044350 g       *ABS*	00000000 end
08006640 g     F .text	00000080 alt_up_char_buffer_init
08005d3c g     F .text	000000c0 altera_avalon_jtag_uart_init
080001d0 g     F .exceptions	00000074 alt_instruction_exception_entry
08008624 g       *ABS*	00000000 __CTOR_LIST__
10000000 g       *ABS*	00000000 __alt_stack_pointer
0800641c g     F .text	00000224 altera_avalon_jtag_uart_write
08000aa0 g     F .text	00000020 __sfp_lock_acquire
080022a8 g     F .text	000001bc memchr
08004030 g     F .text	00000560 _free_r
08008404 g     F .text	000001ec __call_exitprocs
08042678 g     O .rwdata	00000004 __malloc_sbrk_base
08000244 g     F .text	0000004c _start
08044214 g     O .bss	00000004 _alt_tick_rate
08044218 g     O .bss	00000004 _alt_nticks
080052c8 g     F .text	000000fc read
08000334 g     F .text	00000068 displayImage
0800581c g     F .text	000003bc alt_sys_init
08008294 g     F .text	00000170 __register_exitproc
080060a8 g     F .text	00000068 altera_avalon_jtag_uart_close
08040b58 g       *ABS*	00000000 __ram_rwdata_start
08008624 g       *ABS*	00000000 __ram_rodata_start
08044228 g     O .bss	00000028 __malloc_current_mallinfo
08005bd8 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
080002c4 g     F .text	00000070 displayFrameRate
08003a8c g     F .text	00000060 _close_r
08008020 g     F .text	00000134 memcmp
08005c98 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
08044350 g       *ABS*	00000000 __alt_stack_base
08005ce8 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
080038ec g     F .text	000001a0 __swsetup_r
080007bc g     F .text	00000194 __sfp
08040f7c g     O .rwdata	00000408 __malloc_av_
08000b00 g     F .text	00000020 __sinit_lock_release
08003608 g     F .text	0000009c __sread
08007984 g     F .text	000000a4 alt_dev_llist_insert
08005244 g     F .text	00000024 __malloc_lock
08005428 g     F .text	000000b0 sbrk
08003f54 g     F .text	00000088 _fflush_r
080441f0 g       *ABS*	00000000 __bss_start
080027f4 g     F .text	000001c4 memset
0800039c g     F .text	00000044 main
08044210 g     O .bss	00000004 alt_envp
08044200 g     O .bss	00000004 __malloc_max_total_mem
08006b4c g     F .text	00000060 alt_up_pixel_buffer_dma_swap_buffers
080066c0 g     F .text	0000003c alt_up_char_buffer_open_dev
08005c38 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08003828 g     F .text	00000054 __sclose
10000000 g       *ABS*	00000000 __alt_heap_limit
08003c18 g     F .text	00000038 fclose
0800172c g     F .text	00000b7c _malloc_r
08042690 g     O .rwdata	00000004 alt_errno
080011c4 g     F .text	000000d8 _fwalk
08004b30 g     F .text	00000084 .hidden __divsi3
08004590 g     F .text	000001cc _malloc_trim_r
08008624 g       *ABS*	00000000 __CTOR_END__
08008154 g     F .text	00000140 strcmp
08008624 g       *ABS*	00000000 __flash_rodata_start
08008624 g       *ABS*	00000000 __DTOR_LIST__
080057e4 g     F .text	00000038 alt_irq_init
080053c4 g     F .text	00000064 alt_release_fd
08007f9c g     F .text	0000003c atexit
0800387c g     F .text	00000070 _write_r
0804266c g     O .rwdata	00000004 _impure_ptr
08044208 g     O .bss	00000004 alt_argc
08003c50 g     F .text	00000304 __sflush_r
08007a88 g     F .text	00000060 _do_dtors
08000020 g       .exceptions	00000000 alt_irq_entry
08000ba8 g     F .text	00000040 __fp_unlock_all
0804267c g     O .rwdata	00000008 alt_fs_list
08000020 g       *ABS*	00000000 __ram_exceptions_start
08007bac g     F .text	00000050 alt_ic_isr_register
080426a4 g       *ABS*	00000000 _edata
08044350 g       *ABS*	00000000 _end
08000244 g       *ABS*	00000000 __ram_exceptions_end
08006110 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
08007c84 g     F .text	0000008c alt_ic_irq_disable
080036d4 g     F .text	000000b4 __swrite
08042674 g     O .rwdata	00000004 __malloc_trim_threshold
08007fd8 g     F .text	00000048 exit
0800129c g     F .text	000000dc _fwalk_reent
08004bb4 g     F .text	00000074 .hidden __modsi3
10000000 g       *ABS*	00000000 __alt_data_end
08000020 g     F .exceptions	00000000 alt_exception
08000ac0 g     F .text	00000020 __sfp_lock_release
080085f0 g     F .text	00000034 _exit
080077d4 g     F .text	0000012c alt_alarm_start
080047cc g     F .text	0000022c __smakebuf_r
08000530 g     F .text	000000f4 strlen
08007b78 g     F .text	00000034 alt_icache_flush_all
080426a0 g     O .rwdata	00000004 alt_priority_mask
08007bfc g     F .text	00000088 alt_ic_irq_enable
08042698 g     O .rwdata	00000008 alt_alarm_list
08007a28 g     F .text	00000060 _do_ctors
08004d20 g     F .text	000000d0 close
08005050 g     F .text	00000084 alt_load
08000ae0 g     F .text	00000020 __sinit_lock_acquire



Disassembly of section .entry:

08000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 8000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 8000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 8000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 800000c:	00bffd16 	blt	zero,r2,8000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 8000010:	00420034 	movhi	at,2048
    ori r1, r1, %lo(_start)
 8000014:	08409114 	ori	at,at,580
    jmp r1
 8000018:	0800683a 	jmp	at
 800001c:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>

Disassembly of section .exceptions:

08000020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8000020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8000024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8000028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 800002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8000030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8000034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8000038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 800003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8000040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8000044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8000048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 800004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8000050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8000054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8000058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 800005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 8000060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 8000064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 8000068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 800006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 8000070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 8000074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 8000078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 800007c:	10000326 	beq	r2,zero,800008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 8000080:	20000226 	beq	r4,zero,800008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 8000084:	80000fc0 	call	80000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 8000088:	00000706 	br	80000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 800008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 8000090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 8000094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 8000098:	80001d00 	call	80001d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 800009c:	1000021e 	bne	r2,zero,80000a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 80000a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 80000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 80000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 80000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 80000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 80000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 80000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 80000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 80000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 80000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 80000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 80000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 80000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 80000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 80000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 80000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 80000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 80000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 80000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 80000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 80000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 80000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 80000f8:	ef80083a 	eret

080000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 80000fc:	defff904 	addi	sp,sp,-28
 8000100:	dfc00615 	stw	ra,24(sp)
 8000104:	df000515 	stw	fp,20(sp)
 8000108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 800010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8000110:	0005313a 	rdctl	r2,ipending
 8000114:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8000118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 800011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8000120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8000124:	00800044 	movi	r2,1
 8000128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 800012c:	e0fffb17 	ldw	r3,-20(fp)
 8000130:	e0bffc17 	ldw	r2,-16(fp)
 8000134:	1884703a 	and	r2,r3,r2
 8000138:	10001426 	beq	r2,zero,800018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 800013c:	00820134 	movhi	r2,2052
 8000140:	10909404 	addi	r2,r2,16976
 8000144:	e0fffd17 	ldw	r3,-12(fp)
 8000148:	180690fa 	slli	r3,r3,3
 800014c:	10c5883a 	add	r2,r2,r3
 8000150:	10c00017 	ldw	r3,0(r2)
 8000154:	00820134 	movhi	r2,2052
 8000158:	10909404 	addi	r2,r2,16976
 800015c:	e13ffd17 	ldw	r4,-12(fp)
 8000160:	200890fa 	slli	r4,r4,3
 8000164:	1105883a 	add	r2,r2,r4
 8000168:	10800104 	addi	r2,r2,4
 800016c:	10800017 	ldw	r2,0(r2)
 8000170:	1009883a 	mov	r4,r2
 8000174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 8000178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 800017c:	0005313a 	rdctl	r2,ipending
 8000180:	e0bfff15 	stw	r2,-4(fp)

  return active;
 8000184:	e0bfff17 	ldw	r2,-4(fp)
 8000188:	00000706 	br	80001a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 800018c:	e0bffc17 	ldw	r2,-16(fp)
 8000190:	1085883a 	add	r2,r2,r2
 8000194:	e0bffc15 	stw	r2,-16(fp)
      i++;
 8000198:	e0bffd17 	ldw	r2,-12(fp)
 800019c:	10800044 	addi	r2,r2,1
 80001a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 80001a4:	003fe106 	br	800012c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 80001a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 80001ac:	e0bffb17 	ldw	r2,-20(fp)
 80001b0:	103fdb1e 	bne	r2,zero,8000120 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 80001b4:	0001883a 	nop
}
 80001b8:	0001883a 	nop
 80001bc:	e037883a 	mov	sp,fp
 80001c0:	dfc00117 	ldw	ra,4(sp)
 80001c4:	df000017 	ldw	fp,0(sp)
 80001c8:	dec00204 	addi	sp,sp,8
 80001cc:	f800283a 	ret

080001d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 80001d0:	defffb04 	addi	sp,sp,-20
 80001d4:	dfc00415 	stw	ra,16(sp)
 80001d8:	df000315 	stw	fp,12(sp)
 80001dc:	df000304 	addi	fp,sp,12
 80001e0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
 80001e4:	000531fa 	rdctl	r2,exception
 80001e8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
 80001ec:	e0bffd17 	ldw	r2,-12(fp)
 80001f0:	10801f0c 	andi	r2,r2,124
 80001f4:	1004d0ba 	srli	r2,r2,2
 80001f8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
 80001fc:	0005333a 	rdctl	r2,badaddr
 8000200:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 8000204:	d0a6ed17 	ldw	r2,-25676(gp)
 8000208:	10000726 	beq	r2,zero,8000228 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 800020c:	d0a6ed17 	ldw	r2,-25676(gp)
 8000210:	e0fffd17 	ldw	r3,-12(fp)
 8000214:	e1bffe17 	ldw	r6,-8(fp)
 8000218:	e17fff17 	ldw	r5,-4(fp)
 800021c:	1809883a 	mov	r4,r3
 8000220:	103ee83a 	callr	r2
 8000224:	00000206 	br	8000230 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 8000228:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 800022c:	0005883a 	mov	r2,zero
}
 8000230:	e037883a 	mov	sp,fp
 8000234:	dfc00117 	ldw	ra,4(sp)
 8000238:	df000017 	ldw	fp,0(sp)
 800023c:	dec00204 	addi	sp,sp,8
 8000240:	f800283a 	ret

Disassembly of section .text:

08000244 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 8000244:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 8000248:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 800024c:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 8000250:	00bffd16 	blt	zero,r2,8000248 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8000254:	06c40034 	movhi	sp,4096
    ori sp, sp, %lo(__alt_stack_pointer)
 8000258:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 800025c:	06820134 	movhi	gp,2052
    ori gp, gp, %lo(_gp)
 8000260:	d6a99b14 	ori	gp,gp,42604
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8000264:	00820134 	movhi	r2,2052
    ori r2, r2, %lo(__bss_start)
 8000268:	10907c14 	ori	r2,r2,16880

    movhi r3, %hi(__bss_end)
 800026c:	00c20134 	movhi	r3,2052
    ori r3, r3, %lo(__bss_end)
 8000270:	18d0d414 	ori	r3,r3,17232

    beq r2, r3, 1f
 8000274:	10c00326 	beq	r2,r3,8000284 <_start+0x40>

0:
    stw zero, (r2)
 8000278:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 800027c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 8000280:	10fffd36 	bltu	r2,r3,8000278 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 8000284:	80050500 	call	8005050 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8000288:	80051e40 	call	80051e4 <alt_main>

0800028c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 800028c:	003fff06 	br	800028c <alt_after_alt_main>

08000290 <measuringFrameRate>:
#include <math.h>
#include <stdlib.h>
#include <sys/alt_alarm.h>
#include "myfile.h"

void measuringFrameRate() {
 8000290:	defffc04 	addi	sp,sp,-16
 8000294:	df000315 	stw	fp,12(sp)
 8000298:	df000304 	addi	fp,sp,12
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 800029c:	d0a6ea17 	ldw	r2,-25688(gp)
  alt_u32 ticks_per_second = alt_ticks_per_second();
 80002a0:	e0bffd15 	stw	r2,-12(fp)
  alt_u32 current_tick = 0, prev_tick = alt_nticks();
 80002a4:	e03ffe15 	stw	zero,-8(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 80002a8:	d0a6eb17 	ldw	r2,-25684(gp)
 80002ac:	e0bfff15 	stw	r2,-4(fp)
}
 80002b0:	0001883a 	nop
 80002b4:	e037883a 	mov	sp,fp
 80002b8:	df000017 	ldw	fp,0(sp)
 80002bc:	dec00104 	addi	sp,sp,4
 80002c0:	f800283a 	ret

080002c4 <displayFrameRate>:
void displayFrameRate(alt_up_char_buffer_dev *char_buf) {
 80002c4:	defffd04 	addi	sp,sp,-12
 80002c8:	dfc00215 	stw	ra,8(sp)
 80002cc:	df000115 	stw	fp,4(sp)
 80002d0:	df000104 	addi	fp,sp,4
 80002d4:	e13fff15 	stw	r4,-4(fp)
  char_buf = alt_up_char_buffer_open_dev("/dev/video_character_buffer_with_dma_0");
 80002d8:	01020074 	movhi	r4,2049
 80002dc:	21218904 	addi	r4,r4,-31196
 80002e0:	80066c00 	call	80066c0 <alt_up_char_buffer_open_dev>
 80002e4:	e0bfff15 	stw	r2,-4(fp)
  if (!char_buf) printf("error opening character buffer\n");
 80002e8:	e0bfff17 	ldw	r2,-4(fp)
 80002ec:	1000031e 	bne	r2,zero,80002fc <displayFrameRate+0x38>
 80002f0:	01020074 	movhi	r4,2049
 80002f4:	21219304 	addi	r4,r4,-31156
 80002f8:	80004f80 	call	80004f8 <puts>
  alt_up_char_buffer_clear(char_buf);
 80002fc:	e13fff17 	ldw	r4,-4(fp)
 8000300:	80068c40 	call	80068c4 <alt_up_char_buffer_clear>
  alt_up_char_buffer_string(char_buf, "Video Works", 35, 50);
 8000304:	01c00c84 	movi	r7,50
 8000308:	018008c4 	movi	r6,35
 800030c:	01420074 	movhi	r5,2049
 8000310:	29619b04 	addi	r5,r5,-31124
 8000314:	e13fff17 	ldw	r4,-4(fp)
 8000318:	80067c80 	call	80067c8 <alt_up_char_buffer_string>
}
 800031c:	0001883a 	nop
 8000320:	e037883a 	mov	sp,fp
 8000324:	dfc00117 	ldw	ra,4(sp)
 8000328:	df000017 	ldw	fp,0(sp)
 800032c:	dec00204 	addi	sp,sp,8
 8000330:	f800283a 	ret

08000334 <displayImage>:

void displayImage (alt_u8 *image_array, int screen_width, int screen_height) {
 8000334:	defff804 	addi	sp,sp,-32
 8000338:	dfc00715 	stw	ra,28(sp)
 800033c:	df000615 	stw	fp,24(sp)
 8000340:	df000604 	addi	fp,sp,24
 8000344:	e13ffd15 	stw	r4,-12(fp)
 8000348:	e17ffe15 	stw	r5,-8(fp)
 800034c:	e1bfff15 	stw	r6,-4(fp)
  alt_up_pixel_buffer_dma_dev *pix_buf;
  pix_buf = alt_up_pixel_buffer_dma_open_dev("/dev/video_pixel_buffer_dma_0");
 8000350:	01020074 	movhi	r4,2049
 8000354:	21219e04 	addi	r4,r4,-31112
 8000358:	80069200 	call	8006920 <alt_up_pixel_buffer_dma_open_dev>
 800035c:	e0bffa15 	stw	r2,-24(fp)
  alt_up_pixel_buffer_dma_clear_screen(pix_buf, 0);
 8000360:	000b883a 	mov	r5,zero
 8000364:	e13ffa17 	ldw	r4,-24(fp)
 8000368:	8006be00 	call	8006be0 <alt_up_pixel_buffer_dma_clear_screen>
       (myimage[(i*screen_height+j)*3+2]), j, i);
    }
  }*/
  
  // Attempting to rotate the image 30 degrees. This is not working at the moment
  float c = 1.1;
 800036c:	008fe374 	movhi	r2,16269
 8000370:	10b33344 	addi	r2,r2,-13107
 8000374:	e0bffb15 	stw	r2,-20(fp)
  float r = 2.2;
 8000378:	00900374 	movhi	r2,16397
 800037c:	10b33344 	addi	r2,r2,-13107
 8000380:	e0bffc15 	stw	r2,-16(fp)
       (myimage[(i*screen_height+j)*3+2]), (int)c, (int)r);
    }
  }*/
  
  
}
 8000384:	0001883a 	nop
 8000388:	e037883a 	mov	sp,fp
 800038c:	dfc00117 	ldw	ra,4(sp)
 8000390:	df000017 	ldw	fp,0(sp)
 8000394:	dec00204 	addi	sp,sp,8
 8000398:	f800283a 	ret

0800039c <main>:

int main() {  
 800039c:	defffd04 	addi	sp,sp,-12
 80003a0:	dfc00215 	stw	ra,8(sp)
 80003a4:	df000115 	stw	fp,4(sp)
 80003a8:	df000104 	addi	fp,sp,4
  myimage[230401];
  alt_up_char_buffer_dev *char_buf;
  displayImage(myimage, 480, 320);
 80003ac:	01805004 	movi	r6,320
 80003b0:	01407804 	movi	r5,480
 80003b4:	01020074 	movhi	r4,2049
 80003b8:	2121a584 	addi	r4,r4,-31082
 80003bc:	80003340 	call	8000334 <displayImage>
  displayFrameRate(char_buf);
 80003c0:	e13fff17 	ldw	r4,-4(fp)
 80003c4:	80002c40 	call	80002c4 <displayFrameRate>
    
  return 0;
 80003c8:	0005883a 	mov	r2,zero
}
 80003cc:	e037883a 	mov	sp,fp
 80003d0:	dfc00117 	ldw	ra,4(sp)
 80003d4:	df000017 	ldw	fp,0(sp)
 80003d8:	dec00204 	addi	sp,sp,8
 80003dc:	f800283a 	ret

080003e0 <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
 80003e0:	defff104 	addi	sp,sp,-60
 80003e4:	dfc00e15 	stw	ra,56(sp)
 80003e8:	df000d15 	stw	fp,52(sp)
 80003ec:	df000d04 	addi	fp,sp,52
 80003f0:	e13ffe15 	stw	r4,-8(fp)
 80003f4:	e17fff15 	stw	r5,-4(fp)
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
 80003f8:	e13fff17 	ldw	r4,-4(fp)
 80003fc:	80005300 	call	8000530 <strlen>
 8000400:	e0bff315 	stw	r2,-52(fp)
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
 8000404:	e0bfff17 	ldw	r2,-4(fp)
 8000408:	e0bffa15 	stw	r2,-24(fp)
  iov[0].iov_len = c;
 800040c:	e0bff317 	ldw	r2,-52(fp)
 8000410:	e0bffb15 	stw	r2,-20(fp)
  iov[1].iov_base = "\n";
 8000414:	00820134 	movhi	r2,2052
 8000418:	1082a604 	addi	r2,r2,2712
 800041c:	e0bffc15 	stw	r2,-16(fp)
  iov[1].iov_len = 1;
 8000420:	00800044 	movi	r2,1
 8000424:	e0bffd15 	stw	r2,-12(fp)
  uio.uio_resid = c + 1;
 8000428:	e0bff317 	ldw	r2,-52(fp)
 800042c:	10800044 	addi	r2,r2,1
 8000430:	e0bff915 	stw	r2,-28(fp)
  uio.uio_iov = &iov[0];
 8000434:	e0bffa04 	addi	r2,fp,-24
 8000438:	e0bff715 	stw	r2,-36(fp)
  uio.uio_iovcnt = 2;
 800043c:	00800084 	movi	r2,2
 8000440:	e0bff815 	stw	r2,-32(fp)

  CHECK_STD_INIT (ptr);
 8000444:	e0bffe17 	ldw	r2,-8(fp)
 8000448:	e0bff415 	stw	r2,-48(fp)
 800044c:	e0bff417 	ldw	r2,-48(fp)
 8000450:	10000526 	beq	r2,zero,8000468 <_puts_r+0x88>
 8000454:	e0bff417 	ldw	r2,-48(fp)
 8000458:	10800e17 	ldw	r2,56(r2)
 800045c:	1000021e 	bne	r2,zero,8000468 <_puts_r+0x88>
 8000460:	e13ff417 	ldw	r4,-48(fp)
 8000464:	80009c80 	call	80009c8 <__sinit>
  fp = _stdout_r (ptr);
 8000468:	e0bffe17 	ldw	r2,-8(fp)
 800046c:	10800217 	ldw	r2,8(r2)
 8000470:	e0bff515 	stw	r2,-44(fp)
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
 8000474:	e0bff517 	ldw	r2,-44(fp)
 8000478:	1080030b 	ldhu	r2,12(r2)
 800047c:	10bfffcc 	andi	r2,r2,65535
 8000480:	1088000c 	andi	r2,r2,8192
 8000484:	10000c1e 	bne	r2,zero,80004b8 <_puts_r+0xd8>
 8000488:	e0bff517 	ldw	r2,-44(fp)
 800048c:	1080030b 	ldhu	r2,12(r2)
 8000490:	10880014 	ori	r2,r2,8192
 8000494:	1007883a 	mov	r3,r2
 8000498:	e0bff517 	ldw	r2,-44(fp)
 800049c:	10c0030d 	sth	r3,12(r2)
 80004a0:	e0bff517 	ldw	r2,-44(fp)
 80004a4:	10c01917 	ldw	r3,100(r2)
 80004a8:	00b7ffc4 	movi	r2,-8193
 80004ac:	1886703a 	and	r3,r3,r2
 80004b0:	e0bff517 	ldw	r2,-44(fp)
 80004b4:	10c01915 	stw	r3,100(r2)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
 80004b8:	e0bff704 	addi	r2,fp,-36
 80004bc:	100d883a 	mov	r6,r2
 80004c0:	e17ff517 	ldw	r5,-44(fp)
 80004c4:	e13ffe17 	ldw	r4,-8(fp)
 80004c8:	8000be80 	call	8000be8 <__sfvwrite_r>
 80004cc:	10000226 	beq	r2,zero,80004d8 <_puts_r+0xf8>
 80004d0:	00bfffc4 	movi	r2,-1
 80004d4:	00000106 	br	80004dc <_puts_r+0xfc>
 80004d8:	00800284 	movi	r2,10
 80004dc:	e0bff615 	stw	r2,-40(fp)
  _newlib_flockfile_end (fp);
  return result;
 80004e0:	e0bff617 	ldw	r2,-40(fp)

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
 80004e4:	e037883a 	mov	sp,fp
 80004e8:	dfc00117 	ldw	ra,4(sp)
 80004ec:	df000017 	ldw	fp,0(sp)
 80004f0:	dec00204 	addi	sp,sp,8
 80004f4:	f800283a 	ret

080004f8 <puts>:
#ifndef _REENT_ONLY

int
_DEFUN(puts, (s),
       char _CONST * s)
{
 80004f8:	defffd04 	addi	sp,sp,-12
 80004fc:	dfc00215 	stw	ra,8(sp)
 8000500:	df000115 	stw	fp,4(sp)
 8000504:	df000104 	addi	fp,sp,4
 8000508:	e13fff15 	stw	r4,-4(fp)
  return _puts_r (_REENT, s);
 800050c:	d0a00017 	ldw	r2,-32768(gp)
 8000510:	e17fff17 	ldw	r5,-4(fp)
 8000514:	1009883a 	mov	r4,r2
 8000518:	80003e00 	call	80003e0 <_puts_r>
}
 800051c:	e037883a 	mov	sp,fp
 8000520:	dfc00117 	ldw	ra,4(sp)
 8000524:	df000017 	ldw	fp,0(sp)
 8000528:	dec00204 	addi	sp,sp,8
 800052c:	f800283a 	ret

08000530 <strlen>:
#endif

size_t
_DEFUN (strlen, (str),
	_CONST char *str)
{
 8000530:	defffc04 	addi	sp,sp,-16
 8000534:	df000315 	stw	fp,12(sp)
 8000538:	df000304 	addi	fp,sp,12
 800053c:	e13fff15 	stw	r4,-4(fp)
  _CONST char *start = str;
 8000540:	e0bfff17 	ldw	r2,-4(fp)
 8000544:	e0bffe15 	stw	r2,-8(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 8000548:	00000d06 	br	8000580 <strlen+0x50>
    {
      if (!*str)
 800054c:	e0bfff17 	ldw	r2,-4(fp)
 8000550:	10800003 	ldbu	r2,0(r2)
 8000554:	10803fcc 	andi	r2,r2,255
 8000558:	1080201c 	xori	r2,r2,128
 800055c:	10bfe004 	addi	r2,r2,-128
 8000560:	1000041e 	bne	r2,zero,8000574 <strlen+0x44>
	return str - start;
 8000564:	e0ffff17 	ldw	r3,-4(fp)
 8000568:	e0bffe17 	ldw	r2,-8(fp)
 800056c:	1885c83a 	sub	r2,r3,r2
 8000570:	00002806 	br	8000614 <strlen+0xe4>
      str++;
 8000574:	e0bfff17 	ldw	r2,-4(fp)
 8000578:	10800044 	addi	r2,r2,1
 800057c:	e0bfff15 	stw	r2,-4(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 8000580:	e0bfff17 	ldw	r2,-4(fp)
 8000584:	108000cc 	andi	r2,r2,3
 8000588:	103ff01e 	bne	r2,zero,800054c <strlen+0x1c>
      str++;
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
 800058c:	e0bfff17 	ldw	r2,-4(fp)
 8000590:	e0bffd15 	stw	r2,-12(fp)
  while (!DETECTNULL (*aligned_addr))
 8000594:	00000306 	br	80005a4 <strlen+0x74>
    aligned_addr++;
 8000598:	e0bffd17 	ldw	r2,-12(fp)
 800059c:	10800104 	addi	r2,r2,4
 80005a0:	e0bffd15 	stw	r2,-12(fp)
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
  while (!DETECTNULL (*aligned_addr))
 80005a4:	e0bffd17 	ldw	r2,-12(fp)
 80005a8:	10c00017 	ldw	r3,0(r2)
 80005ac:	00bfbff4 	movhi	r2,65279
 80005b0:	10bfbfc4 	addi	r2,r2,-257
 80005b4:	1887883a 	add	r3,r3,r2
 80005b8:	e0bffd17 	ldw	r2,-12(fp)
 80005bc:	10800017 	ldw	r2,0(r2)
 80005c0:	0084303a 	nor	r2,zero,r2
 80005c4:	1886703a 	and	r3,r3,r2
 80005c8:	00a02074 	movhi	r2,32897
 80005cc:	10a02004 	addi	r2,r2,-32640
 80005d0:	1884703a 	and	r2,r3,r2
 80005d4:	103ff026 	beq	r2,zero,8000598 <strlen+0x68>
    aligned_addr++;

  /* Once a null is detected, we check each byte in that block for a
     precise position of the null.  */
  str = (char *) aligned_addr;
 80005d8:	e0bffd17 	ldw	r2,-12(fp)
 80005dc:	e0bfff15 	stw	r2,-4(fp)

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 80005e0:	00000306 	br	80005f0 <strlen+0xc0>
    str++;
 80005e4:	e0bfff17 	ldw	r2,-4(fp)
 80005e8:	10800044 	addi	r2,r2,1
 80005ec:	e0bfff15 	stw	r2,-4(fp)
     precise position of the null.  */
  str = (char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 80005f0:	e0bfff17 	ldw	r2,-4(fp)
 80005f4:	10800003 	ldbu	r2,0(r2)
 80005f8:	10803fcc 	andi	r2,r2,255
 80005fc:	1080201c 	xori	r2,r2,128
 8000600:	10bfe004 	addi	r2,r2,-128
 8000604:	103ff71e 	bne	r2,zero,80005e4 <strlen+0xb4>
    str++;
  return str - start;
 8000608:	e0ffff17 	ldw	r3,-4(fp)
 800060c:	e0bffe17 	ldw	r2,-8(fp)
 8000610:	1885c83a 	sub	r2,r3,r2
}
 8000614:	e037883a 	mov	sp,fp
 8000618:	df000017 	ldw	fp,0(sp)
 800061c:	dec00104 	addi	sp,sp,4
 8000620:	f800283a 	ret

08000624 <std>:
_DEFUN(std, (ptr, flags, file, data),
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
 8000624:	defffa04 	addi	sp,sp,-24
 8000628:	dfc00515 	stw	ra,20(sp)
 800062c:	df000415 	stw	fp,16(sp)
 8000630:	df000404 	addi	fp,sp,16
 8000634:	e13ffc15 	stw	r4,-16(fp)
 8000638:	e17ffd15 	stw	r5,-12(fp)
 800063c:	e1bffe15 	stw	r6,-8(fp)
 8000640:	e1ffff15 	stw	r7,-4(fp)
  ptr->_p = 0;
 8000644:	e0bffc17 	ldw	r2,-16(fp)
 8000648:	10000015 	stw	zero,0(r2)
  ptr->_r = 0;
 800064c:	e0bffc17 	ldw	r2,-16(fp)
 8000650:	10000115 	stw	zero,4(r2)
  ptr->_w = 0;
 8000654:	e0bffc17 	ldw	r2,-16(fp)
 8000658:	10000215 	stw	zero,8(r2)
  ptr->_flags = flags;
 800065c:	e0bffd17 	ldw	r2,-12(fp)
 8000660:	1007883a 	mov	r3,r2
 8000664:	e0bffc17 	ldw	r2,-16(fp)
 8000668:	10c0030d 	sth	r3,12(r2)
  ptr->_flags2 = 0;
 800066c:	e0bffc17 	ldw	r2,-16(fp)
 8000670:	10001915 	stw	zero,100(r2)
  ptr->_file = file;
 8000674:	e0bffe17 	ldw	r2,-8(fp)
 8000678:	1007883a 	mov	r3,r2
 800067c:	e0bffc17 	ldw	r2,-16(fp)
 8000680:	10c0038d 	sth	r3,14(r2)
  ptr->_bf._base = 0;
 8000684:	e0bffc17 	ldw	r2,-16(fp)
 8000688:	10000415 	stw	zero,16(r2)
  ptr->_bf._size = 0;
 800068c:	e0bffc17 	ldw	r2,-16(fp)
 8000690:	10000515 	stw	zero,20(r2)
  ptr->_lbfsize = 0;
 8000694:	e0bffc17 	ldw	r2,-16(fp)
 8000698:	10000615 	stw	zero,24(r2)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
 800069c:	e0bffc17 	ldw	r2,-16(fp)
 80006a0:	10801704 	addi	r2,r2,92
 80006a4:	01800204 	movi	r6,8
 80006a8:	000b883a 	mov	r5,zero
 80006ac:	1009883a 	mov	r4,r2
 80006b0:	80027f40 	call	80027f4 <memset>
  ptr->_cookie = ptr;
 80006b4:	e0bffc17 	ldw	r2,-16(fp)
 80006b8:	e0fffc17 	ldw	r3,-16(fp)
 80006bc:	10c00715 	stw	r3,28(r2)
  ptr->_read = __sread;
 80006c0:	e0fffc17 	ldw	r3,-16(fp)
 80006c4:	00820034 	movhi	r2,2048
 80006c8:	108d8204 	addi	r2,r2,13832
 80006cc:	18800815 	stw	r2,32(r3)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
 80006d0:	e0fffc17 	ldw	r3,-16(fp)
 80006d4:	00820034 	movhi	r2,2048
 80006d8:	108db504 	addi	r2,r2,14036
 80006dc:	18800915 	stw	r2,36(r3)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
 80006e0:	e0fffc17 	ldw	r3,-16(fp)
 80006e4:	00820034 	movhi	r2,2048
 80006e8:	108de204 	addi	r2,r2,14216
 80006ec:	18800a15 	stw	r2,40(r3)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
 80006f0:	e0fffc17 	ldw	r3,-16(fp)
 80006f4:	00820034 	movhi	r2,2048
 80006f8:	108e0a04 	addi	r2,r2,14376
 80006fc:	18800b15 	stw	r2,44(r3)

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
 8000700:	0001883a 	nop
 8000704:	e037883a 	mov	sp,fp
 8000708:	dfc00117 	ldw	ra,4(sp)
 800070c:	df000017 	ldw	fp,0(sp)
 8000710:	dec00204 	addi	sp,sp,8
 8000714:	f800283a 	ret

08000718 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
 8000718:	defffb04 	addi	sp,sp,-20
 800071c:	dfc00415 	stw	ra,16(sp)
 8000720:	df000315 	stw	fp,12(sp)
 8000724:	dc000215 	stw	r16,8(sp)
 8000728:	df000304 	addi	fp,sp,12
 800072c:	e13ffe15 	stw	r4,-8(fp)
 8000730:	2821883a 	mov	r16,r5
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
 8000734:	80bfffc4 	addi	r2,r16,-1
 8000738:	10801a24 	muli	r2,r2,104
 800073c:	10801d04 	addi	r2,r2,116
       struct _reent *d _AND
       register int n)
{
  struct glue_with_file *g;

  g = (struct glue_with_file *)
 8000740:	100b883a 	mov	r5,r2
 8000744:	e13ffe17 	ldw	r4,-8(fp)
 8000748:	800172c0 	call	800172c <_malloc_r>
 800074c:	e0bffd15 	stw	r2,-12(fp)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
 8000750:	e0bffd17 	ldw	r2,-12(fp)
 8000754:	1000021e 	bne	r2,zero,8000760 <__sfmoreglue+0x48>
    return NULL;
 8000758:	0005883a 	mov	r2,zero
 800075c:	00001106 	br	80007a4 <__sfmoreglue+0x8c>
  g->glue._next = NULL;
 8000760:	e0bffd17 	ldw	r2,-12(fp)
 8000764:	10000015 	stw	zero,0(r2)
  g->glue._niobs = n;
 8000768:	e0bffd17 	ldw	r2,-12(fp)
 800076c:	14000115 	stw	r16,4(r2)
  g->glue._iobs = &g->file;
 8000770:	e0bffd17 	ldw	r2,-12(fp)
 8000774:	10c00304 	addi	r3,r2,12
 8000778:	e0bffd17 	ldw	r2,-12(fp)
 800077c:	10c00215 	stw	r3,8(r2)
  memset (&g->file, 0, n * sizeof (FILE));
 8000780:	e0bffd17 	ldw	r2,-12(fp)
 8000784:	10800304 	addi	r2,r2,12
 8000788:	8007883a 	mov	r3,r16
 800078c:	18c01a24 	muli	r3,r3,104
 8000790:	180d883a 	mov	r6,r3
 8000794:	000b883a 	mov	r5,zero
 8000798:	1009883a 	mov	r4,r2
 800079c:	80027f40 	call	80027f4 <memset>
  return &g->glue;
 80007a0:	e0bffd17 	ldw	r2,-12(fp)
}
 80007a4:	e6ffff04 	addi	sp,fp,-4
 80007a8:	dfc00217 	ldw	ra,8(sp)
 80007ac:	df000117 	ldw	fp,4(sp)
 80007b0:	dc000017 	ldw	r16,0(sp)
 80007b4:	dec00304 	addi	sp,sp,12
 80007b8:	f800283a 	ret

080007bc <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
 80007bc:	defffa04 	addi	sp,sp,-24
 80007c0:	dfc00515 	stw	ra,20(sp)
 80007c4:	df000415 	stw	fp,16(sp)
 80007c8:	df000404 	addi	fp,sp,16
 80007cc:	e13fff15 	stw	r4,-4(fp)
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
 80007d0:	8000aa00 	call	8000aa0 <__sfp_lock_acquire>

  if (!_GLOBAL_REENT->__sdidinit)
 80007d4:	d0a00117 	ldw	r2,-32764(gp)
 80007d8:	10800e17 	ldw	r2,56(r2)
 80007dc:	1000031e 	bne	r2,zero,80007ec <__sfp+0x30>
    __sinit (_GLOBAL_REENT);
 80007e0:	d0a00117 	ldw	r2,-32764(gp)
 80007e4:	1009883a 	mov	r4,r2
 80007e8:	80009c80 	call	80009c8 <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 80007ec:	d0a00117 	ldw	r2,-32764(gp)
 80007f0:	1080b804 	addi	r2,r2,736
 80007f4:	e0bffe15 	stw	r2,-8(fp)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 80007f8:	e0bffe17 	ldw	r2,-8(fp)
 80007fc:	10800217 	ldw	r2,8(r2)
 8000800:	e0bffc15 	stw	r2,-16(fp)
 8000804:	e0bffe17 	ldw	r2,-8(fp)
 8000808:	10800117 	ldw	r2,4(r2)
 800080c:	e0bffd15 	stw	r2,-12(fp)
 8000810:	00000906 	br	8000838 <__sfp+0x7c>
	if (fp->_flags == 0)
 8000814:	e0bffc17 	ldw	r2,-16(fp)
 8000818:	1080030b 	ldhu	r2,12(r2)
 800081c:	10bfffcc 	andi	r2,r2,65535
 8000820:	10a0001c 	xori	r2,r2,32768
 8000824:	10a00004 	addi	r2,r2,-32768
 8000828:	10001f26 	beq	r2,zero,80008a8 <__sfp+0xec>

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 800082c:	e0bffc17 	ldw	r2,-16(fp)
 8000830:	10801a04 	addi	r2,r2,104
 8000834:	e0bffc15 	stw	r2,-16(fp)
 8000838:	e0bffd17 	ldw	r2,-12(fp)
 800083c:	10bfffc4 	addi	r2,r2,-1
 8000840:	e0bffd15 	stw	r2,-12(fp)
 8000844:	e0bffd17 	ldw	r2,-12(fp)
 8000848:	103ff20e 	bge	r2,zero,8000814 <__sfp+0x58>
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
 800084c:	e0bffe17 	ldw	r2,-8(fp)
 8000850:	10800017 	ldw	r2,0(r2)
 8000854:	1000091e 	bne	r2,zero,800087c <__sfp+0xc0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
 8000858:	01400104 	movi	r5,4
 800085c:	e13fff17 	ldw	r4,-4(fp)
 8000860:	80007180 	call	8000718 <__sfmoreglue>
 8000864:	1007883a 	mov	r3,r2
 8000868:	e0bffe17 	ldw	r2,-8(fp)
 800086c:	10c00015 	stw	r3,0(r2)
 8000870:	e0bffe17 	ldw	r2,-8(fp)
 8000874:	10800017 	ldw	r2,0(r2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
 8000878:	10000426 	beq	r2,zero,800088c <__sfp+0xd0>

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 800087c:	e0bffe17 	ldw	r2,-8(fp)
 8000880:	10800017 	ldw	r2,0(r2)
 8000884:	e0bffe15 	stw	r2,-8(fp)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
 8000888:	003fdb06 	br	80007f8 <__sfp+0x3c>
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
 800088c:	0001883a 	nop
    }
  _newlib_sfp_lock_exit ();
 8000890:	8000ac00 	call	8000ac0 <__sfp_lock_release>
  d->_errno = ENOMEM;
 8000894:	e0bfff17 	ldw	r2,-4(fp)
 8000898:	00c00304 	movi	r3,12
 800089c:	10c00015 	stw	r3,0(r2)
  return NULL;
 80008a0:	0005883a 	mov	r2,zero
 80008a4:	00002506 	br	800093c <__sfp+0x180>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
 80008a8:	0001883a 	nop
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
 80008ac:	e0bffc17 	ldw	r2,-16(fp)
 80008b0:	00ffffc4 	movi	r3,-1
 80008b4:	10c0038d 	sth	r3,14(r2)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
 80008b8:	e0bffc17 	ldw	r2,-16(fp)
 80008bc:	00c00044 	movi	r3,1
 80008c0:	10c0030d 	sth	r3,12(r2)
  fp->_flags2 = 0;
 80008c4:	e0bffc17 	ldw	r2,-16(fp)
 80008c8:	10001915 	stw	zero,100(r2)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();
 80008cc:	8000ac00 	call	8000ac0 <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
 80008d0:	e0bffc17 	ldw	r2,-16(fp)
 80008d4:	10000015 	stw	zero,0(r2)
  fp->_w = 0;			/* nothing to read or write */
 80008d8:	e0bffc17 	ldw	r2,-16(fp)
 80008dc:	10000215 	stw	zero,8(r2)
  fp->_r = 0;
 80008e0:	e0bffc17 	ldw	r2,-16(fp)
 80008e4:	10000115 	stw	zero,4(r2)
  fp->_bf._base = NULL;		/* no buffer */
 80008e8:	e0bffc17 	ldw	r2,-16(fp)
 80008ec:	10000415 	stw	zero,16(r2)
  fp->_bf._size = 0;
 80008f0:	e0bffc17 	ldw	r2,-16(fp)
 80008f4:	10000515 	stw	zero,20(r2)
  fp->_lbfsize = 0;		/* not line buffered */
 80008f8:	e0bffc17 	ldw	r2,-16(fp)
 80008fc:	10000615 	stw	zero,24(r2)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
 8000900:	e0bffc17 	ldw	r2,-16(fp)
 8000904:	10801704 	addi	r2,r2,92
 8000908:	01800204 	movi	r6,8
 800090c:	000b883a 	mov	r5,zero
 8000910:	1009883a 	mov	r4,r2
 8000914:	80027f40 	call	80027f4 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
 8000918:	e0bffc17 	ldw	r2,-16(fp)
 800091c:	10000c15 	stw	zero,48(r2)
  fp->_ub._size = 0;
 8000920:	e0bffc17 	ldw	r2,-16(fp)
 8000924:	10000d15 	stw	zero,52(r2)
  fp->_lb._base = NULL;		/* no line buffer */
 8000928:	e0bffc17 	ldw	r2,-16(fp)
 800092c:	10001115 	stw	zero,68(r2)
  fp->_lb._size = 0;
 8000930:	e0bffc17 	ldw	r2,-16(fp)
 8000934:	10001215 	stw	zero,72(r2)

  return fp;
 8000938:	e0bffc17 	ldw	r2,-16(fp)
}
 800093c:	e037883a 	mov	sp,fp
 8000940:	dfc00117 	ldw	ra,4(sp)
 8000944:	df000017 	ldw	fp,0(sp)
 8000948:	dec00204 	addi	sp,sp,8
 800094c:	f800283a 	ret

08000950 <_cleanup_r>:
 */

_VOID
_DEFUN(_cleanup_r, (ptr),
       struct _reent *ptr)
{
 8000950:	defffc04 	addi	sp,sp,-16
 8000954:	dfc00315 	stw	ra,12(sp)
 8000958:	df000215 	stw	fp,8(sp)
 800095c:	df000204 	addi	fp,sp,8
 8000960:	e13fff15 	stw	r4,-4(fp)
  /* Otherwise close files and flush read streams, too.
     Note we call flush directly if "--enable-lite-exit" is in effect.  */
#ifdef _LITE_EXIT
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
 8000964:	00820034 	movhi	r2,2048
 8000968:	108ebb04 	addi	r2,r2,15084
 800096c:	e0bffe15 	stw	r2,-8(fp)
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
 8000970:	e17ffe17 	ldw	r5,-8(fp)
 8000974:	e13fff17 	ldw	r4,-4(fp)
 8000978:	800129c0 	call	800129c <_fwalk_reent>
}
 800097c:	0001883a 	nop
 8000980:	e037883a 	mov	sp,fp
 8000984:	dfc00117 	ldw	ra,4(sp)
 8000988:	df000017 	ldw	fp,0(sp)
 800098c:	dec00204 	addi	sp,sp,8
 8000990:	f800283a 	ret

08000994 <_cleanup>:

#ifndef _REENT_ONLY
_VOID
_DEFUN_VOID(_cleanup)
{
 8000994:	defffe04 	addi	sp,sp,-8
 8000998:	dfc00115 	stw	ra,4(sp)
 800099c:	df000015 	stw	fp,0(sp)
 80009a0:	d839883a 	mov	fp,sp
  _cleanup_r (_GLOBAL_REENT);
 80009a4:	d0a00117 	ldw	r2,-32764(gp)
 80009a8:	1009883a 	mov	r4,r2
 80009ac:	80009500 	call	8000950 <_cleanup_r>
}
 80009b0:	0001883a 	nop
 80009b4:	e037883a 	mov	sp,fp
 80009b8:	dfc00117 	ldw	ra,4(sp)
 80009bc:	df000017 	ldw	fp,0(sp)
 80009c0:	dec00204 	addi	sp,sp,8
 80009c4:	f800283a 	ret

080009c8 <__sinit>:
 */

_VOID
_DEFUN(__sinit, (s),
       struct _reent *s)
{
 80009c8:	defffd04 	addi	sp,sp,-12
 80009cc:	dfc00215 	stw	ra,8(sp)
 80009d0:	df000115 	stw	fp,4(sp)
 80009d4:	df000104 	addi	fp,sp,4
 80009d8:	e13fff15 	stw	r4,-4(fp)
  __sinit_lock_acquire ();
 80009dc:	8000ae00 	call	8000ae0 <__sinit_lock_acquire>

  if (s->__sdidinit)
 80009e0:	e0bfff17 	ldw	r2,-4(fp)
 80009e4:	10800e17 	ldw	r2,56(r2)
 80009e8:	10000226 	beq	r2,zero,80009f4 <__sinit+0x2c>
    {
      __sinit_lock_release ();
 80009ec:	8000b000 	call	8000b00 <__sinit_lock_release>
      return;
 80009f0:	00002606 	br	8000a8c <__sinit+0xc4>
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
 80009f4:	e0ffff17 	ldw	r3,-4(fp)
 80009f8:	00820034 	movhi	r2,2048
 80009fc:	10825404 	addi	r2,r2,2384
 8000a00:	18800f15 	stw	r2,60(r3)

  s->__sglue._next = NULL;
 8000a04:	e0bfff17 	ldw	r2,-4(fp)
 8000a08:	1000b815 	stw	zero,736(r2)
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
 8000a0c:	e0bfff17 	ldw	r2,-4(fp)
 8000a10:	00c000c4 	movi	r3,3
 8000a14:	10c0b915 	stw	r3,740(r2)
  s->__sglue._iobs = &s->__sf[0];
 8000a18:	e0bfff17 	ldw	r2,-4(fp)
 8000a1c:	10c0bb04 	addi	r3,r2,748
 8000a20:	e0bfff17 	ldw	r2,-4(fp)
 8000a24:	10c0ba15 	stw	r3,744(r2)
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
 8000a28:	e0bfff17 	ldw	r2,-4(fp)
 8000a2c:	10800117 	ldw	r2,4(r2)
 8000a30:	e1ffff17 	ldw	r7,-4(fp)
 8000a34:	000d883a 	mov	r6,zero
 8000a38:	01400104 	movi	r5,4
 8000a3c:	1009883a 	mov	r4,r2
 8000a40:	80006240 	call	8000624 <std>
#ifdef HAVE_FCNTL
/*std (s->_stdout, __SWR, 1, s); */
  std (s->_stdout, __SWR | __SNBF, 1, s);	/* AlteraSpecific: Change to have no buffering on stdout. */
#else
/*std (s->_stdout, __SWR | __SLBF, 1, s); */
  std (s->_stdout, __SWR | __SNBF, 1, s);	/* AlteraSpecific: Change to have no buffering on stdout. */
 8000a44:	e0bfff17 	ldw	r2,-4(fp)
 8000a48:	10800217 	ldw	r2,8(r2)
 8000a4c:	e1ffff17 	ldw	r7,-4(fp)
 8000a50:	01800044 	movi	r6,1
 8000a54:	01400284 	movi	r5,10
 8000a58:	1009883a 	mov	r4,r2
 8000a5c:	80006240 	call	8000624 <std>
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
 8000a60:	e0bfff17 	ldw	r2,-4(fp)
 8000a64:	10800317 	ldw	r2,12(r2)
 8000a68:	e1ffff17 	ldw	r7,-4(fp)
 8000a6c:	01800084 	movi	r6,2
 8000a70:	01400484 	movi	r5,18
 8000a74:	1009883a 	mov	r4,r2
 8000a78:	80006240 	call	8000624 <std>

  s->__sdidinit = 1;
 8000a7c:	e0bfff17 	ldw	r2,-4(fp)
 8000a80:	00c00044 	movi	r3,1
 8000a84:	10c00e15 	stw	r3,56(r2)

  __sinit_lock_release ();
 8000a88:	8000b000 	call	8000b00 <__sinit_lock_release>
}
 8000a8c:	e037883a 	mov	sp,fp
 8000a90:	dfc00117 	ldw	ra,4(sp)
 8000a94:	df000017 	ldw	fp,0(sp)
 8000a98:	dec00204 	addi	sp,sp,8
 8000a9c:	f800283a 	ret

08000aa0 <__sfp_lock_acquire>:
__LOCK_INIT_RECURSIVE(static, __sfp_lock);
__LOCK_INIT_RECURSIVE(static, __sinit_lock);

_VOID
_DEFUN_VOID(__sfp_lock_acquire)
{
 8000aa0:	deffff04 	addi	sp,sp,-4
 8000aa4:	df000015 	stw	fp,0(sp)
 8000aa8:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sfp_lock);
}
 8000aac:	0001883a 	nop
 8000ab0:	e037883a 	mov	sp,fp
 8000ab4:	df000017 	ldw	fp,0(sp)
 8000ab8:	dec00104 	addi	sp,sp,4
 8000abc:	f800283a 	ret

08000ac0 <__sfp_lock_release>:

_VOID
_DEFUN_VOID(__sfp_lock_release)
{
 8000ac0:	deffff04 	addi	sp,sp,-4
 8000ac4:	df000015 	stw	fp,0(sp)
 8000ac8:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sfp_lock);
}
 8000acc:	0001883a 	nop
 8000ad0:	e037883a 	mov	sp,fp
 8000ad4:	df000017 	ldw	fp,0(sp)
 8000ad8:	dec00104 	addi	sp,sp,4
 8000adc:	f800283a 	ret

08000ae0 <__sinit_lock_acquire>:

_VOID
_DEFUN_VOID(__sinit_lock_acquire)
{
 8000ae0:	deffff04 	addi	sp,sp,-4
 8000ae4:	df000015 	stw	fp,0(sp)
 8000ae8:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sinit_lock);
}
 8000aec:	0001883a 	nop
 8000af0:	e037883a 	mov	sp,fp
 8000af4:	df000017 	ldw	fp,0(sp)
 8000af8:	dec00104 	addi	sp,sp,4
 8000afc:	f800283a 	ret

08000b00 <__sinit_lock_release>:

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
 8000b00:	deffff04 	addi	sp,sp,-4
 8000b04:	df000015 	stw	fp,0(sp)
 8000b08:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sinit_lock);
}
 8000b0c:	0001883a 	nop
 8000b10:	e037883a 	mov	sp,fp
 8000b14:	df000017 	ldw	fp,0(sp)
 8000b18:	dec00104 	addi	sp,sp,4
 8000b1c:	f800283a 	ret

08000b20 <__fp_lock>:

/* Walkable file locking routine.  */
static int
_DEFUN(__fp_lock, (ptr),
       FILE * ptr)
{
 8000b20:	defffe04 	addi	sp,sp,-8
 8000b24:	df000115 	stw	fp,4(sp)
 8000b28:	df000104 	addi	fp,sp,4
 8000b2c:	e13fff15 	stw	r4,-4(fp)
  _flockfile (ptr);

  return 0;
 8000b30:	0005883a 	mov	r2,zero
}
 8000b34:	e037883a 	mov	sp,fp
 8000b38:	df000017 	ldw	fp,0(sp)
 8000b3c:	dec00104 	addi	sp,sp,4
 8000b40:	f800283a 	ret

08000b44 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
_DEFUN(__fp_unlock, (ptr),
       FILE * ptr)
{
 8000b44:	defffe04 	addi	sp,sp,-8
 8000b48:	df000115 	stw	fp,4(sp)
 8000b4c:	df000104 	addi	fp,sp,4
 8000b50:	e13fff15 	stw	r4,-4(fp)
  _funlockfile (ptr);

  return 0;
 8000b54:	0005883a 	mov	r2,zero
}
 8000b58:	e037883a 	mov	sp,fp
 8000b5c:	df000017 	ldw	fp,0(sp)
 8000b60:	dec00104 	addi	sp,sp,4
 8000b64:	f800283a 	ret

08000b68 <__fp_lock_all>:

_VOID
_DEFUN_VOID(__fp_lock_all)
{
 8000b68:	defffe04 	addi	sp,sp,-8
 8000b6c:	dfc00115 	stw	ra,4(sp)
 8000b70:	df000015 	stw	fp,0(sp)
 8000b74:	d839883a 	mov	fp,sp
  __sfp_lock_acquire ();
 8000b78:	8000aa00 	call	8000aa0 <__sfp_lock_acquire>

  _CAST_VOID _fwalk (_REENT, __fp_lock);
 8000b7c:	d0a00017 	ldw	r2,-32768(gp)
 8000b80:	01420034 	movhi	r5,2048
 8000b84:	2942c804 	addi	r5,r5,2848
 8000b88:	1009883a 	mov	r4,r2
 8000b8c:	80011c40 	call	80011c4 <_fwalk>
}
 8000b90:	0001883a 	nop
 8000b94:	e037883a 	mov	sp,fp
 8000b98:	dfc00117 	ldw	ra,4(sp)
 8000b9c:	df000017 	ldw	fp,0(sp)
 8000ba0:	dec00204 	addi	sp,sp,8
 8000ba4:	f800283a 	ret

08000ba8 <__fp_unlock_all>:

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
 8000ba8:	defffe04 	addi	sp,sp,-8
 8000bac:	dfc00115 	stw	ra,4(sp)
 8000bb0:	df000015 	stw	fp,0(sp)
 8000bb4:	d839883a 	mov	fp,sp
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
 8000bb8:	d0a00017 	ldw	r2,-32768(gp)
 8000bbc:	01420034 	movhi	r5,2048
 8000bc0:	2942d104 	addi	r5,r5,2884
 8000bc4:	1009883a 	mov	r4,r2
 8000bc8:	80011c40 	call	80011c4 <_fwalk>

  __sfp_lock_release ();
 8000bcc:	8000ac00 	call	8000ac0 <__sfp_lock_release>
}
 8000bd0:	0001883a 	nop
 8000bd4:	e037883a 	mov	sp,fp
 8000bd8:	dfc00117 	ldw	ra,4(sp)
 8000bdc:	df000017 	ldw	fp,0(sp)
 8000be0:	dec00204 	addi	sp,sp,8
 8000be4:	f800283a 	ret

08000be8 <__sfvwrite_r>:
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
 8000be8:	defff004 	addi	sp,sp,-64
 8000bec:	dfc00f15 	stw	ra,60(sp)
 8000bf0:	df000e15 	stw	fp,56(sp)
 8000bf4:	dd800d15 	stw	r22,52(sp)
 8000bf8:	dd400c15 	stw	r21,48(sp)
 8000bfc:	dd000b15 	stw	r20,44(sp)
 8000c00:	dcc00a15 	stw	r19,40(sp)
 8000c04:	dc800915 	stw	r18,36(sp)
 8000c08:	dc400815 	stw	r17,32(sp)
 8000c0c:	dc000715 	stw	r16,28(sp)
 8000c10:	df000e04 	addi	fp,sp,56
 8000c14:	e13ff815 	stw	r4,-32(fp)
 8000c18:	2821883a 	mov	r16,r5
 8000c1c:	302b883a 	mov	r21,r6
  register size_t len;
  register _CONST char *p = NULL;
 8000c20:	0027883a 	mov	r19,zero
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
 8000c24:	ac800217 	ldw	r18,8(r21)
 8000c28:	9000021e 	bne	r18,zero,8000c34 <__sfvwrite_r+0x4c>
    return 0;
 8000c2c:	0005883a 	mov	r2,zero
 8000c30:	00015806 	br	8001194 <__sfvwrite_r+0x5ac>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
 8000c34:	8080030b 	ldhu	r2,12(r16)
 8000c38:	10bfffcc 	andi	r2,r2,65535
 8000c3c:	1080020c 	andi	r2,r2,8
 8000c40:	10000226 	beq	r2,zero,8000c4c <__sfvwrite_r+0x64>
 8000c44:	80800417 	ldw	r2,16(r16)
 8000c48:	1000061e 	bne	r2,zero,8000c64 <__sfvwrite_r+0x7c>
 8000c4c:	800b883a 	mov	r5,r16
 8000c50:	e13ff817 	ldw	r4,-32(fp)
 8000c54:	80038ec0 	call	80038ec <__swsetup_r>
 8000c58:	10000226 	beq	r2,zero,8000c64 <__sfvwrite_r+0x7c>
    return EOF;
 8000c5c:	00bfffc4 	movi	r2,-1
 8000c60:	00014c06 	br	8001194 <__sfvwrite_r+0x5ac>

  iov = uio->uio_iov;
 8000c64:	ad000017 	ldw	r20,0(r21)
  len = 0;
 8000c68:	0025883a 	mov	r18,zero
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
 8000c6c:	8080030b 	ldhu	r2,12(r16)
 8000c70:	10bfffcc 	andi	r2,r2,65535
 8000c74:	1080008c 	andi	r2,r2,2
 8000c78:	10001f26 	beq	r2,zero,8000cf8 <__sfvwrite_r+0x110>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
 8000c7c:	00000306 	br	8000c8c <__sfvwrite_r+0xa4>
 8000c80:	a4c00017 	ldw	r19,0(r20)
 8000c84:	a4800117 	ldw	r18,4(r20)
 8000c88:	a5000204 	addi	r20,r20,8
 8000c8c:	903ffc26 	beq	r18,zero,8000c80 <__sfvwrite_r+0x98>
	  w = fp->_write (ptr, fp->_cookie, p,
 8000c90:	82000917 	ldw	r8,36(r16)
 8000c94:	81000717 	ldw	r4,28(r16)
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
 8000c98:	9005883a 	mov	r2,r18
 8000c9c:	00e00034 	movhi	r3,32768
 8000ca0:	18ff0004 	addi	r3,r3,-1024
 8000ca4:	1880022e 	bgeu	r3,r2,8000cb0 <__sfvwrite_r+0xc8>
 8000ca8:	00a00034 	movhi	r2,32768
 8000cac:	10bf0004 	addi	r2,r2,-1024
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
 8000cb0:	100f883a 	mov	r7,r2
 8000cb4:	980d883a 	mov	r6,r19
 8000cb8:	200b883a 	mov	r5,r4
 8000cbc:	e13ff817 	ldw	r4,-32(fp)
 8000cc0:	403ee83a 	callr	r8
 8000cc4:	1023883a 	mov	r17,r2
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
 8000cc8:	0441290e 	bge	zero,r17,8001170 <__sfvwrite_r+0x588>
	    goto err;
	  p += w;
 8000ccc:	8805883a 	mov	r2,r17
 8000cd0:	98a7883a 	add	r19,r19,r2
	  len -= w;
 8000cd4:	8805883a 	mov	r2,r17
 8000cd8:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 8000cdc:	a8800217 	ldw	r2,8(r21)
 8000ce0:	8807883a 	mov	r3,r17
 8000ce4:	10c5c83a 	sub	r2,r2,r3
 8000ce8:	a8800215 	stw	r2,8(r21)
 8000cec:	a8800217 	ldw	r2,8(r21)
 8000cf0:	103fe61e 	bne	r2,zero,8000c8c <__sfvwrite_r+0xa4>
 8000cf4:	00011c06 	br	8001168 <__sfvwrite_r+0x580>
    }
  else if ((fp->_flags & __SLBF) == 0)
 8000cf8:	8080030b 	ldhu	r2,12(r16)
 8000cfc:	10bfffcc 	andi	r2,r2,65535
 8000d00:	1080004c 	andi	r2,r2,1
 8000d04:	1000b51e 	bne	r2,zero,8000fdc <__sfvwrite_r+0x3f4>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
 8000d08:	00000306 	br	8000d18 <__sfvwrite_r+0x130>
 8000d0c:	a4c00017 	ldw	r19,0(r20)
 8000d10:	a4800117 	ldw	r18,4(r20)
 8000d14:	a5000204 	addi	r20,r20,8
 8000d18:	903ffc26 	beq	r18,zero,8000d0c <__sfvwrite_r+0x124>
	  w = fp->_w;
 8000d1c:	84400217 	ldw	r17,8(r16)
	  if (fp->_flags & __SSTR)
 8000d20:	8080030b 	ldhu	r2,12(r16)
 8000d24:	10bfffcc 	andi	r2,r2,65535
 8000d28:	1080800c 	andi	r2,r2,512
 8000d2c:	10006b26 	beq	r2,zero,8000edc <__sfvwrite_r+0x2f4>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
 8000d30:	8805883a 	mov	r2,r17
 8000d34:	90805736 	bltu	r18,r2,8000e94 <__sfvwrite_r+0x2ac>
 8000d38:	8080030b 	ldhu	r2,12(r16)
 8000d3c:	10bfffcc 	andi	r2,r2,65535
 8000d40:	1081200c 	andi	r2,r2,1152
 8000d44:	10005326 	beq	r2,zero,8000e94 <__sfvwrite_r+0x2ac>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
 8000d48:	80800017 	ldw	r2,0(r16)
 8000d4c:	1007883a 	mov	r3,r2
 8000d50:	80800417 	ldw	r2,16(r16)
 8000d54:	1885c83a 	sub	r2,r3,r2
 8000d58:	e0bff615 	stw	r2,-40(fp)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
 8000d5c:	80c00517 	ldw	r3,20(r16)
 8000d60:	1805883a 	mov	r2,r3
 8000d64:	1085883a 	add	r2,r2,r2
 8000d68:	10c5883a 	add	r2,r2,r3
 8000d6c:	1006d7fa 	srli	r3,r2,31
 8000d70:	1885883a 	add	r2,r3,r2
 8000d74:	1005d07a 	srai	r2,r2,1
 8000d78:	e0bff515 	stw	r2,-44(fp)
		  if (newsize < curpos + len + 1)
 8000d7c:	e0bff617 	ldw	r2,-40(fp)
 8000d80:	1485883a 	add	r2,r2,r18
 8000d84:	10800044 	addi	r2,r2,1
 8000d88:	e0fff517 	ldw	r3,-44(fp)
 8000d8c:	1880042e 	bgeu	r3,r2,8000da0 <__sfvwrite_r+0x1b8>
		    newsize = curpos + len + 1;
 8000d90:	e0bff617 	ldw	r2,-40(fp)
 8000d94:	1485883a 	add	r2,r2,r18
 8000d98:	10800044 	addi	r2,r2,1
 8000d9c:	e0bff515 	stw	r2,-44(fp)
		  if (fp->_flags & __SOPT)
 8000da0:	8080030b 	ldhu	r2,12(r16)
 8000da4:	10bfffcc 	andi	r2,r2,65535
 8000da8:	1081000c 	andi	r2,r2,1024
 8000dac:	10001726 	beq	r2,zero,8000e0c <__sfvwrite_r+0x224>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
 8000db0:	e0bff517 	ldw	r2,-44(fp)
 8000db4:	100b883a 	mov	r5,r2
 8000db8:	e13ff817 	ldw	r4,-32(fp)
 8000dbc:	800172c0 	call	800172c <_malloc_r>
 8000dc0:	e0bff415 	stw	r2,-48(fp)
		      if (!str)
 8000dc4:	e0bff417 	ldw	r2,-48(fp)
 8000dc8:	1000041e 	bne	r2,zero,8000ddc <__sfvwrite_r+0x1f4>
			{
			  ptr->_errno = ENOMEM;
 8000dcc:	e0bff817 	ldw	r2,-32(fp)
 8000dd0:	00c00304 	movi	r3,12
 8000dd4:	10c00015 	stw	r3,0(r2)
			  goto err;
 8000dd8:	0000ea06 	br	8001184 <__sfvwrite_r+0x59c>
			}
		      memcpy (str, fp->_bf._base, curpos);
 8000ddc:	80800417 	ldw	r2,16(r16)
 8000de0:	e0fff617 	ldw	r3,-40(fp)
 8000de4:	180d883a 	mov	r6,r3
 8000de8:	100b883a 	mov	r5,r2
 8000dec:	e13ff417 	ldw	r4,-48(fp)
 8000df0:	80024640 	call	8002464 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
 8000df4:	80c0030b 	ldhu	r3,12(r16)
 8000df8:	00bedfc4 	movi	r2,-1153
 8000dfc:	1884703a 	and	r2,r3,r2
 8000e00:	10802014 	ori	r2,r2,128
 8000e04:	8080030d 	sth	r2,12(r16)
 8000e08:	00001506 	br	8000e60 <__sfvwrite_r+0x278>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
 8000e0c:	80800417 	ldw	r2,16(r16)
 8000e10:	e0fff517 	ldw	r3,-44(fp)
 8000e14:	180d883a 	mov	r6,r3
 8000e18:	100b883a 	mov	r5,r2
 8000e1c:	e13ff817 	ldw	r4,-32(fp)
 8000e20:	80029b80 	call	80029b8 <_realloc_r>
 8000e24:	e0bff415 	stw	r2,-48(fp)
							 newsize);
		      if (!str)
 8000e28:	e0bff417 	ldw	r2,-48(fp)
 8000e2c:	10000c1e 	bne	r2,zero,8000e60 <__sfvwrite_r+0x278>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
 8000e30:	80800417 	ldw	r2,16(r16)
 8000e34:	100b883a 	mov	r5,r2
 8000e38:	e13ff817 	ldw	r4,-32(fp)
 8000e3c:	80040300 	call	8004030 <_free_r>
			  fp->_flags &=  ~__SMBF;
 8000e40:	80c0030b 	ldhu	r3,12(r16)
 8000e44:	00bfdfc4 	movi	r2,-129
 8000e48:	1884703a 	and	r2,r3,r2
 8000e4c:	8080030d 	sth	r2,12(r16)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
 8000e50:	e0bff817 	ldw	r2,-32(fp)
 8000e54:	00c00304 	movi	r3,12
 8000e58:	10c00015 	stw	r3,0(r2)
			  goto err;
 8000e5c:	0000c906 	br	8001184 <__sfvwrite_r+0x59c>
			}
		    }
		  fp->_bf._base = str;
 8000e60:	e0bff417 	ldw	r2,-48(fp)
 8000e64:	80800415 	stw	r2,16(r16)
		  fp->_p = str + curpos;
 8000e68:	e0bff617 	ldw	r2,-40(fp)
 8000e6c:	e0fff417 	ldw	r3,-48(fp)
 8000e70:	1885883a 	add	r2,r3,r2
 8000e74:	80800015 	stw	r2,0(r16)
		  fp->_bf._size = newsize;
 8000e78:	e0bff517 	ldw	r2,-44(fp)
 8000e7c:	80800515 	stw	r2,20(r16)
		  w = len;
 8000e80:	9023883a 	mov	r17,r18
		  fp->_w = newsize - curpos;
 8000e84:	e0fff517 	ldw	r3,-44(fp)
 8000e88:	e0bff617 	ldw	r2,-40(fp)
 8000e8c:	1885c83a 	sub	r2,r3,r2
 8000e90:	80800215 	stw	r2,8(r16)
		}
	      if (len < w)
 8000e94:	8805883a 	mov	r2,r17
 8000e98:	9080012e 	bgeu	r18,r2,8000ea0 <__sfvwrite_r+0x2b8>
		w = len;
 8000e9c:	9023883a 	mov	r17,r18
	      COPY (w);		/* copy MIN(fp->_w,len), */
 8000ea0:	80800017 	ldw	r2,0(r16)
 8000ea4:	8807883a 	mov	r3,r17
 8000ea8:	180d883a 	mov	r6,r3
 8000eac:	980b883a 	mov	r5,r19
 8000eb0:	1009883a 	mov	r4,r2
 8000eb4:	80025ec0 	call	80025ec <memmove>
	      fp->_w -= w;
 8000eb8:	80800217 	ldw	r2,8(r16)
 8000ebc:	1445c83a 	sub	r2,r2,r17
 8000ec0:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 8000ec4:	80800017 	ldw	r2,0(r16)
 8000ec8:	8807883a 	mov	r3,r17
 8000ecc:	10c5883a 	add	r2,r2,r3
 8000ed0:	80800015 	stw	r2,0(r16)
	      w = len;		/* but pretend copied all */
 8000ed4:	9023883a 	mov	r17,r18
 8000ed8:	00003506 	br	8000fb0 <__sfvwrite_r+0x3c8>
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
 8000edc:	80800017 	ldw	r2,0(r16)
 8000ee0:	80c00417 	ldw	r3,16(r16)
 8000ee4:	18800236 	bltu	r3,r2,8000ef0 <__sfvwrite_r+0x308>
 8000ee8:	80800517 	ldw	r2,20(r16)
 8000eec:	9080182e 	bgeu	r18,r2,8000f50 <__sfvwrite_r+0x368>
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
 8000ef0:	8805883a 	mov	r2,r17
 8000ef4:	9080012e 	bgeu	r18,r2,8000efc <__sfvwrite_r+0x314>
 8000ef8:	9005883a 	mov	r2,r18
 8000efc:	1023883a 	mov	r17,r2
	      COPY (w);
 8000f00:	80800017 	ldw	r2,0(r16)
 8000f04:	8807883a 	mov	r3,r17
 8000f08:	180d883a 	mov	r6,r3
 8000f0c:	980b883a 	mov	r5,r19
 8000f10:	1009883a 	mov	r4,r2
 8000f14:	80025ec0 	call	80025ec <memmove>
	      fp->_w -= w;
 8000f18:	80800217 	ldw	r2,8(r16)
 8000f1c:	1445c83a 	sub	r2,r2,r17
 8000f20:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 8000f24:	80800017 	ldw	r2,0(r16)
 8000f28:	8807883a 	mov	r3,r17
 8000f2c:	10c5883a 	add	r2,r2,r3
 8000f30:	80800015 	stw	r2,0(r16)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 8000f34:	80800217 	ldw	r2,8(r16)
 8000f38:	10001c1e 	bne	r2,zero,8000fac <__sfvwrite_r+0x3c4>
 8000f3c:	800b883a 	mov	r5,r16
 8000f40:	e13ff817 	ldw	r4,-32(fp)
 8000f44:	8003f540 	call	8003f54 <_fflush_r>
 8000f48:	10001826 	beq	r2,zero,8000fac <__sfvwrite_r+0x3c4>
		goto err;
 8000f4c:	00008d06 	br	8001184 <__sfvwrite_r+0x59c>
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
 8000f50:	9005883a 	mov	r2,r18
 8000f54:	00e00034 	movhi	r3,32768
 8000f58:	10c00236 	bltu	r2,r3,8000f64 <__sfvwrite_r+0x37c>
 8000f5c:	00a00034 	movhi	r2,32768
 8000f60:	10bfffc4 	addi	r2,r2,-1
 8000f64:	1007883a 	mov	r3,r2
 8000f68:	80800517 	ldw	r2,20(r16)
 8000f6c:	100b883a 	mov	r5,r2
 8000f70:	1809883a 	mov	r4,r3
 8000f74:	8004b300 	call	8004b30 <__divsi3>
 8000f78:	1007883a 	mov	r3,r2
 8000f7c:	80800517 	ldw	r2,20(r16)
 8000f80:	18a3383a 	mul	r17,r3,r2
	      w = fp->_write (ptr, fp->_cookie, p, w);
 8000f84:	80800917 	ldw	r2,36(r16)
 8000f88:	80c00717 	ldw	r3,28(r16)
 8000f8c:	880f883a 	mov	r7,r17
 8000f90:	980d883a 	mov	r6,r19
 8000f94:	180b883a 	mov	r5,r3
 8000f98:	e13ff817 	ldw	r4,-32(fp)
 8000f9c:	103ee83a 	callr	r2
 8000fa0:	1023883a 	mov	r17,r2
	      if (w <= 0)
 8000fa4:	0440740e 	bge	zero,r17,8001178 <__sfvwrite_r+0x590>
 8000fa8:	00000106 	br	8000fb0 <__sfvwrite_r+0x3c8>
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 8000fac:	0001883a 	nop
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
 8000fb0:	8805883a 	mov	r2,r17
 8000fb4:	98a7883a 	add	r19,r19,r2
	  len -= w;
 8000fb8:	8805883a 	mov	r2,r17
 8000fbc:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 8000fc0:	a8800217 	ldw	r2,8(r21)
 8000fc4:	8807883a 	mov	r3,r17
 8000fc8:	10c5c83a 	sub	r2,r2,r3
 8000fcc:	a8800215 	stw	r2,8(r21)
 8000fd0:	a8800217 	ldw	r2,8(r21)
 8000fd4:	103f501e 	bne	r2,zero,8000d18 <__sfvwrite_r+0x130>
 8000fd8:	00006306 	br	8001168 <__sfvwrite_r+0x580>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
 8000fdc:	e03ff215 	stw	zero,-56(fp)
      nldist = 0;
 8000fe0:	e03ff315 	stw	zero,-52(fp)
      do
	{
	  GETIOV (nlknown = 0);
 8000fe4:	00000406 	br	8000ff8 <__sfvwrite_r+0x410>
 8000fe8:	e03ff215 	stw	zero,-56(fp)
 8000fec:	a4c00017 	ldw	r19,0(r20)
 8000ff0:	a4800117 	ldw	r18,4(r20)
 8000ff4:	a5000204 	addi	r20,r20,8
 8000ff8:	903ffb26 	beq	r18,zero,8000fe8 <__sfvwrite_r+0x400>
	  if (!nlknown)
 8000ffc:	e0bff217 	ldw	r2,-56(fp)
 8001000:	1000111e 	bne	r2,zero,8001048 <__sfvwrite_r+0x460>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
 8001004:	900d883a 	mov	r6,r18
 8001008:	01400284 	movi	r5,10
 800100c:	9809883a 	mov	r4,r19
 8001010:	80022a80 	call	80022a8 <memchr>
 8001014:	e0bff715 	stw	r2,-36(fp)
	      nldist = nl ? nl + 1 - p : len + 1;
 8001018:	e0bff717 	ldw	r2,-36(fp)
 800101c:	10000626 	beq	r2,zero,8001038 <__sfvwrite_r+0x450>
 8001020:	e0bff717 	ldw	r2,-36(fp)
 8001024:	10800044 	addi	r2,r2,1
 8001028:	1007883a 	mov	r3,r2
 800102c:	9805883a 	mov	r2,r19
 8001030:	1885c83a 	sub	r2,r3,r2
 8001034:	00000106 	br	800103c <__sfvwrite_r+0x454>
 8001038:	90800044 	addi	r2,r18,1
 800103c:	e0bff315 	stw	r2,-52(fp)
	      nlknown = 1;
 8001040:	00800044 	movi	r2,1
 8001044:	e0bff215 	stw	r2,-56(fp)
	    }
	  s = MIN (len, nldist);
 8001048:	e0bff317 	ldw	r2,-52(fp)
 800104c:	9080012e 	bgeu	r18,r2,8001054 <__sfvwrite_r+0x46c>
 8001050:	9005883a 	mov	r2,r18
 8001054:	102d883a 	mov	r22,r2
	  w = fp->_w + fp->_bf._size;
 8001058:	80c00217 	ldw	r3,8(r16)
 800105c:	80800517 	ldw	r2,20(r16)
 8001060:	18a3883a 	add	r17,r3,r2
	  if (fp->_p > fp->_bf._base && s > w)
 8001064:	80800017 	ldw	r2,0(r16)
 8001068:	80c00417 	ldw	r3,16(r16)
 800106c:	1880102e 	bgeu	r3,r2,80010b0 <__sfvwrite_r+0x4c8>
 8001070:	8d800f0e 	bge	r17,r22,80010b0 <__sfvwrite_r+0x4c8>
	    {
	      COPY (w);
 8001074:	80800017 	ldw	r2,0(r16)
 8001078:	8807883a 	mov	r3,r17
 800107c:	180d883a 	mov	r6,r3
 8001080:	980b883a 	mov	r5,r19
 8001084:	1009883a 	mov	r4,r2
 8001088:	80025ec0 	call	80025ec <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
 800108c:	80800017 	ldw	r2,0(r16)
 8001090:	8807883a 	mov	r3,r17
 8001094:	10c5883a 	add	r2,r2,r3
 8001098:	80800015 	stw	r2,0(r16)
	      if (_fflush_r (ptr, fp))
 800109c:	800b883a 	mov	r5,r16
 80010a0:	e13ff817 	ldw	r4,-32(fp)
 80010a4:	8003f540 	call	8003f54 <_fflush_r>
 80010a8:	10001b26 	beq	r2,zero,8001118 <__sfvwrite_r+0x530>
		goto err;
 80010ac:	00003506 	br	8001184 <__sfvwrite_r+0x59c>
	    }
	  else if (s >= (w = fp->_bf._size))
 80010b0:	84400517 	ldw	r17,20(r16)
 80010b4:	b4400a16 	blt	r22,r17,80010e0 <__sfvwrite_r+0x4f8>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
 80010b8:	80800917 	ldw	r2,36(r16)
 80010bc:	80c00717 	ldw	r3,28(r16)
 80010c0:	880f883a 	mov	r7,r17
 80010c4:	980d883a 	mov	r6,r19
 80010c8:	180b883a 	mov	r5,r3
 80010cc:	e13ff817 	ldw	r4,-32(fp)
 80010d0:	103ee83a 	callr	r2
 80010d4:	1023883a 	mov	r17,r2
	      if (w <= 0)
 80010d8:	04400f16 	blt	zero,r17,8001118 <__sfvwrite_r+0x530>
		goto err;
 80010dc:	00002906 	br	8001184 <__sfvwrite_r+0x59c>
	    }
	  else
	    {
	      w = s;
 80010e0:	b023883a 	mov	r17,r22
	      COPY (w);
 80010e4:	80800017 	ldw	r2,0(r16)
 80010e8:	8807883a 	mov	r3,r17
 80010ec:	180d883a 	mov	r6,r3
 80010f0:	980b883a 	mov	r5,r19
 80010f4:	1009883a 	mov	r4,r2
 80010f8:	80025ec0 	call	80025ec <memmove>
	      fp->_w -= w;
 80010fc:	80800217 	ldw	r2,8(r16)
 8001100:	1445c83a 	sub	r2,r2,r17
 8001104:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 8001108:	80800017 	ldw	r2,0(r16)
 800110c:	8807883a 	mov	r3,r17
 8001110:	10c5883a 	add	r2,r2,r3
 8001114:	80800015 	stw	r2,0(r16)
	    }
	  if ((nldist -= w) == 0)
 8001118:	e0bff317 	ldw	r2,-52(fp)
 800111c:	1445c83a 	sub	r2,r2,r17
 8001120:	e0bff315 	stw	r2,-52(fp)
 8001124:	e0bff317 	ldw	r2,-52(fp)
 8001128:	1000051e 	bne	r2,zero,8001140 <__sfvwrite_r+0x558>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
 800112c:	800b883a 	mov	r5,r16
 8001130:	e13ff817 	ldw	r4,-32(fp)
 8001134:	8003f540 	call	8003f54 <_fflush_r>
 8001138:	1000111e 	bne	r2,zero,8001180 <__sfvwrite_r+0x598>
		goto err;
	      nlknown = 0;
 800113c:	e03ff215 	stw	zero,-56(fp)
	    }
	  p += w;
 8001140:	8805883a 	mov	r2,r17
 8001144:	98a7883a 	add	r19,r19,r2
	  len -= w;
 8001148:	8805883a 	mov	r2,r17
 800114c:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 8001150:	a8800217 	ldw	r2,8(r21)
 8001154:	8807883a 	mov	r3,r17
 8001158:	10c5c83a 	sub	r2,r2,r3
 800115c:	a8800215 	stw	r2,8(r21)
 8001160:	a8800217 	ldw	r2,8(r21)
 8001164:	103fa41e 	bne	r2,zero,8000ff8 <__sfvwrite_r+0x410>
    }
  return 0;
 8001168:	0005883a 	mov	r2,zero
 800116c:	00000906 	br	8001194 <__sfvwrite_r+0x5ac>
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
 8001170:	0001883a 	nop
 8001174:	00000306 	br	8001184 <__sfvwrite_r+0x59c>
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
 8001178:	0001883a 	nop
 800117c:	00000106 	br	8001184 <__sfvwrite_r+0x59c>
	    }
	  if ((nldist -= w) == 0)
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
 8001180:	0001883a 	nop
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
 8001184:	8080030b 	ldhu	r2,12(r16)
 8001188:	10801014 	ori	r2,r2,64
 800118c:	8080030d 	sth	r2,12(r16)
  return EOF;
 8001190:	00bfffc4 	movi	r2,-1
}
 8001194:	e6fff904 	addi	sp,fp,-28
 8001198:	dfc00817 	ldw	ra,32(sp)
 800119c:	df000717 	ldw	fp,28(sp)
 80011a0:	dd800617 	ldw	r22,24(sp)
 80011a4:	dd400517 	ldw	r21,20(sp)
 80011a8:	dd000417 	ldw	r20,16(sp)
 80011ac:	dcc00317 	ldw	r19,12(sp)
 80011b0:	dc800217 	ldw	r18,8(sp)
 80011b4:	dc400117 	ldw	r17,4(sp)
 80011b8:	dc000017 	ldw	r16,0(sp)
 80011bc:	dec00904 	addi	sp,sp,36
 80011c0:	f800283a 	ret

080011c4 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
 80011c4:	defff804 	addi	sp,sp,-32
 80011c8:	dfc00715 	stw	ra,28(sp)
 80011cc:	df000615 	stw	fp,24(sp)
 80011d0:	dd000515 	stw	r20,20(sp)
 80011d4:	dcc00415 	stw	r19,16(sp)
 80011d8:	dc800315 	stw	r18,12(sp)
 80011dc:	dc400215 	stw	r17,8(sp)
 80011e0:	dc000115 	stw	r16,4(sp)
 80011e4:	df000604 	addi	fp,sp,24
 80011e8:	e13ffa15 	stw	r4,-24(fp)
 80011ec:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 80011f0:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 80011f4:	e0bffa17 	ldw	r2,-24(fp)
 80011f8:	1440b804 	addi	r17,r2,736
 80011fc:	00001b06 	br	800126c <_fwalk+0xa8>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8001200:	8c000217 	ldw	r16,8(r17)
 8001204:	8c800117 	ldw	r18,4(r17)
 8001208:	00001506 	br	8001260 <_fwalk+0x9c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 800120c:	8080030b 	ldhu	r2,12(r16)
 8001210:	10bfffcc 	andi	r2,r2,65535
 8001214:	10a0001c 	xori	r2,r2,32768
 8001218:	10a00004 	addi	r2,r2,-32768
 800121c:	10000f26 	beq	r2,zero,800125c <_fwalk+0x98>
 8001220:	8080030b 	ldhu	r2,12(r16)
 8001224:	10bfffcc 	andi	r2,r2,65535
 8001228:	10a0001c 	xori	r2,r2,32768
 800122c:	10a00004 	addi	r2,r2,-32768
 8001230:	10800060 	cmpeqi	r2,r2,1
 8001234:	1000091e 	bne	r2,zero,800125c <_fwalk+0x98>
 8001238:	8080038b 	ldhu	r2,14(r16)
 800123c:	10bfffcc 	andi	r2,r2,65535
 8001240:	10a0001c 	xori	r2,r2,32768
 8001244:	10a00004 	addi	r2,r2,-32768
 8001248:	10bfffe0 	cmpeqi	r2,r2,-1
 800124c:	1000031e 	bne	r2,zero,800125c <_fwalk+0x98>
	ret |= (*function) (fp);
 8001250:	8009883a 	mov	r4,r16
 8001254:	a03ee83a 	callr	r20
 8001258:	98a6b03a 	or	r19,r19,r2
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 800125c:	84001a04 	addi	r16,r16,104
 8001260:	94bfffc4 	addi	r18,r18,-1
 8001264:	903fe90e 	bge	r18,zero,800120c <_fwalk+0x48>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8001268:	8c400017 	ldw	r17,0(r17)
 800126c:	883fe41e 	bne	r17,zero,8001200 <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
 8001270:	9805883a 	mov	r2,r19
}
 8001274:	e6fffb04 	addi	sp,fp,-20
 8001278:	dfc00617 	ldw	ra,24(sp)
 800127c:	df000517 	ldw	fp,20(sp)
 8001280:	dd000417 	ldw	r20,16(sp)
 8001284:	dcc00317 	ldw	r19,12(sp)
 8001288:	dc800217 	ldw	r18,8(sp)
 800128c:	dc400117 	ldw	r17,4(sp)
 8001290:	dc000017 	ldw	r16,0(sp)
 8001294:	dec00704 	addi	sp,sp,28
 8001298:	f800283a 	ret

0800129c <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
 800129c:	defff804 	addi	sp,sp,-32
 80012a0:	dfc00715 	stw	ra,28(sp)
 80012a4:	df000615 	stw	fp,24(sp)
 80012a8:	dd000515 	stw	r20,20(sp)
 80012ac:	dcc00415 	stw	r19,16(sp)
 80012b0:	dc800315 	stw	r18,12(sp)
 80012b4:	dc400215 	stw	r17,8(sp)
 80012b8:	dc000115 	stw	r16,4(sp)
 80012bc:	df000604 	addi	fp,sp,24
 80012c0:	e13ffa15 	stw	r4,-24(fp)
 80012c4:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 80012c8:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 80012cc:	e0bffa17 	ldw	r2,-24(fp)
 80012d0:	1440b804 	addi	r17,r2,736
 80012d4:	00001c06 	br	8001348 <_fwalk_reent+0xac>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 80012d8:	8c000217 	ldw	r16,8(r17)
 80012dc:	8c800117 	ldw	r18,4(r17)
 80012e0:	00001606 	br	800133c <_fwalk_reent+0xa0>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 80012e4:	8080030b 	ldhu	r2,12(r16)
 80012e8:	10bfffcc 	andi	r2,r2,65535
 80012ec:	10a0001c 	xori	r2,r2,32768
 80012f0:	10a00004 	addi	r2,r2,-32768
 80012f4:	10001026 	beq	r2,zero,8001338 <_fwalk_reent+0x9c>
 80012f8:	8080030b 	ldhu	r2,12(r16)
 80012fc:	10bfffcc 	andi	r2,r2,65535
 8001300:	10a0001c 	xori	r2,r2,32768
 8001304:	10a00004 	addi	r2,r2,-32768
 8001308:	10800060 	cmpeqi	r2,r2,1
 800130c:	10000a1e 	bne	r2,zero,8001338 <_fwalk_reent+0x9c>
 8001310:	8080038b 	ldhu	r2,14(r16)
 8001314:	10bfffcc 	andi	r2,r2,65535
 8001318:	10a0001c 	xori	r2,r2,32768
 800131c:	10a00004 	addi	r2,r2,-32768
 8001320:	10bfffe0 	cmpeqi	r2,r2,-1
 8001324:	1000041e 	bne	r2,zero,8001338 <_fwalk_reent+0x9c>
	ret |= (*reent_function) (ptr, fp);
 8001328:	800b883a 	mov	r5,r16
 800132c:	e13ffa17 	ldw	r4,-24(fp)
 8001330:	a03ee83a 	callr	r20
 8001334:	98a6b03a 	or	r19,r19,r2
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8001338:	84001a04 	addi	r16,r16,104
 800133c:	94bfffc4 	addi	r18,r18,-1
 8001340:	903fe80e 	bge	r18,zero,80012e4 <_fwalk_reent+0x48>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8001344:	8c400017 	ldw	r17,0(r17)
 8001348:	883fe31e 	bne	r17,zero,80012d8 <_fwalk_reent+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
 800134c:	9805883a 	mov	r2,r19
}
 8001350:	e6fffb04 	addi	sp,fp,-20
 8001354:	dfc00617 	ldw	ra,24(sp)
 8001358:	df000517 	ldw	fp,20(sp)
 800135c:	dd000417 	ldw	r20,16(sp)
 8001360:	dcc00317 	ldw	r19,12(sp)
 8001364:	dc800217 	ldw	r18,8(sp)
 8001368:	dc400117 	ldw	r17,4(sp)
 800136c:	dc000017 	ldw	r16,0(sp)
 8001370:	dec00704 	addi	sp,sp,28
 8001374:	f800283a 	ret

08001378 <malloc_extend_top>:
#if __STD_C
static void malloc_extend_top(RARG INTERNAL_SIZE_T nb)
#else
static void malloc_extend_top(RARG nb) RDECL INTERNAL_SIZE_T nb;
#endif
{
 8001378:	defff104 	addi	sp,sp,-60
 800137c:	dfc00e15 	stw	ra,56(sp)
 8001380:	df000d15 	stw	fp,52(sp)
 8001384:	df000d04 	addi	fp,sp,52
 8001388:	e13ffe15 	stw	r4,-8(fp)
 800138c:	e17fff15 	stw	r5,-4(fp)
  char*     brk;                  /* return value from sbrk */
  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of sbrked space */
  INTERNAL_SIZE_T correction;     /* bytes for 2nd sbrk call */
  int correction_failed = 0;      /* whether we should relax the assertion */
 8001390:	e03ff715 	stw	zero,-36(fp)
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
 8001394:	00820134 	movhi	r2,2052
 8001398:	1083df04 	addi	r2,r2,3964
 800139c:	10800217 	ldw	r2,8(r2)
 80013a0:	e0bff815 	stw	r2,-32(fp)
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
 80013a4:	e0bff817 	ldw	r2,-32(fp)
 80013a8:	10c00117 	ldw	r3,4(r2)
 80013ac:	00bfff04 	movi	r2,-4
 80013b0:	1884703a 	and	r2,r3,r2
 80013b4:	e0bff915 	stw	r2,-28(fp)
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
 80013b8:	e0fff817 	ldw	r3,-32(fp)
 80013bc:	e0bff917 	ldw	r2,-28(fp)
 80013c0:	1885883a 	add	r2,r3,r2
 80013c4:	e0bffa15 	stw	r2,-24(fp)

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
 80013c8:	d0e6e317 	ldw	r3,-25716(gp)
 80013cc:	e0bfff17 	ldw	r2,-4(fp)
 80013d0:	1885883a 	add	r2,r3,r2
 80013d4:	10800404 	addi	r2,r2,16
 80013d8:	e0bff615 	stw	r2,-40(fp)
  unsigned long pagesz    = malloc_getpagesize;
 80013dc:	00840004 	movi	r2,4096
 80013e0:	e0bffb15 	stw	r2,-20(fp)

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
 80013e4:	d0a00317 	ldw	r2,-32756(gp)
 80013e8:	10bfffe0 	cmpeqi	r2,r2,-1
 80013ec:	1000081e 	bne	r2,zero,8001410 <malloc_extend_top+0x98>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
 80013f0:	e0fffb17 	ldw	r3,-20(fp)
 80013f4:	e0bff617 	ldw	r2,-40(fp)
 80013f8:	1885883a 	add	r2,r3,r2
 80013fc:	10ffffc4 	addi	r3,r2,-1
 8001400:	e0bffb17 	ldw	r2,-20(fp)
 8001404:	0085c83a 	sub	r2,zero,r2
 8001408:	1884703a 	and	r2,r3,r2
 800140c:	e0bff615 	stw	r2,-40(fp)

  brk = (char*)(MORECORE (sbrk_size));
 8001410:	e0bff617 	ldw	r2,-40(fp)
 8001414:	100b883a 	mov	r5,r2
 8001418:	e13ffe17 	ldw	r4,-8(fp)
 800141c:	80035a80 	call	80035a8 <_sbrk_r>
 8001420:	e0bff315 	stw	r2,-52(fp)

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
 8001424:	e0bff317 	ldw	r2,-52(fp)
 8001428:	10bfffe0 	cmpeqi	r2,r2,-1
 800142c:	1000b91e 	bne	r2,zero,8001714 <malloc_extend_top+0x39c>
 8001430:	e0fff317 	ldw	r3,-52(fp)
 8001434:	e0bffa17 	ldw	r2,-24(fp)
 8001438:	1880042e 	bgeu	r3,r2,800144c <malloc_extend_top+0xd4>
      (brk < old_end && old_top != initial_top))
 800143c:	00820134 	movhi	r2,2052
 8001440:	1083df04 	addi	r2,r2,3964
 8001444:	e0fff817 	ldw	r3,-32(fp)
 8001448:	1880b21e 	bne	r3,r2,8001714 <malloc_extend_top+0x39c>
    return;

  sbrked_mem += sbrk_size;
 800144c:	00820134 	movhi	r2,2052
 8001450:	10908a04 	addi	r2,r2,16936
 8001454:	10800017 	ldw	r2,0(r2)
 8001458:	1007883a 	mov	r3,r2
 800145c:	e0bff617 	ldw	r2,-40(fp)
 8001460:	1885883a 	add	r2,r3,r2
 8001464:	1007883a 	mov	r3,r2
 8001468:	00820134 	movhi	r2,2052
 800146c:	10908a04 	addi	r2,r2,16936
 8001470:	10c00015 	stw	r3,0(r2)

  if (brk == old_end /* can just add bytes to current top, unless
 8001474:	e0fff317 	ldw	r3,-52(fp)
 8001478:	e0bffa17 	ldw	r2,-24(fp)
 800147c:	1880101e 	bne	r3,r2,80014c0 <malloc_extend_top+0x148>
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
 8001480:	e0bffb17 	ldw	r2,-20(fp)
 8001484:	10ffffc4 	addi	r3,r2,-1
 8001488:	e0bffa17 	ldw	r2,-24(fp)
 800148c:	1884703a 	and	r2,r3,r2
 8001490:	10000b1e 	bne	r2,zero,80014c0 <malloc_extend_top+0x148>
  {
    top_size = sbrk_size + old_top_size;
 8001494:	e0fff617 	ldw	r3,-40(fp)
 8001498:	e0bff917 	ldw	r2,-28(fp)
 800149c:	1885883a 	add	r2,r3,r2
 80014a0:	e0bffc15 	stw	r2,-16(fp)
    set_head(top, top_size | PREV_INUSE);
 80014a4:	00820134 	movhi	r2,2052
 80014a8:	1083df04 	addi	r2,r2,3964
 80014ac:	10800217 	ldw	r2,8(r2)
 80014b0:	e0fffc17 	ldw	r3,-16(fp)
 80014b4:	18c00054 	ori	r3,r3,1
 80014b8:	10c00115 	stw	r3,4(r2)
 80014bc:	00008006 	br	80016c0 <malloc_extend_top+0x348>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
 80014c0:	d0a00317 	ldw	r2,-32756(gp)
 80014c4:	10bfffd8 	cmpnei	r2,r2,-1
 80014c8:	1000031e 	bne	r2,zero,80014d8 <malloc_extend_top+0x160>
      sbrk_base = brk;
 80014cc:	e0bff317 	ldw	r2,-52(fp)
 80014d0:	d0a00315 	stw	r2,-32756(gp)
 80014d4:	00000a06 	br	8001500 <malloc_extend_top+0x188>
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
 80014d8:	00820134 	movhi	r2,2052
 80014dc:	10908a04 	addi	r2,r2,16936
 80014e0:	10c00017 	ldw	r3,0(r2)
 80014e4:	e13ff317 	ldw	r4,-52(fp)
 80014e8:	e0bffa17 	ldw	r2,-24(fp)
 80014ec:	2085c83a 	sub	r2,r4,r2
 80014f0:	1887883a 	add	r3,r3,r2
 80014f4:	00820134 	movhi	r2,2052
 80014f8:	10908a04 	addi	r2,r2,16936
 80014fc:	10c00015 	stw	r3,0(r2)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
 8001500:	e0bff317 	ldw	r2,-52(fp)
 8001504:	10800204 	addi	r2,r2,8
 8001508:	108001cc 	andi	r2,r2,7
 800150c:	e0bffd15 	stw	r2,-12(fp)
    if (front_misalign > 0) 
 8001510:	e0bffd17 	ldw	r2,-12(fp)
 8001514:	10000926 	beq	r2,zero,800153c <malloc_extend_top+0x1c4>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
 8001518:	00c00204 	movi	r3,8
 800151c:	e0bffd17 	ldw	r2,-12(fp)
 8001520:	1885c83a 	sub	r2,r3,r2
 8001524:	e0bff415 	stw	r2,-48(fp)
      brk += correction;
 8001528:	e0fff317 	ldw	r3,-52(fp)
 800152c:	e0bff417 	ldw	r2,-48(fp)
 8001530:	1885883a 	add	r2,r3,r2
 8001534:	e0bff315 	stw	r2,-52(fp)
 8001538:	00000106 	br	8001540 <malloc_extend_top+0x1c8>
    }
    else
      correction = 0;
 800153c:	e03ff415 	stw	zero,-48(fp)

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
 8001540:	e0fff317 	ldw	r3,-52(fp)
 8001544:	e0bff617 	ldw	r2,-40(fp)
 8001548:	1885883a 	add	r2,r3,r2
 800154c:	1007883a 	mov	r3,r2
 8001550:	e0bffb17 	ldw	r2,-20(fp)
 8001554:	10bfffc4 	addi	r2,r2,-1
 8001558:	1884703a 	and	r2,r3,r2
 800155c:	e0fffb17 	ldw	r3,-20(fp)
 8001560:	1885c83a 	sub	r2,r3,r2
 8001564:	e0fff417 	ldw	r3,-48(fp)
 8001568:	1885883a 	add	r2,r3,r2
 800156c:	e0bff415 	stw	r2,-48(fp)

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
 8001570:	e0bff417 	ldw	r2,-48(fp)
 8001574:	100b883a 	mov	r5,r2
 8001578:	e13ffe17 	ldw	r4,-8(fp)
 800157c:	80035a80 	call	80035a8 <_sbrk_r>
 8001580:	e0bff515 	stw	r2,-44(fp)
    if (new_brk == (char*)(MORECORE_FAILURE))
 8001584:	e0bff517 	ldw	r2,-44(fp)
 8001588:	10bfffd8 	cmpnei	r2,r2,-1
 800158c:	1000051e 	bne	r2,zero,80015a4 <malloc_extend_top+0x22c>
      {
	correction = 0;
 8001590:	e03ff415 	stw	zero,-48(fp)
	correction_failed = 1;
 8001594:	00800044 	movi	r2,1
 8001598:	e0bff715 	stw	r2,-36(fp)
	new_brk = brk;
 800159c:	e0bff317 	ldw	r2,-52(fp)
 80015a0:	e0bff515 	stw	r2,-44(fp)
      }

    sbrked_mem += correction;
 80015a4:	00820134 	movhi	r2,2052
 80015a8:	10908a04 	addi	r2,r2,16936
 80015ac:	10800017 	ldw	r2,0(r2)
 80015b0:	1007883a 	mov	r3,r2
 80015b4:	e0bff417 	ldw	r2,-48(fp)
 80015b8:	1885883a 	add	r2,r3,r2
 80015bc:	1007883a 	mov	r3,r2
 80015c0:	00820134 	movhi	r2,2052
 80015c4:	10908a04 	addi	r2,r2,16936
 80015c8:	10c00015 	stw	r3,0(r2)

    top = (mchunkptr)brk;
 80015cc:	00820134 	movhi	r2,2052
 80015d0:	1083df04 	addi	r2,r2,3964
 80015d4:	e0fff317 	ldw	r3,-52(fp)
 80015d8:	10c00215 	stw	r3,8(r2)
    top_size = new_brk - brk + correction;
 80015dc:	e0fff517 	ldw	r3,-44(fp)
 80015e0:	e0bff317 	ldw	r2,-52(fp)
 80015e4:	1885c83a 	sub	r2,r3,r2
 80015e8:	1007883a 	mov	r3,r2
 80015ec:	e0bff417 	ldw	r2,-48(fp)
 80015f0:	1885883a 	add	r2,r3,r2
 80015f4:	e0bffc15 	stw	r2,-16(fp)
    set_head(top, top_size | PREV_INUSE);
 80015f8:	00820134 	movhi	r2,2052
 80015fc:	1083df04 	addi	r2,r2,3964
 8001600:	10800217 	ldw	r2,8(r2)
 8001604:	e0fffc17 	ldw	r3,-16(fp)
 8001608:	18c00054 	ori	r3,r3,1
 800160c:	10c00115 	stw	r3,4(r2)

    if (old_top != initial_top)
 8001610:	00820134 	movhi	r2,2052
 8001614:	1083df04 	addi	r2,r2,3964
 8001618:	e0fff817 	ldw	r3,-32(fp)
 800161c:	18802826 	beq	r3,r2,80016c0 <malloc_extend_top+0x348>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
 8001620:	e0bff917 	ldw	r2,-28(fp)
 8001624:	10800428 	cmpgeui	r2,r2,16
 8001628:	1000061e 	bne	r2,zero,8001644 <malloc_extend_top+0x2cc>
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
 800162c:	00820134 	movhi	r2,2052
 8001630:	1083df04 	addi	r2,r2,3964
 8001634:	10800217 	ldw	r2,8(r2)
 8001638:	00c00044 	movi	r3,1
 800163c:	10c00115 	stw	r3,4(r2)
        return;
 8001640:	00003506 	br	8001718 <malloc_extend_top+0x3a0>
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
 8001644:	e0bff917 	ldw	r2,-28(fp)
 8001648:	10fffd04 	addi	r3,r2,-12
 800164c:	00bffe04 	movi	r2,-8
 8001650:	1884703a 	and	r2,r3,r2
 8001654:	e0bff915 	stw	r2,-28(fp)
      set_head_size(old_top, old_top_size);
 8001658:	e0bff817 	ldw	r2,-32(fp)
 800165c:	10800117 	ldw	r2,4(r2)
 8001660:	10c0004c 	andi	r3,r2,1
 8001664:	e0bff917 	ldw	r2,-28(fp)
 8001668:	1886b03a 	or	r3,r3,r2
 800166c:	e0bff817 	ldw	r2,-32(fp)
 8001670:	10c00115 	stw	r3,4(r2)
      chunk_at_offset(old_top, old_top_size          )->size =
 8001674:	e0fff817 	ldw	r3,-32(fp)
 8001678:	e0bff917 	ldw	r2,-28(fp)
 800167c:	1885883a 	add	r2,r3,r2
 8001680:	00c00144 	movi	r3,5
 8001684:	10c00115 	stw	r3,4(r2)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
 8001688:	e0bff917 	ldw	r2,-28(fp)
 800168c:	10800104 	addi	r2,r2,4
 8001690:	e0fff817 	ldw	r3,-32(fp)
 8001694:	1885883a 	add	r2,r3,r2
 8001698:	00c00144 	movi	r3,5
 800169c:	10c00115 	stw	r3,4(r2)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
 80016a0:	e0bff917 	ldw	r2,-28(fp)
 80016a4:	10800430 	cmpltui	r2,r2,16
 80016a8:	1000051e 	bne	r2,zero,80016c0 <malloc_extend_top+0x348>
        fREe(RCALL chunk2mem(old_top));
 80016ac:	e0bff817 	ldw	r2,-32(fp)
 80016b0:	10800204 	addi	r2,r2,8
 80016b4:	100b883a 	mov	r5,r2
 80016b8:	e13ffe17 	ldw	r4,-8(fp)
 80016bc:	80040300 	call	8004030 <_free_r>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
 80016c0:	00820134 	movhi	r2,2052
 80016c4:	10908a04 	addi	r2,r2,16936
 80016c8:	10800017 	ldw	r2,0(r2)
 80016cc:	1007883a 	mov	r3,r2
 80016d0:	d0a6e417 	ldw	r2,-25712(gp)
 80016d4:	10c0042e 	bgeu	r2,r3,80016e8 <malloc_extend_top+0x370>
    max_sbrked_mem = sbrked_mem;
 80016d8:	00820134 	movhi	r2,2052
 80016dc:	10908a04 	addi	r2,r2,16936
 80016e0:	10800017 	ldw	r2,0(r2)
 80016e4:	d0a6e415 	stw	r2,-25712(gp)
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
 80016e8:	00820134 	movhi	r2,2052
 80016ec:	10908a04 	addi	r2,r2,16936
 80016f0:	10800017 	ldw	r2,0(r2)
 80016f4:	1007883a 	mov	r3,r2
 80016f8:	d0a6e517 	ldw	r2,-25708(gp)
 80016fc:	10c0062e 	bgeu	r2,r3,8001718 <malloc_extend_top+0x3a0>
    max_total_mem = sbrked_mem;
 8001700:	00820134 	movhi	r2,2052
 8001704:	10908a04 	addi	r2,r2,16936
 8001708:	10800017 	ldw	r2,0(r2)
 800170c:	d0a6e515 	stw	r2,-25708(gp)
 8001710:	00000106 	br	8001718 <malloc_extend_top+0x3a0>
  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
    return;
 8001714:	0001883a 	nop
#endif

  /* We always land on a page boundary */
  assert(((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0
	 || correction_failed);
}
 8001718:	e037883a 	mov	sp,fp
 800171c:	dfc00117 	ldw	ra,4(sp)
 8001720:	df000017 	ldw	fp,0(sp)
 8001724:	dec00204 	addi	sp,sp,8
 8001728:	f800283a 	ret

0800172c <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
 800172c:	deffef04 	addi	sp,sp,-68
 8001730:	dfc01015 	stw	ra,64(sp)
 8001734:	df000f15 	stw	fp,60(sp)
 8001738:	df000f04 	addi	fp,sp,60
 800173c:	e13ffe15 	stw	r4,-8(fp)
 8001740:	e17fff15 	stw	r5,-4(fp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
 8001744:	e0bfff17 	ldw	r2,-4(fp)
 8001748:	108002c4 	addi	r2,r2,11
 800174c:	108005f0 	cmpltui	r2,r2,23
 8001750:	1000051e 	bne	r2,zero,8001768 <_malloc_r+0x3c>
 8001754:	e0bfff17 	ldw	r2,-4(fp)
 8001758:	10c002c4 	addi	r3,r2,11
 800175c:	00bffe04 	movi	r2,-8
 8001760:	1884703a 	and	r2,r3,r2
 8001764:	00000106 	br	800176c <_malloc_r+0x40>
 8001768:	00800404 	movi	r2,16
 800176c:	e0bffa15 	stw	r2,-24(fp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
 8001770:	e0bffa17 	ldw	r2,-24(fp)
 8001774:	10000316 	blt	r2,zero,8001784 <_malloc_r+0x58>
 8001778:	e0fffa17 	ldw	r3,-24(fp)
 800177c:	e0bfff17 	ldw	r2,-4(fp)
 8001780:	1880052e 	bgeu	r3,r2,8001798 <_malloc_r+0x6c>
  {
    RERRNO = ENOMEM;
 8001784:	e0bffe17 	ldw	r2,-8(fp)
 8001788:	00c00304 	movi	r3,12
 800178c:	10c00015 	stw	r3,0(r2)
    return 0;
 8001790:	0005883a 	mov	r2,zero
 8001794:	0002bf06 	br	8002294 <_malloc_r+0xb68>
  }

  MALLOC_LOCK;
 8001798:	e13ffe17 	ldw	r4,-8(fp)
 800179c:	80052440 	call	8005244 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
 80017a0:	e0bffa17 	ldw	r2,-24(fp)
 80017a4:	10807e28 	cmpgeui	r2,r2,504
 80017a8:	10003f1e 	bne	r2,zero,80018a8 <_malloc_r+0x17c>
  {
    idx = smallbin_index(nb); 
 80017ac:	e0bffa17 	ldw	r2,-24(fp)
 80017b0:	1004d0fa 	srli	r2,r2,3
 80017b4:	e0bff215 	stw	r2,-56(fp)

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
 80017b8:	e0bff217 	ldw	r2,-56(fp)
 80017bc:	10800044 	addi	r2,r2,1
 80017c0:	1085883a 	add	r2,r2,r2
 80017c4:	1085883a 	add	r2,r2,r2
 80017c8:	1087883a 	add	r3,r2,r2
 80017cc:	00820134 	movhi	r2,2052
 80017d0:	1083df04 	addi	r2,r2,3964
 80017d4:	1885883a 	add	r2,r3,r2
 80017d8:	10bffe04 	addi	r2,r2,-8
 80017dc:	e0bff915 	stw	r2,-28(fp)
    victim = last(q);
 80017e0:	e0bff917 	ldw	r2,-28(fp)
 80017e4:	10800317 	ldw	r2,12(r2)
 80017e8:	e0bff115 	stw	r2,-60(fp)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
 80017ec:	e0fff117 	ldw	r3,-60(fp)
 80017f0:	e0bff917 	ldw	r2,-28(fp)
 80017f4:	1880061e 	bne	r3,r2,8001810 <_malloc_r+0xe4>
    {
      q = next_bin(q);
 80017f8:	e0bff917 	ldw	r2,-28(fp)
 80017fc:	10800204 	addi	r2,r2,8
 8001800:	e0bff915 	stw	r2,-28(fp)
      victim = last(q);
 8001804:	e0bff917 	ldw	r2,-28(fp)
 8001808:	10800317 	ldw	r2,12(r2)
 800180c:	e0bff115 	stw	r2,-60(fp)
    }
#endif
    if (victim != q)
 8001810:	e0fff117 	ldw	r3,-60(fp)
 8001814:	e0bff917 	ldw	r2,-28(fp)
 8001818:	18801f26 	beq	r3,r2,8001898 <_malloc_r+0x16c>
    {
      victim_size = chunksize(victim);
 800181c:	e0bff117 	ldw	r2,-60(fp)
 8001820:	10c00117 	ldw	r3,4(r2)
 8001824:	00bfff04 	movi	r2,-4
 8001828:	1884703a 	and	r2,r3,r2
 800182c:	e0bffb15 	stw	r2,-20(fp)
      unlink(victim, bck, fwd);
 8001830:	e0bff117 	ldw	r2,-60(fp)
 8001834:	10800317 	ldw	r2,12(r2)
 8001838:	e0bff815 	stw	r2,-32(fp)
 800183c:	e0bff117 	ldw	r2,-60(fp)
 8001840:	10800217 	ldw	r2,8(r2)
 8001844:	e0bff715 	stw	r2,-36(fp)
 8001848:	e0bff717 	ldw	r2,-36(fp)
 800184c:	e0fff817 	ldw	r3,-32(fp)
 8001850:	10c00315 	stw	r3,12(r2)
 8001854:	e0bff817 	ldw	r2,-32(fp)
 8001858:	e0fff717 	ldw	r3,-36(fp)
 800185c:	10c00215 	stw	r3,8(r2)
      set_inuse_bit_at_offset(victim, victim_size);
 8001860:	e0fff117 	ldw	r3,-60(fp)
 8001864:	e0bffb17 	ldw	r2,-20(fp)
 8001868:	1885883a 	add	r2,r3,r2
 800186c:	e13ff117 	ldw	r4,-60(fp)
 8001870:	e0fffb17 	ldw	r3,-20(fp)
 8001874:	20c7883a 	add	r3,r4,r3
 8001878:	18c00117 	ldw	r3,4(r3)
 800187c:	18c00054 	ori	r3,r3,1
 8001880:	10c00115 	stw	r3,4(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 8001884:	e13ffe17 	ldw	r4,-8(fp)
 8001888:	80052680 	call	8005268 <__malloc_unlock>
      return chunk2mem(victim);
 800188c:	e0bff117 	ldw	r2,-60(fp)
 8001890:	10800204 	addi	r2,r2,8
 8001894:	00027f06 	br	8002294 <_malloc_r+0xb68>
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
 8001898:	e0bff217 	ldw	r2,-56(fp)
 800189c:	10800084 	addi	r2,r2,2
 80018a0:	e0bff215 	stw	r2,-56(fp)
 80018a4:	00007306 	br	8001a74 <_malloc_r+0x348>

  }
  else
  {
    idx = bin_index(nb);
 80018a8:	e0bffa17 	ldw	r2,-24(fp)
 80018ac:	1004d27a 	srli	r2,r2,9
 80018b0:	1000031e 	bne	r2,zero,80018c0 <_malloc_r+0x194>
 80018b4:	e0bffa17 	ldw	r2,-24(fp)
 80018b8:	1004d0fa 	srli	r2,r2,3
 80018bc:	00002906 	br	8001964 <_malloc_r+0x238>
 80018c0:	e0bffa17 	ldw	r2,-24(fp)
 80018c4:	1004d27a 	srli	r2,r2,9
 80018c8:	10800168 	cmpgeui	r2,r2,5
 80018cc:	1000041e 	bne	r2,zero,80018e0 <_malloc_r+0x1b4>
 80018d0:	e0bffa17 	ldw	r2,-24(fp)
 80018d4:	1004d1ba 	srli	r2,r2,6
 80018d8:	10800e04 	addi	r2,r2,56
 80018dc:	00002106 	br	8001964 <_malloc_r+0x238>
 80018e0:	e0bffa17 	ldw	r2,-24(fp)
 80018e4:	1004d27a 	srli	r2,r2,9
 80018e8:	10800568 	cmpgeui	r2,r2,21
 80018ec:	1000041e 	bne	r2,zero,8001900 <_malloc_r+0x1d4>
 80018f0:	e0bffa17 	ldw	r2,-24(fp)
 80018f4:	1004d27a 	srli	r2,r2,9
 80018f8:	108016c4 	addi	r2,r2,91
 80018fc:	00001906 	br	8001964 <_malloc_r+0x238>
 8001900:	e0bffa17 	ldw	r2,-24(fp)
 8001904:	1004d27a 	srli	r2,r2,9
 8001908:	10801568 	cmpgeui	r2,r2,85
 800190c:	1000041e 	bne	r2,zero,8001920 <_malloc_r+0x1f4>
 8001910:	e0bffa17 	ldw	r2,-24(fp)
 8001914:	1004d33a 	srli	r2,r2,12
 8001918:	10801b84 	addi	r2,r2,110
 800191c:	00001106 	br	8001964 <_malloc_r+0x238>
 8001920:	e0bffa17 	ldw	r2,-24(fp)
 8001924:	1004d27a 	srli	r2,r2,9
 8001928:	10805568 	cmpgeui	r2,r2,341
 800192c:	1000041e 	bne	r2,zero,8001940 <_malloc_r+0x214>
 8001930:	e0bffa17 	ldw	r2,-24(fp)
 8001934:	1004d3fa 	srli	r2,r2,15
 8001938:	10801dc4 	addi	r2,r2,119
 800193c:	00000906 	br	8001964 <_malloc_r+0x238>
 8001940:	e0bffa17 	ldw	r2,-24(fp)
 8001944:	1004d27a 	srli	r2,r2,9
 8001948:	10815568 	cmpgeui	r2,r2,1365
 800194c:	1000041e 	bne	r2,zero,8001960 <_malloc_r+0x234>
 8001950:	e0bffa17 	ldw	r2,-24(fp)
 8001954:	1004d4ba 	srli	r2,r2,18
 8001958:	10801f04 	addi	r2,r2,124
 800195c:	00000106 	br	8001964 <_malloc_r+0x238>
 8001960:	00801f84 	movi	r2,126
 8001964:	e0bff215 	stw	r2,-56(fp)
    bin = bin_at(idx);
 8001968:	e0bff217 	ldw	r2,-56(fp)
 800196c:	10800044 	addi	r2,r2,1
 8001970:	1085883a 	add	r2,r2,r2
 8001974:	1085883a 	add	r2,r2,r2
 8001978:	1087883a 	add	r3,r2,r2
 800197c:	00820134 	movhi	r2,2052
 8001980:	1083df04 	addi	r2,r2,3964
 8001984:	1885883a 	add	r2,r3,r2
 8001988:	10bffe04 	addi	r2,r2,-8
 800198c:	e0bff315 	stw	r2,-52(fp)

    for (victim = last(bin); victim != bin; victim = victim->bk)
 8001990:	e0bff317 	ldw	r2,-52(fp)
 8001994:	10800317 	ldw	r2,12(r2)
 8001998:	e0bff115 	stw	r2,-60(fp)
 800199c:	00002f06 	br	8001a5c <_malloc_r+0x330>
    {
      victim_size = chunksize(victim);
 80019a0:	e0bff117 	ldw	r2,-60(fp)
 80019a4:	10c00117 	ldw	r3,4(r2)
 80019a8:	00bfff04 	movi	r2,-4
 80019ac:	1884703a 	and	r2,r3,r2
 80019b0:	e0bffb15 	stw	r2,-20(fp)
      remainder_size = long_sub_size_t(victim_size, nb);
 80019b4:	e0fffb17 	ldw	r3,-20(fp)
 80019b8:	e0bffa17 	ldw	r2,-24(fp)
 80019bc:	1885c83a 	sub	r2,r3,r2
 80019c0:	e0bff415 	stw	r2,-48(fp)
      
      if (remainder_size >= (long)MINSIZE) /* too big */
 80019c4:	e0bff417 	ldw	r2,-48(fp)
 80019c8:	10800410 	cmplti	r2,r2,16
 80019cc:	1000041e 	bne	r2,zero,80019e0 <_malloc_r+0x2b4>
      {
        --idx; /* adjust to rescan below after checking last remainder */
 80019d0:	e0bff217 	ldw	r2,-56(fp)
 80019d4:	10bfffc4 	addi	r2,r2,-1
 80019d8:	e0bff215 	stw	r2,-56(fp)
        break;   
 80019dc:	00002206 	br	8001a68 <_malloc_r+0x33c>
      }

      else if (remainder_size >= 0) /* exact fit */
 80019e0:	e0bff417 	ldw	r2,-48(fp)
 80019e4:	10001a16 	blt	r2,zero,8001a50 <_malloc_r+0x324>
      {
        unlink(victim, bck, fwd);
 80019e8:	e0bff117 	ldw	r2,-60(fp)
 80019ec:	10800317 	ldw	r2,12(r2)
 80019f0:	e0bff815 	stw	r2,-32(fp)
 80019f4:	e0bff117 	ldw	r2,-60(fp)
 80019f8:	10800217 	ldw	r2,8(r2)
 80019fc:	e0bff715 	stw	r2,-36(fp)
 8001a00:	e0bff717 	ldw	r2,-36(fp)
 8001a04:	e0fff817 	ldw	r3,-32(fp)
 8001a08:	10c00315 	stw	r3,12(r2)
 8001a0c:	e0bff817 	ldw	r2,-32(fp)
 8001a10:	e0fff717 	ldw	r3,-36(fp)
 8001a14:	10c00215 	stw	r3,8(r2)
        set_inuse_bit_at_offset(victim, victim_size);
 8001a18:	e0fff117 	ldw	r3,-60(fp)
 8001a1c:	e0bffb17 	ldw	r2,-20(fp)
 8001a20:	1885883a 	add	r2,r3,r2
 8001a24:	e13ff117 	ldw	r4,-60(fp)
 8001a28:	e0fffb17 	ldw	r3,-20(fp)
 8001a2c:	20c7883a 	add	r3,r4,r3
 8001a30:	18c00117 	ldw	r3,4(r3)
 8001a34:	18c00054 	ori	r3,r3,1
 8001a38:	10c00115 	stw	r3,4(r2)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
 8001a3c:	e13ffe17 	ldw	r4,-8(fp)
 8001a40:	80052680 	call	8005268 <__malloc_unlock>
        return chunk2mem(victim);
 8001a44:	e0bff117 	ldw	r2,-60(fp)
 8001a48:	10800204 	addi	r2,r2,8
 8001a4c:	00021106 	br	8002294 <_malloc_r+0xb68>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
 8001a50:	e0bff117 	ldw	r2,-60(fp)
 8001a54:	10800317 	ldw	r2,12(r2)
 8001a58:	e0bff115 	stw	r2,-60(fp)
 8001a5c:	e0fff117 	ldw	r3,-60(fp)
 8001a60:	e0bff317 	ldw	r2,-52(fp)
 8001a64:	18bfce1e 	bne	r3,r2,80019a0 <_malloc_r+0x274>
	MALLOC_UNLOCK;
        return chunk2mem(victim);
      }
    }

    ++idx; 
 8001a68:	e0bff217 	ldw	r2,-56(fp)
 8001a6c:	10800044 	addi	r2,r2,1
 8001a70:	e0bff215 	stw	r2,-56(fp)

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
 8001a74:	00820134 	movhi	r2,2052
 8001a78:	1083e104 	addi	r2,r2,3972
 8001a7c:	10800217 	ldw	r2,8(r2)
 8001a80:	e0bff115 	stw	r2,-60(fp)
 8001a84:	00820134 	movhi	r2,2052
 8001a88:	1083e104 	addi	r2,r2,3972
 8001a8c:	e0fff117 	ldw	r3,-60(fp)
 8001a90:	1880e626 	beq	r3,r2,8001e2c <_malloc_r+0x700>
  {
    victim_size = chunksize(victim);
 8001a94:	e0bff117 	ldw	r2,-60(fp)
 8001a98:	10c00117 	ldw	r3,4(r2)
 8001a9c:	00bfff04 	movi	r2,-4
 8001aa0:	1884703a 	and	r2,r3,r2
 8001aa4:	e0bffb15 	stw	r2,-20(fp)
    remainder_size = long_sub_size_t(victim_size, nb);
 8001aa8:	e0fffb17 	ldw	r3,-20(fp)
 8001aac:	e0bffa17 	ldw	r2,-24(fp)
 8001ab0:	1885c83a 	sub	r2,r3,r2
 8001ab4:	e0bff415 	stw	r2,-48(fp)

    if (remainder_size >= (long)MINSIZE) /* re-split */
 8001ab8:	e0bff417 	ldw	r2,-48(fp)
 8001abc:	10800410 	cmplti	r2,r2,16
 8001ac0:	1000271e 	bne	r2,zero,8001b60 <_malloc_r+0x434>
    {
      remainder = chunk_at_offset(victim, nb);
 8001ac4:	e0fff117 	ldw	r3,-60(fp)
 8001ac8:	e0bffa17 	ldw	r2,-24(fp)
 8001acc:	1885883a 	add	r2,r3,r2
 8001ad0:	e0bffc15 	stw	r2,-16(fp)
      set_head(victim, nb | PREV_INUSE);
 8001ad4:	e0bffa17 	ldw	r2,-24(fp)
 8001ad8:	10c00054 	ori	r3,r2,1
 8001adc:	e0bff117 	ldw	r2,-60(fp)
 8001ae0:	10c00115 	stw	r3,4(r2)
      link_last_remainder(remainder);
 8001ae4:	00c20134 	movhi	r3,2052
 8001ae8:	18c3e104 	addi	r3,r3,3972
 8001aec:	00820134 	movhi	r2,2052
 8001af0:	1083e104 	addi	r2,r2,3972
 8001af4:	e13ffc17 	ldw	r4,-16(fp)
 8001af8:	11000315 	stw	r4,12(r2)
 8001afc:	10800317 	ldw	r2,12(r2)
 8001b00:	18800215 	stw	r2,8(r3)
 8001b04:	00820134 	movhi	r2,2052
 8001b08:	1083e104 	addi	r2,r2,3972
 8001b0c:	e0fffc17 	ldw	r3,-16(fp)
 8001b10:	18800315 	stw	r2,12(r3)
 8001b14:	e0bffc17 	ldw	r2,-16(fp)
 8001b18:	10c00317 	ldw	r3,12(r2)
 8001b1c:	e0bffc17 	ldw	r2,-16(fp)
 8001b20:	10c00215 	stw	r3,8(r2)
      set_head(remainder, remainder_size | PREV_INUSE);
 8001b24:	e0bff417 	ldw	r2,-48(fp)
 8001b28:	10800054 	ori	r2,r2,1
 8001b2c:	1007883a 	mov	r3,r2
 8001b30:	e0bffc17 	ldw	r2,-16(fp)
 8001b34:	10c00115 	stw	r3,4(r2)
      set_foot(remainder, remainder_size);
 8001b38:	e0bff417 	ldw	r2,-48(fp)
 8001b3c:	e0fffc17 	ldw	r3,-16(fp)
 8001b40:	1885883a 	add	r2,r3,r2
 8001b44:	e0fff417 	ldw	r3,-48(fp)
 8001b48:	10c00015 	stw	r3,0(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 8001b4c:	e13ffe17 	ldw	r4,-8(fp)
 8001b50:	80052680 	call	8005268 <__malloc_unlock>
      return chunk2mem(victim);
 8001b54:	e0bff117 	ldw	r2,-60(fp)
 8001b58:	10800204 	addi	r2,r2,8
 8001b5c:	0001cd06 	br	8002294 <_malloc_r+0xb68>
    }

    clear_last_remainder;
 8001b60:	00c20134 	movhi	r3,2052
 8001b64:	18c3e104 	addi	r3,r3,3972
 8001b68:	00820134 	movhi	r2,2052
 8001b6c:	1083e104 	addi	r2,r2,3972
 8001b70:	01020134 	movhi	r4,2052
 8001b74:	2103e104 	addi	r4,r4,3972
 8001b78:	11000315 	stw	r4,12(r2)
 8001b7c:	10800317 	ldw	r2,12(r2)
 8001b80:	18800215 	stw	r2,8(r3)

    if (remainder_size >= 0)  /* exhaust */
 8001b84:	e0bff417 	ldw	r2,-48(fp)
 8001b88:	10000e16 	blt	r2,zero,8001bc4 <_malloc_r+0x498>
    {
      set_inuse_bit_at_offset(victim, victim_size);
 8001b8c:	e0fff117 	ldw	r3,-60(fp)
 8001b90:	e0bffb17 	ldw	r2,-20(fp)
 8001b94:	1885883a 	add	r2,r3,r2
 8001b98:	e13ff117 	ldw	r4,-60(fp)
 8001b9c:	e0fffb17 	ldw	r3,-20(fp)
 8001ba0:	20c7883a 	add	r3,r4,r3
 8001ba4:	18c00117 	ldw	r3,4(r3)
 8001ba8:	18c00054 	ori	r3,r3,1
 8001bac:	10c00115 	stw	r3,4(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 8001bb0:	e13ffe17 	ldw	r4,-8(fp)
 8001bb4:	80052680 	call	8005268 <__malloc_unlock>
      return chunk2mem(victim);
 8001bb8:	e0bff117 	ldw	r2,-60(fp)
 8001bbc:	10800204 	addi	r2,r2,8
 8001bc0:	0001b406 	br	8002294 <_malloc_r+0xb68>
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
 8001bc4:	e0bffb17 	ldw	r2,-20(fp)
 8001bc8:	10808028 	cmpgeui	r2,r2,512
 8001bcc:	10002c1e 	bne	r2,zero,8001c80 <_malloc_r+0x554>
 8001bd0:	e0bffb17 	ldw	r2,-20(fp)
 8001bd4:	1004d0fa 	srli	r2,r2,3
 8001bd8:	e0bffd15 	stw	r2,-12(fp)
 8001bdc:	00c20134 	movhi	r3,2052
 8001be0:	18c3df04 	addi	r3,r3,3964
 8001be4:	00820134 	movhi	r2,2052
 8001be8:	1083df04 	addi	r2,r2,3964
 8001bec:	11000117 	ldw	r4,4(r2)
 8001bf0:	e0bffd17 	ldw	r2,-12(fp)
 8001bf4:	1000010e 	bge	r2,zero,8001bfc <_malloc_r+0x4d0>
 8001bf8:	108000c4 	addi	r2,r2,3
 8001bfc:	1005d0ba 	srai	r2,r2,2
 8001c00:	100b883a 	mov	r5,r2
 8001c04:	00800044 	movi	r2,1
 8001c08:	1144983a 	sll	r2,r2,r5
 8001c0c:	2084b03a 	or	r2,r4,r2
 8001c10:	18800115 	stw	r2,4(r3)
 8001c14:	e0bffd17 	ldw	r2,-12(fp)
 8001c18:	10800044 	addi	r2,r2,1
 8001c1c:	1085883a 	add	r2,r2,r2
 8001c20:	1085883a 	add	r2,r2,r2
 8001c24:	1087883a 	add	r3,r2,r2
 8001c28:	00820134 	movhi	r2,2052
 8001c2c:	1083df04 	addi	r2,r2,3964
 8001c30:	1885883a 	add	r2,r3,r2
 8001c34:	10bffe04 	addi	r2,r2,-8
 8001c38:	e0bff815 	stw	r2,-32(fp)
 8001c3c:	e0bff817 	ldw	r2,-32(fp)
 8001c40:	10800217 	ldw	r2,8(r2)
 8001c44:	e0bff715 	stw	r2,-36(fp)
 8001c48:	e0bff117 	ldw	r2,-60(fp)
 8001c4c:	e0fff817 	ldw	r3,-32(fp)
 8001c50:	10c00315 	stw	r3,12(r2)
 8001c54:	e0bff117 	ldw	r2,-60(fp)
 8001c58:	e0fff717 	ldw	r3,-36(fp)
 8001c5c:	10c00215 	stw	r3,8(r2)
 8001c60:	e0bff817 	ldw	r2,-32(fp)
 8001c64:	e0fff117 	ldw	r3,-60(fp)
 8001c68:	10c00215 	stw	r3,8(r2)
 8001c6c:	e0bff817 	ldw	r2,-32(fp)
 8001c70:	10c00217 	ldw	r3,8(r2)
 8001c74:	e0bff717 	ldw	r2,-36(fp)
 8001c78:	10c00315 	stw	r3,12(r2)
 8001c7c:	00006b06 	br	8001e2c <_malloc_r+0x700>
 8001c80:	e0bffb17 	ldw	r2,-20(fp)
 8001c84:	1004d27a 	srli	r2,r2,9
 8001c88:	1000031e 	bne	r2,zero,8001c98 <_malloc_r+0x56c>
 8001c8c:	e0bffb17 	ldw	r2,-20(fp)
 8001c90:	1004d0fa 	srli	r2,r2,3
 8001c94:	00002906 	br	8001d3c <_malloc_r+0x610>
 8001c98:	e0bffb17 	ldw	r2,-20(fp)
 8001c9c:	1004d27a 	srli	r2,r2,9
 8001ca0:	10800168 	cmpgeui	r2,r2,5
 8001ca4:	1000041e 	bne	r2,zero,8001cb8 <_malloc_r+0x58c>
 8001ca8:	e0bffb17 	ldw	r2,-20(fp)
 8001cac:	1004d1ba 	srli	r2,r2,6
 8001cb0:	10800e04 	addi	r2,r2,56
 8001cb4:	00002106 	br	8001d3c <_malloc_r+0x610>
 8001cb8:	e0bffb17 	ldw	r2,-20(fp)
 8001cbc:	1004d27a 	srli	r2,r2,9
 8001cc0:	10800568 	cmpgeui	r2,r2,21
 8001cc4:	1000041e 	bne	r2,zero,8001cd8 <_malloc_r+0x5ac>
 8001cc8:	e0bffb17 	ldw	r2,-20(fp)
 8001ccc:	1004d27a 	srli	r2,r2,9
 8001cd0:	108016c4 	addi	r2,r2,91
 8001cd4:	00001906 	br	8001d3c <_malloc_r+0x610>
 8001cd8:	e0bffb17 	ldw	r2,-20(fp)
 8001cdc:	1004d27a 	srli	r2,r2,9
 8001ce0:	10801568 	cmpgeui	r2,r2,85
 8001ce4:	1000041e 	bne	r2,zero,8001cf8 <_malloc_r+0x5cc>
 8001ce8:	e0bffb17 	ldw	r2,-20(fp)
 8001cec:	1004d33a 	srli	r2,r2,12
 8001cf0:	10801b84 	addi	r2,r2,110
 8001cf4:	00001106 	br	8001d3c <_malloc_r+0x610>
 8001cf8:	e0bffb17 	ldw	r2,-20(fp)
 8001cfc:	1004d27a 	srli	r2,r2,9
 8001d00:	10805568 	cmpgeui	r2,r2,341
 8001d04:	1000041e 	bne	r2,zero,8001d18 <_malloc_r+0x5ec>
 8001d08:	e0bffb17 	ldw	r2,-20(fp)
 8001d0c:	1004d3fa 	srli	r2,r2,15
 8001d10:	10801dc4 	addi	r2,r2,119
 8001d14:	00000906 	br	8001d3c <_malloc_r+0x610>
 8001d18:	e0bffb17 	ldw	r2,-20(fp)
 8001d1c:	1004d27a 	srli	r2,r2,9
 8001d20:	10815568 	cmpgeui	r2,r2,1365
 8001d24:	1000041e 	bne	r2,zero,8001d38 <_malloc_r+0x60c>
 8001d28:	e0bffb17 	ldw	r2,-20(fp)
 8001d2c:	1004d4ba 	srli	r2,r2,18
 8001d30:	10801f04 	addi	r2,r2,124
 8001d34:	00000106 	br	8001d3c <_malloc_r+0x610>
 8001d38:	00801f84 	movi	r2,126
 8001d3c:	e0bffd15 	stw	r2,-12(fp)
 8001d40:	e0bffd17 	ldw	r2,-12(fp)
 8001d44:	10800044 	addi	r2,r2,1
 8001d48:	1085883a 	add	r2,r2,r2
 8001d4c:	1085883a 	add	r2,r2,r2
 8001d50:	1087883a 	add	r3,r2,r2
 8001d54:	00820134 	movhi	r2,2052
 8001d58:	1083df04 	addi	r2,r2,3964
 8001d5c:	1885883a 	add	r2,r3,r2
 8001d60:	10bffe04 	addi	r2,r2,-8
 8001d64:	e0bff815 	stw	r2,-32(fp)
 8001d68:	e0bff817 	ldw	r2,-32(fp)
 8001d6c:	10800217 	ldw	r2,8(r2)
 8001d70:	e0bff715 	stw	r2,-36(fp)
 8001d74:	e0fff717 	ldw	r3,-36(fp)
 8001d78:	e0bff817 	ldw	r2,-32(fp)
 8001d7c:	1880121e 	bne	r3,r2,8001dc8 <_malloc_r+0x69c>
 8001d80:	00c20134 	movhi	r3,2052
 8001d84:	18c3df04 	addi	r3,r3,3964
 8001d88:	00820134 	movhi	r2,2052
 8001d8c:	1083df04 	addi	r2,r2,3964
 8001d90:	11000117 	ldw	r4,4(r2)
 8001d94:	e0bffd17 	ldw	r2,-12(fp)
 8001d98:	1000010e 	bge	r2,zero,8001da0 <_malloc_r+0x674>
 8001d9c:	108000c4 	addi	r2,r2,3
 8001da0:	1005d0ba 	srai	r2,r2,2
 8001da4:	100b883a 	mov	r5,r2
 8001da8:	00800044 	movi	r2,1
 8001dac:	1144983a 	sll	r2,r2,r5
 8001db0:	2084b03a 	or	r2,r4,r2
 8001db4:	18800115 	stw	r2,4(r3)
 8001db8:	00000f06 	br	8001df8 <_malloc_r+0x6cc>
 8001dbc:	e0bff717 	ldw	r2,-36(fp)
 8001dc0:	10800217 	ldw	r2,8(r2)
 8001dc4:	e0bff715 	stw	r2,-36(fp)
 8001dc8:	e0fff717 	ldw	r3,-36(fp)
 8001dcc:	e0bff817 	ldw	r2,-32(fp)
 8001dd0:	18800626 	beq	r3,r2,8001dec <_malloc_r+0x6c0>
 8001dd4:	e0bff717 	ldw	r2,-36(fp)
 8001dd8:	10c00117 	ldw	r3,4(r2)
 8001ddc:	00bfff04 	movi	r2,-4
 8001de0:	1884703a 	and	r2,r3,r2
 8001de4:	e0fffb17 	ldw	r3,-20(fp)
 8001de8:	18bff436 	bltu	r3,r2,8001dbc <_malloc_r+0x690>
 8001dec:	e0bff717 	ldw	r2,-36(fp)
 8001df0:	10800317 	ldw	r2,12(r2)
 8001df4:	e0bff815 	stw	r2,-32(fp)
 8001df8:	e0bff117 	ldw	r2,-60(fp)
 8001dfc:	e0fff817 	ldw	r3,-32(fp)
 8001e00:	10c00315 	stw	r3,12(r2)
 8001e04:	e0bff117 	ldw	r2,-60(fp)
 8001e08:	e0fff717 	ldw	r3,-36(fp)
 8001e0c:	10c00215 	stw	r3,8(r2)
 8001e10:	e0bff817 	ldw	r2,-32(fp)
 8001e14:	e0fff117 	ldw	r3,-60(fp)
 8001e18:	10c00215 	stw	r3,8(r2)
 8001e1c:	e0bff817 	ldw	r2,-32(fp)
 8001e20:	10c00217 	ldw	r3,8(r2)
 8001e24:	e0bff717 	ldw	r2,-36(fp)
 8001e28:	10c00315 	stw	r3,12(r2)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
 8001e2c:	e0bff217 	ldw	r2,-56(fp)
 8001e30:	1000010e 	bge	r2,zero,8001e38 <_malloc_r+0x70c>
 8001e34:	108000c4 	addi	r2,r2,3
 8001e38:	1005d0ba 	srai	r2,r2,2
 8001e3c:	1007883a 	mov	r3,r2
 8001e40:	00800044 	movi	r2,1
 8001e44:	10c4983a 	sll	r2,r2,r3
 8001e48:	e0bff515 	stw	r2,-44(fp)
 8001e4c:	00820134 	movhi	r2,2052
 8001e50:	1083df04 	addi	r2,r2,3964
 8001e54:	10c00117 	ldw	r3,4(r2)
 8001e58:	e0bff517 	ldw	r2,-44(fp)
 8001e5c:	1880c636 	bltu	r3,r2,8002178 <_malloc_r+0xa4c>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
 8001e60:	00820134 	movhi	r2,2052
 8001e64:	1083df04 	addi	r2,r2,3964
 8001e68:	10c00117 	ldw	r3,4(r2)
 8001e6c:	e0bff517 	ldw	r2,-44(fp)
 8001e70:	1884703a 	and	r2,r3,r2
 8001e74:	1000151e 	bne	r2,zero,8001ecc <_malloc_r+0x7a0>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
 8001e78:	e0fff217 	ldw	r3,-56(fp)
 8001e7c:	00bfff04 	movi	r2,-4
 8001e80:	1884703a 	and	r2,r3,r2
 8001e84:	10800104 	addi	r2,r2,4
 8001e88:	e0bff215 	stw	r2,-56(fp)
      block <<= 1;
 8001e8c:	e0bff517 	ldw	r2,-44(fp)
 8001e90:	1085883a 	add	r2,r2,r2
 8001e94:	e0bff515 	stw	r2,-44(fp)
      while ((block & binblocks) == 0)
 8001e98:	00000606 	br	8001eb4 <_malloc_r+0x788>
      {
        idx += BINBLOCKWIDTH;
 8001e9c:	e0bff217 	ldw	r2,-56(fp)
 8001ea0:	10800104 	addi	r2,r2,4
 8001ea4:	e0bff215 	stw	r2,-56(fp)
        block <<= 1;
 8001ea8:	e0bff517 	ldw	r2,-44(fp)
 8001eac:	1085883a 	add	r2,r2,r2
 8001eb0:	e0bff515 	stw	r2,-44(fp)
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
 8001eb4:	00820134 	movhi	r2,2052
 8001eb8:	1083df04 	addi	r2,r2,3964
 8001ebc:	10c00117 	ldw	r3,4(r2)
 8001ec0:	e0bff517 	ldw	r2,-44(fp)
 8001ec4:	1884703a 	and	r2,r3,r2
 8001ec8:	103ff426 	beq	r2,zero,8001e9c <_malloc_r+0x770>
    }
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
 8001ecc:	e0bff217 	ldw	r2,-56(fp)
 8001ed0:	e0bff615 	stw	r2,-40(fp)
      q = bin = bin_at(idx);
 8001ed4:	e0bff217 	ldw	r2,-56(fp)
 8001ed8:	10800044 	addi	r2,r2,1
 8001edc:	1085883a 	add	r2,r2,r2
 8001ee0:	1085883a 	add	r2,r2,r2
 8001ee4:	1087883a 	add	r3,r2,r2
 8001ee8:	00820134 	movhi	r2,2052
 8001eec:	1083df04 	addi	r2,r2,3964
 8001ef0:	1885883a 	add	r2,r3,r2
 8001ef4:	10bffe04 	addi	r2,r2,-8
 8001ef8:	e0bff315 	stw	r2,-52(fp)
 8001efc:	e0bff317 	ldw	r2,-52(fp)
 8001f00:	e0bff915 	stw	r2,-28(fp)
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
 8001f04:	e0bff317 	ldw	r2,-52(fp)
 8001f08:	10800317 	ldw	r2,12(r2)
 8001f0c:	e0bff115 	stw	r2,-60(fp)
 8001f10:	00005e06 	br	800208c <_malloc_r+0x960>
        {
          victim_size = chunksize(victim);
 8001f14:	e0bff117 	ldw	r2,-60(fp)
 8001f18:	10c00117 	ldw	r3,4(r2)
 8001f1c:	00bfff04 	movi	r2,-4
 8001f20:	1884703a 	and	r2,r3,r2
 8001f24:	e0bffb15 	stw	r2,-20(fp)
          remainder_size = long_sub_size_t(victim_size, nb);
 8001f28:	e0fffb17 	ldw	r3,-20(fp)
 8001f2c:	e0bffa17 	ldw	r2,-24(fp)
 8001f30:	1885c83a 	sub	r2,r3,r2
 8001f34:	e0bff415 	stw	r2,-48(fp)

          if (remainder_size >= (long)MINSIZE) /* split */
 8001f38:	e0bff417 	ldw	r2,-48(fp)
 8001f3c:	10800410 	cmplti	r2,r2,16
 8001f40:	1000331e 	bne	r2,zero,8002010 <_malloc_r+0x8e4>
          {
            remainder = chunk_at_offset(victim, nb);
 8001f44:	e0fff117 	ldw	r3,-60(fp)
 8001f48:	e0bffa17 	ldw	r2,-24(fp)
 8001f4c:	1885883a 	add	r2,r3,r2
 8001f50:	e0bffc15 	stw	r2,-16(fp)
            set_head(victim, nb | PREV_INUSE);
 8001f54:	e0bffa17 	ldw	r2,-24(fp)
 8001f58:	10c00054 	ori	r3,r2,1
 8001f5c:	e0bff117 	ldw	r2,-60(fp)
 8001f60:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 8001f64:	e0bff117 	ldw	r2,-60(fp)
 8001f68:	10800317 	ldw	r2,12(r2)
 8001f6c:	e0bff815 	stw	r2,-32(fp)
 8001f70:	e0bff117 	ldw	r2,-60(fp)
 8001f74:	10800217 	ldw	r2,8(r2)
 8001f78:	e0bff715 	stw	r2,-36(fp)
 8001f7c:	e0bff717 	ldw	r2,-36(fp)
 8001f80:	e0fff817 	ldw	r3,-32(fp)
 8001f84:	10c00315 	stw	r3,12(r2)
 8001f88:	e0bff817 	ldw	r2,-32(fp)
 8001f8c:	e0fff717 	ldw	r3,-36(fp)
 8001f90:	10c00215 	stw	r3,8(r2)
            link_last_remainder(remainder);
 8001f94:	00c20134 	movhi	r3,2052
 8001f98:	18c3e104 	addi	r3,r3,3972
 8001f9c:	00820134 	movhi	r2,2052
 8001fa0:	1083e104 	addi	r2,r2,3972
 8001fa4:	e13ffc17 	ldw	r4,-16(fp)
 8001fa8:	11000315 	stw	r4,12(r2)
 8001fac:	10800317 	ldw	r2,12(r2)
 8001fb0:	18800215 	stw	r2,8(r3)
 8001fb4:	00820134 	movhi	r2,2052
 8001fb8:	1083e104 	addi	r2,r2,3972
 8001fbc:	e0fffc17 	ldw	r3,-16(fp)
 8001fc0:	18800315 	stw	r2,12(r3)
 8001fc4:	e0bffc17 	ldw	r2,-16(fp)
 8001fc8:	10c00317 	ldw	r3,12(r2)
 8001fcc:	e0bffc17 	ldw	r2,-16(fp)
 8001fd0:	10c00215 	stw	r3,8(r2)
            set_head(remainder, remainder_size | PREV_INUSE);
 8001fd4:	e0bff417 	ldw	r2,-48(fp)
 8001fd8:	10800054 	ori	r2,r2,1
 8001fdc:	1007883a 	mov	r3,r2
 8001fe0:	e0bffc17 	ldw	r2,-16(fp)
 8001fe4:	10c00115 	stw	r3,4(r2)
            set_foot(remainder, remainder_size);
 8001fe8:	e0bff417 	ldw	r2,-48(fp)
 8001fec:	e0fffc17 	ldw	r3,-16(fp)
 8001ff0:	1885883a 	add	r2,r3,r2
 8001ff4:	e0fff417 	ldw	r3,-48(fp)
 8001ff8:	10c00015 	stw	r3,0(r2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
 8001ffc:	e13ffe17 	ldw	r4,-8(fp)
 8002000:	80052680 	call	8005268 <__malloc_unlock>
            return chunk2mem(victim);
 8002004:	e0bff117 	ldw	r2,-60(fp)
 8002008:	10800204 	addi	r2,r2,8
 800200c:	0000a106 	br	8002294 <_malloc_r+0xb68>
          }

          else if (remainder_size >= 0)  /* take */
 8002010:	e0bff417 	ldw	r2,-48(fp)
 8002014:	10001a16 	blt	r2,zero,8002080 <_malloc_r+0x954>
          {
            set_inuse_bit_at_offset(victim, victim_size);
 8002018:	e0fff117 	ldw	r3,-60(fp)
 800201c:	e0bffb17 	ldw	r2,-20(fp)
 8002020:	1885883a 	add	r2,r3,r2
 8002024:	e13ff117 	ldw	r4,-60(fp)
 8002028:	e0fffb17 	ldw	r3,-20(fp)
 800202c:	20c7883a 	add	r3,r4,r3
 8002030:	18c00117 	ldw	r3,4(r3)
 8002034:	18c00054 	ori	r3,r3,1
 8002038:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 800203c:	e0bff117 	ldw	r2,-60(fp)
 8002040:	10800317 	ldw	r2,12(r2)
 8002044:	e0bff815 	stw	r2,-32(fp)
 8002048:	e0bff117 	ldw	r2,-60(fp)
 800204c:	10800217 	ldw	r2,8(r2)
 8002050:	e0bff715 	stw	r2,-36(fp)
 8002054:	e0bff717 	ldw	r2,-36(fp)
 8002058:	e0fff817 	ldw	r3,-32(fp)
 800205c:	10c00315 	stw	r3,12(r2)
 8002060:	e0bff817 	ldw	r2,-32(fp)
 8002064:	e0fff717 	ldw	r3,-36(fp)
 8002068:	10c00215 	stw	r3,8(r2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
 800206c:	e13ffe17 	ldw	r4,-8(fp)
 8002070:	80052680 	call	8005268 <__malloc_unlock>
            return chunk2mem(victim);
 8002074:	e0bff117 	ldw	r2,-60(fp)
 8002078:	10800204 	addi	r2,r2,8
 800207c:	00008506 	br	8002294 <_malloc_r+0xb68>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
 8002080:	e0bff117 	ldw	r2,-60(fp)
 8002084:	10800317 	ldw	r2,12(r2)
 8002088:	e0bff115 	stw	r2,-60(fp)
 800208c:	e0fff117 	ldw	r3,-60(fp)
 8002090:	e0bff317 	ldw	r2,-52(fp)
 8002094:	18bf9f1e 	bne	r3,r2,8001f14 <_malloc_r+0x7e8>
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
 8002098:	e0bff317 	ldw	r2,-52(fp)
 800209c:	10800204 	addi	r2,r2,8
 80020a0:	e0bff315 	stw	r2,-52(fp)
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
 80020a4:	e0bff217 	ldw	r2,-56(fp)
 80020a8:	10800044 	addi	r2,r2,1
 80020ac:	e0bff215 	stw	r2,-56(fp)
 80020b0:	e0bff217 	ldw	r2,-56(fp)
 80020b4:	108000cc 	andi	r2,r2,3
 80020b8:	103f921e 	bne	r2,zero,8001f04 <_malloc_r+0x7d8>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
 80020bc:	e0bff617 	ldw	r2,-40(fp)
 80020c0:	108000cc 	andi	r2,r2,3
 80020c4:	10000a1e 	bne	r2,zero,80020f0 <_malloc_r+0x9c4>
        {
          binblocks &= ~block;
 80020c8:	00820134 	movhi	r2,2052
 80020cc:	1083df04 	addi	r2,r2,3964
 80020d0:	00c20134 	movhi	r3,2052
 80020d4:	18c3df04 	addi	r3,r3,3964
 80020d8:	19000117 	ldw	r4,4(r3)
 80020dc:	e0fff517 	ldw	r3,-44(fp)
 80020e0:	00c6303a 	nor	r3,zero,r3
 80020e4:	20c6703a 	and	r3,r4,r3
 80020e8:	10c00115 	stw	r3,4(r2)
          break;
 80020ec:	00000a06 	br	8002118 <_malloc_r+0x9ec>
        }
        --startidx;
 80020f0:	e0bff617 	ldw	r2,-40(fp)
 80020f4:	10bfffc4 	addi	r2,r2,-1
 80020f8:	e0bff615 	stw	r2,-40(fp)
       q = prev_bin(q);
 80020fc:	e0bff917 	ldw	r2,-28(fp)
 8002100:	10bffe04 	addi	r2,r2,-8
 8002104:	e0bff915 	stw	r2,-28(fp)
      } while (first(q) == q);
 8002108:	e0bff917 	ldw	r2,-28(fp)
 800210c:	10c00217 	ldw	r3,8(r2)
 8002110:	e0bff917 	ldw	r2,-28(fp)
 8002114:	18bfe926 	beq	r3,r2,80020bc <_malloc_r+0x990>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
 8002118:	e0bff517 	ldw	r2,-44(fp)
 800211c:	1085883a 	add	r2,r2,r2
 8002120:	e0bff515 	stw	r2,-44(fp)
 8002124:	00820134 	movhi	r2,2052
 8002128:	1083df04 	addi	r2,r2,3964
 800212c:	10c00117 	ldw	r3,4(r2)
 8002130:	e0bff517 	ldw	r2,-44(fp)
 8002134:	18801036 	bltu	r3,r2,8002178 <_malloc_r+0xa4c>
 8002138:	e0bff517 	ldw	r2,-44(fp)
 800213c:	10000e26 	beq	r2,zero,8002178 <_malloc_r+0xa4c>
      {
        while ((block & binblocks) == 0)
 8002140:	00000606 	br	800215c <_malloc_r+0xa30>
        {
          idx += BINBLOCKWIDTH;
 8002144:	e0bff217 	ldw	r2,-56(fp)
 8002148:	10800104 	addi	r2,r2,4
 800214c:	e0bff215 	stw	r2,-56(fp)
          block <<= 1;
 8002150:	e0bff517 	ldw	r2,-44(fp)
 8002154:	1085883a 	add	r2,r2,r2
 8002158:	e0bff515 	stw	r2,-44(fp)

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
 800215c:	00820134 	movhi	r2,2052
 8002160:	1083df04 	addi	r2,r2,3964
 8002164:	10c00117 	ldw	r3,4(r2)
 8002168:	e0bff517 	ldw	r2,-44(fp)
 800216c:	1884703a 	and	r2,r3,r2
 8002170:	103ff426 	beq	r2,zero,8002144 <_malloc_r+0xa18>
          block <<= 1;
        }
      }
      else
        break;
    }
 8002174:	003f5506 	br	8001ecc <_malloc_r+0x7a0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
 8002178:	00820134 	movhi	r2,2052
 800217c:	1083df04 	addi	r2,r2,3964
 8002180:	10800217 	ldw	r2,8(r2)
 8002184:	10c00117 	ldw	r3,4(r2)
 8002188:	00bfff04 	movi	r2,-4
 800218c:	1886703a 	and	r3,r3,r2
 8002190:	e0bffa17 	ldw	r2,-24(fp)
 8002194:	1885c83a 	sub	r2,r3,r2
 8002198:	e0bff415 	stw	r2,-48(fp)
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 800219c:	00820134 	movhi	r2,2052
 80021a0:	1083df04 	addi	r2,r2,3964
 80021a4:	10800217 	ldw	r2,8(r2)
 80021a8:	10c00117 	ldw	r3,4(r2)
 80021ac:	00bfff04 	movi	r2,-4
 80021b0:	1886703a 	and	r3,r3,r2
 80021b4:	e0bffa17 	ldw	r2,-24(fp)
 80021b8:	18800336 	bltu	r3,r2,80021c8 <_malloc_r+0xa9c>
 80021bc:	e0bff417 	ldw	r2,-48(fp)
 80021c0:	10800408 	cmpgei	r2,r2,16
 80021c4:	10001b1e 	bne	r2,zero,8002234 <_malloc_r+0xb08>
      return chunk2mem(victim);
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
 80021c8:	e17ffa17 	ldw	r5,-24(fp)
 80021cc:	e13ffe17 	ldw	r4,-8(fp)
 80021d0:	80013780 	call	8001378 <malloc_extend_top>
    remainder_size = long_sub_size_t(chunksize(top), nb);
 80021d4:	00820134 	movhi	r2,2052
 80021d8:	1083df04 	addi	r2,r2,3964
 80021dc:	10800217 	ldw	r2,8(r2)
 80021e0:	10c00117 	ldw	r3,4(r2)
 80021e4:	00bfff04 	movi	r2,-4
 80021e8:	1886703a 	and	r3,r3,r2
 80021ec:	e0bffa17 	ldw	r2,-24(fp)
 80021f0:	1885c83a 	sub	r2,r3,r2
 80021f4:	e0bff415 	stw	r2,-48(fp)
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 80021f8:	00820134 	movhi	r2,2052
 80021fc:	1083df04 	addi	r2,r2,3964
 8002200:	10800217 	ldw	r2,8(r2)
 8002204:	10c00117 	ldw	r3,4(r2)
 8002208:	00bfff04 	movi	r2,-4
 800220c:	1886703a 	and	r3,r3,r2
 8002210:	e0bffa17 	ldw	r2,-24(fp)
 8002214:	18800336 	bltu	r3,r2,8002224 <_malloc_r+0xaf8>
 8002218:	e0bff417 	ldw	r2,-48(fp)
 800221c:	10800408 	cmpgei	r2,r2,16
 8002220:	1000041e 	bne	r2,zero,8002234 <_malloc_r+0xb08>
    {
      MALLOC_UNLOCK;
 8002224:	e13ffe17 	ldw	r4,-8(fp)
 8002228:	80052680 	call	8005268 <__malloc_unlock>
      return 0; /* propagate failure */
 800222c:	0005883a 	mov	r2,zero
 8002230:	00001806 	br	8002294 <_malloc_r+0xb68>
    }
  }

  victim = top;
 8002234:	00820134 	movhi	r2,2052
 8002238:	1083df04 	addi	r2,r2,3964
 800223c:	10800217 	ldw	r2,8(r2)
 8002240:	e0bff115 	stw	r2,-60(fp)
  set_head(victim, nb | PREV_INUSE);
 8002244:	e0bffa17 	ldw	r2,-24(fp)
 8002248:	10c00054 	ori	r3,r2,1
 800224c:	e0bff117 	ldw	r2,-60(fp)
 8002250:	10c00115 	stw	r3,4(r2)
  top = chunk_at_offset(victim, nb);
 8002254:	00820134 	movhi	r2,2052
 8002258:	1083df04 	addi	r2,r2,3964
 800225c:	e13ff117 	ldw	r4,-60(fp)
 8002260:	e0fffa17 	ldw	r3,-24(fp)
 8002264:	20c7883a 	add	r3,r4,r3
 8002268:	10c00215 	stw	r3,8(r2)
  set_head(top, remainder_size | PREV_INUSE);
 800226c:	00820134 	movhi	r2,2052
 8002270:	1083df04 	addi	r2,r2,3964
 8002274:	10800217 	ldw	r2,8(r2)
 8002278:	e0fff417 	ldw	r3,-48(fp)
 800227c:	18c00054 	ori	r3,r3,1
 8002280:	10c00115 	stw	r3,4(r2)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
 8002284:	e13ffe17 	ldw	r4,-8(fp)
 8002288:	80052680 	call	8005268 <__malloc_unlock>
  return chunk2mem(victim);
 800228c:	e0bff117 	ldw	r2,-60(fp)
 8002290:	10800204 	addi	r2,r2,8

#endif /* MALLOC_PROVIDED */
}
 8002294:	e037883a 	mov	sp,fp
 8002298:	dfc00117 	ldw	ra,4(sp)
 800229c:	df000017 	ldw	fp,0(sp)
 80022a0:	dec00204 	addi	sp,sp,8
 80022a4:	f800283a 	ret

080022a8 <memchr>:
_PTR
_DEFUN (memchr, (src_void, c, length),
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
 80022a8:	defff704 	addi	sp,sp,-36
 80022ac:	df000815 	stw	fp,32(sp)
 80022b0:	df000804 	addi	fp,sp,32
 80022b4:	e13ffd15 	stw	r4,-12(fp)
 80022b8:	e17ffe15 	stw	r5,-8(fp)
 80022bc:	e1bfff15 	stw	r6,-4(fp)
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
 80022c0:	e0bffd17 	ldw	r2,-12(fp)
 80022c4:	e0bff815 	stw	r2,-32(fp)
  unsigned char d = c;
 80022c8:	e0bffe17 	ldw	r2,-8(fp)
 80022cc:	e0bffc05 	stb	r2,-16(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 80022d0:	00001006 	br	8002314 <memchr+0x6c>
    {
      if (!length--)
 80022d4:	e0bfff17 	ldw	r2,-4(fp)
 80022d8:	10ffffc4 	addi	r3,r2,-1
 80022dc:	e0ffff15 	stw	r3,-4(fp)
 80022e0:	1000021e 	bne	r2,zero,80022ec <memchr+0x44>
        return NULL;
 80022e4:	0005883a 	mov	r2,zero
 80022e8:	00005a06 	br	8002454 <memchr+0x1ac>
      if (*src == d)
 80022ec:	e0bff817 	ldw	r2,-32(fp)
 80022f0:	10800003 	ldbu	r2,0(r2)
 80022f4:	10c03fcc 	andi	r3,r2,255
 80022f8:	e0bffc03 	ldbu	r2,-16(fp)
 80022fc:	1880021e 	bne	r3,r2,8002308 <memchr+0x60>
        return (void *) src;
 8002300:	e0bff817 	ldw	r2,-32(fp)
 8002304:	00005306 	br	8002454 <memchr+0x1ac>
      src++;
 8002308:	e0bff817 	ldw	r2,-32(fp)
 800230c:	10800044 	addi	r2,r2,1
 8002310:	e0bff815 	stw	r2,-32(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 8002314:	e0bff817 	ldw	r2,-32(fp)
 8002318:	108000cc 	andi	r2,r2,3
 800231c:	103fed1e 	bne	r2,zero,80022d4 <memchr+0x2c>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
 8002320:	e0bfff17 	ldw	r2,-4(fp)
 8002324:	10800130 	cmpltui	r2,r2,4
 8002328:	1000451e 	bne	r2,zero,8002440 <memchr+0x198>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
 800232c:	e0bff817 	ldw	r2,-32(fp)
 8002330:	e0bff915 	stw	r2,-28(fp)
      mask = d << 8 | d;
 8002334:	e0bffc03 	ldbu	r2,-16(fp)
 8002338:	1006923a 	slli	r3,r2,8
 800233c:	e0bffc03 	ldbu	r2,-16(fp)
 8002340:	1884b03a 	or	r2,r3,r2
 8002344:	e0bffa15 	stw	r2,-24(fp)
      mask = mask << 16 | mask;
 8002348:	e0bffa17 	ldw	r2,-24(fp)
 800234c:	1004943a 	slli	r2,r2,16
 8002350:	e0fffa17 	ldw	r3,-24(fp)
 8002354:	1884b03a 	or	r2,r3,r2
 8002358:	e0bffa15 	stw	r2,-24(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 800235c:	00800804 	movi	r2,32
 8002360:	e0bffb15 	stw	r2,-20(fp)
 8002364:	00000906 	br	800238c <memchr+0xe4>
        mask = (mask << i) | mask;
 8002368:	e0fffa17 	ldw	r3,-24(fp)
 800236c:	e0bffb17 	ldw	r2,-20(fp)
 8002370:	1884983a 	sll	r2,r3,r2
 8002374:	e0fffa17 	ldw	r3,-24(fp)
 8002378:	1884b03a 	or	r2,r3,r2
 800237c:	e0bffa15 	stw	r2,-24(fp)
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 8002380:	e0bffb17 	ldw	r2,-20(fp)
 8002384:	1085883a 	add	r2,r2,r2
 8002388:	e0bffb15 	stw	r2,-20(fp)
 800238c:	e0bffb17 	ldw	r2,-20(fp)
 8002390:	10800830 	cmpltui	r2,r2,32
 8002394:	103ff41e 	bne	r2,zero,8002368 <memchr+0xc0>
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
 8002398:	00001706 	br	80023f8 <memchr+0x150>
        {
          if (DETECTCHAR (*asrc, mask))
 800239c:	e0bff917 	ldw	r2,-28(fp)
 80023a0:	10c00017 	ldw	r3,0(r2)
 80023a4:	e0bffa17 	ldw	r2,-24(fp)
 80023a8:	1886f03a 	xor	r3,r3,r2
 80023ac:	00bfbff4 	movhi	r2,65279
 80023b0:	10bfbfc4 	addi	r2,r2,-257
 80023b4:	1887883a 	add	r3,r3,r2
 80023b8:	e0bff917 	ldw	r2,-28(fp)
 80023bc:	11000017 	ldw	r4,0(r2)
 80023c0:	e0bffa17 	ldw	r2,-24(fp)
 80023c4:	2084f03a 	xor	r2,r4,r2
 80023c8:	0084303a 	nor	r2,zero,r2
 80023cc:	1886703a 	and	r3,r3,r2
 80023d0:	00a02074 	movhi	r2,32897
 80023d4:	10a02004 	addi	r2,r2,-32640
 80023d8:	1884703a 	and	r2,r3,r2
 80023dc:	10000a1e 	bne	r2,zero,8002408 <memchr+0x160>
            break;
          length -= LBLOCKSIZE;
 80023e0:	e0bfff17 	ldw	r2,-4(fp)
 80023e4:	10bfff04 	addi	r2,r2,-4
 80023e8:	e0bfff15 	stw	r2,-4(fp)
          asrc++;
 80023ec:	e0bff917 	ldw	r2,-28(fp)
 80023f0:	10800104 	addi	r2,r2,4
 80023f4:	e0bff915 	stw	r2,-28(fp)
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
 80023f8:	e0bfff17 	ldw	r2,-4(fp)
 80023fc:	10800128 	cmpgeui	r2,r2,4
 8002400:	103fe61e 	bne	r2,zero,800239c <memchr+0xf4>
 8002404:	00000106 	br	800240c <memchr+0x164>
        {
          if (DETECTCHAR (*asrc, mask))
            break;
 8002408:	0001883a 	nop
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
 800240c:	e0bff917 	ldw	r2,-28(fp)
 8002410:	e0bff815 	stw	r2,-32(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 8002414:	00000a06 	br	8002440 <memchr+0x198>
    {
      if (*src == d)
 8002418:	e0bff817 	ldw	r2,-32(fp)
 800241c:	10800003 	ldbu	r2,0(r2)
 8002420:	10c03fcc 	andi	r3,r2,255
 8002424:	e0bffc03 	ldbu	r2,-16(fp)
 8002428:	1880021e 	bne	r3,r2,8002434 <memchr+0x18c>
        return (void *) src;
 800242c:	e0bff817 	ldw	r2,-32(fp)
 8002430:	00000806 	br	8002454 <memchr+0x1ac>
      src++;
 8002434:	e0bff817 	ldw	r2,-32(fp)
 8002438:	10800044 	addi	r2,r2,1
 800243c:	e0bff815 	stw	r2,-32(fp)
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 8002440:	e0bfff17 	ldw	r2,-4(fp)
 8002444:	10ffffc4 	addi	r3,r2,-1
 8002448:	e0ffff15 	stw	r3,-4(fp)
 800244c:	103ff21e 	bne	r2,zero,8002418 <memchr+0x170>
      if (*src == d)
        return (void *) src;
      src++;
    }

  return NULL;
 8002450:	0005883a 	mov	r2,zero
}
 8002454:	e037883a 	mov	sp,fp
 8002458:	df000017 	ldw	fp,0(sp)
 800245c:	dec00104 	addi	sp,sp,4
 8002460:	f800283a 	ret

08002464 <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR __restrict dst0 _AND
	_CONST _PTR __restrict src0 _AND
	size_t len0)
{
 8002464:	defff804 	addi	sp,sp,-32
 8002468:	df000715 	stw	fp,28(sp)
 800246c:	df000704 	addi	fp,sp,28
 8002470:	e13ffd15 	stw	r4,-12(fp)
 8002474:	e17ffe15 	stw	r5,-8(fp)
 8002478:	e1bfff15 	stw	r6,-4(fp)
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
 800247c:	e0bffd17 	ldw	r2,-12(fp)
 8002480:	e0bff915 	stw	r2,-28(fp)
  _CONST char *src = src0;
 8002484:	e0bffe17 	ldw	r2,-8(fp)
 8002488:	e0bffa15 	stw	r2,-24(fp)
  long *aligned_dst;
  _CONST long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
 800248c:	e0bfff17 	ldw	r2,-4(fp)
 8002490:	10800430 	cmpltui	r2,r2,16
 8002494:	10004c1e 	bne	r2,zero,80025c8 <memcpy+0x164>
 8002498:	e0fffa17 	ldw	r3,-24(fp)
 800249c:	e0bff917 	ldw	r2,-28(fp)
 80024a0:	1884b03a 	or	r2,r3,r2
 80024a4:	108000cc 	andi	r2,r2,3
 80024a8:	1000471e 	bne	r2,zero,80025c8 <memcpy+0x164>
    {
      aligned_dst = (long*)dst;
 80024ac:	e0bff917 	ldw	r2,-28(fp)
 80024b0:	e0bffb15 	stw	r2,-20(fp)
      aligned_src = (long*)src;
 80024b4:	e0bffa17 	ldw	r2,-24(fp)
 80024b8:	e0bffc15 	stw	r2,-16(fp)

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 80024bc:	00002306 	br	800254c <memcpy+0xe8>
        {
          *aligned_dst++ = *aligned_src++;
 80024c0:	e0bffb17 	ldw	r2,-20(fp)
 80024c4:	10c00104 	addi	r3,r2,4
 80024c8:	e0fffb15 	stw	r3,-20(fp)
 80024cc:	e0fffc17 	ldw	r3,-16(fp)
 80024d0:	19000104 	addi	r4,r3,4
 80024d4:	e13ffc15 	stw	r4,-16(fp)
 80024d8:	18c00017 	ldw	r3,0(r3)
 80024dc:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 80024e0:	e0bffb17 	ldw	r2,-20(fp)
 80024e4:	10c00104 	addi	r3,r2,4
 80024e8:	e0fffb15 	stw	r3,-20(fp)
 80024ec:	e0fffc17 	ldw	r3,-16(fp)
 80024f0:	19000104 	addi	r4,r3,4
 80024f4:	e13ffc15 	stw	r4,-16(fp)
 80024f8:	18c00017 	ldw	r3,0(r3)
 80024fc:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 8002500:	e0bffb17 	ldw	r2,-20(fp)
 8002504:	10c00104 	addi	r3,r2,4
 8002508:	e0fffb15 	stw	r3,-20(fp)
 800250c:	e0fffc17 	ldw	r3,-16(fp)
 8002510:	19000104 	addi	r4,r3,4
 8002514:	e13ffc15 	stw	r4,-16(fp)
 8002518:	18c00017 	ldw	r3,0(r3)
 800251c:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 8002520:	e0bffb17 	ldw	r2,-20(fp)
 8002524:	10c00104 	addi	r3,r2,4
 8002528:	e0fffb15 	stw	r3,-20(fp)
 800252c:	e0fffc17 	ldw	r3,-16(fp)
 8002530:	19000104 	addi	r4,r3,4
 8002534:	e13ffc15 	stw	r4,-16(fp)
 8002538:	18c00017 	ldw	r3,0(r3)
 800253c:	10c00015 	stw	r3,0(r2)
          len0 -= BIGBLOCKSIZE;
 8002540:	e0bfff17 	ldw	r2,-4(fp)
 8002544:	10bffc04 	addi	r2,r2,-16
 8002548:	e0bfff15 	stw	r2,-4(fp)
    {
      aligned_dst = (long*)dst;
      aligned_src = (long*)src;

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 800254c:	e0bfff17 	ldw	r2,-4(fp)
 8002550:	10800428 	cmpgeui	r2,r2,16
 8002554:	103fda1e 	bne	r2,zero,80024c0 <memcpy+0x5c>
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 8002558:	00000b06 	br	8002588 <memcpy+0x124>
        {
          *aligned_dst++ = *aligned_src++;
 800255c:	e0bffb17 	ldw	r2,-20(fp)
 8002560:	10c00104 	addi	r3,r2,4
 8002564:	e0fffb15 	stw	r3,-20(fp)
 8002568:	e0fffc17 	ldw	r3,-16(fp)
 800256c:	19000104 	addi	r4,r3,4
 8002570:	e13ffc15 	stw	r4,-16(fp)
 8002574:	18c00017 	ldw	r3,0(r3)
 8002578:	10c00015 	stw	r3,0(r2)
          len0 -= LITTLEBLOCKSIZE;
 800257c:	e0bfff17 	ldw	r2,-4(fp)
 8002580:	10bfff04 	addi	r2,r2,-4
 8002584:	e0bfff15 	stw	r2,-4(fp)
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 8002588:	e0bfff17 	ldw	r2,-4(fp)
 800258c:	10800128 	cmpgeui	r2,r2,4
 8002590:	103ff21e 	bne	r2,zero,800255c <memcpy+0xf8>
          *aligned_dst++ = *aligned_src++;
          len0 -= LITTLEBLOCKSIZE;
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
 8002594:	e0bffb17 	ldw	r2,-20(fp)
 8002598:	e0bff915 	stw	r2,-28(fp)
      src = (char*)aligned_src;
 800259c:	e0bffc17 	ldw	r2,-16(fp)
 80025a0:	e0bffa15 	stw	r2,-24(fp)
    }

  while (len0--)
 80025a4:	00000806 	br	80025c8 <memcpy+0x164>
    *dst++ = *src++;
 80025a8:	e0bff917 	ldw	r2,-28(fp)
 80025ac:	10c00044 	addi	r3,r2,1
 80025b0:	e0fff915 	stw	r3,-28(fp)
 80025b4:	e0fffa17 	ldw	r3,-24(fp)
 80025b8:	19000044 	addi	r4,r3,1
 80025bc:	e13ffa15 	stw	r4,-24(fp)
 80025c0:	18c00003 	ldbu	r3,0(r3)
 80025c4:	10c00005 	stb	r3,0(r2)
       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }

  while (len0--)
 80025c8:	e0bfff17 	ldw	r2,-4(fp)
 80025cc:	10ffffc4 	addi	r3,r2,-1
 80025d0:	e0ffff15 	stw	r3,-4(fp)
 80025d4:	103ff41e 	bne	r2,zero,80025a8 <memcpy+0x144>
    *dst++ = *src++;

  return dst0;
 80025d8:	e0bffd17 	ldw	r2,-12(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 80025dc:	e037883a 	mov	sp,fp
 80025e0:	df000017 	ldw	fp,0(sp)
 80025e4:	dec00104 	addi	sp,sp,4
 80025e8:	f800283a 	ret

080025ec <memmove>:
__inhibit_loop_to_libcall
_DEFUN (memmove, (dst_void, src_void, length),
	_PTR dst_void _AND
	_CONST _PTR src_void _AND
	size_t length)
{
 80025ec:	defff804 	addi	sp,sp,-32
 80025f0:	df000715 	stw	fp,28(sp)
 80025f4:	df000704 	addi	fp,sp,28
 80025f8:	e13ffd15 	stw	r4,-12(fp)
 80025fc:	e17ffe15 	stw	r5,-8(fp)
 8002600:	e1bfff15 	stw	r6,-4(fp)
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
 8002604:	e0bffd17 	ldw	r2,-12(fp)
 8002608:	e0bff915 	stw	r2,-28(fp)
  _CONST char *src = src_void;
 800260c:	e0bffe17 	ldw	r2,-8(fp)
 8002610:	e0bffa15 	stw	r2,-24(fp)
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
 8002614:	e0fffa17 	ldw	r3,-24(fp)
 8002618:	e0bff917 	ldw	r2,-28(fp)
 800261c:	18801d2e 	bgeu	r3,r2,8002694 <memmove+0xa8>
 8002620:	e0fffa17 	ldw	r3,-24(fp)
 8002624:	e0bfff17 	ldw	r2,-4(fp)
 8002628:	1885883a 	add	r2,r3,r2
 800262c:	e0fff917 	ldw	r3,-28(fp)
 8002630:	1880182e 	bgeu	r3,r2,8002694 <memmove+0xa8>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
 8002634:	e0fffa17 	ldw	r3,-24(fp)
 8002638:	e0bfff17 	ldw	r2,-4(fp)
 800263c:	1885883a 	add	r2,r3,r2
 8002640:	e0bffa15 	stw	r2,-24(fp)
      dst += length;
 8002644:	e0fff917 	ldw	r3,-28(fp)
 8002648:	e0bfff17 	ldw	r2,-4(fp)
 800264c:	1885883a 	add	r2,r3,r2
 8002650:	e0bff915 	stw	r2,-28(fp)
      while (length--)
 8002654:	00000a06 	br	8002680 <memmove+0x94>
	{
	  *--dst = *--src;
 8002658:	e0bff917 	ldw	r2,-28(fp)
 800265c:	10bfffc4 	addi	r2,r2,-1
 8002660:	e0bff915 	stw	r2,-28(fp)
 8002664:	e0bffa17 	ldw	r2,-24(fp)
 8002668:	10bfffc4 	addi	r2,r2,-1
 800266c:	e0bffa15 	stw	r2,-24(fp)
 8002670:	e0bffa17 	ldw	r2,-24(fp)
 8002674:	10c00003 	ldbu	r3,0(r2)
 8002678:	e0bff917 	ldw	r2,-28(fp)
 800267c:	10c00005 	stb	r3,0(r2)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
 8002680:	e0bfff17 	ldw	r2,-4(fp)
 8002684:	10ffffc4 	addi	r3,r2,-1
 8002688:	e0ffff15 	stw	r3,-4(fp)
 800268c:	103ff21e 	bne	r2,zero,8002658 <memmove+0x6c>
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
 8002690:	00005306 	br	80027e0 <memmove+0x1f4>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
 8002694:	e0bfff17 	ldw	r2,-4(fp)
 8002698:	10800430 	cmpltui	r2,r2,16
 800269c:	10004c1e 	bne	r2,zero,80027d0 <memmove+0x1e4>
 80026a0:	e0fffa17 	ldw	r3,-24(fp)
 80026a4:	e0bff917 	ldw	r2,-28(fp)
 80026a8:	1884b03a 	or	r2,r3,r2
 80026ac:	108000cc 	andi	r2,r2,3
 80026b0:	1000471e 	bne	r2,zero,80027d0 <memmove+0x1e4>
        {
          aligned_dst = (long*)dst;
 80026b4:	e0bff917 	ldw	r2,-28(fp)
 80026b8:	e0bffb15 	stw	r2,-20(fp)
          aligned_src = (long*)src;
 80026bc:	e0bffa17 	ldw	r2,-24(fp)
 80026c0:	e0bffc15 	stw	r2,-16(fp)

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 80026c4:	00002306 	br	8002754 <memmove+0x168>
            {
              *aligned_dst++ = *aligned_src++;
 80026c8:	e0bffb17 	ldw	r2,-20(fp)
 80026cc:	10c00104 	addi	r3,r2,4
 80026d0:	e0fffb15 	stw	r3,-20(fp)
 80026d4:	e0fffc17 	ldw	r3,-16(fp)
 80026d8:	19000104 	addi	r4,r3,4
 80026dc:	e13ffc15 	stw	r4,-16(fp)
 80026e0:	18c00017 	ldw	r3,0(r3)
 80026e4:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 80026e8:	e0bffb17 	ldw	r2,-20(fp)
 80026ec:	10c00104 	addi	r3,r2,4
 80026f0:	e0fffb15 	stw	r3,-20(fp)
 80026f4:	e0fffc17 	ldw	r3,-16(fp)
 80026f8:	19000104 	addi	r4,r3,4
 80026fc:	e13ffc15 	stw	r4,-16(fp)
 8002700:	18c00017 	ldw	r3,0(r3)
 8002704:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 8002708:	e0bffb17 	ldw	r2,-20(fp)
 800270c:	10c00104 	addi	r3,r2,4
 8002710:	e0fffb15 	stw	r3,-20(fp)
 8002714:	e0fffc17 	ldw	r3,-16(fp)
 8002718:	19000104 	addi	r4,r3,4
 800271c:	e13ffc15 	stw	r4,-16(fp)
 8002720:	18c00017 	ldw	r3,0(r3)
 8002724:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 8002728:	e0bffb17 	ldw	r2,-20(fp)
 800272c:	10c00104 	addi	r3,r2,4
 8002730:	e0fffb15 	stw	r3,-20(fp)
 8002734:	e0fffc17 	ldw	r3,-16(fp)
 8002738:	19000104 	addi	r4,r3,4
 800273c:	e13ffc15 	stw	r4,-16(fp)
 8002740:	18c00017 	ldw	r3,0(r3)
 8002744:	10c00015 	stw	r3,0(r2)
              length -= BIGBLOCKSIZE;
 8002748:	e0bfff17 	ldw	r2,-4(fp)
 800274c:	10bffc04 	addi	r2,r2,-16
 8002750:	e0bfff15 	stw	r2,-4(fp)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 8002754:	e0bfff17 	ldw	r2,-4(fp)
 8002758:	10800428 	cmpgeui	r2,r2,16
 800275c:	103fda1e 	bne	r2,zero,80026c8 <memmove+0xdc>
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 8002760:	00000b06 	br	8002790 <memmove+0x1a4>
            {
              *aligned_dst++ = *aligned_src++;
 8002764:	e0bffb17 	ldw	r2,-20(fp)
 8002768:	10c00104 	addi	r3,r2,4
 800276c:	e0fffb15 	stw	r3,-20(fp)
 8002770:	e0fffc17 	ldw	r3,-16(fp)
 8002774:	19000104 	addi	r4,r3,4
 8002778:	e13ffc15 	stw	r4,-16(fp)
 800277c:	18c00017 	ldw	r3,0(r3)
 8002780:	10c00015 	stw	r3,0(r2)
              length -= LITTLEBLOCKSIZE;
 8002784:	e0bfff17 	ldw	r2,-4(fp)
 8002788:	10bfff04 	addi	r2,r2,-4
 800278c:	e0bfff15 	stw	r2,-4(fp)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 8002790:	e0bfff17 	ldw	r2,-4(fp)
 8002794:	10800128 	cmpgeui	r2,r2,4
 8002798:	103ff21e 	bne	r2,zero,8002764 <memmove+0x178>
              *aligned_dst++ = *aligned_src++;
              length -= LITTLEBLOCKSIZE;
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
 800279c:	e0bffb17 	ldw	r2,-20(fp)
 80027a0:	e0bff915 	stw	r2,-28(fp)
          src = (char*)aligned_src;
 80027a4:	e0bffc17 	ldw	r2,-16(fp)
 80027a8:	e0bffa15 	stw	r2,-24(fp)
        }

      while (length--)
 80027ac:	00000806 	br	80027d0 <memmove+0x1e4>
        {
          *dst++ = *src++;
 80027b0:	e0bff917 	ldw	r2,-28(fp)
 80027b4:	10c00044 	addi	r3,r2,1
 80027b8:	e0fff915 	stw	r3,-28(fp)
 80027bc:	e0fffa17 	ldw	r3,-24(fp)
 80027c0:	19000044 	addi	r4,r3,1
 80027c4:	e13ffa15 	stw	r4,-24(fp)
 80027c8:	18c00003 	ldbu	r3,0(r3)
 80027cc:	10c00005 	stb	r3,0(r2)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
 80027d0:	e0bfff17 	ldw	r2,-4(fp)
 80027d4:	10ffffc4 	addi	r3,r2,-1
 80027d8:	e0ffff15 	stw	r3,-4(fp)
 80027dc:	103ff41e 	bne	r2,zero,80027b0 <memmove+0x1c4>
        {
          *dst++ = *src++;
        }
    }

  return dst_void;
 80027e0:	e0bffd17 	ldw	r2,-12(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 80027e4:	e037883a 	mov	sp,fp
 80027e8:	df000017 	ldw	fp,0(sp)
 80027ec:	dec00104 	addi	sp,sp,4
 80027f0:	f800283a 	ret

080027f4 <memset>:
__inhibit_loop_to_libcall
_DEFUN (memset, (m, c, n),
	_PTR m _AND
	int c _AND
	size_t n)
{
 80027f4:	defff704 	addi	sp,sp,-36
 80027f8:	df000815 	stw	fp,32(sp)
 80027fc:	df000804 	addi	fp,sp,32
 8002800:	e13ffd15 	stw	r4,-12(fp)
 8002804:	e17ffe15 	stw	r5,-8(fp)
 8002808:	e1bfff15 	stw	r6,-4(fp)
  char *s = (char *) m;
 800280c:	e0bffd17 	ldw	r2,-12(fp)
 8002810:	e0bff815 	stw	r2,-32(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
 8002814:	e0bffe17 	ldw	r2,-8(fp)
 8002818:	10803fcc 	andi	r2,r2,255
 800281c:	e0bffc15 	stw	r2,-16(fp)
				   unsigned variable.  */

  while (UNALIGNED (s))
 8002820:	00000c06 	br	8002854 <memset+0x60>
    {
      if (n--)
 8002824:	e0bfff17 	ldw	r2,-4(fp)
 8002828:	10ffffc4 	addi	r3,r2,-1
 800282c:	e0ffff15 	stw	r3,-4(fp)
 8002830:	10000626 	beq	r2,zero,800284c <memset+0x58>
        *s++ = (char) c;
 8002834:	e0bff817 	ldw	r2,-32(fp)
 8002838:	10c00044 	addi	r3,r2,1
 800283c:	e0fff815 	stw	r3,-32(fp)
 8002840:	e0fffe17 	ldw	r3,-8(fp)
 8002844:	10c00005 	stb	r3,0(r2)
 8002848:	00000206 	br	8002854 <memset+0x60>
      else
        return m;
 800284c:	e0bffd17 	ldw	r2,-12(fp)
 8002850:	00005506 	br	80029a8 <memset+0x1b4>
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
				   unsigned variable.  */

  while (UNALIGNED (s))
 8002854:	e0bff817 	ldw	r2,-32(fp)
 8002858:	108000cc 	andi	r2,r2,3
 800285c:	103ff11e 	bne	r2,zero,8002824 <memset+0x30>
        *s++ = (char) c;
      else
        return m;
    }

  if (!TOO_SMALL (n))
 8002860:	e0bfff17 	ldw	r2,-4(fp)
 8002864:	10800130 	cmpltui	r2,r2,4
 8002868:	10004a1e 	bne	r2,zero,8002994 <memset+0x1a0>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
 800286c:	e0bff817 	ldw	r2,-32(fp)
 8002870:	e0bffb15 	stw	r2,-20(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
 8002874:	e0bffc17 	ldw	r2,-16(fp)
 8002878:	1006923a 	slli	r3,r2,8
 800287c:	e0bffc17 	ldw	r2,-16(fp)
 8002880:	1884b03a 	or	r2,r3,r2
 8002884:	e0bffa15 	stw	r2,-24(fp)
      buffer |= (buffer << 16);
 8002888:	e0bffa17 	ldw	r2,-24(fp)
 800288c:	1004943a 	slli	r2,r2,16
 8002890:	e0fffa17 	ldw	r3,-24(fp)
 8002894:	1884b03a 	or	r2,r3,r2
 8002898:	e0bffa15 	stw	r2,-24(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 800289c:	00800804 	movi	r2,32
 80028a0:	e0bff915 	stw	r2,-28(fp)
 80028a4:	00000906 	br	80028cc <memset+0xd8>
        buffer = (buffer << i) | buffer;
 80028a8:	e0fffa17 	ldw	r3,-24(fp)
 80028ac:	e0bff917 	ldw	r2,-28(fp)
 80028b0:	1884983a 	sll	r2,r3,r2
 80028b4:	e0fffa17 	ldw	r3,-24(fp)
 80028b8:	1884b03a 	or	r2,r3,r2
 80028bc:	e0bffa15 	stw	r2,-24(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 80028c0:	e0bff917 	ldw	r2,-28(fp)
 80028c4:	1085883a 	add	r2,r2,r2
 80028c8:	e0bff915 	stw	r2,-28(fp)
 80028cc:	e0bff917 	ldw	r2,-28(fp)
 80028d0:	10800830 	cmpltui	r2,r2,32
 80028d4:	103ff41e 	bne	r2,zero,80028a8 <memset+0xb4>
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 80028d8:	00001706 	br	8002938 <memset+0x144>
        {
          *aligned_addr++ = buffer;
 80028dc:	e0bffb17 	ldw	r2,-20(fp)
 80028e0:	10c00104 	addi	r3,r2,4
 80028e4:	e0fffb15 	stw	r3,-20(fp)
 80028e8:	e0fffa17 	ldw	r3,-24(fp)
 80028ec:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 80028f0:	e0bffb17 	ldw	r2,-20(fp)
 80028f4:	10c00104 	addi	r3,r2,4
 80028f8:	e0fffb15 	stw	r3,-20(fp)
 80028fc:	e0fffa17 	ldw	r3,-24(fp)
 8002900:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 8002904:	e0bffb17 	ldw	r2,-20(fp)
 8002908:	10c00104 	addi	r3,r2,4
 800290c:	e0fffb15 	stw	r3,-20(fp)
 8002910:	e0fffa17 	ldw	r3,-24(fp)
 8002914:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 8002918:	e0bffb17 	ldw	r2,-20(fp)
 800291c:	10c00104 	addi	r3,r2,4
 8002920:	e0fffb15 	stw	r3,-20(fp)
 8002924:	e0fffa17 	ldw	r3,-24(fp)
 8002928:	10c00015 	stw	r3,0(r2)
          n -= 4*LBLOCKSIZE;
 800292c:	e0bfff17 	ldw	r2,-4(fp)
 8002930:	10bffc04 	addi	r2,r2,-16
 8002934:	e0bfff15 	stw	r2,-4(fp)
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 8002938:	e0bfff17 	ldw	r2,-4(fp)
 800293c:	10800428 	cmpgeui	r2,r2,16
 8002940:	103fe61e 	bne	r2,zero,80028dc <memset+0xe8>
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
 8002944:	00000806 	br	8002968 <memset+0x174>
        {
          *aligned_addr++ = buffer;
 8002948:	e0bffb17 	ldw	r2,-20(fp)
 800294c:	10c00104 	addi	r3,r2,4
 8002950:	e0fffb15 	stw	r3,-20(fp)
 8002954:	e0fffa17 	ldw	r3,-24(fp)
 8002958:	10c00015 	stw	r3,0(r2)
          n -= LBLOCKSIZE;
 800295c:	e0bfff17 	ldw	r2,-4(fp)
 8002960:	10bfff04 	addi	r2,r2,-4
 8002964:	e0bfff15 	stw	r2,-4(fp)
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
 8002968:	e0bfff17 	ldw	r2,-4(fp)
 800296c:	10800128 	cmpgeui	r2,r2,4
 8002970:	103ff51e 	bne	r2,zero,8002948 <memset+0x154>
        {
          *aligned_addr++ = buffer;
          n -= LBLOCKSIZE;
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
 8002974:	e0bffb17 	ldw	r2,-20(fp)
 8002978:	e0bff815 	stw	r2,-32(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 800297c:	00000506 	br	8002994 <memset+0x1a0>
    *s++ = (char) c;
 8002980:	e0bff817 	ldw	r2,-32(fp)
 8002984:	10c00044 	addi	r3,r2,1
 8002988:	e0fff815 	stw	r3,-32(fp)
 800298c:	e0fffe17 	ldw	r3,-8(fp)
 8002990:	10c00005 	stb	r3,0(r2)
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 8002994:	e0bfff17 	ldw	r2,-4(fp)
 8002998:	10ffffc4 	addi	r3,r2,-1
 800299c:	e0ffff15 	stw	r3,-4(fp)
 80029a0:	103ff71e 	bne	r2,zero,8002980 <memset+0x18c>
    *s++ = (char) c;

  return m;
 80029a4:	e0bffd17 	ldw	r2,-12(fp)
}
 80029a8:	e037883a 	mov	sp,fp
 80029ac:	df000017 	ldw	fp,0(sp)
 80029b0:	dec00104 	addi	sp,sp,4
 80029b4:	f800283a 	ret

080029b8 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
 80029b8:	deffe104 	addi	sp,sp,-124
 80029bc:	dfc01e15 	stw	ra,120(sp)
 80029c0:	df001d15 	stw	fp,116(sp)
 80029c4:	df001d04 	addi	fp,sp,116
 80029c8:	e13ffd15 	stw	r4,-12(fp)
 80029cc:	e17ffe15 	stw	r5,-8(fp)
 80029d0:	e1bfff15 	stw	r6,-4(fp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
 80029d4:	e0bffe17 	ldw	r2,-8(fp)
 80029d8:	1000041e 	bne	r2,zero,80029ec <_realloc_r+0x34>
 80029dc:	e17fff17 	ldw	r5,-4(fp)
 80029e0:	e13ffd17 	ldw	r4,-12(fp)
 80029e4:	800172c0 	call	800172c <_malloc_r>
 80029e8:	0002ea06 	br	8003594 <_realloc_r+0xbdc>

  MALLOC_LOCK;
 80029ec:	e13ffd17 	ldw	r4,-12(fp)
 80029f0:	80052440 	call	8005244 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
 80029f4:	e0bffe17 	ldw	r2,-8(fp)
 80029f8:	10bffe04 	addi	r2,r2,-8
 80029fc:	e0bfef15 	stw	r2,-68(fp)
 8002a00:	e0bfef17 	ldw	r2,-68(fp)
 8002a04:	e0bfe315 	stw	r2,-116(fp)
  newsize = oldsize = chunksize(oldp);
 8002a08:	e0bfef17 	ldw	r2,-68(fp)
 8002a0c:	10c00117 	ldw	r3,4(r2)
 8002a10:	00bfff04 	movi	r2,-4
 8002a14:	1884703a 	and	r2,r3,r2
 8002a18:	e0bff015 	stw	r2,-64(fp)
 8002a1c:	e0bff017 	ldw	r2,-64(fp)
 8002a20:	e0bfe415 	stw	r2,-112(fp)


  nb = request2size(bytes);
 8002a24:	e0bfff17 	ldw	r2,-4(fp)
 8002a28:	108002c4 	addi	r2,r2,11
 8002a2c:	108005f0 	cmpltui	r2,r2,23
 8002a30:	1000051e 	bne	r2,zero,8002a48 <_realloc_r+0x90>
 8002a34:	e0bfff17 	ldw	r2,-4(fp)
 8002a38:	10c002c4 	addi	r3,r2,11
 8002a3c:	00bffe04 	movi	r2,-8
 8002a40:	1884703a 	and	r2,r3,r2
 8002a44:	00000106 	br	8002a4c <_realloc_r+0x94>
 8002a48:	00800404 	movi	r2,16
 8002a4c:	e0bff115 	stw	r2,-60(fp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
 8002a50:	e0bff117 	ldw	r2,-60(fp)
 8002a54:	10000316 	blt	r2,zero,8002a64 <_realloc_r+0xac>
 8002a58:	e0fff117 	ldw	r3,-60(fp)
 8002a5c:	e0bfff17 	ldw	r2,-4(fp)
 8002a60:	1880052e 	bgeu	r3,r2,8002a78 <_realloc_r+0xc0>
  {
    RERRNO = ENOMEM;
 8002a64:	e0bffd17 	ldw	r2,-12(fp)
 8002a68:	00c00304 	movi	r3,12
 8002a6c:	10c00015 	stw	r3,0(r2)
    return 0;
 8002a70:	0005883a 	mov	r2,zero
 8002a74:	0002c706 	br	8003594 <_realloc_r+0xbdc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
 8002a78:	e0fff017 	ldw	r3,-64(fp)
 8002a7c:	e0bff117 	ldw	r2,-60(fp)
 8002a80:	18828b0e 	bge	r3,r2,80034b0 <_realloc_r+0xaf8>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
 8002a84:	e0ffef17 	ldw	r3,-68(fp)
 8002a88:	e0bff017 	ldw	r2,-64(fp)
 8002a8c:	1885883a 	add	r2,r3,r2
 8002a90:	e0bfe515 	stw	r2,-108(fp)
    if (next == top || !inuse(next)) 
 8002a94:	00820134 	movhi	r2,2052
 8002a98:	1083df04 	addi	r2,r2,3964
 8002a9c:	10c00217 	ldw	r3,8(r2)
 8002aa0:	e0bfe517 	ldw	r2,-108(fp)
 8002aa4:	18800926 	beq	r3,r2,8002acc <_realloc_r+0x114>
 8002aa8:	e0bfe517 	ldw	r2,-108(fp)
 8002aac:	10c00117 	ldw	r3,4(r2)
 8002ab0:	00bfff84 	movi	r2,-2
 8002ab4:	1884703a 	and	r2,r3,r2
 8002ab8:	e0ffe517 	ldw	r3,-108(fp)
 8002abc:	1885883a 	add	r2,r3,r2
 8002ac0:	10800117 	ldw	r2,4(r2)
 8002ac4:	1080004c 	andi	r2,r2,1
 8002ac8:	1000461e 	bne	r2,zero,8002be4 <_realloc_r+0x22c>
    {
      nextsize = chunksize(next);
 8002acc:	e0bfe517 	ldw	r2,-108(fp)
 8002ad0:	10c00117 	ldw	r3,4(r2)
 8002ad4:	00bfff04 	movi	r2,-4
 8002ad8:	1884703a 	and	r2,r3,r2
 8002adc:	e0bfe615 	stw	r2,-104(fp)

      /* Forward into top only if a remainder */
      if (next == top)
 8002ae0:	00820134 	movhi	r2,2052
 8002ae4:	1083df04 	addi	r2,r2,3964
 8002ae8:	10c00217 	ldw	r3,8(r2)
 8002aec:	e0bfe517 	ldw	r2,-108(fp)
 8002af0:	1880251e 	bne	r3,r2,8002b88 <_realloc_r+0x1d0>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
 8002af4:	e0ffe617 	ldw	r3,-104(fp)
 8002af8:	e0bfe417 	ldw	r2,-112(fp)
 8002afc:	1885883a 	add	r2,r3,r2
 8002b00:	1007883a 	mov	r3,r2
 8002b04:	e0bff117 	ldw	r2,-60(fp)
 8002b08:	10800404 	addi	r2,r2,16
 8002b0c:	18803816 	blt	r3,r2,8002bf0 <_realloc_r+0x238>
        {
          newsize += nextsize;
 8002b10:	e0ffe417 	ldw	r3,-112(fp)
 8002b14:	e0bfe617 	ldw	r2,-104(fp)
 8002b18:	1885883a 	add	r2,r3,r2
 8002b1c:	e0bfe415 	stw	r2,-112(fp)
          top = chunk_at_offset(oldp, nb);
 8002b20:	00820134 	movhi	r2,2052
 8002b24:	1083df04 	addi	r2,r2,3964
 8002b28:	e13fef17 	ldw	r4,-68(fp)
 8002b2c:	e0fff117 	ldw	r3,-60(fp)
 8002b30:	20c7883a 	add	r3,r4,r3
 8002b34:	10c00215 	stw	r3,8(r2)
          set_head(top, (newsize - nb) | PREV_INUSE);
 8002b38:	00820134 	movhi	r2,2052
 8002b3c:	1083df04 	addi	r2,r2,3964
 8002b40:	10800217 	ldw	r2,8(r2)
 8002b44:	e13fe417 	ldw	r4,-112(fp)
 8002b48:	e0fff117 	ldw	r3,-60(fp)
 8002b4c:	20c7c83a 	sub	r3,r4,r3
 8002b50:	18c00054 	ori	r3,r3,1
 8002b54:	10c00115 	stw	r3,4(r2)
          set_head_size(oldp, nb);
 8002b58:	e0bfef17 	ldw	r2,-68(fp)
 8002b5c:	10800117 	ldw	r2,4(r2)
 8002b60:	10c0004c 	andi	r3,r2,1
 8002b64:	e0bff117 	ldw	r2,-60(fp)
 8002b68:	1886b03a 	or	r3,r3,r2
 8002b6c:	e0bfef17 	ldw	r2,-68(fp)
 8002b70:	10c00115 	stw	r3,4(r2)
	  MALLOC_UNLOCK;
 8002b74:	e13ffd17 	ldw	r4,-12(fp)
 8002b78:	80052680 	call	8005268 <__malloc_unlock>
          return chunk2mem(oldp);
 8002b7c:	e0bfef17 	ldw	r2,-68(fp)
 8002b80:	10800204 	addi	r2,r2,8
 8002b84:	00028306 	br	8003594 <_realloc_r+0xbdc>
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
 8002b88:	e0ffe617 	ldw	r3,-104(fp)
 8002b8c:	e0bfe417 	ldw	r2,-112(fp)
 8002b90:	1885883a 	add	r2,r3,r2
 8002b94:	1007883a 	mov	r3,r2
 8002b98:	e0bff117 	ldw	r2,-60(fp)
 8002b9c:	18801416 	blt	r3,r2,8002bf0 <_realloc_r+0x238>
      { 
        unlink(next, bck, fwd);
 8002ba0:	e0bfe517 	ldw	r2,-108(fp)
 8002ba4:	10800317 	ldw	r2,12(r2)
 8002ba8:	e0bff215 	stw	r2,-56(fp)
 8002bac:	e0bfe517 	ldw	r2,-108(fp)
 8002bb0:	10800217 	ldw	r2,8(r2)
 8002bb4:	e0bff315 	stw	r2,-52(fp)
 8002bb8:	e0bff317 	ldw	r2,-52(fp)
 8002bbc:	e0fff217 	ldw	r3,-56(fp)
 8002bc0:	10c00315 	stw	r3,12(r2)
 8002bc4:	e0bff217 	ldw	r2,-56(fp)
 8002bc8:	e0fff317 	ldw	r3,-52(fp)
 8002bcc:	10c00215 	stw	r3,8(r2)
        newsize  += nextsize;
 8002bd0:	e0ffe417 	ldw	r3,-112(fp)
 8002bd4:	e0bfe617 	ldw	r2,-104(fp)
 8002bd8:	1885883a 	add	r2,r3,r2
 8002bdc:	e0bfe415 	stw	r2,-112(fp)
        goto split;
 8002be0:	00023306 	br	80034b0 <_realloc_r+0xaf8>
      }
    }
    else
    {
      next = 0;
 8002be4:	e03fe515 	stw	zero,-108(fp)
      nextsize = 0;
 8002be8:	e03fe615 	stw	zero,-104(fp)
 8002bec:	00000106 	br	8002bf4 <_realloc_r+0x23c>
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
 8002bf0:	0001883a 	nop
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
 8002bf4:	e0bfef17 	ldw	r2,-68(fp)
 8002bf8:	10800117 	ldw	r2,4(r2)
 8002bfc:	1080004c 	andi	r2,r2,1
 8002c00:	1001a91e 	bne	r2,zero,80032a8 <_realloc_r+0x8f0>
    {
      prev = prev_chunk(oldp);
 8002c04:	e0bfef17 	ldw	r2,-68(fp)
 8002c08:	10800017 	ldw	r2,0(r2)
 8002c0c:	0085c83a 	sub	r2,zero,r2
 8002c10:	e0ffef17 	ldw	r3,-68(fp)
 8002c14:	1885883a 	add	r2,r3,r2
 8002c18:	e0bff415 	stw	r2,-48(fp)
      prevsize = chunksize(prev);
 8002c1c:	e0bff417 	ldw	r2,-48(fp)
 8002c20:	10c00117 	ldw	r3,4(r2)
 8002c24:	00bfff04 	movi	r2,-4
 8002c28:	1884703a 	and	r2,r3,r2
 8002c2c:	e0bff515 	stw	r2,-44(fp)

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
 8002c30:	e0bfe517 	ldw	r2,-108(fp)
 8002c34:	10012226 	beq	r2,zero,80030c0 <_realloc_r+0x708>
      {
        /* into top */
        if (next == top)
 8002c38:	00820134 	movhi	r2,2052
 8002c3c:	1083df04 	addi	r2,r2,3964
 8002c40:	10c00217 	ldw	r3,8(r2)
 8002c44:	e0bfe517 	ldw	r2,-108(fp)
 8002c48:	1880951e 	bne	r3,r2,8002ea0 <_realloc_r+0x4e8>
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
 8002c4c:	e0ffe617 	ldw	r3,-104(fp)
 8002c50:	e0bff517 	ldw	r2,-44(fp)
 8002c54:	1887883a 	add	r3,r3,r2
 8002c58:	e0bfe417 	ldw	r2,-112(fp)
 8002c5c:	1885883a 	add	r2,r3,r2
 8002c60:	1007883a 	mov	r3,r2
 8002c64:	e0bff117 	ldw	r2,-60(fp)
 8002c68:	10800404 	addi	r2,r2,16
 8002c6c:	18811416 	blt	r3,r2,80030c0 <_realloc_r+0x708>
          {
            unlink(prev, bck, fwd);
 8002c70:	e0bff417 	ldw	r2,-48(fp)
 8002c74:	10800317 	ldw	r2,12(r2)
 8002c78:	e0bff215 	stw	r2,-56(fp)
 8002c7c:	e0bff417 	ldw	r2,-48(fp)
 8002c80:	10800217 	ldw	r2,8(r2)
 8002c84:	e0bff315 	stw	r2,-52(fp)
 8002c88:	e0bff317 	ldw	r2,-52(fp)
 8002c8c:	e0fff217 	ldw	r3,-56(fp)
 8002c90:	10c00315 	stw	r3,12(r2)
 8002c94:	e0bff217 	ldw	r2,-56(fp)
 8002c98:	e0fff317 	ldw	r3,-52(fp)
 8002c9c:	10c00215 	stw	r3,8(r2)
            newp = prev;
 8002ca0:	e0bff417 	ldw	r2,-48(fp)
 8002ca4:	e0bfe315 	stw	r2,-116(fp)
            newsize += prevsize + nextsize;
 8002ca8:	e0fff517 	ldw	r3,-44(fp)
 8002cac:	e0bfe617 	ldw	r2,-104(fp)
 8002cb0:	1885883a 	add	r2,r3,r2
 8002cb4:	e0ffe417 	ldw	r3,-112(fp)
 8002cb8:	1885883a 	add	r2,r3,r2
 8002cbc:	e0bfe415 	stw	r2,-112(fp)
            newmem = chunk2mem(newp);
 8002cc0:	e0bfe317 	ldw	r2,-116(fp)
 8002cc4:	10800204 	addi	r2,r2,8
 8002cc8:	e0bff615 	stw	r2,-40(fp)
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8002ccc:	e0bff017 	ldw	r2,-64(fp)
 8002cd0:	10bfff04 	addi	r2,r2,-4
 8002cd4:	e0bff715 	stw	r2,-36(fp)
 8002cd8:	e0bff717 	ldw	r2,-36(fp)
 8002cdc:	10800968 	cmpgeui	r2,r2,37
 8002ce0:	1000521e 	bne	r2,zero,8002e2c <_realloc_r+0x474>
 8002ce4:	e0bffe17 	ldw	r2,-8(fp)
 8002ce8:	e0bfe715 	stw	r2,-100(fp)
 8002cec:	e0bff617 	ldw	r2,-40(fp)
 8002cf0:	e0bfe815 	stw	r2,-96(fp)
 8002cf4:	e0bff717 	ldw	r2,-36(fp)
 8002cf8:	10800530 	cmpltui	r2,r2,20
 8002cfc:	1000361e 	bne	r2,zero,8002dd8 <_realloc_r+0x420>
 8002d00:	e0bfe817 	ldw	r2,-96(fp)
 8002d04:	10c00104 	addi	r3,r2,4
 8002d08:	e0ffe815 	stw	r3,-96(fp)
 8002d0c:	e0ffe717 	ldw	r3,-100(fp)
 8002d10:	19000104 	addi	r4,r3,4
 8002d14:	e13fe715 	stw	r4,-100(fp)
 8002d18:	18c00017 	ldw	r3,0(r3)
 8002d1c:	10c00015 	stw	r3,0(r2)
 8002d20:	e0bfe817 	ldw	r2,-96(fp)
 8002d24:	10c00104 	addi	r3,r2,4
 8002d28:	e0ffe815 	stw	r3,-96(fp)
 8002d2c:	e0ffe717 	ldw	r3,-100(fp)
 8002d30:	19000104 	addi	r4,r3,4
 8002d34:	e13fe715 	stw	r4,-100(fp)
 8002d38:	18c00017 	ldw	r3,0(r3)
 8002d3c:	10c00015 	stw	r3,0(r2)
 8002d40:	e0bff717 	ldw	r2,-36(fp)
 8002d44:	10800730 	cmpltui	r2,r2,28
 8002d48:	1000231e 	bne	r2,zero,8002dd8 <_realloc_r+0x420>
 8002d4c:	e0bfe817 	ldw	r2,-96(fp)
 8002d50:	10c00104 	addi	r3,r2,4
 8002d54:	e0ffe815 	stw	r3,-96(fp)
 8002d58:	e0ffe717 	ldw	r3,-100(fp)
 8002d5c:	19000104 	addi	r4,r3,4
 8002d60:	e13fe715 	stw	r4,-100(fp)
 8002d64:	18c00017 	ldw	r3,0(r3)
 8002d68:	10c00015 	stw	r3,0(r2)
 8002d6c:	e0bfe817 	ldw	r2,-96(fp)
 8002d70:	10c00104 	addi	r3,r2,4
 8002d74:	e0ffe815 	stw	r3,-96(fp)
 8002d78:	e0ffe717 	ldw	r3,-100(fp)
 8002d7c:	19000104 	addi	r4,r3,4
 8002d80:	e13fe715 	stw	r4,-100(fp)
 8002d84:	18c00017 	ldw	r3,0(r3)
 8002d88:	10c00015 	stw	r3,0(r2)
 8002d8c:	e0bff717 	ldw	r2,-36(fp)
 8002d90:	10800930 	cmpltui	r2,r2,36
 8002d94:	1000101e 	bne	r2,zero,8002dd8 <_realloc_r+0x420>
 8002d98:	e0bfe817 	ldw	r2,-96(fp)
 8002d9c:	10c00104 	addi	r3,r2,4
 8002da0:	e0ffe815 	stw	r3,-96(fp)
 8002da4:	e0ffe717 	ldw	r3,-100(fp)
 8002da8:	19000104 	addi	r4,r3,4
 8002dac:	e13fe715 	stw	r4,-100(fp)
 8002db0:	18c00017 	ldw	r3,0(r3)
 8002db4:	10c00015 	stw	r3,0(r2)
 8002db8:	e0bfe817 	ldw	r2,-96(fp)
 8002dbc:	10c00104 	addi	r3,r2,4
 8002dc0:	e0ffe815 	stw	r3,-96(fp)
 8002dc4:	e0ffe717 	ldw	r3,-100(fp)
 8002dc8:	19000104 	addi	r4,r3,4
 8002dcc:	e13fe715 	stw	r4,-100(fp)
 8002dd0:	18c00017 	ldw	r3,0(r3)
 8002dd4:	10c00015 	stw	r3,0(r2)
 8002dd8:	e0bfe817 	ldw	r2,-96(fp)
 8002ddc:	10c00104 	addi	r3,r2,4
 8002de0:	e0ffe815 	stw	r3,-96(fp)
 8002de4:	e0ffe717 	ldw	r3,-100(fp)
 8002de8:	19000104 	addi	r4,r3,4
 8002dec:	e13fe715 	stw	r4,-100(fp)
 8002df0:	18c00017 	ldw	r3,0(r3)
 8002df4:	10c00015 	stw	r3,0(r2)
 8002df8:	e0bfe817 	ldw	r2,-96(fp)
 8002dfc:	10c00104 	addi	r3,r2,4
 8002e00:	e0ffe815 	stw	r3,-96(fp)
 8002e04:	e0ffe717 	ldw	r3,-100(fp)
 8002e08:	19000104 	addi	r4,r3,4
 8002e0c:	e13fe715 	stw	r4,-100(fp)
 8002e10:	18c00017 	ldw	r3,0(r3)
 8002e14:	10c00015 	stw	r3,0(r2)
 8002e18:	e0bfe717 	ldw	r2,-100(fp)
 8002e1c:	10c00017 	ldw	r3,0(r2)
 8002e20:	e0bfe817 	ldw	r2,-96(fp)
 8002e24:	10c00015 	stw	r3,0(r2)
 8002e28:	00000406 	br	8002e3c <_realloc_r+0x484>
 8002e2c:	e1bff717 	ldw	r6,-36(fp)
 8002e30:	e17ffe17 	ldw	r5,-8(fp)
 8002e34:	e13ff617 	ldw	r4,-40(fp)
 8002e38:	80025ec0 	call	80025ec <memmove>
            top = chunk_at_offset(newp, nb);
 8002e3c:	00820134 	movhi	r2,2052
 8002e40:	1083df04 	addi	r2,r2,3964
 8002e44:	e13fe317 	ldw	r4,-116(fp)
 8002e48:	e0fff117 	ldw	r3,-60(fp)
 8002e4c:	20c7883a 	add	r3,r4,r3
 8002e50:	10c00215 	stw	r3,8(r2)
            set_head(top, (newsize - nb) | PREV_INUSE);
 8002e54:	00820134 	movhi	r2,2052
 8002e58:	1083df04 	addi	r2,r2,3964
 8002e5c:	10800217 	ldw	r2,8(r2)
 8002e60:	e13fe417 	ldw	r4,-112(fp)
 8002e64:	e0fff117 	ldw	r3,-60(fp)
 8002e68:	20c7c83a 	sub	r3,r4,r3
 8002e6c:	18c00054 	ori	r3,r3,1
 8002e70:	10c00115 	stw	r3,4(r2)
            set_head_size(newp, nb);
 8002e74:	e0bfe317 	ldw	r2,-116(fp)
 8002e78:	10800117 	ldw	r2,4(r2)
 8002e7c:	10c0004c 	andi	r3,r2,1
 8002e80:	e0bff117 	ldw	r2,-60(fp)
 8002e84:	1886b03a 	or	r3,r3,r2
 8002e88:	e0bfe317 	ldw	r2,-116(fp)
 8002e8c:	10c00115 	stw	r3,4(r2)
	    MALLOC_UNLOCK;
 8002e90:	e13ffd17 	ldw	r4,-12(fp)
 8002e94:	80052680 	call	8005268 <__malloc_unlock>
            return newmem;
 8002e98:	e0bff617 	ldw	r2,-40(fp)
 8002e9c:	0001bd06 	br	8003594 <_realloc_r+0xbdc>
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
 8002ea0:	e0ffe617 	ldw	r3,-104(fp)
 8002ea4:	e0bff517 	ldw	r2,-44(fp)
 8002ea8:	1887883a 	add	r3,r3,r2
 8002eac:	e0bfe417 	ldw	r2,-112(fp)
 8002eb0:	1885883a 	add	r2,r3,r2
 8002eb4:	1007883a 	mov	r3,r2
 8002eb8:	e0bff117 	ldw	r2,-60(fp)
 8002ebc:	18808016 	blt	r3,r2,80030c0 <_realloc_r+0x708>
        {
          unlink(next, bck, fwd);
 8002ec0:	e0bfe517 	ldw	r2,-108(fp)
 8002ec4:	10800317 	ldw	r2,12(r2)
 8002ec8:	e0bff215 	stw	r2,-56(fp)
 8002ecc:	e0bfe517 	ldw	r2,-108(fp)
 8002ed0:	10800217 	ldw	r2,8(r2)
 8002ed4:	e0bff315 	stw	r2,-52(fp)
 8002ed8:	e0bff317 	ldw	r2,-52(fp)
 8002edc:	e0fff217 	ldw	r3,-56(fp)
 8002ee0:	10c00315 	stw	r3,12(r2)
 8002ee4:	e0bff217 	ldw	r2,-56(fp)
 8002ee8:	e0fff317 	ldw	r3,-52(fp)
 8002eec:	10c00215 	stw	r3,8(r2)
          unlink(prev, bck, fwd);
 8002ef0:	e0bff417 	ldw	r2,-48(fp)
 8002ef4:	10800317 	ldw	r2,12(r2)
 8002ef8:	e0bff215 	stw	r2,-56(fp)
 8002efc:	e0bff417 	ldw	r2,-48(fp)
 8002f00:	10800217 	ldw	r2,8(r2)
 8002f04:	e0bff315 	stw	r2,-52(fp)
 8002f08:	e0bff317 	ldw	r2,-52(fp)
 8002f0c:	e0fff217 	ldw	r3,-56(fp)
 8002f10:	10c00315 	stw	r3,12(r2)
 8002f14:	e0bff217 	ldw	r2,-56(fp)
 8002f18:	e0fff317 	ldw	r3,-52(fp)
 8002f1c:	10c00215 	stw	r3,8(r2)
          newp = prev;
 8002f20:	e0bff417 	ldw	r2,-48(fp)
 8002f24:	e0bfe315 	stw	r2,-116(fp)
          newsize += nextsize + prevsize;
 8002f28:	e0ffe617 	ldw	r3,-104(fp)
 8002f2c:	e0bff517 	ldw	r2,-44(fp)
 8002f30:	1885883a 	add	r2,r3,r2
 8002f34:	e0ffe417 	ldw	r3,-112(fp)
 8002f38:	1885883a 	add	r2,r3,r2
 8002f3c:	e0bfe415 	stw	r2,-112(fp)
          newmem = chunk2mem(newp);
 8002f40:	e0bfe317 	ldw	r2,-116(fp)
 8002f44:	10800204 	addi	r2,r2,8
 8002f48:	e0bff615 	stw	r2,-40(fp)
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8002f4c:	e0bff017 	ldw	r2,-64(fp)
 8002f50:	10bfff04 	addi	r2,r2,-4
 8002f54:	e0bff815 	stw	r2,-32(fp)
 8002f58:	e0bff817 	ldw	r2,-32(fp)
 8002f5c:	10800968 	cmpgeui	r2,r2,37
 8002f60:	1000521e 	bne	r2,zero,80030ac <_realloc_r+0x6f4>
 8002f64:	e0bffe17 	ldw	r2,-8(fp)
 8002f68:	e0bfe915 	stw	r2,-92(fp)
 8002f6c:	e0bff617 	ldw	r2,-40(fp)
 8002f70:	e0bfea15 	stw	r2,-88(fp)
 8002f74:	e0bff817 	ldw	r2,-32(fp)
 8002f78:	10800530 	cmpltui	r2,r2,20
 8002f7c:	1000361e 	bne	r2,zero,8003058 <_realloc_r+0x6a0>
 8002f80:	e0bfea17 	ldw	r2,-88(fp)
 8002f84:	10c00104 	addi	r3,r2,4
 8002f88:	e0ffea15 	stw	r3,-88(fp)
 8002f8c:	e0ffe917 	ldw	r3,-92(fp)
 8002f90:	19000104 	addi	r4,r3,4
 8002f94:	e13fe915 	stw	r4,-92(fp)
 8002f98:	18c00017 	ldw	r3,0(r3)
 8002f9c:	10c00015 	stw	r3,0(r2)
 8002fa0:	e0bfea17 	ldw	r2,-88(fp)
 8002fa4:	10c00104 	addi	r3,r2,4
 8002fa8:	e0ffea15 	stw	r3,-88(fp)
 8002fac:	e0ffe917 	ldw	r3,-92(fp)
 8002fb0:	19000104 	addi	r4,r3,4
 8002fb4:	e13fe915 	stw	r4,-92(fp)
 8002fb8:	18c00017 	ldw	r3,0(r3)
 8002fbc:	10c00015 	stw	r3,0(r2)
 8002fc0:	e0bff817 	ldw	r2,-32(fp)
 8002fc4:	10800730 	cmpltui	r2,r2,28
 8002fc8:	1000231e 	bne	r2,zero,8003058 <_realloc_r+0x6a0>
 8002fcc:	e0bfea17 	ldw	r2,-88(fp)
 8002fd0:	10c00104 	addi	r3,r2,4
 8002fd4:	e0ffea15 	stw	r3,-88(fp)
 8002fd8:	e0ffe917 	ldw	r3,-92(fp)
 8002fdc:	19000104 	addi	r4,r3,4
 8002fe0:	e13fe915 	stw	r4,-92(fp)
 8002fe4:	18c00017 	ldw	r3,0(r3)
 8002fe8:	10c00015 	stw	r3,0(r2)
 8002fec:	e0bfea17 	ldw	r2,-88(fp)
 8002ff0:	10c00104 	addi	r3,r2,4
 8002ff4:	e0ffea15 	stw	r3,-88(fp)
 8002ff8:	e0ffe917 	ldw	r3,-92(fp)
 8002ffc:	19000104 	addi	r4,r3,4
 8003000:	e13fe915 	stw	r4,-92(fp)
 8003004:	18c00017 	ldw	r3,0(r3)
 8003008:	10c00015 	stw	r3,0(r2)
 800300c:	e0bff817 	ldw	r2,-32(fp)
 8003010:	10800930 	cmpltui	r2,r2,36
 8003014:	1000101e 	bne	r2,zero,8003058 <_realloc_r+0x6a0>
 8003018:	e0bfea17 	ldw	r2,-88(fp)
 800301c:	10c00104 	addi	r3,r2,4
 8003020:	e0ffea15 	stw	r3,-88(fp)
 8003024:	e0ffe917 	ldw	r3,-92(fp)
 8003028:	19000104 	addi	r4,r3,4
 800302c:	e13fe915 	stw	r4,-92(fp)
 8003030:	18c00017 	ldw	r3,0(r3)
 8003034:	10c00015 	stw	r3,0(r2)
 8003038:	e0bfea17 	ldw	r2,-88(fp)
 800303c:	10c00104 	addi	r3,r2,4
 8003040:	e0ffea15 	stw	r3,-88(fp)
 8003044:	e0ffe917 	ldw	r3,-92(fp)
 8003048:	19000104 	addi	r4,r3,4
 800304c:	e13fe915 	stw	r4,-92(fp)
 8003050:	18c00017 	ldw	r3,0(r3)
 8003054:	10c00015 	stw	r3,0(r2)
 8003058:	e0bfea17 	ldw	r2,-88(fp)
 800305c:	10c00104 	addi	r3,r2,4
 8003060:	e0ffea15 	stw	r3,-88(fp)
 8003064:	e0ffe917 	ldw	r3,-92(fp)
 8003068:	19000104 	addi	r4,r3,4
 800306c:	e13fe915 	stw	r4,-92(fp)
 8003070:	18c00017 	ldw	r3,0(r3)
 8003074:	10c00015 	stw	r3,0(r2)
 8003078:	e0bfea17 	ldw	r2,-88(fp)
 800307c:	10c00104 	addi	r3,r2,4
 8003080:	e0ffea15 	stw	r3,-88(fp)
 8003084:	e0ffe917 	ldw	r3,-92(fp)
 8003088:	19000104 	addi	r4,r3,4
 800308c:	e13fe915 	stw	r4,-92(fp)
 8003090:	18c00017 	ldw	r3,0(r3)
 8003094:	10c00015 	stw	r3,0(r2)
 8003098:	e0bfe917 	ldw	r2,-92(fp)
 800309c:	10c00017 	ldw	r3,0(r2)
 80030a0:	e0bfea17 	ldw	r2,-88(fp)
 80030a4:	10c00015 	stw	r3,0(r2)
          goto split;
 80030a8:	00010106 	br	80034b0 <_realloc_r+0xaf8>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 80030ac:	e1bff817 	ldw	r6,-32(fp)
 80030b0:	e17ffe17 	ldw	r5,-8(fp)
 80030b4:	e13ff617 	ldw	r4,-40(fp)
 80030b8:	80025ec0 	call	80025ec <memmove>
          goto split;
 80030bc:	0000fc06 	br	80034b0 <_realloc_r+0xaf8>
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
 80030c0:	e0bff417 	ldw	r2,-48(fp)
 80030c4:	10007826 	beq	r2,zero,80032a8 <_realloc_r+0x8f0>
 80030c8:	e0fff517 	ldw	r3,-44(fp)
 80030cc:	e0bfe417 	ldw	r2,-112(fp)
 80030d0:	1885883a 	add	r2,r3,r2
 80030d4:	1007883a 	mov	r3,r2
 80030d8:	e0bff117 	ldw	r2,-60(fp)
 80030dc:	18807216 	blt	r3,r2,80032a8 <_realloc_r+0x8f0>
      {
        unlink(prev, bck, fwd);
 80030e0:	e0bff417 	ldw	r2,-48(fp)
 80030e4:	10800317 	ldw	r2,12(r2)
 80030e8:	e0bff215 	stw	r2,-56(fp)
 80030ec:	e0bff417 	ldw	r2,-48(fp)
 80030f0:	10800217 	ldw	r2,8(r2)
 80030f4:	e0bff315 	stw	r2,-52(fp)
 80030f8:	e0bff317 	ldw	r2,-52(fp)
 80030fc:	e0fff217 	ldw	r3,-56(fp)
 8003100:	10c00315 	stw	r3,12(r2)
 8003104:	e0bff217 	ldw	r2,-56(fp)
 8003108:	e0fff317 	ldw	r3,-52(fp)
 800310c:	10c00215 	stw	r3,8(r2)
        newp = prev;
 8003110:	e0bff417 	ldw	r2,-48(fp)
 8003114:	e0bfe315 	stw	r2,-116(fp)
        newsize += prevsize;
 8003118:	e0ffe417 	ldw	r3,-112(fp)
 800311c:	e0bff517 	ldw	r2,-44(fp)
 8003120:	1885883a 	add	r2,r3,r2
 8003124:	e0bfe415 	stw	r2,-112(fp)
        newmem = chunk2mem(newp);
 8003128:	e0bfe317 	ldw	r2,-116(fp)
 800312c:	10800204 	addi	r2,r2,8
 8003130:	e0bff615 	stw	r2,-40(fp)
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8003134:	e0bff017 	ldw	r2,-64(fp)
 8003138:	10bfff04 	addi	r2,r2,-4
 800313c:	e0bff915 	stw	r2,-28(fp)
 8003140:	e0bff917 	ldw	r2,-28(fp)
 8003144:	10800968 	cmpgeui	r2,r2,37
 8003148:	1000521e 	bne	r2,zero,8003294 <_realloc_r+0x8dc>
 800314c:	e0bffe17 	ldw	r2,-8(fp)
 8003150:	e0bfeb15 	stw	r2,-84(fp)
 8003154:	e0bff617 	ldw	r2,-40(fp)
 8003158:	e0bfec15 	stw	r2,-80(fp)
 800315c:	e0bff917 	ldw	r2,-28(fp)
 8003160:	10800530 	cmpltui	r2,r2,20
 8003164:	1000361e 	bne	r2,zero,8003240 <_realloc_r+0x888>
 8003168:	e0bfec17 	ldw	r2,-80(fp)
 800316c:	10c00104 	addi	r3,r2,4
 8003170:	e0ffec15 	stw	r3,-80(fp)
 8003174:	e0ffeb17 	ldw	r3,-84(fp)
 8003178:	19000104 	addi	r4,r3,4
 800317c:	e13feb15 	stw	r4,-84(fp)
 8003180:	18c00017 	ldw	r3,0(r3)
 8003184:	10c00015 	stw	r3,0(r2)
 8003188:	e0bfec17 	ldw	r2,-80(fp)
 800318c:	10c00104 	addi	r3,r2,4
 8003190:	e0ffec15 	stw	r3,-80(fp)
 8003194:	e0ffeb17 	ldw	r3,-84(fp)
 8003198:	19000104 	addi	r4,r3,4
 800319c:	e13feb15 	stw	r4,-84(fp)
 80031a0:	18c00017 	ldw	r3,0(r3)
 80031a4:	10c00015 	stw	r3,0(r2)
 80031a8:	e0bff917 	ldw	r2,-28(fp)
 80031ac:	10800730 	cmpltui	r2,r2,28
 80031b0:	1000231e 	bne	r2,zero,8003240 <_realloc_r+0x888>
 80031b4:	e0bfec17 	ldw	r2,-80(fp)
 80031b8:	10c00104 	addi	r3,r2,4
 80031bc:	e0ffec15 	stw	r3,-80(fp)
 80031c0:	e0ffeb17 	ldw	r3,-84(fp)
 80031c4:	19000104 	addi	r4,r3,4
 80031c8:	e13feb15 	stw	r4,-84(fp)
 80031cc:	18c00017 	ldw	r3,0(r3)
 80031d0:	10c00015 	stw	r3,0(r2)
 80031d4:	e0bfec17 	ldw	r2,-80(fp)
 80031d8:	10c00104 	addi	r3,r2,4
 80031dc:	e0ffec15 	stw	r3,-80(fp)
 80031e0:	e0ffeb17 	ldw	r3,-84(fp)
 80031e4:	19000104 	addi	r4,r3,4
 80031e8:	e13feb15 	stw	r4,-84(fp)
 80031ec:	18c00017 	ldw	r3,0(r3)
 80031f0:	10c00015 	stw	r3,0(r2)
 80031f4:	e0bff917 	ldw	r2,-28(fp)
 80031f8:	10800930 	cmpltui	r2,r2,36
 80031fc:	1000101e 	bne	r2,zero,8003240 <_realloc_r+0x888>
 8003200:	e0bfec17 	ldw	r2,-80(fp)
 8003204:	10c00104 	addi	r3,r2,4
 8003208:	e0ffec15 	stw	r3,-80(fp)
 800320c:	e0ffeb17 	ldw	r3,-84(fp)
 8003210:	19000104 	addi	r4,r3,4
 8003214:	e13feb15 	stw	r4,-84(fp)
 8003218:	18c00017 	ldw	r3,0(r3)
 800321c:	10c00015 	stw	r3,0(r2)
 8003220:	e0bfec17 	ldw	r2,-80(fp)
 8003224:	10c00104 	addi	r3,r2,4
 8003228:	e0ffec15 	stw	r3,-80(fp)
 800322c:	e0ffeb17 	ldw	r3,-84(fp)
 8003230:	19000104 	addi	r4,r3,4
 8003234:	e13feb15 	stw	r4,-84(fp)
 8003238:	18c00017 	ldw	r3,0(r3)
 800323c:	10c00015 	stw	r3,0(r2)
 8003240:	e0bfec17 	ldw	r2,-80(fp)
 8003244:	10c00104 	addi	r3,r2,4
 8003248:	e0ffec15 	stw	r3,-80(fp)
 800324c:	e0ffeb17 	ldw	r3,-84(fp)
 8003250:	19000104 	addi	r4,r3,4
 8003254:	e13feb15 	stw	r4,-84(fp)
 8003258:	18c00017 	ldw	r3,0(r3)
 800325c:	10c00015 	stw	r3,0(r2)
 8003260:	e0bfec17 	ldw	r2,-80(fp)
 8003264:	10c00104 	addi	r3,r2,4
 8003268:	e0ffec15 	stw	r3,-80(fp)
 800326c:	e0ffeb17 	ldw	r3,-84(fp)
 8003270:	19000104 	addi	r4,r3,4
 8003274:	e13feb15 	stw	r4,-84(fp)
 8003278:	18c00017 	ldw	r3,0(r3)
 800327c:	10c00015 	stw	r3,0(r2)
 8003280:	e0bfeb17 	ldw	r2,-84(fp)
 8003284:	10c00017 	ldw	r3,0(r2)
 8003288:	e0bfec17 	ldw	r2,-80(fp)
 800328c:	10c00015 	stw	r3,0(r2)
        goto split;
 8003290:	00008706 	br	80034b0 <_realloc_r+0xaf8>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8003294:	e1bff917 	ldw	r6,-28(fp)
 8003298:	e17ffe17 	ldw	r5,-8(fp)
 800329c:	e13ff617 	ldw	r4,-40(fp)
 80032a0:	80025ec0 	call	80025ec <memmove>
        goto split;
 80032a4:	00008206 	br	80034b0 <_realloc_r+0xaf8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
 80032a8:	e17fff17 	ldw	r5,-4(fp)
 80032ac:	e13ffd17 	ldw	r4,-12(fp)
 80032b0:	800172c0 	call	800172c <_malloc_r>
 80032b4:	e0bff615 	stw	r2,-40(fp)

    if (newmem == 0)  /* propagate failure */
 80032b8:	e0bff617 	ldw	r2,-40(fp)
 80032bc:	1000041e 	bne	r2,zero,80032d0 <_realloc_r+0x918>
    {
      MALLOC_UNLOCK;
 80032c0:	e13ffd17 	ldw	r4,-12(fp)
 80032c4:	80052680 	call	8005268 <__malloc_unlock>
      return 0;
 80032c8:	0005883a 	mov	r2,zero
 80032cc:	0000b106 	br	8003594 <_realloc_r+0xbdc>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
 80032d0:	e0bff617 	ldw	r2,-40(fp)
 80032d4:	10bffe04 	addi	r2,r2,-8
 80032d8:	e0bfe315 	stw	r2,-116(fp)
 80032dc:	e0bfef17 	ldw	r2,-68(fp)
 80032e0:	10c00117 	ldw	r3,4(r2)
 80032e4:	00bfff84 	movi	r2,-2
 80032e8:	1884703a 	and	r2,r3,r2
 80032ec:	e0ffef17 	ldw	r3,-68(fp)
 80032f0:	1885883a 	add	r2,r3,r2
 80032f4:	e0ffe317 	ldw	r3,-116(fp)
 80032f8:	18800a1e 	bne	r3,r2,8003324 <_realloc_r+0x96c>
    {
      newsize += chunksize(newp);
 80032fc:	e0bfe317 	ldw	r2,-116(fp)
 8003300:	10c00117 	ldw	r3,4(r2)
 8003304:	00bfff04 	movi	r2,-4
 8003308:	1884703a 	and	r2,r3,r2
 800330c:	e0ffe417 	ldw	r3,-112(fp)
 8003310:	1885883a 	add	r2,r3,r2
 8003314:	e0bfe415 	stw	r2,-112(fp)
      newp = oldp;
 8003318:	e0bfef17 	ldw	r2,-68(fp)
 800331c:	e0bfe315 	stw	r2,-116(fp)
      goto split;
 8003320:	00006306 	br	80034b0 <_realloc_r+0xaf8>
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8003324:	e0bff017 	ldw	r2,-64(fp)
 8003328:	10bfff04 	addi	r2,r2,-4
 800332c:	e0bffa15 	stw	r2,-24(fp)
 8003330:	e0bffa17 	ldw	r2,-24(fp)
 8003334:	10800968 	cmpgeui	r2,r2,37
 8003338:	1000521e 	bne	r2,zero,8003484 <_realloc_r+0xacc>
 800333c:	e0bffe17 	ldw	r2,-8(fp)
 8003340:	e0bfed15 	stw	r2,-76(fp)
 8003344:	e0bff617 	ldw	r2,-40(fp)
 8003348:	e0bfee15 	stw	r2,-72(fp)
 800334c:	e0bffa17 	ldw	r2,-24(fp)
 8003350:	10800530 	cmpltui	r2,r2,20
 8003354:	1000361e 	bne	r2,zero,8003430 <_realloc_r+0xa78>
 8003358:	e0bfee17 	ldw	r2,-72(fp)
 800335c:	10c00104 	addi	r3,r2,4
 8003360:	e0ffee15 	stw	r3,-72(fp)
 8003364:	e0ffed17 	ldw	r3,-76(fp)
 8003368:	19000104 	addi	r4,r3,4
 800336c:	e13fed15 	stw	r4,-76(fp)
 8003370:	18c00017 	ldw	r3,0(r3)
 8003374:	10c00015 	stw	r3,0(r2)
 8003378:	e0bfee17 	ldw	r2,-72(fp)
 800337c:	10c00104 	addi	r3,r2,4
 8003380:	e0ffee15 	stw	r3,-72(fp)
 8003384:	e0ffed17 	ldw	r3,-76(fp)
 8003388:	19000104 	addi	r4,r3,4
 800338c:	e13fed15 	stw	r4,-76(fp)
 8003390:	18c00017 	ldw	r3,0(r3)
 8003394:	10c00015 	stw	r3,0(r2)
 8003398:	e0bffa17 	ldw	r2,-24(fp)
 800339c:	10800730 	cmpltui	r2,r2,28
 80033a0:	1000231e 	bne	r2,zero,8003430 <_realloc_r+0xa78>
 80033a4:	e0bfee17 	ldw	r2,-72(fp)
 80033a8:	10c00104 	addi	r3,r2,4
 80033ac:	e0ffee15 	stw	r3,-72(fp)
 80033b0:	e0ffed17 	ldw	r3,-76(fp)
 80033b4:	19000104 	addi	r4,r3,4
 80033b8:	e13fed15 	stw	r4,-76(fp)
 80033bc:	18c00017 	ldw	r3,0(r3)
 80033c0:	10c00015 	stw	r3,0(r2)
 80033c4:	e0bfee17 	ldw	r2,-72(fp)
 80033c8:	10c00104 	addi	r3,r2,4
 80033cc:	e0ffee15 	stw	r3,-72(fp)
 80033d0:	e0ffed17 	ldw	r3,-76(fp)
 80033d4:	19000104 	addi	r4,r3,4
 80033d8:	e13fed15 	stw	r4,-76(fp)
 80033dc:	18c00017 	ldw	r3,0(r3)
 80033e0:	10c00015 	stw	r3,0(r2)
 80033e4:	e0bffa17 	ldw	r2,-24(fp)
 80033e8:	10800930 	cmpltui	r2,r2,36
 80033ec:	1000101e 	bne	r2,zero,8003430 <_realloc_r+0xa78>
 80033f0:	e0bfee17 	ldw	r2,-72(fp)
 80033f4:	10c00104 	addi	r3,r2,4
 80033f8:	e0ffee15 	stw	r3,-72(fp)
 80033fc:	e0ffed17 	ldw	r3,-76(fp)
 8003400:	19000104 	addi	r4,r3,4
 8003404:	e13fed15 	stw	r4,-76(fp)
 8003408:	18c00017 	ldw	r3,0(r3)
 800340c:	10c00015 	stw	r3,0(r2)
 8003410:	e0bfee17 	ldw	r2,-72(fp)
 8003414:	10c00104 	addi	r3,r2,4
 8003418:	e0ffee15 	stw	r3,-72(fp)
 800341c:	e0ffed17 	ldw	r3,-76(fp)
 8003420:	19000104 	addi	r4,r3,4
 8003424:	e13fed15 	stw	r4,-76(fp)
 8003428:	18c00017 	ldw	r3,0(r3)
 800342c:	10c00015 	stw	r3,0(r2)
 8003430:	e0bfee17 	ldw	r2,-72(fp)
 8003434:	10c00104 	addi	r3,r2,4
 8003438:	e0ffee15 	stw	r3,-72(fp)
 800343c:	e0ffed17 	ldw	r3,-76(fp)
 8003440:	19000104 	addi	r4,r3,4
 8003444:	e13fed15 	stw	r4,-76(fp)
 8003448:	18c00017 	ldw	r3,0(r3)
 800344c:	10c00015 	stw	r3,0(r2)
 8003450:	e0bfee17 	ldw	r2,-72(fp)
 8003454:	10c00104 	addi	r3,r2,4
 8003458:	e0ffee15 	stw	r3,-72(fp)
 800345c:	e0ffed17 	ldw	r3,-76(fp)
 8003460:	19000104 	addi	r4,r3,4
 8003464:	e13fed15 	stw	r4,-76(fp)
 8003468:	18c00017 	ldw	r3,0(r3)
 800346c:	10c00015 	stw	r3,0(r2)
 8003470:	e0bfed17 	ldw	r2,-76(fp)
 8003474:	10c00017 	ldw	r3,0(r2)
 8003478:	e0bfee17 	ldw	r2,-72(fp)
 800347c:	10c00015 	stw	r3,0(r2)
 8003480:	00000406 	br	8003494 <_realloc_r+0xadc>
 8003484:	e1bffa17 	ldw	r6,-24(fp)
 8003488:	e17ffe17 	ldw	r5,-8(fp)
 800348c:	e13ff617 	ldw	r4,-40(fp)
 8003490:	80025ec0 	call	80025ec <memmove>
    fREe(RCALL oldmem);
 8003494:	e17ffe17 	ldw	r5,-8(fp)
 8003498:	e13ffd17 	ldw	r4,-12(fp)
 800349c:	80040300 	call	8004030 <_free_r>
    MALLOC_UNLOCK;
 80034a0:	e13ffd17 	ldw	r4,-12(fp)
 80034a4:	80052680 	call	8005268 <__malloc_unlock>
    return newmem;
 80034a8:	e0bff617 	ldw	r2,-40(fp)
 80034ac:	00003906 	br	8003594 <_realloc_r+0xbdc>
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
 80034b0:	e0ffe417 	ldw	r3,-112(fp)
 80034b4:	e0bff117 	ldw	r2,-60(fp)
 80034b8:	1885c83a 	sub	r2,r3,r2
 80034bc:	e0bffb15 	stw	r2,-20(fp)

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
 80034c0:	e0bffb17 	ldw	r2,-20(fp)
 80034c4:	10800430 	cmpltui	r2,r2,16
 80034c8:	10001e1e 	bne	r2,zero,8003544 <_realloc_r+0xb8c>
  {
    remainder = chunk_at_offset(newp, nb);
 80034cc:	e0ffe317 	ldw	r3,-116(fp)
 80034d0:	e0bff117 	ldw	r2,-60(fp)
 80034d4:	1885883a 	add	r2,r3,r2
 80034d8:	e0bffc15 	stw	r2,-16(fp)
    set_head_size(newp, nb);
 80034dc:	e0bfe317 	ldw	r2,-116(fp)
 80034e0:	10800117 	ldw	r2,4(r2)
 80034e4:	10c0004c 	andi	r3,r2,1
 80034e8:	e0bff117 	ldw	r2,-60(fp)
 80034ec:	1886b03a 	or	r3,r3,r2
 80034f0:	e0bfe317 	ldw	r2,-116(fp)
 80034f4:	10c00115 	stw	r3,4(r2)
    set_head(remainder, remainder_size | PREV_INUSE);
 80034f8:	e0bffb17 	ldw	r2,-20(fp)
 80034fc:	10c00054 	ori	r3,r2,1
 8003500:	e0bffc17 	ldw	r2,-16(fp)
 8003504:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(remainder, remainder_size);
 8003508:	e0fffc17 	ldw	r3,-16(fp)
 800350c:	e0bffb17 	ldw	r2,-20(fp)
 8003510:	1885883a 	add	r2,r3,r2
 8003514:	e13ffc17 	ldw	r4,-16(fp)
 8003518:	e0fffb17 	ldw	r3,-20(fp)
 800351c:	20c7883a 	add	r3,r4,r3
 8003520:	18c00117 	ldw	r3,4(r3)
 8003524:	18c00054 	ori	r3,r3,1
 8003528:	10c00115 	stw	r3,4(r2)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
 800352c:	e0bffc17 	ldw	r2,-16(fp)
 8003530:	10800204 	addi	r2,r2,8
 8003534:	100b883a 	mov	r5,r2
 8003538:	e13ffd17 	ldw	r4,-12(fp)
 800353c:	80040300 	call	8004030 <_free_r>
 8003540:	00001006 	br	8003584 <_realloc_r+0xbcc>
  }
  else
  {
    set_head_size(newp, newsize);
 8003544:	e0bfe317 	ldw	r2,-116(fp)
 8003548:	10800117 	ldw	r2,4(r2)
 800354c:	10c0004c 	andi	r3,r2,1
 8003550:	e0bfe417 	ldw	r2,-112(fp)
 8003554:	1886b03a 	or	r3,r3,r2
 8003558:	e0bfe317 	ldw	r2,-116(fp)
 800355c:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(newp, newsize);
 8003560:	e0ffe317 	ldw	r3,-116(fp)
 8003564:	e0bfe417 	ldw	r2,-112(fp)
 8003568:	1885883a 	add	r2,r3,r2
 800356c:	e13fe317 	ldw	r4,-116(fp)
 8003570:	e0ffe417 	ldw	r3,-112(fp)
 8003574:	20c7883a 	add	r3,r4,r3
 8003578:	18c00117 	ldw	r3,4(r3)
 800357c:	18c00054 	ori	r3,r3,1
 8003580:	10c00115 	stw	r3,4(r2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
 8003584:	e13ffd17 	ldw	r4,-12(fp)
 8003588:	80052680 	call	8005268 <__malloc_unlock>
  return chunk2mem(newp);
 800358c:	e0bfe317 	ldw	r2,-116(fp)
 8003590:	10800204 	addi	r2,r2,8

#endif /* MALLOC_PROVIDED */
}
 8003594:	e037883a 	mov	sp,fp
 8003598:	dfc00117 	ldw	ra,4(sp)
 800359c:	df000017 	ldw	fp,0(sp)
 80035a0:	dec00204 	addi	sp,sp,8
 80035a4:	f800283a 	ret

080035a8 <_sbrk_r>:

void *
_DEFUN (_sbrk_r, (ptr, incr),
     struct _reent *ptr _AND
     ptrdiff_t incr)
{
 80035a8:	defffb04 	addi	sp,sp,-20
 80035ac:	dfc00415 	stw	ra,16(sp)
 80035b0:	df000315 	stw	fp,12(sp)
 80035b4:	df000304 	addi	fp,sp,12
 80035b8:	e13ffe15 	stw	r4,-8(fp)
 80035bc:	e17fff15 	stw	r5,-4(fp)
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
 80035c0:	d026e615 	stw	zero,-25704(gp)
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
 80035c4:	e13fff17 	ldw	r4,-4(fp)
 80035c8:	80054280 	call	8005428 <sbrk>
 80035cc:	e0bffd15 	stw	r2,-12(fp)
 80035d0:	e0bffd17 	ldw	r2,-12(fp)
 80035d4:	10bfffd8 	cmpnei	r2,r2,-1
 80035d8:	1000051e 	bne	r2,zero,80035f0 <_sbrk_r+0x48>
 80035dc:	d0a6e617 	ldw	r2,-25704(gp)
 80035e0:	10000326 	beq	r2,zero,80035f0 <_sbrk_r+0x48>
    ptr->_errno = errno;
 80035e4:	d0e6e617 	ldw	r3,-25704(gp)
 80035e8:	e0bffe17 	ldw	r2,-8(fp)
 80035ec:	10c00015 	stw	r3,0(r2)
  return ret;
 80035f0:	e0bffd17 	ldw	r2,-12(fp)
}
 80035f4:	e037883a 	mov	sp,fp
 80035f8:	dfc00117 	ldw	ra,4(sp)
 80035fc:	df000017 	ldw	fp,0(sp)
 8003600:	dec00204 	addi	sp,sp,8
 8003604:	f800283a 	ret

08003608 <__sread>:
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
 8003608:	defff804 	addi	sp,sp,-32
 800360c:	dfc00715 	stw	ra,28(sp)
 8003610:	df000615 	stw	fp,24(sp)
 8003614:	dc400515 	stw	r17,20(sp)
 8003618:	dc000415 	stw	r16,16(sp)
 800361c:	df000604 	addi	fp,sp,24
 8003620:	e13ffa15 	stw	r4,-24(fp)
 8003624:	e17ffb15 	stw	r5,-20(fp)
 8003628:	e1bffc15 	stw	r6,-16(fp)
 800362c:	e1fffd15 	stw	r7,-12(fp)
  register FILE *fp = (FILE *) cookie;
 8003630:	e43ffb17 	ldw	r16,-20(fp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
 8003634:	8080038b 	ldhu	r2,14(r16)
 8003638:	10bfffcc 	andi	r2,r2,65535
 800363c:	10a0001c 	xori	r2,r2,32768
 8003640:	10a00004 	addi	r2,r2,-32768
 8003644:	e0fffd17 	ldw	r3,-12(fp)
 8003648:	180f883a 	mov	r7,r3
 800364c:	e1bffc17 	ldw	r6,-16(fp)
 8003650:	100b883a 	mov	r5,r2
 8003654:	e13ffa17 	ldw	r4,-24(fp)
 8003658:	80049f80 	call	80049f8 <_read_r>
 800365c:	1023883a 	mov	r17,r2
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
 8003660:	88000416 	blt	r17,zero,8003674 <__sread+0x6c>
    fp->_offset += ret;
 8003664:	80801417 	ldw	r2,80(r16)
 8003668:	1445883a 	add	r2,r2,r17
 800366c:	80801415 	stw	r2,80(r16)
 8003670:	00000406 	br	8003684 <__sread+0x7c>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
 8003674:	80c0030b 	ldhu	r3,12(r16)
 8003678:	00bbffc4 	movi	r2,-4097
 800367c:	1884703a 	and	r2,r3,r2
 8003680:	8080030d 	sth	r2,12(r16)
  return ret;
 8003684:	8805883a 	mov	r2,r17
}
 8003688:	e6fffe04 	addi	sp,fp,-8
 800368c:	dfc00317 	ldw	ra,12(sp)
 8003690:	df000217 	ldw	fp,8(sp)
 8003694:	dc400117 	ldw	r17,4(sp)
 8003698:	dc000017 	ldw	r16,0(sp)
 800369c:	dec00404 	addi	sp,sp,16
 80036a0:	f800283a 	ret

080036a4 <__seofread>:
_DEFUN(__seofread, (ptr, cookie, buf, len),
       struct _reent *_ptr _AND
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
 80036a4:	defffb04 	addi	sp,sp,-20
 80036a8:	df000415 	stw	fp,16(sp)
 80036ac:	df000404 	addi	fp,sp,16
 80036b0:	e13ffc15 	stw	r4,-16(fp)
 80036b4:	e17ffd15 	stw	r5,-12(fp)
 80036b8:	e1bffe15 	stw	r6,-8(fp)
 80036bc:	e1ffff15 	stw	r7,-4(fp)
  return 0;
 80036c0:	0005883a 	mov	r2,zero
}
 80036c4:	e037883a 	mov	sp,fp
 80036c8:	df000017 	ldw	fp,0(sp)
 80036cc:	dec00104 	addi	sp,sp,4
 80036d0:	f800283a 	ret

080036d4 <__swrite>:
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
 80036d4:	defff804 	addi	sp,sp,-32
 80036d8:	dfc00715 	stw	ra,28(sp)
 80036dc:	df000615 	stw	fp,24(sp)
 80036e0:	dc000515 	stw	r16,20(sp)
 80036e4:	df000604 	addi	fp,sp,24
 80036e8:	e13ffb15 	stw	r4,-20(fp)
 80036ec:	e17ffc15 	stw	r5,-16(fp)
 80036f0:	e1bffd15 	stw	r6,-12(fp)
 80036f4:	e1fffe15 	stw	r7,-8(fp)
  register FILE *fp = (FILE *) cookie;
 80036f8:	e43ffc17 	ldw	r16,-16(fp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
 80036fc:	8080030b 	ldhu	r2,12(r16)
 8003700:	10bfffcc 	andi	r2,r2,65535
 8003704:	1080400c 	andi	r2,r2,256
 8003708:	10000926 	beq	r2,zero,8003730 <__swrite+0x5c>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
 800370c:	8080038b 	ldhu	r2,14(r16)
 8003710:	10bfffcc 	andi	r2,r2,65535
 8003714:	10a0001c 	xori	r2,r2,32768
 8003718:	10a00004 	addi	r2,r2,-32768
 800371c:	01c00084 	movi	r7,2
 8003720:	000d883a 	mov	r6,zero
 8003724:	100b883a 	mov	r5,r2
 8003728:	e13ffb17 	ldw	r4,-20(fp)
 800372c:	800475c0 	call	800475c <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
 8003730:	80c0030b 	ldhu	r3,12(r16)
 8003734:	00bbffc4 	movi	r2,-4097
 8003738:	1884703a 	and	r2,r3,r2
 800373c:	8080030d 	sth	r2,12(r16)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
 8003740:	8080038b 	ldhu	r2,14(r16)
 8003744:	10bfffcc 	andi	r2,r2,65535
 8003748:	10a0001c 	xori	r2,r2,32768
 800374c:	10a00004 	addi	r2,r2,-32768
 8003750:	e0fffe17 	ldw	r3,-8(fp)
 8003754:	180f883a 	mov	r7,r3
 8003758:	e1bffd17 	ldw	r6,-12(fp)
 800375c:	100b883a 	mov	r5,r2
 8003760:	e13ffb17 	ldw	r4,-20(fp)
 8003764:	800387c0 	call	800387c <_write_r>
 8003768:	e0bffa15 	stw	r2,-24(fp)
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
 800376c:	e0bffa17 	ldw	r2,-24(fp)
}
 8003770:	e6ffff04 	addi	sp,fp,-4
 8003774:	dfc00217 	ldw	ra,8(sp)
 8003778:	df000117 	ldw	fp,4(sp)
 800377c:	dc000017 	ldw	r16,0(sp)
 8003780:	dec00304 	addi	sp,sp,12
 8003784:	f800283a 	ret

08003788 <__sseek>:
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
 8003788:	defff804 	addi	sp,sp,-32
 800378c:	dfc00715 	stw	ra,28(sp)
 8003790:	df000615 	stw	fp,24(sp)
 8003794:	dc400515 	stw	r17,20(sp)
 8003798:	dc000415 	stw	r16,16(sp)
 800379c:	df000604 	addi	fp,sp,24
 80037a0:	e13ffa15 	stw	r4,-24(fp)
 80037a4:	e17ffb15 	stw	r5,-20(fp)
 80037a8:	e1bffc15 	stw	r6,-16(fp)
 80037ac:	e1fffd15 	stw	r7,-12(fp)
  register FILE *fp = (FILE *) cookie;
 80037b0:	e43ffb17 	ldw	r16,-20(fp)
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
 80037b4:	8080038b 	ldhu	r2,14(r16)
 80037b8:	10bfffcc 	andi	r2,r2,65535
 80037bc:	10a0001c 	xori	r2,r2,32768
 80037c0:	10a00004 	addi	r2,r2,-32768
 80037c4:	e1fffd17 	ldw	r7,-12(fp)
 80037c8:	e1bffc17 	ldw	r6,-16(fp)
 80037cc:	100b883a 	mov	r5,r2
 80037d0:	e13ffa17 	ldw	r4,-24(fp)
 80037d4:	800475c0 	call	800475c <_lseek_r>
 80037d8:	1023883a 	mov	r17,r2
  if (ret == -1L)
 80037dc:	88bfffd8 	cmpnei	r2,r17,-1
 80037e0:	1000051e 	bne	r2,zero,80037f8 <__sseek+0x70>
    fp->_flags &= ~__SOFF;
 80037e4:	80c0030b 	ldhu	r3,12(r16)
 80037e8:	00bbffc4 	movi	r2,-4097
 80037ec:	1884703a 	and	r2,r3,r2
 80037f0:	8080030d 	sth	r2,12(r16)
 80037f4:	00000406 	br	8003808 <__sseek+0x80>
  else
    {
      fp->_flags |= __SOFF;
 80037f8:	8080030b 	ldhu	r2,12(r16)
 80037fc:	10840014 	ori	r2,r2,4096
 8003800:	8080030d 	sth	r2,12(r16)
      fp->_offset = ret;
 8003804:	84401415 	stw	r17,80(r16)
    }
  return ret;
 8003808:	8805883a 	mov	r2,r17
}
 800380c:	e6fffe04 	addi	sp,fp,-8
 8003810:	dfc00317 	ldw	ra,12(sp)
 8003814:	df000217 	ldw	fp,8(sp)
 8003818:	dc400117 	ldw	r17,4(sp)
 800381c:	dc000017 	ldw	r16,0(sp)
 8003820:	dec00404 	addi	sp,sp,16
 8003824:	f800283a 	ret

08003828 <__sclose>:

int
_DEFUN(__sclose, (ptr, cookie),
       struct _reent *ptr _AND
       void *cookie)
{
 8003828:	defffb04 	addi	sp,sp,-20
 800382c:	dfc00415 	stw	ra,16(sp)
 8003830:	df000315 	stw	fp,12(sp)
 8003834:	df000304 	addi	fp,sp,12
 8003838:	e13ffe15 	stw	r4,-8(fp)
 800383c:	e17fff15 	stw	r5,-4(fp)
  FILE *fp = (FILE *) cookie;
 8003840:	e0bfff17 	ldw	r2,-4(fp)
 8003844:	e0bffd15 	stw	r2,-12(fp)

  return _close_r (ptr, fp->_file);
 8003848:	e0bffd17 	ldw	r2,-12(fp)
 800384c:	1080038b 	ldhu	r2,14(r2)
 8003850:	10bfffcc 	andi	r2,r2,65535
 8003854:	10a0001c 	xori	r2,r2,32768
 8003858:	10a00004 	addi	r2,r2,-32768
 800385c:	100b883a 	mov	r5,r2
 8003860:	e13ffe17 	ldw	r4,-8(fp)
 8003864:	8003a8c0 	call	8003a8c <_close_r>
}
 8003868:	e037883a 	mov	sp,fp
 800386c:	dfc00117 	ldw	ra,4(sp)
 8003870:	df000017 	ldw	fp,0(sp)
 8003874:	dec00204 	addi	sp,sp,8
 8003878:	f800283a 	ret

0800387c <_write_r>:
_DEFUN (_write_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _CONST _PTR buf _AND
     size_t cnt)
{
 800387c:	defff904 	addi	sp,sp,-28
 8003880:	dfc00615 	stw	ra,24(sp)
 8003884:	df000515 	stw	fp,20(sp)
 8003888:	df000504 	addi	fp,sp,20
 800388c:	e13ffc15 	stw	r4,-16(fp)
 8003890:	e17ffd15 	stw	r5,-12(fp)
 8003894:	e1bffe15 	stw	r6,-8(fp)
 8003898:	e1ffff15 	stw	r7,-4(fp)
  _ssize_t ret;

  errno = 0;
 800389c:	d026e615 	stw	zero,-25704(gp)
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
 80038a0:	e1bfff17 	ldw	r6,-4(fp)
 80038a4:	e17ffe17 	ldw	r5,-8(fp)
 80038a8:	e13ffd17 	ldw	r4,-12(fp)
 80038ac:	80056b80 	call	80056b8 <write>
 80038b0:	e0bffb15 	stw	r2,-20(fp)
 80038b4:	e0bffb17 	ldw	r2,-20(fp)
 80038b8:	10bfffd8 	cmpnei	r2,r2,-1
 80038bc:	1000051e 	bne	r2,zero,80038d4 <_write_r+0x58>
 80038c0:	d0a6e617 	ldw	r2,-25704(gp)
 80038c4:	10000326 	beq	r2,zero,80038d4 <_write_r+0x58>
    ptr->_errno = errno;
 80038c8:	d0e6e617 	ldw	r3,-25704(gp)
 80038cc:	e0bffc17 	ldw	r2,-16(fp)
 80038d0:	10c00015 	stw	r3,0(r2)
  return ret;
 80038d4:	e0bffb17 	ldw	r2,-20(fp)
}
 80038d8:	e037883a 	mov	sp,fp
 80038dc:	dfc00117 	ldw	ra,4(sp)
 80038e0:	df000017 	ldw	fp,0(sp)
 80038e4:	dec00204 	addi	sp,sp,8
 80038e8:	f800283a 	ret

080038ec <__swsetup_r>:

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 80038ec:	defffb04 	addi	sp,sp,-20
 80038f0:	dfc00415 	stw	ra,16(sp)
 80038f4:	df000315 	stw	fp,12(sp)
 80038f8:	dc000215 	stw	r16,8(sp)
 80038fc:	df000304 	addi	fp,sp,12
 8003900:	e13ffe15 	stw	r4,-8(fp)
 8003904:	2821883a 	mov	r16,r5
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
 8003908:	d0a00017 	ldw	r2,-32768(gp)
 800390c:	e0bffd15 	stw	r2,-12(fp)
 8003910:	e0bffd17 	ldw	r2,-12(fp)
 8003914:	10000526 	beq	r2,zero,800392c <__swsetup_r+0x40>
 8003918:	e0bffd17 	ldw	r2,-12(fp)
 800391c:	10800e17 	ldw	r2,56(r2)
 8003920:	1000021e 	bne	r2,zero,800392c <__swsetup_r+0x40>
 8003924:	e13ffd17 	ldw	r4,-12(fp)
 8003928:	80009c80 	call	80009c8 <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
 800392c:	8080030b 	ldhu	r2,12(r16)
 8003930:	10bfffcc 	andi	r2,r2,65535
 8003934:	1080020c 	andi	r2,r2,8
 8003938:	1000241e 	bne	r2,zero,80039cc <__swsetup_r+0xe0>
    {
      if ((fp->_flags & __SRW) == 0)
 800393c:	8080030b 	ldhu	r2,12(r16)
 8003940:	10bfffcc 	andi	r2,r2,65535
 8003944:	1080040c 	andi	r2,r2,16
 8003948:	1000081e 	bne	r2,zero,800396c <__swsetup_r+0x80>
        {
	  ptr->_errno = EBADF;
 800394c:	e0bffe17 	ldw	r2,-8(fp)
 8003950:	00c00244 	movi	r3,9
 8003954:	10c00015 	stw	r3,0(r2)
	  fp->_flags |= __SERR;
 8003958:	8080030b 	ldhu	r2,12(r16)
 800395c:	10801014 	ori	r2,r2,64
 8003960:	8080030d 	sth	r2,12(r16)
	  return EOF;
 8003964:	00bfffc4 	movi	r2,-1
 8003968:	00004206 	br	8003a74 <__swsetup_r+0x188>
        }
      if (fp->_flags & __SRD)
 800396c:	8080030b 	ldhu	r2,12(r16)
 8003970:	10bfffcc 	andi	r2,r2,65535
 8003974:	1080010c 	andi	r2,r2,4
 8003978:	10001126 	beq	r2,zero,80039c0 <__swsetup_r+0xd4>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
 800397c:	80800c17 	ldw	r2,48(r16)
 8003980:	10000826 	beq	r2,zero,80039a4 <__swsetup_r+0xb8>
	    FREEUB (ptr, fp);
 8003984:	80c00c17 	ldw	r3,48(r16)
 8003988:	80801004 	addi	r2,r16,64
 800398c:	18800426 	beq	r3,r2,80039a0 <__swsetup_r+0xb4>
 8003990:	80800c17 	ldw	r2,48(r16)
 8003994:	100b883a 	mov	r5,r2
 8003998:	e13ffe17 	ldw	r4,-8(fp)
 800399c:	80040300 	call	8004030 <_free_r>
 80039a0:	80000c15 	stw	zero,48(r16)
	  fp->_flags &= ~(__SRD | __SEOF);
 80039a4:	80c0030b 	ldhu	r3,12(r16)
 80039a8:	00bff6c4 	movi	r2,-37
 80039ac:	1884703a 	and	r2,r3,r2
 80039b0:	8080030d 	sth	r2,12(r16)
	  fp->_r = 0;
 80039b4:	80000115 	stw	zero,4(r16)
	  fp->_p = fp->_bf._base;
 80039b8:	80800417 	ldw	r2,16(r16)
 80039bc:	80800015 	stw	r2,0(r16)
	}
      fp->_flags |= __SWR;
 80039c0:	8080030b 	ldhu	r2,12(r16)
 80039c4:	10800214 	ori	r2,r2,8
 80039c8:	8080030d 	sth	r2,12(r16)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
 80039cc:	80800417 	ldw	r2,16(r16)
 80039d0:	10000b1e 	bne	r2,zero,8003a00 <__swsetup_r+0x114>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
 80039d4:	8080030b 	ldhu	r2,12(r16)
 80039d8:	10bfffcc 	andi	r2,r2,65535
 80039dc:	1080800c 	andi	r2,r2,512
 80039e0:	10000426 	beq	r2,zero,80039f4 <__swsetup_r+0x108>
 80039e4:	8080030b 	ldhu	r2,12(r16)
 80039e8:	10bfffcc 	andi	r2,r2,65535
 80039ec:	1080200c 	andi	r2,r2,128
 80039f0:	10000326 	beq	r2,zero,8003a00 <__swsetup_r+0x114>
    __smakebuf_r (ptr, fp);
 80039f4:	800b883a 	mov	r5,r16
 80039f8:	e13ffe17 	ldw	r4,-8(fp)
 80039fc:	80047cc0 	call	80047cc <__smakebuf_r>

  if (fp->_flags & __SLBF)
 8003a00:	8080030b 	ldhu	r2,12(r16)
 8003a04:	10bfffcc 	andi	r2,r2,65535
 8003a08:	1080004c 	andi	r2,r2,1
 8003a0c:	10000526 	beq	r2,zero,8003a24 <__swsetup_r+0x138>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
 8003a10:	80000215 	stw	zero,8(r16)
      fp->_lbfsize = -fp->_bf._size;
 8003a14:	80800517 	ldw	r2,20(r16)
 8003a18:	0085c83a 	sub	r2,zero,r2
 8003a1c:	80800615 	stw	r2,24(r16)
 8003a20:	00000806 	br	8003a44 <__swsetup_r+0x158>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
 8003a24:	8080030b 	ldhu	r2,12(r16)
 8003a28:	10bfffcc 	andi	r2,r2,65535
 8003a2c:	1080008c 	andi	r2,r2,2
 8003a30:	1000021e 	bne	r2,zero,8003a3c <__swsetup_r+0x150>
 8003a34:	80800517 	ldw	r2,20(r16)
 8003a38:	00000106 	br	8003a40 <__swsetup_r+0x154>
 8003a3c:	0005883a 	mov	r2,zero
 8003a40:	80800215 	stw	r2,8(r16)

  if (!fp->_bf._base && (fp->_flags & __SMBF))
 8003a44:	80800417 	ldw	r2,16(r16)
 8003a48:	1000091e 	bne	r2,zero,8003a70 <__swsetup_r+0x184>
 8003a4c:	8080030b 	ldhu	r2,12(r16)
 8003a50:	10bfffcc 	andi	r2,r2,65535
 8003a54:	1080200c 	andi	r2,r2,128
 8003a58:	10000526 	beq	r2,zero,8003a70 <__swsetup_r+0x184>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
 8003a5c:	8080030b 	ldhu	r2,12(r16)
 8003a60:	10801014 	ori	r2,r2,64
 8003a64:	8080030d 	sth	r2,12(r16)
      return EOF;
 8003a68:	00bfffc4 	movi	r2,-1
 8003a6c:	00000106 	br	8003a74 <__swsetup_r+0x188>
    }
  return 0;
 8003a70:	0005883a 	mov	r2,zero
}
 8003a74:	e6ffff04 	addi	sp,fp,-4
 8003a78:	dfc00217 	ldw	ra,8(sp)
 8003a7c:	df000117 	ldw	fp,4(sp)
 8003a80:	dc000017 	ldw	r16,0(sp)
 8003a84:	dec00304 	addi	sp,sp,12
 8003a88:	f800283a 	ret

08003a8c <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 8003a8c:	defffb04 	addi	sp,sp,-20
 8003a90:	dfc00415 	stw	ra,16(sp)
 8003a94:	df000315 	stw	fp,12(sp)
 8003a98:	df000304 	addi	fp,sp,12
 8003a9c:	e13ffe15 	stw	r4,-8(fp)
 8003aa0:	e17fff15 	stw	r5,-4(fp)
  int ret;

  errno = 0;
 8003aa4:	d026e615 	stw	zero,-25704(gp)
  if ((ret = _close (fd)) == -1 && errno != 0)
 8003aa8:	e13fff17 	ldw	r4,-4(fp)
 8003aac:	8004d200 	call	8004d20 <close>
 8003ab0:	e0bffd15 	stw	r2,-12(fp)
 8003ab4:	e0bffd17 	ldw	r2,-12(fp)
 8003ab8:	10bfffd8 	cmpnei	r2,r2,-1
 8003abc:	1000051e 	bne	r2,zero,8003ad4 <_close_r+0x48>
 8003ac0:	d0a6e617 	ldw	r2,-25704(gp)
 8003ac4:	10000326 	beq	r2,zero,8003ad4 <_close_r+0x48>
    ptr->_errno = errno;
 8003ac8:	d0e6e617 	ldw	r3,-25704(gp)
 8003acc:	e0bffe17 	ldw	r2,-8(fp)
 8003ad0:	10c00015 	stw	r3,0(r2)
  return ret;
 8003ad4:	e0bffd17 	ldw	r2,-12(fp)
}
 8003ad8:	e037883a 	mov	sp,fp
 8003adc:	dfc00117 	ldw	ra,4(sp)
 8003ae0:	df000017 	ldw	fp,0(sp)
 8003ae4:	dec00204 	addi	sp,sp,8
 8003ae8:	f800283a 	ret

08003aec <_fclose_r>:

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
 8003aec:	defffa04 	addi	sp,sp,-24
 8003af0:	dfc00515 	stw	ra,20(sp)
 8003af4:	df000415 	stw	fp,16(sp)
 8003af8:	dc000315 	stw	r16,12(sp)
 8003afc:	df000404 	addi	fp,sp,16
 8003b00:	e13ffe15 	stw	r4,-8(fp)
 8003b04:	2821883a 	mov	r16,r5
  int r;

  if (fp == NULL)
 8003b08:	8000021e 	bne	r16,zero,8003b14 <_fclose_r+0x28>
    return (0);			/* on NULL */
 8003b0c:	0005883a 	mov	r2,zero
 8003b10:	00003b06 	br	8003c00 <_fclose_r+0x114>

  CHECK_INIT (rptr, fp);
 8003b14:	e0bffe17 	ldw	r2,-8(fp)
 8003b18:	e0bffd15 	stw	r2,-12(fp)
 8003b1c:	e0bffd17 	ldw	r2,-12(fp)
 8003b20:	10000526 	beq	r2,zero,8003b38 <_fclose_r+0x4c>
 8003b24:	e0bffd17 	ldw	r2,-12(fp)
 8003b28:	10800e17 	ldw	r2,56(r2)
 8003b2c:	1000021e 	bne	r2,zero,8003b38 <_fclose_r+0x4c>
 8003b30:	e13ffd17 	ldw	r4,-12(fp)
 8003b34:	80009c80 	call	80009c8 <__sinit>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
 8003b38:	8080030b 	ldhu	r2,12(r16)
 8003b3c:	10bfffcc 	andi	r2,r2,65535
 8003b40:	10a0001c 	xori	r2,r2,32768
 8003b44:	10a00004 	addi	r2,r2,-32768
 8003b48:	1000021e 	bne	r2,zero,8003b54 <_fclose_r+0x68>
    {
      _funlockfile (fp);
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
 8003b4c:	0005883a 	mov	r2,zero
 8003b50:	00002b06 	br	8003c00 <_fclose_r+0x114>
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
 8003b54:	800b883a 	mov	r5,r16
 8003b58:	e13ffe17 	ldw	r4,-8(fp)
 8003b5c:	8003c500 	call	8003c50 <__sflush_r>
 8003b60:	e0bffc15 	stw	r2,-16(fp)
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
 8003b64:	80800b17 	ldw	r2,44(r16)
 8003b68:	10000826 	beq	r2,zero,8003b8c <_fclose_r+0xa0>
 8003b6c:	80800b17 	ldw	r2,44(r16)
 8003b70:	80c00717 	ldw	r3,28(r16)
 8003b74:	180b883a 	mov	r5,r3
 8003b78:	e13ffe17 	ldw	r4,-8(fp)
 8003b7c:	103ee83a 	callr	r2
 8003b80:	1000020e 	bge	r2,zero,8003b8c <_fclose_r+0xa0>
    r = EOF;
 8003b84:	00bfffc4 	movi	r2,-1
 8003b88:	e0bffc15 	stw	r2,-16(fp)
  if (fp->_flags & __SMBF)
 8003b8c:	8080030b 	ldhu	r2,12(r16)
 8003b90:	10bfffcc 	andi	r2,r2,65535
 8003b94:	1080200c 	andi	r2,r2,128
 8003b98:	10000426 	beq	r2,zero,8003bac <_fclose_r+0xc0>
    _free_r (rptr, (char *) fp->_bf._base);
 8003b9c:	80800417 	ldw	r2,16(r16)
 8003ba0:	100b883a 	mov	r5,r2
 8003ba4:	e13ffe17 	ldw	r4,-8(fp)
 8003ba8:	80040300 	call	8004030 <_free_r>
  if (HASUB (fp))
 8003bac:	80800c17 	ldw	r2,48(r16)
 8003bb0:	10000826 	beq	r2,zero,8003bd4 <_fclose_r+0xe8>
    FREEUB (rptr, fp);
 8003bb4:	80c00c17 	ldw	r3,48(r16)
 8003bb8:	80801004 	addi	r2,r16,64
 8003bbc:	18800426 	beq	r3,r2,8003bd0 <_fclose_r+0xe4>
 8003bc0:	80800c17 	ldw	r2,48(r16)
 8003bc4:	100b883a 	mov	r5,r2
 8003bc8:	e13ffe17 	ldw	r4,-8(fp)
 8003bcc:	80040300 	call	8004030 <_free_r>
 8003bd0:	80000c15 	stw	zero,48(r16)
  if (HASLB (fp))
 8003bd4:	80801117 	ldw	r2,68(r16)
 8003bd8:	10000526 	beq	r2,zero,8003bf0 <_fclose_r+0x104>
    FREELB (rptr, fp);
 8003bdc:	80801117 	ldw	r2,68(r16)
 8003be0:	100b883a 	mov	r5,r2
 8003be4:	e13ffe17 	ldw	r4,-8(fp)
 8003be8:	80040300 	call	8004030 <_free_r>
 8003bec:	80001115 	stw	zero,68(r16)
  __sfp_lock_acquire ();
 8003bf0:	8000aa00 	call	8000aa0 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
 8003bf4:	8000030d 	sth	zero,12(r16)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
 8003bf8:	8000ac00 	call	8000ac0 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
 8003bfc:	e0bffc17 	ldw	r2,-16(fp)
}
 8003c00:	e6ffff04 	addi	sp,fp,-4
 8003c04:	dfc00217 	ldw	ra,8(sp)
 8003c08:	df000117 	ldw	fp,4(sp)
 8003c0c:	dc000017 	ldw	r16,0(sp)
 8003c10:	dec00304 	addi	sp,sp,12
 8003c14:	f800283a 	ret

08003c18 <fclose>:
#ifndef _REENT_ONLY

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
 8003c18:	defffe04 	addi	sp,sp,-8
 8003c1c:	dfc00115 	stw	ra,4(sp)
 8003c20:	df000015 	stw	fp,0(sp)
 8003c24:	d839883a 	mov	fp,sp
 8003c28:	2007883a 	mov	r3,r4
  return _fclose_r(_REENT, fp);
 8003c2c:	d0a00017 	ldw	r2,-32768(gp)
 8003c30:	180b883a 	mov	r5,r3
 8003c34:	1009883a 	mov	r4,r2
 8003c38:	8003aec0 	call	8003aec <_fclose_r>
}
 8003c3c:	e037883a 	mov	sp,fp
 8003c40:	dfc00117 	ldw	ra,4(sp)
 8003c44:	df000017 	ldw	fp,0(sp)
 8003c48:	dec00204 	addi	sp,sp,8
 8003c4c:	f800283a 	ret

08003c50 <__sflush_r>:
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 8003c50:	defff504 	addi	sp,sp,-44
 8003c54:	dfc00a15 	stw	ra,40(sp)
 8003c58:	df000915 	stw	fp,36(sp)
 8003c5c:	dcc00815 	stw	r19,32(sp)
 8003c60:	dc800715 	stw	r18,28(sp)
 8003c64:	dc400615 	stw	r17,24(sp)
 8003c68:	dc000515 	stw	r16,20(sp)
 8003c6c:	df000904 	addi	fp,sp,36
 8003c70:	e13ffb15 	stw	r4,-20(fp)
 8003c74:	2821883a 	mov	r16,r5
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
 8003c78:	8080030b 	ldhu	r2,12(r16)
 8003c7c:	e0bff90d 	sth	r2,-28(fp)
  if ((flags & __SWR) == 0)
 8003c80:	e0bff90b 	ldhu	r2,-28(fp)
 8003c84:	10bfffcc 	andi	r2,r2,65535
 8003c88:	1080020c 	andi	r2,r2,8
 8003c8c:	1000831e 	bne	r2,zero,8003e9c <__sflush_r+0x24c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
 8003c90:	8080030b 	ldhu	r2,12(r16)
 8003c94:	10820014 	ori	r2,r2,2048
 8003c98:	8080030d 	sth	r2,12(r16)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
 8003c9c:	80800117 	ldw	r2,4(r16)
 8003ca0:	00800216 	blt	zero,r2,8003cac <__sflush_r+0x5c>
 8003ca4:	80800f17 	ldw	r2,60(r16)
 8003ca8:	00807a0e 	bge	zero,r2,8003e94 <__sflush_r+0x244>
 8003cac:	80800a17 	ldw	r2,40(r16)
 8003cb0:	10007826 	beq	r2,zero,8003e94 <__sflush_r+0x244>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
 8003cb4:	e0bffb17 	ldw	r2,-20(fp)
 8003cb8:	10800017 	ldw	r2,0(r2)
 8003cbc:	e0bffa15 	stw	r2,-24(fp)
	  ptr->_errno = 0;
 8003cc0:	e0bffb17 	ldw	r2,-20(fp)
 8003cc4:	10000015 	stw	zero,0(r2)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
 8003cc8:	8080030b 	ldhu	r2,12(r16)
 8003ccc:	10bfffcc 	andi	r2,r2,65535
 8003cd0:	1084000c 	andi	r2,r2,4096
 8003cd4:	10000326 	beq	r2,zero,8003ce4 <__sflush_r+0x94>
	    curoff = fp->_offset;
 8003cd8:	80801417 	ldw	r2,80(r16)
 8003cdc:	e0bff715 	stw	r2,-36(fp)
 8003ce0:	00002206 	br	8003d6c <__sflush_r+0x11c>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
 8003ce4:	80800a17 	ldw	r2,40(r16)
 8003ce8:	80c00717 	ldw	r3,28(r16)
 8003cec:	01c00044 	movi	r7,1
 8003cf0:	000d883a 	mov	r6,zero
 8003cf4:	180b883a 	mov	r5,r3
 8003cf8:	e13ffb17 	ldw	r4,-20(fp)
 8003cfc:	103ee83a 	callr	r2
 8003d00:	e0bff715 	stw	r2,-36(fp)
	      if (curoff == -1L && ptr->_errno != 0)
 8003d04:	e0bff717 	ldw	r2,-36(fp)
 8003d08:	10bfffd8 	cmpnei	r2,r2,-1
 8003d0c:	1000171e 	bne	r2,zero,8003d6c <__sflush_r+0x11c>
 8003d10:	e0bffb17 	ldw	r2,-20(fp)
 8003d14:	10800017 	ldw	r2,0(r2)
 8003d18:	10001426 	beq	r2,zero,8003d6c <__sflush_r+0x11c>
		{
		  int result = EOF;
 8003d1c:	00bfffc4 	movi	r2,-1
 8003d20:	e0bff815 	stw	r2,-32(fp)
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 8003d24:	e0bffb17 	ldw	r2,-20(fp)
 8003d28:	10800017 	ldw	r2,0(r2)
 8003d2c:	10800760 	cmpeqi	r2,r2,29
 8003d30:	1000041e 	bne	r2,zero,8003d44 <__sflush_r+0xf4>
 8003d34:	e0bffb17 	ldw	r2,-20(fp)
 8003d38:	10800017 	ldw	r2,0(r2)
 8003d3c:	10800598 	cmpnei	r2,r2,22
 8003d40:	1000051e 	bne	r2,zero,8003d58 <__sflush_r+0x108>
		    {
		      result = 0;
 8003d44:	e03ff815 	stw	zero,-32(fp)
		      ptr->_errno = tmp_errno;
 8003d48:	e0bffb17 	ldw	r2,-20(fp)
 8003d4c:	e0fffa17 	ldw	r3,-24(fp)
 8003d50:	10c00015 	stw	r3,0(r2)
 8003d54:	00000306 	br	8003d64 <__sflush_r+0x114>
		    }
		  else
		    fp->_flags |= __SERR;
 8003d58:	8080030b 	ldhu	r2,12(r16)
 8003d5c:	10801014 	ori	r2,r2,64
 8003d60:	8080030d 	sth	r2,12(r16)
		  return result;
 8003d64:	e0bff817 	ldw	r2,-32(fp)
 8003d68:	00007106 	br	8003f30 <__sflush_r+0x2e0>
		}
            }
          if (fp->_flags & __SRD)
 8003d6c:	8080030b 	ldhu	r2,12(r16)
 8003d70:	10bfffcc 	andi	r2,r2,65535
 8003d74:	1080010c 	andi	r2,r2,4
 8003d78:	10000a26 	beq	r2,zero,8003da4 <__sflush_r+0x154>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
 8003d7c:	80800117 	ldw	r2,4(r16)
 8003d80:	e0fff717 	ldw	r3,-36(fp)
 8003d84:	1885c83a 	sub	r2,r3,r2
 8003d88:	e0bff715 	stw	r2,-36(fp)
              if (HASUB (fp))
 8003d8c:	80800c17 	ldw	r2,48(r16)
 8003d90:	10000426 	beq	r2,zero,8003da4 <__sflush_r+0x154>
                curoff -= fp->_ur;
 8003d94:	80800f17 	ldw	r2,60(r16)
 8003d98:	e0fff717 	ldw	r3,-36(fp)
 8003d9c:	1885c83a 	sub	r2,r3,r2
 8003da0:	e0bff715 	stw	r2,-36(fp)
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
 8003da4:	80800a17 	ldw	r2,40(r16)
 8003da8:	80c00717 	ldw	r3,28(r16)
 8003dac:	000f883a 	mov	r7,zero
 8003db0:	e1bff717 	ldw	r6,-36(fp)
 8003db4:	180b883a 	mov	r5,r3
 8003db8:	e13ffb17 	ldw	r4,-20(fp)
 8003dbc:	103ee83a 	callr	r2
 8003dc0:	e0bff715 	stw	r2,-36(fp)
	  if (curoff != -1 || ptr->_errno == 0
 8003dc4:	e0bff717 	ldw	r2,-36(fp)
 8003dc8:	10bfffd8 	cmpnei	r2,r2,-1
 8003dcc:	10000b1e 	bne	r2,zero,8003dfc <__sflush_r+0x1ac>
 8003dd0:	e0bffb17 	ldw	r2,-20(fp)
 8003dd4:	10800017 	ldw	r2,0(r2)
 8003dd8:	10000826 	beq	r2,zero,8003dfc <__sflush_r+0x1ac>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 8003ddc:	e0bffb17 	ldw	r2,-20(fp)
 8003de0:	10800017 	ldw	r2,0(r2)
 8003de4:	10800760 	cmpeqi	r2,r2,29
 8003de8:	1000041e 	bne	r2,zero,8003dfc <__sflush_r+0x1ac>
 8003dec:	e0bffb17 	ldw	r2,-20(fp)
 8003df0:	10800017 	ldw	r2,0(r2)
 8003df4:	10800598 	cmpnei	r2,r2,22
 8003df8:	1000211e 	bne	r2,zero,8003e80 <__sflush_r+0x230>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
 8003dfc:	80c0030b 	ldhu	r3,12(r16)
 8003e00:	00bdffc4 	movi	r2,-2049
 8003e04:	1884703a 	and	r2,r3,r2
 8003e08:	8080030d 	sth	r2,12(r16)
#endif
	      fp->_r = 0;
 8003e0c:	80000115 	stw	zero,4(r16)
	      fp->_p = fp->_bf._base;
 8003e10:	80800417 	ldw	r2,16(r16)
 8003e14:	80800015 	stw	r2,0(r16)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
 8003e18:	8080030b 	ldhu	r2,12(r16)
 8003e1c:	10bfffcc 	andi	r2,r2,65535
 8003e20:	1084000c 	andi	r2,r2,4096
 8003e24:	10000826 	beq	r2,zero,8003e48 <__sflush_r+0x1f8>
 8003e28:	e0bff717 	ldw	r2,-36(fp)
 8003e2c:	10bfffd8 	cmpnei	r2,r2,-1
 8003e30:	1000031e 	bne	r2,zero,8003e40 <__sflush_r+0x1f0>
 8003e34:	e0bffb17 	ldw	r2,-20(fp)
 8003e38:	10800017 	ldw	r2,0(r2)
 8003e3c:	1000021e 	bne	r2,zero,8003e48 <__sflush_r+0x1f8>
		fp->_offset = curoff;
 8003e40:	e0bff717 	ldw	r2,-36(fp)
 8003e44:	80801415 	stw	r2,80(r16)
	      ptr->_errno = tmp_errno;
 8003e48:	e0bffb17 	ldw	r2,-20(fp)
 8003e4c:	e0fffa17 	ldw	r3,-24(fp)
 8003e50:	10c00015 	stw	r3,0(r2)
	      if (HASUB (fp))
 8003e54:	80800c17 	ldw	r2,48(r16)
 8003e58:	10000e26 	beq	r2,zero,8003e94 <__sflush_r+0x244>
		FREEUB (ptr, fp);
 8003e5c:	80c00c17 	ldw	r3,48(r16)
 8003e60:	80801004 	addi	r2,r16,64
 8003e64:	18800426 	beq	r3,r2,8003e78 <__sflush_r+0x228>
 8003e68:	80800c17 	ldw	r2,48(r16)
 8003e6c:	100b883a 	mov	r5,r2
 8003e70:	e13ffb17 	ldw	r4,-20(fp)
 8003e74:	80040300 	call	8004030 <_free_r>
 8003e78:	80000c15 	stw	zero,48(r16)
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
 8003e7c:	00000506 	br	8003e94 <__sflush_r+0x244>
		FREEUB (ptr, fp);
	    }
	  else
	    {
	      fp->_flags |= __SERR;
 8003e80:	8080030b 	ldhu	r2,12(r16)
 8003e84:	10801014 	ori	r2,r2,64
 8003e88:	8080030d 	sth	r2,12(r16)
	      return EOF;
 8003e8c:	00bfffc4 	movi	r2,-1
 8003e90:	00002706 	br	8003f30 <__sflush_r+0x2e0>
	    }
	}
      return 0;
 8003e94:	0005883a 	mov	r2,zero
 8003e98:	00002506 	br	8003f30 <__sflush_r+0x2e0>
    }
  if ((p = fp->_bf._base) == NULL)
 8003e9c:	84400417 	ldw	r17,16(r16)
 8003ea0:	8800021e 	bne	r17,zero,8003eac <__sflush_r+0x25c>
    {
      /* Nothing to flush.  */
      return 0;
 8003ea4:	0005883a 	mov	r2,zero
 8003ea8:	00002106 	br	8003f30 <__sflush_r+0x2e0>
    }
  n = fp->_p - p;		/* write this much */
 8003eac:	80800017 	ldw	r2,0(r16)
 8003eb0:	1007883a 	mov	r3,r2
 8003eb4:	8805883a 	mov	r2,r17
 8003eb8:	18a5c83a 	sub	r18,r3,r2
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
 8003ebc:	84400015 	stw	r17,0(r16)
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
 8003ec0:	e0bff90b 	ldhu	r2,-28(fp)
 8003ec4:	10bfffcc 	andi	r2,r2,65535
 8003ec8:	108000cc 	andi	r2,r2,3
 8003ecc:	1000021e 	bne	r2,zero,8003ed8 <__sflush_r+0x288>
 8003ed0:	80800517 	ldw	r2,20(r16)
 8003ed4:	00000106 	br	8003edc <__sflush_r+0x28c>
 8003ed8:	0005883a 	mov	r2,zero
 8003edc:	80800215 	stw	r2,8(r16)

  while (n > 0)
 8003ee0:	00001106 	br	8003f28 <__sflush_r+0x2d8>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
 8003ee4:	80800917 	ldw	r2,36(r16)
 8003ee8:	80c00717 	ldw	r3,28(r16)
 8003eec:	900f883a 	mov	r7,r18
 8003ef0:	880d883a 	mov	r6,r17
 8003ef4:	180b883a 	mov	r5,r3
 8003ef8:	e13ffb17 	ldw	r4,-20(fp)
 8003efc:	103ee83a 	callr	r2
 8003f00:	1027883a 	mov	r19,r2
      if (t <= 0)
 8003f04:	04c00516 	blt	zero,r19,8003f1c <__sflush_r+0x2cc>
	{
          fp->_flags |= __SERR;
 8003f08:	8080030b 	ldhu	r2,12(r16)
 8003f0c:	10801014 	ori	r2,r2,64
 8003f10:	8080030d 	sth	r2,12(r16)
          return EOF;
 8003f14:	00bfffc4 	movi	r2,-1
 8003f18:	00000506 	br	8003f30 <__sflush_r+0x2e0>
	}
      p += t;
 8003f1c:	9805883a 	mov	r2,r19
 8003f20:	88a3883a 	add	r17,r17,r2
      n -= t;
 8003f24:	94e5c83a 	sub	r18,r18,r19
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
 8003f28:	04bfee16 	blt	zero,r18,8003ee4 <__sflush_r+0x294>
          return EOF;
	}
      p += t;
      n -= t;
    }
  return 0;
 8003f2c:	0005883a 	mov	r2,zero
}
 8003f30:	e6fffc04 	addi	sp,fp,-16
 8003f34:	dfc00517 	ldw	ra,20(sp)
 8003f38:	df000417 	ldw	fp,16(sp)
 8003f3c:	dcc00317 	ldw	r19,12(sp)
 8003f40:	dc800217 	ldw	r18,8(sp)
 8003f44:	dc400117 	ldw	r17,4(sp)
 8003f48:	dc000017 	ldw	r16,0(sp)
 8003f4c:	dec00604 	addi	sp,sp,24
 8003f50:	f800283a 	ret

08003f54 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 8003f54:	defffa04 	addi	sp,sp,-24
 8003f58:	dfc00515 	stw	ra,20(sp)
 8003f5c:	df000415 	stw	fp,16(sp)
 8003f60:	dc000315 	stw	r16,12(sp)
 8003f64:	df000404 	addi	fp,sp,16
 8003f68:	e13ffe15 	stw	r4,-8(fp)
 8003f6c:	2821883a 	mov	r16,r5
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
 8003f70:	e0bffe17 	ldw	r2,-8(fp)
 8003f74:	e0bffc15 	stw	r2,-16(fp)
 8003f78:	e0bffc17 	ldw	r2,-16(fp)
 8003f7c:	10000526 	beq	r2,zero,8003f94 <_fflush_r+0x40>
 8003f80:	e0bffc17 	ldw	r2,-16(fp)
 8003f84:	10800e17 	ldw	r2,56(r2)
 8003f88:	1000021e 	bne	r2,zero,8003f94 <_fflush_r+0x40>
 8003f8c:	e13ffc17 	ldw	r4,-16(fp)
 8003f90:	80009c80 	call	80009c8 <__sinit>

  if (!fp->_flags)
 8003f94:	8080030b 	ldhu	r2,12(r16)
 8003f98:	10bfffcc 	andi	r2,r2,65535
 8003f9c:	10a0001c 	xori	r2,r2,32768
 8003fa0:	10a00004 	addi	r2,r2,-32768
 8003fa4:	1000021e 	bne	r2,zero,8003fb0 <_fflush_r+0x5c>
    return 0;
 8003fa8:	0005883a 	mov	r2,zero
 8003fac:	00000506 	br	8003fc4 <_fflush_r+0x70>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
 8003fb0:	800b883a 	mov	r5,r16
 8003fb4:	e13ffe17 	ldw	r4,-8(fp)
 8003fb8:	8003c500 	call	8003c50 <__sflush_r>
 8003fbc:	e0bffd15 	stw	r2,-12(fp)
  _newlib_flockfile_end (fp);
  return ret;
 8003fc0:	e0bffd17 	ldw	r2,-12(fp)
}
 8003fc4:	e6ffff04 	addi	sp,fp,-4
 8003fc8:	dfc00217 	ldw	ra,8(sp)
 8003fcc:	df000117 	ldw	fp,4(sp)
 8003fd0:	dc000017 	ldw	r16,0(sp)
 8003fd4:	dec00304 	addi	sp,sp,12
 8003fd8:	f800283a 	ret

08003fdc <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
 8003fdc:	defffe04 	addi	sp,sp,-8
 8003fe0:	dfc00115 	stw	ra,4(sp)
 8003fe4:	df000015 	stw	fp,0(sp)
 8003fe8:	d839883a 	mov	fp,sp
 8003fec:	2005883a 	mov	r2,r4
  if (fp == NULL)
 8003ff0:	1000061e 	bne	r2,zero,800400c <fflush+0x30>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
 8003ff4:	d0a00117 	ldw	r2,-32764(gp)
 8003ff8:	01420034 	movhi	r5,2048
 8003ffc:	294fd504 	addi	r5,r5,16212
 8004000:	1009883a 	mov	r4,r2
 8004004:	800129c0 	call	800129c <_fwalk_reent>
 8004008:	00000406 	br	800401c <fflush+0x40>

  return _fflush_r (_REENT, fp);
 800400c:	d0e00017 	ldw	r3,-32768(gp)
 8004010:	100b883a 	mov	r5,r2
 8004014:	1809883a 	mov	r4,r3
 8004018:	8003f540 	call	8003f54 <_fflush_r>
}
 800401c:	e037883a 	mov	sp,fp
 8004020:	dfc00117 	ldw	ra,4(sp)
 8004024:	df000017 	ldw	fp,0(sp)
 8004028:	dec00204 	addi	sp,sp,8
 800402c:	f800283a 	ret

08004030 <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
 8004030:	defff204 	addi	sp,sp,-56
 8004034:	dfc00d15 	stw	ra,52(sp)
 8004038:	df000c15 	stw	fp,48(sp)
 800403c:	df000c04 	addi	fp,sp,48
 8004040:	e13ffe15 	stw	r4,-8(fp)
 8004044:	e17fff15 	stw	r5,-4(fp)
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
 8004048:	e0bfff17 	ldw	r2,-4(fp)
 800404c:	10014a26 	beq	r2,zero,8004578 <_free_r+0x548>
    return;

  MALLOC_LOCK;
 8004050:	e13ffe17 	ldw	r4,-8(fp)
 8004054:	80052440 	call	8005244 <__malloc_lock>

  p = mem2chunk(mem);
 8004058:	e0bfff17 	ldw	r2,-4(fp)
 800405c:	10bffe04 	addi	r2,r2,-8
 8004060:	e0bff415 	stw	r2,-48(fp)
  hd = p->size;
 8004064:	e0bff417 	ldw	r2,-48(fp)
 8004068:	10800117 	ldw	r2,4(r2)
 800406c:	e0bff915 	stw	r2,-28(fp)
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
 8004070:	e0fff917 	ldw	r3,-28(fp)
 8004074:	00bfff84 	movi	r2,-2
 8004078:	1884703a 	and	r2,r3,r2
 800407c:	e0bff515 	stw	r2,-44(fp)
  next = chunk_at_offset(p, sz);
 8004080:	e0fff417 	ldw	r3,-48(fp)
 8004084:	e0bff517 	ldw	r2,-44(fp)
 8004088:	1885883a 	add	r2,r3,r2
 800408c:	e0bffa15 	stw	r2,-24(fp)
  nextsz = chunksize(next);
 8004090:	e0bffa17 	ldw	r2,-24(fp)
 8004094:	10c00117 	ldw	r3,4(r2)
 8004098:	00bfff04 	movi	r2,-4
 800409c:	1884703a 	and	r2,r3,r2
 80040a0:	e0bffb15 	stw	r2,-20(fp)
  
  if (next == top)                            /* merge with top */
 80040a4:	00820134 	movhi	r2,2052
 80040a8:	1083df04 	addi	r2,r2,3964
 80040ac:	10c00217 	ldw	r3,8(r2)
 80040b0:	e0bffa17 	ldw	r2,-24(fp)
 80040b4:	1880311e 	bne	r3,r2,800417c <_free_r+0x14c>
  {
    sz += nextsz;
 80040b8:	e0fff517 	ldw	r3,-44(fp)
 80040bc:	e0bffb17 	ldw	r2,-20(fp)
 80040c0:	1885883a 	add	r2,r3,r2
 80040c4:	e0bff515 	stw	r2,-44(fp)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
 80040c8:	e0bff917 	ldw	r2,-28(fp)
 80040cc:	1080004c 	andi	r2,r2,1
 80040d0:	1000181e 	bne	r2,zero,8004134 <_free_r+0x104>
    {
      prevsz = p->prev_size;
 80040d4:	e0bff417 	ldw	r2,-48(fp)
 80040d8:	10800017 	ldw	r2,0(r2)
 80040dc:	e0bffc15 	stw	r2,-16(fp)
      p = chunk_at_offset(p, -prevsz);
 80040e0:	e0bffc17 	ldw	r2,-16(fp)
 80040e4:	0085c83a 	sub	r2,zero,r2
 80040e8:	e0fff417 	ldw	r3,-48(fp)
 80040ec:	1885883a 	add	r2,r3,r2
 80040f0:	e0bff415 	stw	r2,-48(fp)
      sz += prevsz;
 80040f4:	e0fff517 	ldw	r3,-44(fp)
 80040f8:	e0bffc17 	ldw	r2,-16(fp)
 80040fc:	1885883a 	add	r2,r3,r2
 8004100:	e0bff515 	stw	r2,-44(fp)
      unlink(p, bck, fwd);
 8004104:	e0bff417 	ldw	r2,-48(fp)
 8004108:	10800317 	ldw	r2,12(r2)
 800410c:	e0bff615 	stw	r2,-40(fp)
 8004110:	e0bff417 	ldw	r2,-48(fp)
 8004114:	10800217 	ldw	r2,8(r2)
 8004118:	e0bff715 	stw	r2,-36(fp)
 800411c:	e0bff717 	ldw	r2,-36(fp)
 8004120:	e0fff617 	ldw	r3,-40(fp)
 8004124:	10c00315 	stw	r3,12(r2)
 8004128:	e0bff617 	ldw	r2,-40(fp)
 800412c:	e0fff717 	ldw	r3,-36(fp)
 8004130:	10c00215 	stw	r3,8(r2)
    }

    set_head(p, sz | PREV_INUSE);
 8004134:	e0bff517 	ldw	r2,-44(fp)
 8004138:	10c00054 	ori	r3,r2,1
 800413c:	e0bff417 	ldw	r2,-48(fp)
 8004140:	10c00115 	stw	r3,4(r2)
    top = p;
 8004144:	00820134 	movhi	r2,2052
 8004148:	1083df04 	addi	r2,r2,3964
 800414c:	e0fff417 	ldw	r3,-48(fp)
 8004150:	10c00215 	stw	r3,8(r2)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
 8004154:	d0a00217 	ldw	r2,-32760(gp)
 8004158:	e0fff517 	ldw	r3,-44(fp)
 800415c:	18800436 	bltu	r3,r2,8004170 <_free_r+0x140>
      malloc_trim(RCALL top_pad); 
 8004160:	d0a6e317 	ldw	r2,-25716(gp)
 8004164:	100b883a 	mov	r5,r2
 8004168:	e13ffe17 	ldw	r4,-8(fp)
 800416c:	80045900 	call	8004590 <_malloc_trim_r>
    MALLOC_UNLOCK;
 8004170:	e13ffe17 	ldw	r4,-8(fp)
 8004174:	80052680 	call	8005268 <__malloc_unlock>
    return;
 8004178:	00010006 	br	800457c <_free_r+0x54c>
  }

  set_head(next, nextsz);                    /* clear inuse bit */
 800417c:	e0bffa17 	ldw	r2,-24(fp)
 8004180:	e0fffb17 	ldw	r3,-20(fp)
 8004184:	10c00115 	stw	r3,4(r2)

  islr = 0;
 8004188:	e03ff815 	stw	zero,-32(fp)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
 800418c:	e0bff917 	ldw	r2,-28(fp)
 8004190:	1080004c 	andi	r2,r2,1
 8004194:	1000201e 	bne	r2,zero,8004218 <_free_r+0x1e8>
  {
    prevsz = p->prev_size;
 8004198:	e0bff417 	ldw	r2,-48(fp)
 800419c:	10800017 	ldw	r2,0(r2)
 80041a0:	e0bffc15 	stw	r2,-16(fp)
    p = chunk_at_offset(p, -prevsz);
 80041a4:	e0bffc17 	ldw	r2,-16(fp)
 80041a8:	0085c83a 	sub	r2,zero,r2
 80041ac:	e0fff417 	ldw	r3,-48(fp)
 80041b0:	1885883a 	add	r2,r3,r2
 80041b4:	e0bff415 	stw	r2,-48(fp)
    sz += prevsz;
 80041b8:	e0fff517 	ldw	r3,-44(fp)
 80041bc:	e0bffc17 	ldw	r2,-16(fp)
 80041c0:	1885883a 	add	r2,r3,r2
 80041c4:	e0bff515 	stw	r2,-44(fp)
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
 80041c8:	e0bff417 	ldw	r2,-48(fp)
 80041cc:	10c00217 	ldw	r3,8(r2)
 80041d0:	00820134 	movhi	r2,2052
 80041d4:	1083e104 	addi	r2,r2,3972
 80041d8:	1880031e 	bne	r3,r2,80041e8 <_free_r+0x1b8>
      islr = 1;
 80041dc:	00800044 	movi	r2,1
 80041e0:	e0bff815 	stw	r2,-32(fp)
 80041e4:	00000c06 	br	8004218 <_free_r+0x1e8>
    else
      unlink(p, bck, fwd);
 80041e8:	e0bff417 	ldw	r2,-48(fp)
 80041ec:	10800317 	ldw	r2,12(r2)
 80041f0:	e0bff615 	stw	r2,-40(fp)
 80041f4:	e0bff417 	ldw	r2,-48(fp)
 80041f8:	10800217 	ldw	r2,8(r2)
 80041fc:	e0bff715 	stw	r2,-36(fp)
 8004200:	e0bff717 	ldw	r2,-36(fp)
 8004204:	e0fff617 	ldw	r3,-40(fp)
 8004208:	10c00315 	stw	r3,12(r2)
 800420c:	e0bff617 	ldw	r2,-40(fp)
 8004210:	e0fff717 	ldw	r3,-36(fp)
 8004214:	10c00215 	stw	r3,8(r2)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
 8004218:	e0fffa17 	ldw	r3,-24(fp)
 800421c:	e0bffb17 	ldw	r2,-20(fp)
 8004220:	1885883a 	add	r2,r3,r2
 8004224:	10800117 	ldw	r2,4(r2)
 8004228:	1080004c 	andi	r2,r2,1
 800422c:	10002a1e 	bne	r2,zero,80042d8 <_free_r+0x2a8>
  {
    sz += nextsz;
 8004230:	e0fff517 	ldw	r3,-44(fp)
 8004234:	e0bffb17 	ldw	r2,-20(fp)
 8004238:	1885883a 	add	r2,r3,r2
 800423c:	e0bff515 	stw	r2,-44(fp)
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
 8004240:	e0bff817 	ldw	r2,-32(fp)
 8004244:	1000181e 	bne	r2,zero,80042a8 <_free_r+0x278>
 8004248:	e0bffa17 	ldw	r2,-24(fp)
 800424c:	10c00217 	ldw	r3,8(r2)
 8004250:	00820134 	movhi	r2,2052
 8004254:	1083e104 	addi	r2,r2,3972
 8004258:	1880131e 	bne	r3,r2,80042a8 <_free_r+0x278>
    {
      islr = 1;
 800425c:	00800044 	movi	r2,1
 8004260:	e0bff815 	stw	r2,-32(fp)
      link_last_remainder(p);   
 8004264:	00c20134 	movhi	r3,2052
 8004268:	18c3e104 	addi	r3,r3,3972
 800426c:	00820134 	movhi	r2,2052
 8004270:	1083e104 	addi	r2,r2,3972
 8004274:	e13ff417 	ldw	r4,-48(fp)
 8004278:	11000315 	stw	r4,12(r2)
 800427c:	10800317 	ldw	r2,12(r2)
 8004280:	18800215 	stw	r2,8(r3)
 8004284:	00820134 	movhi	r2,2052
 8004288:	1083e104 	addi	r2,r2,3972
 800428c:	e0fff417 	ldw	r3,-48(fp)
 8004290:	18800315 	stw	r2,12(r3)
 8004294:	e0bff417 	ldw	r2,-48(fp)
 8004298:	10c00317 	ldw	r3,12(r2)
 800429c:	e0bff417 	ldw	r2,-48(fp)
 80042a0:	10c00215 	stw	r3,8(r2)
 80042a4:	00000c06 	br	80042d8 <_free_r+0x2a8>
    }
    else
      unlink(next, bck, fwd);
 80042a8:	e0bffa17 	ldw	r2,-24(fp)
 80042ac:	10800317 	ldw	r2,12(r2)
 80042b0:	e0bff615 	stw	r2,-40(fp)
 80042b4:	e0bffa17 	ldw	r2,-24(fp)
 80042b8:	10800217 	ldw	r2,8(r2)
 80042bc:	e0bff715 	stw	r2,-36(fp)
 80042c0:	e0bff717 	ldw	r2,-36(fp)
 80042c4:	e0fff617 	ldw	r3,-40(fp)
 80042c8:	10c00315 	stw	r3,12(r2)
 80042cc:	e0bff617 	ldw	r2,-40(fp)
 80042d0:	e0fff717 	ldw	r3,-36(fp)
 80042d4:	10c00215 	stw	r3,8(r2)
  }


  set_head(p, sz | PREV_INUSE);
 80042d8:	e0bff517 	ldw	r2,-44(fp)
 80042dc:	10c00054 	ori	r3,r2,1
 80042e0:	e0bff417 	ldw	r2,-48(fp)
 80042e4:	10c00115 	stw	r3,4(r2)
  set_foot(p, sz);
 80042e8:	e0fff417 	ldw	r3,-48(fp)
 80042ec:	e0bff517 	ldw	r2,-44(fp)
 80042f0:	1885883a 	add	r2,r3,r2
 80042f4:	e0fff517 	ldw	r3,-44(fp)
 80042f8:	10c00015 	stw	r3,0(r2)
  if (!islr)
 80042fc:	e0bff817 	ldw	r2,-32(fp)
 8004300:	10009a1e 	bne	r2,zero,800456c <_free_r+0x53c>
    frontlink(p, sz, idx, bck, fwd);  
 8004304:	e0bff517 	ldw	r2,-44(fp)
 8004308:	10808028 	cmpgeui	r2,r2,512
 800430c:	10002c1e 	bne	r2,zero,80043c0 <_free_r+0x390>
 8004310:	e0bff517 	ldw	r2,-44(fp)
 8004314:	1004d0fa 	srli	r2,r2,3
 8004318:	e0bffd15 	stw	r2,-12(fp)
 800431c:	00c20134 	movhi	r3,2052
 8004320:	18c3df04 	addi	r3,r3,3964
 8004324:	00820134 	movhi	r2,2052
 8004328:	1083df04 	addi	r2,r2,3964
 800432c:	11000117 	ldw	r4,4(r2)
 8004330:	e0bffd17 	ldw	r2,-12(fp)
 8004334:	1000010e 	bge	r2,zero,800433c <_free_r+0x30c>
 8004338:	108000c4 	addi	r2,r2,3
 800433c:	1005d0ba 	srai	r2,r2,2
 8004340:	100b883a 	mov	r5,r2
 8004344:	00800044 	movi	r2,1
 8004348:	1144983a 	sll	r2,r2,r5
 800434c:	2084b03a 	or	r2,r4,r2
 8004350:	18800115 	stw	r2,4(r3)
 8004354:	e0bffd17 	ldw	r2,-12(fp)
 8004358:	10800044 	addi	r2,r2,1
 800435c:	1085883a 	add	r2,r2,r2
 8004360:	1085883a 	add	r2,r2,r2
 8004364:	1087883a 	add	r3,r2,r2
 8004368:	00820134 	movhi	r2,2052
 800436c:	1083df04 	addi	r2,r2,3964
 8004370:	1885883a 	add	r2,r3,r2
 8004374:	10bffe04 	addi	r2,r2,-8
 8004378:	e0bff615 	stw	r2,-40(fp)
 800437c:	e0bff617 	ldw	r2,-40(fp)
 8004380:	10800217 	ldw	r2,8(r2)
 8004384:	e0bff715 	stw	r2,-36(fp)
 8004388:	e0bff417 	ldw	r2,-48(fp)
 800438c:	e0fff617 	ldw	r3,-40(fp)
 8004390:	10c00315 	stw	r3,12(r2)
 8004394:	e0bff417 	ldw	r2,-48(fp)
 8004398:	e0fff717 	ldw	r3,-36(fp)
 800439c:	10c00215 	stw	r3,8(r2)
 80043a0:	e0bff617 	ldw	r2,-40(fp)
 80043a4:	e0fff417 	ldw	r3,-48(fp)
 80043a8:	10c00215 	stw	r3,8(r2)
 80043ac:	e0bff617 	ldw	r2,-40(fp)
 80043b0:	10c00217 	ldw	r3,8(r2)
 80043b4:	e0bff717 	ldw	r2,-36(fp)
 80043b8:	10c00315 	stw	r3,12(r2)
 80043bc:	00006b06 	br	800456c <_free_r+0x53c>
 80043c0:	e0bff517 	ldw	r2,-44(fp)
 80043c4:	1004d27a 	srli	r2,r2,9
 80043c8:	1000031e 	bne	r2,zero,80043d8 <_free_r+0x3a8>
 80043cc:	e0bff517 	ldw	r2,-44(fp)
 80043d0:	1004d0fa 	srli	r2,r2,3
 80043d4:	00002906 	br	800447c <_free_r+0x44c>
 80043d8:	e0bff517 	ldw	r2,-44(fp)
 80043dc:	1004d27a 	srli	r2,r2,9
 80043e0:	10800168 	cmpgeui	r2,r2,5
 80043e4:	1000041e 	bne	r2,zero,80043f8 <_free_r+0x3c8>
 80043e8:	e0bff517 	ldw	r2,-44(fp)
 80043ec:	1004d1ba 	srli	r2,r2,6
 80043f0:	10800e04 	addi	r2,r2,56
 80043f4:	00002106 	br	800447c <_free_r+0x44c>
 80043f8:	e0bff517 	ldw	r2,-44(fp)
 80043fc:	1004d27a 	srli	r2,r2,9
 8004400:	10800568 	cmpgeui	r2,r2,21
 8004404:	1000041e 	bne	r2,zero,8004418 <_free_r+0x3e8>
 8004408:	e0bff517 	ldw	r2,-44(fp)
 800440c:	1004d27a 	srli	r2,r2,9
 8004410:	108016c4 	addi	r2,r2,91
 8004414:	00001906 	br	800447c <_free_r+0x44c>
 8004418:	e0bff517 	ldw	r2,-44(fp)
 800441c:	1004d27a 	srli	r2,r2,9
 8004420:	10801568 	cmpgeui	r2,r2,85
 8004424:	1000041e 	bne	r2,zero,8004438 <_free_r+0x408>
 8004428:	e0bff517 	ldw	r2,-44(fp)
 800442c:	1004d33a 	srli	r2,r2,12
 8004430:	10801b84 	addi	r2,r2,110
 8004434:	00001106 	br	800447c <_free_r+0x44c>
 8004438:	e0bff517 	ldw	r2,-44(fp)
 800443c:	1004d27a 	srli	r2,r2,9
 8004440:	10805568 	cmpgeui	r2,r2,341
 8004444:	1000041e 	bne	r2,zero,8004458 <_free_r+0x428>
 8004448:	e0bff517 	ldw	r2,-44(fp)
 800444c:	1004d3fa 	srli	r2,r2,15
 8004450:	10801dc4 	addi	r2,r2,119
 8004454:	00000906 	br	800447c <_free_r+0x44c>
 8004458:	e0bff517 	ldw	r2,-44(fp)
 800445c:	1004d27a 	srli	r2,r2,9
 8004460:	10815568 	cmpgeui	r2,r2,1365
 8004464:	1000041e 	bne	r2,zero,8004478 <_free_r+0x448>
 8004468:	e0bff517 	ldw	r2,-44(fp)
 800446c:	1004d4ba 	srli	r2,r2,18
 8004470:	10801f04 	addi	r2,r2,124
 8004474:	00000106 	br	800447c <_free_r+0x44c>
 8004478:	00801f84 	movi	r2,126
 800447c:	e0bffd15 	stw	r2,-12(fp)
 8004480:	e0bffd17 	ldw	r2,-12(fp)
 8004484:	10800044 	addi	r2,r2,1
 8004488:	1085883a 	add	r2,r2,r2
 800448c:	1085883a 	add	r2,r2,r2
 8004490:	1087883a 	add	r3,r2,r2
 8004494:	00820134 	movhi	r2,2052
 8004498:	1083df04 	addi	r2,r2,3964
 800449c:	1885883a 	add	r2,r3,r2
 80044a0:	10bffe04 	addi	r2,r2,-8
 80044a4:	e0bff615 	stw	r2,-40(fp)
 80044a8:	e0bff617 	ldw	r2,-40(fp)
 80044ac:	10800217 	ldw	r2,8(r2)
 80044b0:	e0bff715 	stw	r2,-36(fp)
 80044b4:	e0fff717 	ldw	r3,-36(fp)
 80044b8:	e0bff617 	ldw	r2,-40(fp)
 80044bc:	1880121e 	bne	r3,r2,8004508 <_free_r+0x4d8>
 80044c0:	00c20134 	movhi	r3,2052
 80044c4:	18c3df04 	addi	r3,r3,3964
 80044c8:	00820134 	movhi	r2,2052
 80044cc:	1083df04 	addi	r2,r2,3964
 80044d0:	11000117 	ldw	r4,4(r2)
 80044d4:	e0bffd17 	ldw	r2,-12(fp)
 80044d8:	1000010e 	bge	r2,zero,80044e0 <_free_r+0x4b0>
 80044dc:	108000c4 	addi	r2,r2,3
 80044e0:	1005d0ba 	srai	r2,r2,2
 80044e4:	100b883a 	mov	r5,r2
 80044e8:	00800044 	movi	r2,1
 80044ec:	1144983a 	sll	r2,r2,r5
 80044f0:	2084b03a 	or	r2,r4,r2
 80044f4:	18800115 	stw	r2,4(r3)
 80044f8:	00000f06 	br	8004538 <_free_r+0x508>
 80044fc:	e0bff717 	ldw	r2,-36(fp)
 8004500:	10800217 	ldw	r2,8(r2)
 8004504:	e0bff715 	stw	r2,-36(fp)
 8004508:	e0fff717 	ldw	r3,-36(fp)
 800450c:	e0bff617 	ldw	r2,-40(fp)
 8004510:	18800626 	beq	r3,r2,800452c <_free_r+0x4fc>
 8004514:	e0bff717 	ldw	r2,-36(fp)
 8004518:	10c00117 	ldw	r3,4(r2)
 800451c:	00bfff04 	movi	r2,-4
 8004520:	1884703a 	and	r2,r3,r2
 8004524:	e0fff517 	ldw	r3,-44(fp)
 8004528:	18bff436 	bltu	r3,r2,80044fc <_free_r+0x4cc>
 800452c:	e0bff717 	ldw	r2,-36(fp)
 8004530:	10800317 	ldw	r2,12(r2)
 8004534:	e0bff615 	stw	r2,-40(fp)
 8004538:	e0bff417 	ldw	r2,-48(fp)
 800453c:	e0fff617 	ldw	r3,-40(fp)
 8004540:	10c00315 	stw	r3,12(r2)
 8004544:	e0bff417 	ldw	r2,-48(fp)
 8004548:	e0fff717 	ldw	r3,-36(fp)
 800454c:	10c00215 	stw	r3,8(r2)
 8004550:	e0bff617 	ldw	r2,-40(fp)
 8004554:	e0fff417 	ldw	r3,-48(fp)
 8004558:	10c00215 	stw	r3,8(r2)
 800455c:	e0bff617 	ldw	r2,-40(fp)
 8004560:	10c00217 	ldw	r3,8(r2)
 8004564:	e0bff717 	ldw	r2,-36(fp)
 8004568:	10c00315 	stw	r3,12(r2)

  MALLOC_UNLOCK;
 800456c:	e13ffe17 	ldw	r4,-8(fp)
 8004570:	80052680 	call	8005268 <__malloc_unlock>
 8004574:	00000106 	br	800457c <_free_r+0x54c>
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;
 8004578:	0001883a 	nop
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
 800457c:	e037883a 	mov	sp,fp
 8004580:	dfc00117 	ldw	ra,4(sp)
 8004584:	df000017 	ldw	fp,0(sp)
 8004588:	dec00204 	addi	sp,sp,8
 800458c:	f800283a 	ret

08004590 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
 8004590:	defff704 	addi	sp,sp,-36
 8004594:	dfc00815 	stw	ra,32(sp)
 8004598:	df000715 	stw	fp,28(sp)
 800459c:	df000704 	addi	fp,sp,28
 80045a0:	e13ffe15 	stw	r4,-8(fp)
 80045a4:	e17fff15 	stw	r5,-4(fp)
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
 80045a8:	00840004 	movi	r2,4096
 80045ac:	e0bff915 	stw	r2,-28(fp)

  MALLOC_LOCK;
 80045b0:	e13ffe17 	ldw	r4,-8(fp)
 80045b4:	80052440 	call	8005244 <__malloc_lock>

  top_size = chunksize(top);
 80045b8:	00820134 	movhi	r2,2052
 80045bc:	1083df04 	addi	r2,r2,3964
 80045c0:	10800217 	ldw	r2,8(r2)
 80045c4:	10800117 	ldw	r2,4(r2)
 80045c8:	1007883a 	mov	r3,r2
 80045cc:	00bfff04 	movi	r2,-4
 80045d0:	1884703a 	and	r2,r3,r2
 80045d4:	e0bffa15 	stw	r2,-24(fp)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
 80045d8:	e0fffa17 	ldw	r3,-24(fp)
 80045dc:	e0bfff17 	ldw	r2,-4(fp)
 80045e0:	1887c83a 	sub	r3,r3,r2
 80045e4:	e0bff917 	ldw	r2,-28(fp)
 80045e8:	1885883a 	add	r2,r3,r2
 80045ec:	10bffbc4 	addi	r2,r2,-17
 80045f0:	e17ff917 	ldw	r5,-28(fp)
 80045f4:	1009883a 	mov	r4,r2
 80045f8:	8004c280 	call	8004c28 <__udivsi3>
 80045fc:	10ffffc4 	addi	r3,r2,-1
 8004600:	e0bff917 	ldw	r2,-28(fp)
 8004604:	1885383a 	mul	r2,r3,r2
 8004608:	e0bffb15 	stw	r2,-20(fp)

  if (extra < (long)pagesz)  /* Not enough memory to release */
 800460c:	e0bff917 	ldw	r2,-28(fp)
 8004610:	e0fffb17 	ldw	r3,-20(fp)
 8004614:	1880040e 	bge	r3,r2,8004628 <_malloc_trim_r+0x98>
  {
    MALLOC_UNLOCK;
 8004618:	e13ffe17 	ldw	r4,-8(fp)
 800461c:	80052680 	call	8005268 <__malloc_unlock>
    return 0;
 8004620:	0005883a 	mov	r2,zero
 8004624:	00004806 	br	8004748 <_malloc_trim_r+0x1b8>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
 8004628:	000b883a 	mov	r5,zero
 800462c:	e13ffe17 	ldw	r4,-8(fp)
 8004630:	80035a80 	call	80035a8 <_sbrk_r>
 8004634:	e0bffc15 	stw	r2,-16(fp)
    if (current_brk != (char*)(top) + top_size)
 8004638:	00820134 	movhi	r2,2052
 800463c:	1083df04 	addi	r2,r2,3964
 8004640:	10c00217 	ldw	r3,8(r2)
 8004644:	e0bffa17 	ldw	r2,-24(fp)
 8004648:	1887883a 	add	r3,r3,r2
 800464c:	e0bffc17 	ldw	r2,-16(fp)
 8004650:	18800426 	beq	r3,r2,8004664 <_malloc_trim_r+0xd4>
    {
      MALLOC_UNLOCK;
 8004654:	e13ffe17 	ldw	r4,-8(fp)
 8004658:	80052680 	call	8005268 <__malloc_unlock>
      return 0;     /* Apparently we don't own memory; must fail */
 800465c:	0005883a 	mov	r2,zero
 8004660:	00003906 	br	8004748 <_malloc_trim_r+0x1b8>
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
 8004664:	e0bffb17 	ldw	r2,-20(fp)
 8004668:	0085c83a 	sub	r2,zero,r2
 800466c:	100b883a 	mov	r5,r2
 8004670:	e13ffe17 	ldw	r4,-8(fp)
 8004674:	80035a80 	call	80035a8 <_sbrk_r>
 8004678:	e0bffd15 	stw	r2,-12(fp)
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
 800467c:	e0bffd17 	ldw	r2,-12(fp)
 8004680:	10bfffd8 	cmpnei	r2,r2,-1
 8004684:	10001d1e 	bne	r2,zero,80046fc <_malloc_trim_r+0x16c>
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
 8004688:	000b883a 	mov	r5,zero
 800468c:	e13ffe17 	ldw	r4,-8(fp)
 8004690:	80035a80 	call	80035a8 <_sbrk_r>
 8004694:	e0bffc15 	stw	r2,-16(fp)
        top_size = current_brk - (char*)top;
 8004698:	e0fffc17 	ldw	r3,-16(fp)
 800469c:	00820134 	movhi	r2,2052
 80046a0:	1083df04 	addi	r2,r2,3964
 80046a4:	10800217 	ldw	r2,8(r2)
 80046a8:	1885c83a 	sub	r2,r3,r2
 80046ac:	e0bffa15 	stw	r2,-24(fp)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
 80046b0:	e0bffa17 	ldw	r2,-24(fp)
 80046b4:	10800410 	cmplti	r2,r2,16
 80046b8:	10000c1e 	bne	r2,zero,80046ec <_malloc_trim_r+0x15c>
        {
          sbrked_mem = current_brk - sbrk_base;
 80046bc:	e0bffc17 	ldw	r2,-16(fp)
 80046c0:	d0e00317 	ldw	r3,-32756(gp)
 80046c4:	10c7c83a 	sub	r3,r2,r3
 80046c8:	00820134 	movhi	r2,2052
 80046cc:	10908a04 	addi	r2,r2,16936
 80046d0:	10c00015 	stw	r3,0(r2)
          set_head(top, top_size | PREV_INUSE);
 80046d4:	00820134 	movhi	r2,2052
 80046d8:	1083df04 	addi	r2,r2,3964
 80046dc:	10800217 	ldw	r2,8(r2)
 80046e0:	e0fffa17 	ldw	r3,-24(fp)
 80046e4:	18c00054 	ori	r3,r3,1
 80046e8:	10c00115 	stw	r3,4(r2)
        }
        check_chunk(top);
	MALLOC_UNLOCK;
 80046ec:	e13ffe17 	ldw	r4,-8(fp)
 80046f0:	80052680 	call	8005268 <__malloc_unlock>
        return 0; 
 80046f4:	0005883a 	mov	r2,zero
 80046f8:	00001306 	br	8004748 <_malloc_trim_r+0x1b8>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
 80046fc:	00820134 	movhi	r2,2052
 8004700:	1083df04 	addi	r2,r2,3964
 8004704:	10800217 	ldw	r2,8(r2)
 8004708:	e13ffa17 	ldw	r4,-24(fp)
 800470c:	e0fffb17 	ldw	r3,-20(fp)
 8004710:	20c7c83a 	sub	r3,r4,r3
 8004714:	18c00054 	ori	r3,r3,1
 8004718:	10c00115 	stw	r3,4(r2)
        sbrked_mem -= extra;
 800471c:	00820134 	movhi	r2,2052
 8004720:	10908a04 	addi	r2,r2,16936
 8004724:	10c00017 	ldw	r3,0(r2)
 8004728:	e0bffb17 	ldw	r2,-20(fp)
 800472c:	1887c83a 	sub	r3,r3,r2
 8004730:	00820134 	movhi	r2,2052
 8004734:	10908a04 	addi	r2,r2,16936
 8004738:	10c00015 	stw	r3,0(r2)
        check_chunk(top);
	MALLOC_UNLOCK;
 800473c:	e13ffe17 	ldw	r4,-8(fp)
 8004740:	80052680 	call	8005268 <__malloc_unlock>
        return 1;
 8004744:	00800044 	movi	r2,1
      }
    }
  }
}
 8004748:	e037883a 	mov	sp,fp
 800474c:	dfc00117 	ldw	ra,4(sp)
 8004750:	df000017 	ldw	fp,0(sp)
 8004754:	dec00204 	addi	sp,sp,8
 8004758:	f800283a 	ret

0800475c <_lseek_r>:
_DEFUN (_lseek_r, (ptr, fd, pos, whence),
     struct _reent *ptr _AND
     int fd _AND
     _off_t pos _AND
     int whence)
{
 800475c:	defff904 	addi	sp,sp,-28
 8004760:	dfc00615 	stw	ra,24(sp)
 8004764:	df000515 	stw	fp,20(sp)
 8004768:	df000504 	addi	fp,sp,20
 800476c:	e13ffc15 	stw	r4,-16(fp)
 8004770:	e17ffd15 	stw	r5,-12(fp)
 8004774:	e1bffe15 	stw	r6,-8(fp)
 8004778:	e1ffff15 	stw	r7,-4(fp)
  _off_t ret;

  errno = 0;
 800477c:	d026e615 	stw	zero,-25704(gp)
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
 8004780:	e1bfff17 	ldw	r6,-4(fp)
 8004784:	e17ffe17 	ldw	r5,-8(fp)
 8004788:	e13ffd17 	ldw	r4,-12(fp)
 800478c:	80051100 	call	8005110 <lseek>
 8004790:	e0bffb15 	stw	r2,-20(fp)
 8004794:	e0bffb17 	ldw	r2,-20(fp)
 8004798:	10bfffd8 	cmpnei	r2,r2,-1
 800479c:	1000051e 	bne	r2,zero,80047b4 <_lseek_r+0x58>
 80047a0:	d0a6e617 	ldw	r2,-25704(gp)
 80047a4:	10000326 	beq	r2,zero,80047b4 <_lseek_r+0x58>
    ptr->_errno = errno;
 80047a8:	d0e6e617 	ldw	r3,-25704(gp)
 80047ac:	e0bffc17 	ldw	r2,-16(fp)
 80047b0:	10c00015 	stw	r3,0(r2)
  return ret;
 80047b4:	e0bffb17 	ldw	r2,-20(fp)
}
 80047b8:	e037883a 	mov	sp,fp
 80047bc:	dfc00117 	ldw	ra,4(sp)
 80047c0:	df000017 	ldw	fp,0(sp)
 80047c4:	dec00204 	addi	sp,sp,8
 80047c8:	f800283a 	ret

080047cc <__smakebuf_r>:

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
 80047cc:	deffea04 	addi	sp,sp,-88
 80047d0:	dfc01515 	stw	ra,84(sp)
 80047d4:	df001415 	stw	fp,80(sp)
 80047d8:	dcc01315 	stw	r19,76(sp)
 80047dc:	dc801215 	stw	r18,72(sp)
 80047e0:	dc401115 	stw	r17,68(sp)
 80047e4:	dc001015 	stw	r16,64(sp)
 80047e8:	df001404 	addi	fp,sp,80
 80047ec:	e13ffb15 	stw	r4,-20(fp)
 80047f0:	2821883a 	mov	r16,r5
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
 80047f4:	8080030b 	ldhu	r2,12(r16)
 80047f8:	10bfffcc 	andi	r2,r2,65535
 80047fc:	1080008c 	andi	r2,r2,2
 8004800:	10000726 	beq	r2,zero,8004820 <__smakebuf_r+0x54>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
 8004804:	808010c4 	addi	r2,r16,67
 8004808:	80800015 	stw	r2,0(r16)
 800480c:	80800017 	ldw	r2,0(r16)
 8004810:	80800415 	stw	r2,16(r16)
      fp->_bf._size = 1;
 8004814:	00800044 	movi	r2,1
 8004818:	80800515 	stw	r2,20(r16)
 800481c:	00006d06 	br	80049d4 <__smakebuf_r+0x208>
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
 8004820:	8080038b 	ldhu	r2,14(r16)
 8004824:	10bfffcc 	andi	r2,r2,65535
 8004828:	10a0001c 	xori	r2,r2,32768
 800482c:	10a00004 	addi	r2,r2,-32768
 8004830:	10000916 	blt	r2,zero,8004858 <__smakebuf_r+0x8c>
 8004834:	8080038b 	ldhu	r2,14(r16)
 8004838:	10bfffcc 	andi	r2,r2,65535
 800483c:	10a0001c 	xori	r2,r2,32768
 8004840:	10a00004 	addi	r2,r2,-32768
 8004844:	e1bfec04 	addi	r6,fp,-80
 8004848:	100b883a 	mov	r5,r2
 800484c:	e13ffb17 	ldw	r4,-20(fp)
 8004850:	8004a680 	call	8004a68 <_fstat_r>
 8004854:	10000c0e 	bge	r2,zero,8004888 <__smakebuf_r+0xbc>
#endif
    {
      couldbetty = 0;
 8004858:	0025883a 	mov	r18,zero
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
 800485c:	8080030b 	ldhu	r2,12(r16)
 8004860:	10bfffcc 	andi	r2,r2,65535
 8004864:	1080200c 	andi	r2,r2,128
 8004868:	10000226 	beq	r2,zero,8004874 <__smakebuf_r+0xa8>
        size = _DEFAULT_ASPRINTF_BUFSIZE;
 800486c:	04401004 	movi	r17,64
 8004870:	00000106 	br	8004878 <__smakebuf_r+0xac>
      else
        size = BUFSIZ;
 8004874:	04410004 	movi	r17,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
 8004878:	8080030b 	ldhu	r2,12(r16)
 800487c:	10820014 	ori	r2,r2,2048
 8004880:	8080030d 	sth	r2,12(r16)
 8004884:	00001606 	br	80048e0 <__smakebuf_r+0x114>
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
 8004888:	e0bfed17 	ldw	r2,-76(fp)
 800488c:	10bc000c 	andi	r2,r2,61440
 8004890:	10880020 	cmpeqi	r2,r2,8192
 8004894:	14803fcc 	andi	r18,r2,255
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
 8004898:	04410004 	movi	r17,1024
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
 800489c:	e0bfed17 	ldw	r2,-76(fp)
 80048a0:	10fc000c 	andi	r3,r2,61440
 80048a4:	00a00014 	movui	r2,32768
 80048a8:	18800a1e 	bne	r3,r2,80048d4 <__smakebuf_r+0x108>
 80048ac:	80c00a17 	ldw	r3,40(r16)
 80048b0:	00820034 	movhi	r2,2048
 80048b4:	108de204 	addi	r2,r2,14216
 80048b8:	1880061e 	bne	r3,r2,80048d4 <__smakebuf_r+0x108>
	{
	  fp->_flags |= __SOPT;
 80048bc:	8080030b 	ldhu	r2,12(r16)
 80048c0:	10810014 	ori	r2,r2,1024
 80048c4:	8080030d 	sth	r2,12(r16)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
 80048c8:	00810004 	movi	r2,1024
 80048cc:	80801315 	stw	r2,76(r16)
 80048d0:	00000306 	br	80048e0 <__smakebuf_r+0x114>
#endif
	}
      else
	fp->_flags |= __SNPT;
 80048d4:	8080030b 	ldhu	r2,12(r16)
 80048d8:	10820014 	ori	r2,r2,2048
 80048dc:	8080030d 	sth	r2,12(r16)
#endif
    }

  /* Make unbuffered by default: */			/* AlteraSpecific */
  if (couldbetty && _isatty_r (ptr, fp->_file))		/* AlteraSpecific */
 80048e0:	90001126 	beq	r18,zero,8004928 <__smakebuf_r+0x15c>
 80048e4:	8080038b 	ldhu	r2,14(r16)
 80048e8:	10bfffcc 	andi	r2,r2,65535
 80048ec:	10a0001c 	xori	r2,r2,32768
 80048f0:	10a00004 	addi	r2,r2,-32768
 80048f4:	100b883a 	mov	r5,r2
 80048f8:	e13ffb17 	ldw	r4,-20(fp)
 80048fc:	8004ad00 	call	8004ad0 <_isatty_r>
 8004900:	10000926 	beq	r2,zero,8004928 <__smakebuf_r+0x15c>
  {							/* AlteraSpecific */
    fp->_flags |= __SLBF;				/* AlteraSpecific __SLBF == "line buffered */
 8004904:	8080030b 	ldhu	r2,12(r16)
 8004908:	10800054 	ori	r2,r2,1
 800490c:	8080030d 	sth	r2,12(r16)
    fp->_bf._base = fp->_p = fp->_nbuf;			/* AlteraSpecific (see newlib/libc/include/stdio.h) */
 8004910:	808010c4 	addi	r2,r16,67
 8004914:	80800015 	stw	r2,0(r16)
 8004918:	80800017 	ldw	r2,0(r16)
 800491c:	80800415 	stw	r2,16(r16)
    fp->_bf._size = 1;					/* AlteraSpecific */
 8004920:	00800044 	movi	r2,1
 8004924:	80800515 	stw	r2,20(r16)
  }							/* AlteraSpecific */

  if ((p = _malloc_r (ptr, size)) == NULL)
 8004928:	880b883a 	mov	r5,r17
 800492c:	e13ffb17 	ldw	r4,-20(fp)
 8004930:	800172c0 	call	800172c <_malloc_r>
 8004934:	1027883a 	mov	r19,r2
 8004938:	98000e1e 	bne	r19,zero,8004974 <__smakebuf_r+0x1a8>
    {
      if (!(fp->_flags & __SSTR))
 800493c:	8080030b 	ldhu	r2,12(r16)
 8004940:	10bfffcc 	andi	r2,r2,65535
 8004944:	1080800c 	andi	r2,r2,512
 8004948:	1000221e 	bne	r2,zero,80049d4 <__smakebuf_r+0x208>
	{
	  fp->_flags |= __SNBF;
 800494c:	8080030b 	ldhu	r2,12(r16)
 8004950:	10800094 	ori	r2,r2,2
 8004954:	8080030d 	sth	r2,12(r16)
	  fp->_bf._base = fp->_p = fp->_nbuf;
 8004958:	808010c4 	addi	r2,r16,67
 800495c:	80800015 	stw	r2,0(r16)
 8004960:	80800017 	ldw	r2,0(r16)
 8004964:	80800415 	stw	r2,16(r16)
	  fp->_bf._size = 1;
 8004968:	00800044 	movi	r2,1
 800496c:	80800515 	stw	r2,20(r16)
 8004970:	00001806 	br	80049d4 <__smakebuf_r+0x208>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
 8004974:	e0fffb17 	ldw	r3,-20(fp)
 8004978:	00820034 	movhi	r2,2048
 800497c:	10825404 	addi	r2,r2,2384
 8004980:	18800f15 	stw	r2,60(r3)
      fp->_flags |= __SMBF;
 8004984:	8080030b 	ldhu	r2,12(r16)
 8004988:	10802014 	ori	r2,r2,128
 800498c:	8080030d 	sth	r2,12(r16)
      fp->_bf._base = fp->_p = (unsigned char *) p;
 8004990:	84c00015 	stw	r19,0(r16)
 8004994:	80800017 	ldw	r2,0(r16)
 8004998:	80800415 	stw	r2,16(r16)
      fp->_bf._size = size;
 800499c:	8805883a 	mov	r2,r17
 80049a0:	80800515 	stw	r2,20(r16)
      if (couldbetty && _isatty_r (ptr, fp->_file))
 80049a4:	90000b26 	beq	r18,zero,80049d4 <__smakebuf_r+0x208>
 80049a8:	8080038b 	ldhu	r2,14(r16)
 80049ac:	10bfffcc 	andi	r2,r2,65535
 80049b0:	10a0001c 	xori	r2,r2,32768
 80049b4:	10a00004 	addi	r2,r2,-32768
 80049b8:	100b883a 	mov	r5,r2
 80049bc:	e13ffb17 	ldw	r4,-20(fp)
 80049c0:	8004ad00 	call	8004ad0 <_isatty_r>
 80049c4:	10000326 	beq	r2,zero,80049d4 <__smakebuf_r+0x208>
	fp->_flags |= __SLBF;
 80049c8:	8080030b 	ldhu	r2,12(r16)
 80049cc:	10800054 	ori	r2,r2,1
 80049d0:	8080030d 	sth	r2,12(r16)
    }
}
 80049d4:	e6fffc04 	addi	sp,fp,-16
 80049d8:	dfc00517 	ldw	ra,20(sp)
 80049dc:	df000417 	ldw	fp,16(sp)
 80049e0:	dcc00317 	ldw	r19,12(sp)
 80049e4:	dc800217 	ldw	r18,8(sp)
 80049e8:	dc400117 	ldw	r17,4(sp)
 80049ec:	dc000017 	ldw	r16,0(sp)
 80049f0:	dec00604 	addi	sp,sp,24
 80049f4:	f800283a 	ret

080049f8 <_read_r>:
_DEFUN (_read_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _PTR buf _AND
     size_t cnt)
{
 80049f8:	defff904 	addi	sp,sp,-28
 80049fc:	dfc00615 	stw	ra,24(sp)
 8004a00:	df000515 	stw	fp,20(sp)
 8004a04:	df000504 	addi	fp,sp,20
 8004a08:	e13ffc15 	stw	r4,-16(fp)
 8004a0c:	e17ffd15 	stw	r5,-12(fp)
 8004a10:	e1bffe15 	stw	r6,-8(fp)
 8004a14:	e1ffff15 	stw	r7,-4(fp)
  _ssize_t ret;

  errno = 0;
 8004a18:	d026e615 	stw	zero,-25704(gp)
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
 8004a1c:	e1bfff17 	ldw	r6,-4(fp)
 8004a20:	e17ffe17 	ldw	r5,-8(fp)
 8004a24:	e13ffd17 	ldw	r4,-12(fp)
 8004a28:	80052c80 	call	80052c8 <read>
 8004a2c:	e0bffb15 	stw	r2,-20(fp)
 8004a30:	e0bffb17 	ldw	r2,-20(fp)
 8004a34:	10bfffd8 	cmpnei	r2,r2,-1
 8004a38:	1000051e 	bne	r2,zero,8004a50 <_read_r+0x58>
 8004a3c:	d0a6e617 	ldw	r2,-25704(gp)
 8004a40:	10000326 	beq	r2,zero,8004a50 <_read_r+0x58>
    ptr->_errno = errno;
 8004a44:	d0e6e617 	ldw	r3,-25704(gp)
 8004a48:	e0bffc17 	ldw	r2,-16(fp)
 8004a4c:	10c00015 	stw	r3,0(r2)
  return ret;
 8004a50:	e0bffb17 	ldw	r2,-20(fp)
}
 8004a54:	e037883a 	mov	sp,fp
 8004a58:	dfc00117 	ldw	ra,4(sp)
 8004a5c:	df000017 	ldw	fp,0(sp)
 8004a60:	dec00204 	addi	sp,sp,8
 8004a64:	f800283a 	ret

08004a68 <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
 8004a68:	defffa04 	addi	sp,sp,-24
 8004a6c:	dfc00515 	stw	ra,20(sp)
 8004a70:	df000415 	stw	fp,16(sp)
 8004a74:	df000404 	addi	fp,sp,16
 8004a78:	e13ffd15 	stw	r4,-12(fp)
 8004a7c:	e17ffe15 	stw	r5,-8(fp)
 8004a80:	e1bfff15 	stw	r6,-4(fp)
  int ret;

  errno = 0;
 8004a84:	d026e615 	stw	zero,-25704(gp)
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
 8004a88:	e17fff17 	ldw	r5,-4(fp)
 8004a8c:	e13ffe17 	ldw	r4,-8(fp)
 8004a90:	8004e580 	call	8004e58 <fstat>
 8004a94:	e0bffc15 	stw	r2,-16(fp)
 8004a98:	e0bffc17 	ldw	r2,-16(fp)
 8004a9c:	10bfffd8 	cmpnei	r2,r2,-1
 8004aa0:	1000051e 	bne	r2,zero,8004ab8 <_fstat_r+0x50>
 8004aa4:	d0a6e617 	ldw	r2,-25704(gp)
 8004aa8:	10000326 	beq	r2,zero,8004ab8 <_fstat_r+0x50>
    ptr->_errno = errno;
 8004aac:	d0e6e617 	ldw	r3,-25704(gp)
 8004ab0:	e0bffd17 	ldw	r2,-12(fp)
 8004ab4:	10c00015 	stw	r3,0(r2)
  return ret;
 8004ab8:	e0bffc17 	ldw	r2,-16(fp)
}
 8004abc:	e037883a 	mov	sp,fp
 8004ac0:	dfc00117 	ldw	ra,4(sp)
 8004ac4:	df000017 	ldw	fp,0(sp)
 8004ac8:	dec00204 	addi	sp,sp,8
 8004acc:	f800283a 	ret

08004ad0 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 8004ad0:	defffb04 	addi	sp,sp,-20
 8004ad4:	dfc00415 	stw	ra,16(sp)
 8004ad8:	df000315 	stw	fp,12(sp)
 8004adc:	df000304 	addi	fp,sp,12
 8004ae0:	e13ffe15 	stw	r4,-8(fp)
 8004ae4:	e17fff15 	stw	r5,-4(fp)
  int ret;

  errno = 0;
 8004ae8:	d026e615 	stw	zero,-25704(gp)
  if ((ret = _isatty (fd)) == -1 && errno != 0)
 8004aec:	e13fff17 	ldw	r4,-4(fp)
 8004af0:	8004f440 	call	8004f44 <isatty>
 8004af4:	e0bffd15 	stw	r2,-12(fp)
 8004af8:	e0bffd17 	ldw	r2,-12(fp)
 8004afc:	10bfffd8 	cmpnei	r2,r2,-1
 8004b00:	1000051e 	bne	r2,zero,8004b18 <_isatty_r+0x48>
 8004b04:	d0a6e617 	ldw	r2,-25704(gp)
 8004b08:	10000326 	beq	r2,zero,8004b18 <_isatty_r+0x48>
    ptr->_errno = errno;
 8004b0c:	d0e6e617 	ldw	r3,-25704(gp)
 8004b10:	e0bffe17 	ldw	r2,-8(fp)
 8004b14:	10c00015 	stw	r3,0(r2)
  return ret;
 8004b18:	e0bffd17 	ldw	r2,-12(fp)
}
 8004b1c:	e037883a 	mov	sp,fp
 8004b20:	dfc00117 	ldw	ra,4(sp)
 8004b24:	df000017 	ldw	fp,0(sp)
 8004b28:	dec00204 	addi	sp,sp,8
 8004b2c:	f800283a 	ret

08004b30 <__divsi3>:
 8004b30:	20001b16 	blt	r4,zero,8004ba0 <__divsi3+0x70>
 8004b34:	000f883a 	mov	r7,zero
 8004b38:	28001616 	blt	r5,zero,8004b94 <__divsi3+0x64>
 8004b3c:	200d883a 	mov	r6,r4
 8004b40:	29001a2e 	bgeu	r5,r4,8004bac <__divsi3+0x7c>
 8004b44:	00800804 	movi	r2,32
 8004b48:	00c00044 	movi	r3,1
 8004b4c:	00000106 	br	8004b54 <__divsi3+0x24>
 8004b50:	10000d26 	beq	r2,zero,8004b88 <__divsi3+0x58>
 8004b54:	294b883a 	add	r5,r5,r5
 8004b58:	10bfffc4 	addi	r2,r2,-1
 8004b5c:	18c7883a 	add	r3,r3,r3
 8004b60:	293ffb36 	bltu	r5,r4,8004b50 <__divsi3+0x20>
 8004b64:	0005883a 	mov	r2,zero
 8004b68:	18000726 	beq	r3,zero,8004b88 <__divsi3+0x58>
 8004b6c:	0005883a 	mov	r2,zero
 8004b70:	31400236 	bltu	r6,r5,8004b7c <__divsi3+0x4c>
 8004b74:	314dc83a 	sub	r6,r6,r5
 8004b78:	10c4b03a 	or	r2,r2,r3
 8004b7c:	1806d07a 	srli	r3,r3,1
 8004b80:	280ad07a 	srli	r5,r5,1
 8004b84:	183ffa1e 	bne	r3,zero,8004b70 <__divsi3+0x40>
 8004b88:	38000126 	beq	r7,zero,8004b90 <__divsi3+0x60>
 8004b8c:	0085c83a 	sub	r2,zero,r2
 8004b90:	f800283a 	ret
 8004b94:	014bc83a 	sub	r5,zero,r5
 8004b98:	39c0005c 	xori	r7,r7,1
 8004b9c:	003fe706 	br	8004b3c <__divsi3+0xc>
 8004ba0:	0109c83a 	sub	r4,zero,r4
 8004ba4:	01c00044 	movi	r7,1
 8004ba8:	003fe306 	br	8004b38 <__divsi3+0x8>
 8004bac:	00c00044 	movi	r3,1
 8004bb0:	003fee06 	br	8004b6c <__divsi3+0x3c>

08004bb4 <__modsi3>:
 8004bb4:	20001716 	blt	r4,zero,8004c14 <__modsi3+0x60>
 8004bb8:	000f883a 	mov	r7,zero
 8004bbc:	2005883a 	mov	r2,r4
 8004bc0:	28001216 	blt	r5,zero,8004c0c <__modsi3+0x58>
 8004bc4:	2900162e 	bgeu	r5,r4,8004c20 <__modsi3+0x6c>
 8004bc8:	01800804 	movi	r6,32
 8004bcc:	00c00044 	movi	r3,1
 8004bd0:	00000106 	br	8004bd8 <__modsi3+0x24>
 8004bd4:	30000a26 	beq	r6,zero,8004c00 <__modsi3+0x4c>
 8004bd8:	294b883a 	add	r5,r5,r5
 8004bdc:	31bfffc4 	addi	r6,r6,-1
 8004be0:	18c7883a 	add	r3,r3,r3
 8004be4:	293ffb36 	bltu	r5,r4,8004bd4 <__modsi3+0x20>
 8004be8:	18000526 	beq	r3,zero,8004c00 <__modsi3+0x4c>
 8004bec:	1806d07a 	srli	r3,r3,1
 8004bf0:	11400136 	bltu	r2,r5,8004bf8 <__modsi3+0x44>
 8004bf4:	1145c83a 	sub	r2,r2,r5
 8004bf8:	280ad07a 	srli	r5,r5,1
 8004bfc:	183ffb1e 	bne	r3,zero,8004bec <__modsi3+0x38>
 8004c00:	38000126 	beq	r7,zero,8004c08 <__modsi3+0x54>
 8004c04:	0085c83a 	sub	r2,zero,r2
 8004c08:	f800283a 	ret
 8004c0c:	014bc83a 	sub	r5,zero,r5
 8004c10:	003fec06 	br	8004bc4 <__modsi3+0x10>
 8004c14:	0109c83a 	sub	r4,zero,r4
 8004c18:	01c00044 	movi	r7,1
 8004c1c:	003fe706 	br	8004bbc <__modsi3+0x8>
 8004c20:	00c00044 	movi	r3,1
 8004c24:	003ff106 	br	8004bec <__modsi3+0x38>

08004c28 <__udivsi3>:
 8004c28:	200d883a 	mov	r6,r4
 8004c2c:	2900152e 	bgeu	r5,r4,8004c84 <__udivsi3+0x5c>
 8004c30:	28001416 	blt	r5,zero,8004c84 <__udivsi3+0x5c>
 8004c34:	00800804 	movi	r2,32
 8004c38:	00c00044 	movi	r3,1
 8004c3c:	00000206 	br	8004c48 <__udivsi3+0x20>
 8004c40:	10000e26 	beq	r2,zero,8004c7c <__udivsi3+0x54>
 8004c44:	28000516 	blt	r5,zero,8004c5c <__udivsi3+0x34>
 8004c48:	294b883a 	add	r5,r5,r5
 8004c4c:	10bfffc4 	addi	r2,r2,-1
 8004c50:	18c7883a 	add	r3,r3,r3
 8004c54:	293ffa36 	bltu	r5,r4,8004c40 <__udivsi3+0x18>
 8004c58:	18000826 	beq	r3,zero,8004c7c <__udivsi3+0x54>
 8004c5c:	0005883a 	mov	r2,zero
 8004c60:	31400236 	bltu	r6,r5,8004c6c <__udivsi3+0x44>
 8004c64:	314dc83a 	sub	r6,r6,r5
 8004c68:	10c4b03a 	or	r2,r2,r3
 8004c6c:	1806d07a 	srli	r3,r3,1
 8004c70:	280ad07a 	srli	r5,r5,1
 8004c74:	183ffa1e 	bne	r3,zero,8004c60 <__udivsi3+0x38>
 8004c78:	f800283a 	ret
 8004c7c:	0005883a 	mov	r2,zero
 8004c80:	f800283a 	ret
 8004c84:	00c00044 	movi	r3,1
 8004c88:	003ff406 	br	8004c5c <__udivsi3+0x34>

08004c8c <__umodsi3>:
 8004c8c:	2005883a 	mov	r2,r4
 8004c90:	2900122e 	bgeu	r5,r4,8004cdc <__umodsi3+0x50>
 8004c94:	28001116 	blt	r5,zero,8004cdc <__umodsi3+0x50>
 8004c98:	01800804 	movi	r6,32
 8004c9c:	00c00044 	movi	r3,1
 8004ca0:	00000206 	br	8004cac <__umodsi3+0x20>
 8004ca4:	30000c26 	beq	r6,zero,8004cd8 <__umodsi3+0x4c>
 8004ca8:	28000516 	blt	r5,zero,8004cc0 <__umodsi3+0x34>
 8004cac:	294b883a 	add	r5,r5,r5
 8004cb0:	31bfffc4 	addi	r6,r6,-1
 8004cb4:	18c7883a 	add	r3,r3,r3
 8004cb8:	293ffa36 	bltu	r5,r4,8004ca4 <__umodsi3+0x18>
 8004cbc:	18000626 	beq	r3,zero,8004cd8 <__umodsi3+0x4c>
 8004cc0:	1806d07a 	srli	r3,r3,1
 8004cc4:	11400136 	bltu	r2,r5,8004ccc <__umodsi3+0x40>
 8004cc8:	1145c83a 	sub	r2,r2,r5
 8004ccc:	280ad07a 	srli	r5,r5,1
 8004cd0:	183ffb1e 	bne	r3,zero,8004cc0 <__umodsi3+0x34>
 8004cd4:	f800283a 	ret
 8004cd8:	f800283a 	ret
 8004cdc:	00c00044 	movi	r3,1
 8004ce0:	003ff706 	br	8004cc0 <__umodsi3+0x34>

08004ce4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8004ce4:	defffe04 	addi	sp,sp,-8
 8004ce8:	dfc00115 	stw	ra,4(sp)
 8004cec:	df000015 	stw	fp,0(sp)
 8004cf0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8004cf4:	d0a00917 	ldw	r2,-32732(gp)
 8004cf8:	10000326 	beq	r2,zero,8004d08 <alt_get_errno+0x24>
 8004cfc:	d0a00917 	ldw	r2,-32732(gp)
 8004d00:	103ee83a 	callr	r2
 8004d04:	00000106 	br	8004d0c <alt_get_errno+0x28>
 8004d08:	d0a6e604 	addi	r2,gp,-25704
}
 8004d0c:	e037883a 	mov	sp,fp
 8004d10:	dfc00117 	ldw	ra,4(sp)
 8004d14:	df000017 	ldw	fp,0(sp)
 8004d18:	dec00204 	addi	sp,sp,8
 8004d1c:	f800283a 	ret

08004d20 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 8004d20:	defffb04 	addi	sp,sp,-20
 8004d24:	dfc00415 	stw	ra,16(sp)
 8004d28:	df000315 	stw	fp,12(sp)
 8004d2c:	df000304 	addi	fp,sp,12
 8004d30:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 8004d34:	e0bfff17 	ldw	r2,-4(fp)
 8004d38:	10000616 	blt	r2,zero,8004d54 <close+0x34>
 8004d3c:	e0bfff17 	ldw	r2,-4(fp)
 8004d40:	10c00324 	muli	r3,r2,12
 8004d44:	00820134 	movhi	r2,2052
 8004d48:	1084eb04 	addi	r2,r2,5036
 8004d4c:	1885883a 	add	r2,r3,r2
 8004d50:	00000106 	br	8004d58 <close+0x38>
 8004d54:	0005883a 	mov	r2,zero
 8004d58:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 8004d5c:	e0bffd17 	ldw	r2,-12(fp)
 8004d60:	10001926 	beq	r2,zero,8004dc8 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 8004d64:	e0bffd17 	ldw	r2,-12(fp)
 8004d68:	10800017 	ldw	r2,0(r2)
 8004d6c:	10800417 	ldw	r2,16(r2)
 8004d70:	10000626 	beq	r2,zero,8004d8c <close+0x6c>
 8004d74:	e0bffd17 	ldw	r2,-12(fp)
 8004d78:	10800017 	ldw	r2,0(r2)
 8004d7c:	10800417 	ldw	r2,16(r2)
 8004d80:	e13ffd17 	ldw	r4,-12(fp)
 8004d84:	103ee83a 	callr	r2
 8004d88:	00000106 	br	8004d90 <close+0x70>
 8004d8c:	0005883a 	mov	r2,zero
 8004d90:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 8004d94:	e13fff17 	ldw	r4,-4(fp)
 8004d98:	80053c40 	call	80053c4 <alt_release_fd>
    if (rval < 0)
 8004d9c:	e0bffe17 	ldw	r2,-8(fp)
 8004da0:	1000070e 	bge	r2,zero,8004dc0 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 8004da4:	8004ce40 	call	8004ce4 <alt_get_errno>
 8004da8:	1007883a 	mov	r3,r2
 8004dac:	e0bffe17 	ldw	r2,-8(fp)
 8004db0:	0085c83a 	sub	r2,zero,r2
 8004db4:	18800015 	stw	r2,0(r3)
      return -1;
 8004db8:	00bfffc4 	movi	r2,-1
 8004dbc:	00000706 	br	8004ddc <close+0xbc>
    }
    return 0;
 8004dc0:	0005883a 	mov	r2,zero
 8004dc4:	00000506 	br	8004ddc <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 8004dc8:	8004ce40 	call	8004ce4 <alt_get_errno>
 8004dcc:	1007883a 	mov	r3,r2
 8004dd0:	00801444 	movi	r2,81
 8004dd4:	18800015 	stw	r2,0(r3)
    return -1;
 8004dd8:	00bfffc4 	movi	r2,-1
  }
}
 8004ddc:	e037883a 	mov	sp,fp
 8004de0:	dfc00117 	ldw	ra,4(sp)
 8004de4:	df000017 	ldw	fp,0(sp)
 8004de8:	dec00204 	addi	sp,sp,8
 8004dec:	f800283a 	ret

08004df0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 8004df0:	defffc04 	addi	sp,sp,-16
 8004df4:	df000315 	stw	fp,12(sp)
 8004df8:	df000304 	addi	fp,sp,12
 8004dfc:	e13ffd15 	stw	r4,-12(fp)
 8004e00:	e17ffe15 	stw	r5,-8(fp)
 8004e04:	e1bfff15 	stw	r6,-4(fp)
  return len;
 8004e08:	e0bfff17 	ldw	r2,-4(fp)
}
 8004e0c:	e037883a 	mov	sp,fp
 8004e10:	df000017 	ldw	fp,0(sp)
 8004e14:	dec00104 	addi	sp,sp,4
 8004e18:	f800283a 	ret

08004e1c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8004e1c:	defffe04 	addi	sp,sp,-8
 8004e20:	dfc00115 	stw	ra,4(sp)
 8004e24:	df000015 	stw	fp,0(sp)
 8004e28:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8004e2c:	d0a00917 	ldw	r2,-32732(gp)
 8004e30:	10000326 	beq	r2,zero,8004e40 <alt_get_errno+0x24>
 8004e34:	d0a00917 	ldw	r2,-32732(gp)
 8004e38:	103ee83a 	callr	r2
 8004e3c:	00000106 	br	8004e44 <alt_get_errno+0x28>
 8004e40:	d0a6e604 	addi	r2,gp,-25704
}
 8004e44:	e037883a 	mov	sp,fp
 8004e48:	dfc00117 	ldw	ra,4(sp)
 8004e4c:	df000017 	ldw	fp,0(sp)
 8004e50:	dec00204 	addi	sp,sp,8
 8004e54:	f800283a 	ret

08004e58 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 8004e58:	defffb04 	addi	sp,sp,-20
 8004e5c:	dfc00415 	stw	ra,16(sp)
 8004e60:	df000315 	stw	fp,12(sp)
 8004e64:	df000304 	addi	fp,sp,12
 8004e68:	e13ffe15 	stw	r4,-8(fp)
 8004e6c:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8004e70:	e0bffe17 	ldw	r2,-8(fp)
 8004e74:	10000616 	blt	r2,zero,8004e90 <fstat+0x38>
 8004e78:	e0bffe17 	ldw	r2,-8(fp)
 8004e7c:	10c00324 	muli	r3,r2,12
 8004e80:	00820134 	movhi	r2,2052
 8004e84:	1084eb04 	addi	r2,r2,5036
 8004e88:	1885883a 	add	r2,r3,r2
 8004e8c:	00000106 	br	8004e94 <fstat+0x3c>
 8004e90:	0005883a 	mov	r2,zero
 8004e94:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 8004e98:	e0bffd17 	ldw	r2,-12(fp)
 8004e9c:	10001026 	beq	r2,zero,8004ee0 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 8004ea0:	e0bffd17 	ldw	r2,-12(fp)
 8004ea4:	10800017 	ldw	r2,0(r2)
 8004ea8:	10800817 	ldw	r2,32(r2)
 8004eac:	10000726 	beq	r2,zero,8004ecc <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 8004eb0:	e0bffd17 	ldw	r2,-12(fp)
 8004eb4:	10800017 	ldw	r2,0(r2)
 8004eb8:	10800817 	ldw	r2,32(r2)
 8004ebc:	e17fff17 	ldw	r5,-4(fp)
 8004ec0:	e13ffd17 	ldw	r4,-12(fp)
 8004ec4:	103ee83a 	callr	r2
 8004ec8:	00000a06 	br	8004ef4 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 8004ecc:	e0bfff17 	ldw	r2,-4(fp)
 8004ed0:	00c80004 	movi	r3,8192
 8004ed4:	10c00115 	stw	r3,4(r2)
      return 0;
 8004ed8:	0005883a 	mov	r2,zero
 8004edc:	00000506 	br	8004ef4 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 8004ee0:	8004e1c0 	call	8004e1c <alt_get_errno>
 8004ee4:	1007883a 	mov	r3,r2
 8004ee8:	00801444 	movi	r2,81
 8004eec:	18800015 	stw	r2,0(r3)
    return -1;
 8004ef0:	00bfffc4 	movi	r2,-1
  }
}
 8004ef4:	e037883a 	mov	sp,fp
 8004ef8:	dfc00117 	ldw	ra,4(sp)
 8004efc:	df000017 	ldw	fp,0(sp)
 8004f00:	dec00204 	addi	sp,sp,8
 8004f04:	f800283a 	ret

08004f08 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8004f08:	defffe04 	addi	sp,sp,-8
 8004f0c:	dfc00115 	stw	ra,4(sp)
 8004f10:	df000015 	stw	fp,0(sp)
 8004f14:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8004f18:	d0a00917 	ldw	r2,-32732(gp)
 8004f1c:	10000326 	beq	r2,zero,8004f2c <alt_get_errno+0x24>
 8004f20:	d0a00917 	ldw	r2,-32732(gp)
 8004f24:	103ee83a 	callr	r2
 8004f28:	00000106 	br	8004f30 <alt_get_errno+0x28>
 8004f2c:	d0a6e604 	addi	r2,gp,-25704
}
 8004f30:	e037883a 	mov	sp,fp
 8004f34:	dfc00117 	ldw	ra,4(sp)
 8004f38:	df000017 	ldw	fp,0(sp)
 8004f3c:	dec00204 	addi	sp,sp,8
 8004f40:	f800283a 	ret

08004f44 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 8004f44:	deffed04 	addi	sp,sp,-76
 8004f48:	dfc01215 	stw	ra,72(sp)
 8004f4c:	df001115 	stw	fp,68(sp)
 8004f50:	df001104 	addi	fp,sp,68
 8004f54:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8004f58:	e0bfff17 	ldw	r2,-4(fp)
 8004f5c:	10000616 	blt	r2,zero,8004f78 <isatty+0x34>
 8004f60:	e0bfff17 	ldw	r2,-4(fp)
 8004f64:	10c00324 	muli	r3,r2,12
 8004f68:	00820134 	movhi	r2,2052
 8004f6c:	1084eb04 	addi	r2,r2,5036
 8004f70:	1885883a 	add	r2,r3,r2
 8004f74:	00000106 	br	8004f7c <isatty+0x38>
 8004f78:	0005883a 	mov	r2,zero
 8004f7c:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 8004f80:	e0bfef17 	ldw	r2,-68(fp)
 8004f84:	10000e26 	beq	r2,zero,8004fc0 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 8004f88:	e0bfef17 	ldw	r2,-68(fp)
 8004f8c:	10800017 	ldw	r2,0(r2)
 8004f90:	10800817 	ldw	r2,32(r2)
 8004f94:	1000021e 	bne	r2,zero,8004fa0 <isatty+0x5c>
    {
      return 1;
 8004f98:	00800044 	movi	r2,1
 8004f9c:	00000d06 	br	8004fd4 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 8004fa0:	e0bff004 	addi	r2,fp,-64
 8004fa4:	100b883a 	mov	r5,r2
 8004fa8:	e13fff17 	ldw	r4,-4(fp)
 8004fac:	8004e580 	call	8004e58 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 8004fb0:	e0bff117 	ldw	r2,-60(fp)
 8004fb4:	10880020 	cmpeqi	r2,r2,8192
 8004fb8:	10803fcc 	andi	r2,r2,255
 8004fbc:	00000506 	br	8004fd4 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 8004fc0:	8004f080 	call	8004f08 <alt_get_errno>
 8004fc4:	1007883a 	mov	r3,r2
 8004fc8:	00801444 	movi	r2,81
 8004fcc:	18800015 	stw	r2,0(r3)
    return 0;
 8004fd0:	0005883a 	mov	r2,zero
  }
}
 8004fd4:	e037883a 	mov	sp,fp
 8004fd8:	dfc00117 	ldw	ra,4(sp)
 8004fdc:	df000017 	ldw	fp,0(sp)
 8004fe0:	dec00204 	addi	sp,sp,8
 8004fe4:	f800283a 	ret

08004fe8 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 8004fe8:	defffc04 	addi	sp,sp,-16
 8004fec:	df000315 	stw	fp,12(sp)
 8004ff0:	df000304 	addi	fp,sp,12
 8004ff4:	e13ffd15 	stw	r4,-12(fp)
 8004ff8:	e17ffe15 	stw	r5,-8(fp)
 8004ffc:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 8005000:	e0fffe17 	ldw	r3,-8(fp)
 8005004:	e0bffd17 	ldw	r2,-12(fp)
 8005008:	18800c26 	beq	r3,r2,800503c <alt_load_section+0x54>
  {
    while( to != end )
 800500c:	00000806 	br	8005030 <alt_load_section+0x48>
    {
      *to++ = *from++;
 8005010:	e0bffe17 	ldw	r2,-8(fp)
 8005014:	10c00104 	addi	r3,r2,4
 8005018:	e0fffe15 	stw	r3,-8(fp)
 800501c:	e0fffd17 	ldw	r3,-12(fp)
 8005020:	19000104 	addi	r4,r3,4
 8005024:	e13ffd15 	stw	r4,-12(fp)
 8005028:	18c00017 	ldw	r3,0(r3)
 800502c:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 8005030:	e0fffe17 	ldw	r3,-8(fp)
 8005034:	e0bfff17 	ldw	r2,-4(fp)
 8005038:	18bff51e 	bne	r3,r2,8005010 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 800503c:	0001883a 	nop
 8005040:	e037883a 	mov	sp,fp
 8005044:	df000017 	ldw	fp,0(sp)
 8005048:	dec00104 	addi	sp,sp,4
 800504c:	f800283a 	ret

08005050 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 8005050:	defffe04 	addi	sp,sp,-8
 8005054:	dfc00115 	stw	ra,4(sp)
 8005058:	df000015 	stw	fp,0(sp)
 800505c:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 8005060:	01820134 	movhi	r6,2052
 8005064:	3189a904 	addi	r6,r6,9892
 8005068:	01420134 	movhi	r5,2052
 800506c:	2942d604 	addi	r5,r5,2904
 8005070:	01020134 	movhi	r4,2052
 8005074:	2109a904 	addi	r4,r4,9892
 8005078:	8004fe80 	call	8004fe8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 800507c:	01820034 	movhi	r6,2048
 8005080:	31809104 	addi	r6,r6,580
 8005084:	01420034 	movhi	r5,2048
 8005088:	29400804 	addi	r5,r5,32
 800508c:	01020034 	movhi	r4,2048
 8005090:	21000804 	addi	r4,r4,32
 8005094:	8004fe80 	call	8004fe8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 8005098:	01820134 	movhi	r6,2052
 800509c:	3182d604 	addi	r6,r6,2904
 80050a0:	01420074 	movhi	r5,2049
 80050a4:	29618904 	addi	r5,r5,-31196
 80050a8:	01020074 	movhi	r4,2049
 80050ac:	21218904 	addi	r4,r4,-31196
 80050b0:	8004fe80 	call	8004fe8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 80050b4:	80079000 	call	8007900 <alt_dcache_flush_all>
  alt_icache_flush_all();
 80050b8:	8007b780 	call	8007b78 <alt_icache_flush_all>
}
 80050bc:	0001883a 	nop
 80050c0:	e037883a 	mov	sp,fp
 80050c4:	dfc00117 	ldw	ra,4(sp)
 80050c8:	df000017 	ldw	fp,0(sp)
 80050cc:	dec00204 	addi	sp,sp,8
 80050d0:	f800283a 	ret

080050d4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 80050d4:	defffe04 	addi	sp,sp,-8
 80050d8:	dfc00115 	stw	ra,4(sp)
 80050dc:	df000015 	stw	fp,0(sp)
 80050e0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 80050e4:	d0a00917 	ldw	r2,-32732(gp)
 80050e8:	10000326 	beq	r2,zero,80050f8 <alt_get_errno+0x24>
 80050ec:	d0a00917 	ldw	r2,-32732(gp)
 80050f0:	103ee83a 	callr	r2
 80050f4:	00000106 	br	80050fc <alt_get_errno+0x28>
 80050f8:	d0a6e604 	addi	r2,gp,-25704
}
 80050fc:	e037883a 	mov	sp,fp
 8005100:	dfc00117 	ldw	ra,4(sp)
 8005104:	df000017 	ldw	fp,0(sp)
 8005108:	dec00204 	addi	sp,sp,8
 800510c:	f800283a 	ret

08005110 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 8005110:	defff904 	addi	sp,sp,-28
 8005114:	dfc00615 	stw	ra,24(sp)
 8005118:	df000515 	stw	fp,20(sp)
 800511c:	df000504 	addi	fp,sp,20
 8005120:	e13ffd15 	stw	r4,-12(fp)
 8005124:	e17ffe15 	stw	r5,-8(fp)
 8005128:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 800512c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8005130:	e0bffd17 	ldw	r2,-12(fp)
 8005134:	10000616 	blt	r2,zero,8005150 <lseek+0x40>
 8005138:	e0bffd17 	ldw	r2,-12(fp)
 800513c:	10c00324 	muli	r3,r2,12
 8005140:	00820134 	movhi	r2,2052
 8005144:	1084eb04 	addi	r2,r2,5036
 8005148:	1885883a 	add	r2,r3,r2
 800514c:	00000106 	br	8005154 <lseek+0x44>
 8005150:	0005883a 	mov	r2,zero
 8005154:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 8005158:	e0bffc17 	ldw	r2,-16(fp)
 800515c:	10001026 	beq	r2,zero,80051a0 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 8005160:	e0bffc17 	ldw	r2,-16(fp)
 8005164:	10800017 	ldw	r2,0(r2)
 8005168:	10800717 	ldw	r2,28(r2)
 800516c:	10000926 	beq	r2,zero,8005194 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 8005170:	e0bffc17 	ldw	r2,-16(fp)
 8005174:	10800017 	ldw	r2,0(r2)
 8005178:	10800717 	ldw	r2,28(r2)
 800517c:	e1bfff17 	ldw	r6,-4(fp)
 8005180:	e17ffe17 	ldw	r5,-8(fp)
 8005184:	e13ffc17 	ldw	r4,-16(fp)
 8005188:	103ee83a 	callr	r2
 800518c:	e0bffb15 	stw	r2,-20(fp)
 8005190:	00000506 	br	80051a8 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 8005194:	00bfde84 	movi	r2,-134
 8005198:	e0bffb15 	stw	r2,-20(fp)
 800519c:	00000206 	br	80051a8 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 80051a0:	00bfebc4 	movi	r2,-81
 80051a4:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 80051a8:	e0bffb17 	ldw	r2,-20(fp)
 80051ac:	1000070e 	bge	r2,zero,80051cc <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 80051b0:	80050d40 	call	80050d4 <alt_get_errno>
 80051b4:	1007883a 	mov	r3,r2
 80051b8:	e0bffb17 	ldw	r2,-20(fp)
 80051bc:	0085c83a 	sub	r2,zero,r2
 80051c0:	18800015 	stw	r2,0(r3)
    rc = -1;
 80051c4:	00bfffc4 	movi	r2,-1
 80051c8:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 80051cc:	e0bffb17 	ldw	r2,-20(fp)
}
 80051d0:	e037883a 	mov	sp,fp
 80051d4:	dfc00117 	ldw	ra,4(sp)
 80051d8:	df000017 	ldw	fp,0(sp)
 80051dc:	dec00204 	addi	sp,sp,8
 80051e0:	f800283a 	ret

080051e4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 80051e4:	defffd04 	addi	sp,sp,-12
 80051e8:	dfc00215 	stw	ra,8(sp)
 80051ec:	df000115 	stw	fp,4(sp)
 80051f0:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 80051f4:	0009883a 	mov	r4,zero
 80051f8:	80057e40 	call	80057e4 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 80051fc:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 8005200:	800581c0 	call	800581c <alt_sys_init>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 8005204:	8007a280 	call	8007a28 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 8005208:	01020034 	movhi	r4,2048
 800520c:	211ea204 	addi	r4,r4,31368
 8005210:	8007f9c0 	call	8007f9c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 8005214:	d0a6e717 	ldw	r2,-25700(gp)
 8005218:	d0e6e817 	ldw	r3,-25696(gp)
 800521c:	d126e917 	ldw	r4,-25692(gp)
 8005220:	200d883a 	mov	r6,r4
 8005224:	180b883a 	mov	r5,r3
 8005228:	1009883a 	mov	r4,r2
 800522c:	800039c0 	call	800039c <main>
 8005230:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 8005234:	01000044 	movi	r4,1
 8005238:	8004d200 	call	8004d20 <close>
  exit (result);
 800523c:	e13fff17 	ldw	r4,-4(fp)
 8005240:	8007fd80 	call	8007fd8 <exit>

08005244 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 8005244:	defffe04 	addi	sp,sp,-8
 8005248:	df000115 	stw	fp,4(sp)
 800524c:	df000104 	addi	fp,sp,4
 8005250:	e13fff15 	stw	r4,-4(fp)
}
 8005254:	0001883a 	nop
 8005258:	e037883a 	mov	sp,fp
 800525c:	df000017 	ldw	fp,0(sp)
 8005260:	dec00104 	addi	sp,sp,4
 8005264:	f800283a 	ret

08005268 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 8005268:	defffe04 	addi	sp,sp,-8
 800526c:	df000115 	stw	fp,4(sp)
 8005270:	df000104 	addi	fp,sp,4
 8005274:	e13fff15 	stw	r4,-4(fp)
}
 8005278:	0001883a 	nop
 800527c:	e037883a 	mov	sp,fp
 8005280:	df000017 	ldw	fp,0(sp)
 8005284:	dec00104 	addi	sp,sp,4
 8005288:	f800283a 	ret

0800528c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800528c:	defffe04 	addi	sp,sp,-8
 8005290:	dfc00115 	stw	ra,4(sp)
 8005294:	df000015 	stw	fp,0(sp)
 8005298:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800529c:	d0a00917 	ldw	r2,-32732(gp)
 80052a0:	10000326 	beq	r2,zero,80052b0 <alt_get_errno+0x24>
 80052a4:	d0a00917 	ldw	r2,-32732(gp)
 80052a8:	103ee83a 	callr	r2
 80052ac:	00000106 	br	80052b4 <alt_get_errno+0x28>
 80052b0:	d0a6e604 	addi	r2,gp,-25704
}
 80052b4:	e037883a 	mov	sp,fp
 80052b8:	dfc00117 	ldw	ra,4(sp)
 80052bc:	df000017 	ldw	fp,0(sp)
 80052c0:	dec00204 	addi	sp,sp,8
 80052c4:	f800283a 	ret

080052c8 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 80052c8:	defff904 	addi	sp,sp,-28
 80052cc:	dfc00615 	stw	ra,24(sp)
 80052d0:	df000515 	stw	fp,20(sp)
 80052d4:	df000504 	addi	fp,sp,20
 80052d8:	e13ffd15 	stw	r4,-12(fp)
 80052dc:	e17ffe15 	stw	r5,-8(fp)
 80052e0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 80052e4:	e0bffd17 	ldw	r2,-12(fp)
 80052e8:	10000616 	blt	r2,zero,8005304 <read+0x3c>
 80052ec:	e0bffd17 	ldw	r2,-12(fp)
 80052f0:	10c00324 	muli	r3,r2,12
 80052f4:	00820134 	movhi	r2,2052
 80052f8:	1084eb04 	addi	r2,r2,5036
 80052fc:	1885883a 	add	r2,r3,r2
 8005300:	00000106 	br	8005308 <read+0x40>
 8005304:	0005883a 	mov	r2,zero
 8005308:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 800530c:	e0bffb17 	ldw	r2,-20(fp)
 8005310:	10002226 	beq	r2,zero,800539c <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 8005314:	e0bffb17 	ldw	r2,-20(fp)
 8005318:	10800217 	ldw	r2,8(r2)
 800531c:	108000cc 	andi	r2,r2,3
 8005320:	10800060 	cmpeqi	r2,r2,1
 8005324:	1000181e 	bne	r2,zero,8005388 <read+0xc0>
        (fd->dev->read))
 8005328:	e0bffb17 	ldw	r2,-20(fp)
 800532c:	10800017 	ldw	r2,0(r2)
 8005330:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 8005334:	10001426 	beq	r2,zero,8005388 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 8005338:	e0bffb17 	ldw	r2,-20(fp)
 800533c:	10800017 	ldw	r2,0(r2)
 8005340:	10800517 	ldw	r2,20(r2)
 8005344:	e0ffff17 	ldw	r3,-4(fp)
 8005348:	180d883a 	mov	r6,r3
 800534c:	e17ffe17 	ldw	r5,-8(fp)
 8005350:	e13ffb17 	ldw	r4,-20(fp)
 8005354:	103ee83a 	callr	r2
 8005358:	e0bffc15 	stw	r2,-16(fp)
 800535c:	e0bffc17 	ldw	r2,-16(fp)
 8005360:	1000070e 	bge	r2,zero,8005380 <read+0xb8>
        {
          ALT_ERRNO = -rval;
 8005364:	800528c0 	call	800528c <alt_get_errno>
 8005368:	1007883a 	mov	r3,r2
 800536c:	e0bffc17 	ldw	r2,-16(fp)
 8005370:	0085c83a 	sub	r2,zero,r2
 8005374:	18800015 	stw	r2,0(r3)
          return -1;
 8005378:	00bfffc4 	movi	r2,-1
 800537c:	00000c06 	br	80053b0 <read+0xe8>
        }
        return rval;
 8005380:	e0bffc17 	ldw	r2,-16(fp)
 8005384:	00000a06 	br	80053b0 <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 8005388:	800528c0 	call	800528c <alt_get_errno>
 800538c:	1007883a 	mov	r3,r2
 8005390:	00800344 	movi	r2,13
 8005394:	18800015 	stw	r2,0(r3)
 8005398:	00000406 	br	80053ac <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 800539c:	800528c0 	call	800528c <alt_get_errno>
 80053a0:	1007883a 	mov	r3,r2
 80053a4:	00801444 	movi	r2,81
 80053a8:	18800015 	stw	r2,0(r3)
  }
  return -1;
 80053ac:	00bfffc4 	movi	r2,-1
}
 80053b0:	e037883a 	mov	sp,fp
 80053b4:	dfc00117 	ldw	ra,4(sp)
 80053b8:	df000017 	ldw	fp,0(sp)
 80053bc:	dec00204 	addi	sp,sp,8
 80053c0:	f800283a 	ret

080053c4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 80053c4:	defffe04 	addi	sp,sp,-8
 80053c8:	df000115 	stw	fp,4(sp)
 80053cc:	df000104 	addi	fp,sp,4
 80053d0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 80053d4:	e0bfff17 	ldw	r2,-4(fp)
 80053d8:	108000d0 	cmplti	r2,r2,3
 80053dc:	10000d1e 	bne	r2,zero,8005414 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 80053e0:	00820134 	movhi	r2,2052
 80053e4:	1084eb04 	addi	r2,r2,5036
 80053e8:	e0ffff17 	ldw	r3,-4(fp)
 80053ec:	18c00324 	muli	r3,r3,12
 80053f0:	10c5883a 	add	r2,r2,r3
 80053f4:	10800204 	addi	r2,r2,8
 80053f8:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 80053fc:	00820134 	movhi	r2,2052
 8005400:	1084eb04 	addi	r2,r2,5036
 8005404:	e0ffff17 	ldw	r3,-4(fp)
 8005408:	18c00324 	muli	r3,r3,12
 800540c:	10c5883a 	add	r2,r2,r3
 8005410:	10000015 	stw	zero,0(r2)
  }
}
 8005414:	0001883a 	nop
 8005418:	e037883a 	mov	sp,fp
 800541c:	df000017 	ldw	fp,0(sp)
 8005420:	dec00104 	addi	sp,sp,4
 8005424:	f800283a 	ret

08005428 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 8005428:	defff904 	addi	sp,sp,-28
 800542c:	df000615 	stw	fp,24(sp)
 8005430:	df000604 	addi	fp,sp,24
 8005434:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8005438:	0005303a 	rdctl	r2,status
 800543c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8005440:	e0fffe17 	ldw	r3,-8(fp)
 8005444:	00bfff84 	movi	r2,-2
 8005448:	1884703a 	and	r2,r3,r2
 800544c:	1001703a 	wrctl	status,r2
  
  return context;
 8005450:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 8005454:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 8005458:	d0a00a17 	ldw	r2,-32728(gp)
 800545c:	10c000c4 	addi	r3,r2,3
 8005460:	00bfff04 	movi	r2,-4
 8005464:	1884703a 	and	r2,r3,r2
 8005468:	d0a00a15 	stw	r2,-32728(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 800546c:	d0e00a17 	ldw	r3,-32728(gp)
 8005470:	e0bfff17 	ldw	r2,-4(fp)
 8005474:	1887883a 	add	r3,r3,r2
 8005478:	00840034 	movhi	r2,4096
 800547c:	10800004 	addi	r2,r2,0
 8005480:	10c0062e 	bgeu	r2,r3,800549c <sbrk+0x74>
 8005484:	e0bffb17 	ldw	r2,-20(fp)
 8005488:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800548c:	e0bffa17 	ldw	r2,-24(fp)
 8005490:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 8005494:	00bfffc4 	movi	r2,-1
 8005498:	00000b06 	br	80054c8 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 800549c:	d0a00a17 	ldw	r2,-32728(gp)
 80054a0:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 80054a4:	d0e00a17 	ldw	r3,-32728(gp)
 80054a8:	e0bfff17 	ldw	r2,-4(fp)
 80054ac:	1885883a 	add	r2,r3,r2
 80054b0:	d0a00a15 	stw	r2,-32728(gp)
 80054b4:	e0bffb17 	ldw	r2,-20(fp)
 80054b8:	e0bffc15 	stw	r2,-16(fp)
 80054bc:	e0bffc17 	ldw	r2,-16(fp)
 80054c0:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 80054c4:	e0bffd17 	ldw	r2,-12(fp)
} 
 80054c8:	e037883a 	mov	sp,fp
 80054cc:	df000017 	ldw	fp,0(sp)
 80054d0:	dec00104 	addi	sp,sp,4
 80054d4:	f800283a 	ret

080054d8 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 80054d8:	defffa04 	addi	sp,sp,-24
 80054dc:	df000515 	stw	fp,20(sp)
 80054e0:	df000504 	addi	fp,sp,20
 80054e4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 80054e8:	0005303a 	rdctl	r2,status
 80054ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 80054f0:	e0fffc17 	ldw	r3,-16(fp)
 80054f4:	00bfff84 	movi	r2,-2
 80054f8:	1884703a 	and	r2,r3,r2
 80054fc:	1001703a 	wrctl	status,r2
  
  return context;
 8005500:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 8005504:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 8005508:	e0bfff17 	ldw	r2,-4(fp)
 800550c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 8005510:	e0bffd17 	ldw	r2,-12(fp)
 8005514:	10800017 	ldw	r2,0(r2)
 8005518:	e0fffd17 	ldw	r3,-12(fp)
 800551c:	18c00117 	ldw	r3,4(r3)
 8005520:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 8005524:	e0bffd17 	ldw	r2,-12(fp)
 8005528:	10800117 	ldw	r2,4(r2)
 800552c:	e0fffd17 	ldw	r3,-12(fp)
 8005530:	18c00017 	ldw	r3,0(r3)
 8005534:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 8005538:	e0bffd17 	ldw	r2,-12(fp)
 800553c:	e0fffd17 	ldw	r3,-12(fp)
 8005540:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 8005544:	e0bffd17 	ldw	r2,-12(fp)
 8005548:	e0fffd17 	ldw	r3,-12(fp)
 800554c:	10c00015 	stw	r3,0(r2)
 8005550:	e0bffb17 	ldw	r2,-20(fp)
 8005554:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8005558:	e0bffe17 	ldw	r2,-8(fp)
 800555c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 8005560:	0001883a 	nop
 8005564:	e037883a 	mov	sp,fp
 8005568:	df000017 	ldw	fp,0(sp)
 800556c:	dec00104 	addi	sp,sp,4
 8005570:	f800283a 	ret

08005574 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 8005574:	defffb04 	addi	sp,sp,-20
 8005578:	dfc00415 	stw	ra,16(sp)
 800557c:	df000315 	stw	fp,12(sp)
 8005580:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 8005584:	d0a00b17 	ldw	r2,-32724(gp)
 8005588:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 800558c:	d0a6eb17 	ldw	r2,-25684(gp)
 8005590:	10800044 	addi	r2,r2,1
 8005594:	d0a6eb15 	stw	r2,-25684(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 8005598:	00002e06 	br	8005654 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 800559c:	e0bffd17 	ldw	r2,-12(fp)
 80055a0:	10800017 	ldw	r2,0(r2)
 80055a4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 80055a8:	e0bffd17 	ldw	r2,-12(fp)
 80055ac:	10800403 	ldbu	r2,16(r2)
 80055b0:	10803fcc 	andi	r2,r2,255
 80055b4:	10000426 	beq	r2,zero,80055c8 <alt_tick+0x54>
 80055b8:	d0a6eb17 	ldw	r2,-25684(gp)
 80055bc:	1000021e 	bne	r2,zero,80055c8 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 80055c0:	e0bffd17 	ldw	r2,-12(fp)
 80055c4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 80055c8:	e0bffd17 	ldw	r2,-12(fp)
 80055cc:	10800217 	ldw	r2,8(r2)
 80055d0:	d0e6eb17 	ldw	r3,-25684(gp)
 80055d4:	18801d36 	bltu	r3,r2,800564c <alt_tick+0xd8>
 80055d8:	e0bffd17 	ldw	r2,-12(fp)
 80055dc:	10800403 	ldbu	r2,16(r2)
 80055e0:	10803fcc 	andi	r2,r2,255
 80055e4:	1000191e 	bne	r2,zero,800564c <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 80055e8:	e0bffd17 	ldw	r2,-12(fp)
 80055ec:	10800317 	ldw	r2,12(r2)
 80055f0:	e0fffd17 	ldw	r3,-12(fp)
 80055f4:	18c00517 	ldw	r3,20(r3)
 80055f8:	1809883a 	mov	r4,r3
 80055fc:	103ee83a 	callr	r2
 8005600:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 8005604:	e0bfff17 	ldw	r2,-4(fp)
 8005608:	1000031e 	bne	r2,zero,8005618 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 800560c:	e13ffd17 	ldw	r4,-12(fp)
 8005610:	80054d80 	call	80054d8 <alt_alarm_stop>
 8005614:	00000d06 	br	800564c <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 8005618:	e0bffd17 	ldw	r2,-12(fp)
 800561c:	10c00217 	ldw	r3,8(r2)
 8005620:	e0bfff17 	ldw	r2,-4(fp)
 8005624:	1887883a 	add	r3,r3,r2
 8005628:	e0bffd17 	ldw	r2,-12(fp)
 800562c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 8005630:	e0bffd17 	ldw	r2,-12(fp)
 8005634:	10c00217 	ldw	r3,8(r2)
 8005638:	d0a6eb17 	ldw	r2,-25684(gp)
 800563c:	1880032e 	bgeu	r3,r2,800564c <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 8005640:	e0bffd17 	ldw	r2,-12(fp)
 8005644:	00c00044 	movi	r3,1
 8005648:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 800564c:	e0bffe17 	ldw	r2,-8(fp)
 8005650:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 8005654:	e0fffd17 	ldw	r3,-12(fp)
 8005658:	d0a00b04 	addi	r2,gp,-32724
 800565c:	18bfcf1e 	bne	r3,r2,800559c <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 8005660:	0001883a 	nop
}
 8005664:	0001883a 	nop
 8005668:	e037883a 	mov	sp,fp
 800566c:	dfc00117 	ldw	ra,4(sp)
 8005670:	df000017 	ldw	fp,0(sp)
 8005674:	dec00204 	addi	sp,sp,8
 8005678:	f800283a 	ret

0800567c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800567c:	defffe04 	addi	sp,sp,-8
 8005680:	dfc00115 	stw	ra,4(sp)
 8005684:	df000015 	stw	fp,0(sp)
 8005688:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800568c:	d0a00917 	ldw	r2,-32732(gp)
 8005690:	10000326 	beq	r2,zero,80056a0 <alt_get_errno+0x24>
 8005694:	d0a00917 	ldw	r2,-32732(gp)
 8005698:	103ee83a 	callr	r2
 800569c:	00000106 	br	80056a4 <alt_get_errno+0x28>
 80056a0:	d0a6e604 	addi	r2,gp,-25704
}
 80056a4:	e037883a 	mov	sp,fp
 80056a8:	dfc00117 	ldw	ra,4(sp)
 80056ac:	df000017 	ldw	fp,0(sp)
 80056b0:	dec00204 	addi	sp,sp,8
 80056b4:	f800283a 	ret

080056b8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 80056b8:	defff904 	addi	sp,sp,-28
 80056bc:	dfc00615 	stw	ra,24(sp)
 80056c0:	df000515 	stw	fp,20(sp)
 80056c4:	df000504 	addi	fp,sp,20
 80056c8:	e13ffd15 	stw	r4,-12(fp)
 80056cc:	e17ffe15 	stw	r5,-8(fp)
 80056d0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 80056d4:	e0bffd17 	ldw	r2,-12(fp)
 80056d8:	10000616 	blt	r2,zero,80056f4 <write+0x3c>
 80056dc:	e0bffd17 	ldw	r2,-12(fp)
 80056e0:	10c00324 	muli	r3,r2,12
 80056e4:	00820134 	movhi	r2,2052
 80056e8:	1084eb04 	addi	r2,r2,5036
 80056ec:	1885883a 	add	r2,r3,r2
 80056f0:	00000106 	br	80056f8 <write+0x40>
 80056f4:	0005883a 	mov	r2,zero
 80056f8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 80056fc:	e0bffb17 	ldw	r2,-20(fp)
 8005700:	10002126 	beq	r2,zero,8005788 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 8005704:	e0bffb17 	ldw	r2,-20(fp)
 8005708:	10800217 	ldw	r2,8(r2)
 800570c:	108000cc 	andi	r2,r2,3
 8005710:	10001826 	beq	r2,zero,8005774 <write+0xbc>
 8005714:	e0bffb17 	ldw	r2,-20(fp)
 8005718:	10800017 	ldw	r2,0(r2)
 800571c:	10800617 	ldw	r2,24(r2)
 8005720:	10001426 	beq	r2,zero,8005774 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 8005724:	e0bffb17 	ldw	r2,-20(fp)
 8005728:	10800017 	ldw	r2,0(r2)
 800572c:	10800617 	ldw	r2,24(r2)
 8005730:	e0ffff17 	ldw	r3,-4(fp)
 8005734:	180d883a 	mov	r6,r3
 8005738:	e17ffe17 	ldw	r5,-8(fp)
 800573c:	e13ffb17 	ldw	r4,-20(fp)
 8005740:	103ee83a 	callr	r2
 8005744:	e0bffc15 	stw	r2,-16(fp)
 8005748:	e0bffc17 	ldw	r2,-16(fp)
 800574c:	1000070e 	bge	r2,zero,800576c <write+0xb4>
      {
        ALT_ERRNO = -rval;
 8005750:	800567c0 	call	800567c <alt_get_errno>
 8005754:	1007883a 	mov	r3,r2
 8005758:	e0bffc17 	ldw	r2,-16(fp)
 800575c:	0085c83a 	sub	r2,zero,r2
 8005760:	18800015 	stw	r2,0(r3)
        return -1;
 8005764:	00bfffc4 	movi	r2,-1
 8005768:	00000c06 	br	800579c <write+0xe4>
      }
      return rval;
 800576c:	e0bffc17 	ldw	r2,-16(fp)
 8005770:	00000a06 	br	800579c <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 8005774:	800567c0 	call	800567c <alt_get_errno>
 8005778:	1007883a 	mov	r3,r2
 800577c:	00800344 	movi	r2,13
 8005780:	18800015 	stw	r2,0(r3)
 8005784:	00000406 	br	8005798 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 8005788:	800567c0 	call	800567c <alt_get_errno>
 800578c:	1007883a 	mov	r3,r2
 8005790:	00801444 	movi	r2,81
 8005794:	18800015 	stw	r2,0(r3)
  }
  return -1;
 8005798:	00bfffc4 	movi	r2,-1
}
 800579c:	e037883a 	mov	sp,fp
 80057a0:	dfc00117 	ldw	ra,4(sp)
 80057a4:	df000017 	ldw	fp,0(sp)
 80057a8:	dec00204 	addi	sp,sp,8
 80057ac:	f800283a 	ret

080057b0 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 80057b0:	defffd04 	addi	sp,sp,-12
 80057b4:	dfc00215 	stw	ra,8(sp)
 80057b8:	df000115 	stw	fp,4(sp)
 80057bc:	df000104 	addi	fp,sp,4
 80057c0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 80057c4:	d1600604 	addi	r5,gp,-32744
 80057c8:	e13fff17 	ldw	r4,-4(fp)
 80057cc:	80079840 	call	8007984 <alt_dev_llist_insert>
}
 80057d0:	e037883a 	mov	sp,fp
 80057d4:	dfc00117 	ldw	ra,4(sp)
 80057d8:	df000017 	ldw	fp,0(sp)
 80057dc:	dec00204 	addi	sp,sp,8
 80057e0:	f800283a 	ret

080057e4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 80057e4:	defffd04 	addi	sp,sp,-12
 80057e8:	dfc00215 	stw	ra,8(sp)
 80057ec:	df000115 	stw	fp,4(sp)
 80057f0:	df000104 	addi	fp,sp,4
 80057f4:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
 80057f8:	8007e4c0 	call	8007e4c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 80057fc:	00800044 	movi	r2,1
 8005800:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 8005804:	0001883a 	nop
 8005808:	e037883a 	mov	sp,fp
 800580c:	dfc00117 	ldw	ra,4(sp)
 8005810:	df000017 	ldw	fp,0(sp)
 8005814:	dec00204 	addi	sp,sp,8
 8005818:	f800283a 	ret

0800581c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 800581c:	defffd04 	addi	sp,sp,-12
 8005820:	dfc00215 	stw	ra,8(sp)
 8005824:	df000115 	stw	fp,4(sp)
 8005828:	df000104 	addi	fp,sp,4
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 800582c:	000d883a 	mov	r6,zero
 8005830:	000b883a 	mov	r5,zero
 8005834:	01020134 	movhi	r4,2052
 8005838:	21055504 	addi	r4,r4,5460
 800583c:	8005d3c0 	call	8005d3c <altera_avalon_jtag_uart_init>
 8005840:	01020134 	movhi	r4,2052
 8005844:	21054b04 	addi	r4,r4,5420
 8005848:	80057b00 	call	80057b0 <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_CHARACTER_BUFFER_WITH_DMA_INIT ( VIDEO_CHARACTER_BUFFER_WITH_DMA_0, video_character_buffer_with_dma_0);
 800584c:	00820134 	movhi	r2,2052
 8005850:	10896304 	addi	r2,r2,9612
 8005854:	10800a17 	ldw	r2,40(r2)
 8005858:	10800104 	addi	r2,r2,4
 800585c:	10800017 	ldw	r2,0(r2)
 8005860:	10ffffcc 	andi	r3,r2,65535
 8005864:	00820134 	movhi	r2,2052
 8005868:	10896304 	addi	r2,r2,9612
 800586c:	10c00c15 	stw	r3,48(r2)
 8005870:	00820134 	movhi	r2,2052
 8005874:	10896304 	addi	r2,r2,9612
 8005878:	10800a17 	ldw	r2,40(r2)
 800587c:	10800104 	addi	r2,r2,4
 8005880:	10800017 	ldw	r2,0(r2)
 8005884:	1006d43a 	srli	r3,r2,16
 8005888:	00820134 	movhi	r2,2052
 800588c:	10896304 	addi	r2,r2,9612
 8005890:	10c00d15 	stw	r3,52(r2)
 8005894:	00820134 	movhi	r2,2052
 8005898:	10896304 	addi	r2,r2,9612
 800589c:	10800c17 	ldw	r2,48(r2)
 80058a0:	10801068 	cmpgeui	r2,r2,65
 80058a4:	1000081e 	bne	r2,zero,80058c8 <alt_sys_init+0xac>
 80058a8:	00820134 	movhi	r2,2052
 80058ac:	10896304 	addi	r2,r2,9612
 80058b0:	00c00fc4 	movi	r3,63
 80058b4:	10c00f15 	stw	r3,60(r2)
 80058b8:	00820134 	movhi	r2,2052
 80058bc:	10896304 	addi	r2,r2,9612
 80058c0:	00c00184 	movi	r3,6
 80058c4:	10c01015 	stw	r3,64(r2)
 80058c8:	00820134 	movhi	r2,2052
 80058cc:	10896304 	addi	r2,r2,9612
 80058d0:	10800d17 	ldw	r2,52(r2)
 80058d4:	10800868 	cmpgeui	r2,r2,33
 80058d8:	1000041e 	bne	r2,zero,80058ec <alt_sys_init+0xd0>
 80058dc:	00820134 	movhi	r2,2052
 80058e0:	10896304 	addi	r2,r2,9612
 80058e4:	00c007c4 	movi	r3,31
 80058e8:	10c01115 	stw	r3,68(r2)
 80058ec:	01020134 	movhi	r4,2052
 80058f0:	21096304 	addi	r4,r4,9612
 80058f4:	80066400 	call	8006640 <alt_up_char_buffer_init>
 80058f8:	01020134 	movhi	r4,2052
 80058fc:	21096304 	addi	r4,r4,9612
 8005900:	80057b00 	call	80057b0 <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_PIXEL_BUFFER_DMA_INIT ( VIDEO_PIXEL_BUFFER_DMA_0, video_pixel_buffer_dma_0);
 8005904:	00820134 	movhi	r2,2052
 8005908:	10897504 	addi	r2,r2,9684
 800590c:	10800a17 	ldw	r2,40(r2)
 8005910:	10800017 	ldw	r2,0(r2)
 8005914:	1007883a 	mov	r3,r2
 8005918:	00820134 	movhi	r2,2052
 800591c:	10897504 	addi	r2,r2,9684
 8005920:	10c00b15 	stw	r3,44(r2)
 8005924:	00820134 	movhi	r2,2052
 8005928:	10897504 	addi	r2,r2,9684
 800592c:	10800a17 	ldw	r2,40(r2)
 8005930:	10800104 	addi	r2,r2,4
 8005934:	10800017 	ldw	r2,0(r2)
 8005938:	1007883a 	mov	r3,r2
 800593c:	00820134 	movhi	r2,2052
 8005940:	10897504 	addi	r2,r2,9684
 8005944:	10c00c15 	stw	r3,48(r2)
 8005948:	00820134 	movhi	r2,2052
 800594c:	10897504 	addi	r2,r2,9684
 8005950:	10800a17 	ldw	r2,40(r2)
 8005954:	10800204 	addi	r2,r2,8
 8005958:	10800017 	ldw	r2,0(r2)
 800595c:	10ffffcc 	andi	r3,r2,65535
 8005960:	00820134 	movhi	r2,2052
 8005964:	10897504 	addi	r2,r2,9684
 8005968:	10c00f15 	stw	r3,60(r2)
 800596c:	00820134 	movhi	r2,2052
 8005970:	10897504 	addi	r2,r2,9684
 8005974:	10800a17 	ldw	r2,40(r2)
 8005978:	10800204 	addi	r2,r2,8
 800597c:	10800017 	ldw	r2,0(r2)
 8005980:	1006d43a 	srli	r3,r2,16
 8005984:	00820134 	movhi	r2,2052
 8005988:	10897504 	addi	r2,r2,9684
 800598c:	10c01015 	stw	r3,64(r2)
 8005990:	00820134 	movhi	r2,2052
 8005994:	10897504 	addi	r2,r2,9684
 8005998:	10800a17 	ldw	r2,40(r2)
 800599c:	10800304 	addi	r2,r2,12
 80059a0:	10800017 	ldw	r2,0(r2)
 80059a4:	1005d07a 	srai	r2,r2,1
 80059a8:	10c0004c 	andi	r3,r2,1
 80059ac:	00820134 	movhi	r2,2052
 80059b0:	10897504 	addi	r2,r2,9684
 80059b4:	10c00d15 	stw	r3,52(r2)
 80059b8:	00820134 	movhi	r2,2052
 80059bc:	10897504 	addi	r2,r2,9684
 80059c0:	10800a17 	ldw	r2,40(r2)
 80059c4:	10800304 	addi	r2,r2,12
 80059c8:	10800017 	ldw	r2,0(r2)
 80059cc:	1005d13a 	srai	r2,r2,4
 80059d0:	10c003cc 	andi	r3,r2,15
 80059d4:	00820134 	movhi	r2,2052
 80059d8:	10897504 	addi	r2,r2,9684
 80059dc:	10c00e15 	stw	r3,56(r2)
 80059e0:	00820134 	movhi	r2,2052
 80059e4:	10897504 	addi	r2,r2,9684
 80059e8:	10800a17 	ldw	r2,40(r2)
 80059ec:	10800304 	addi	r2,r2,12
 80059f0:	10800017 	ldw	r2,0(r2)
 80059f4:	1005d43a 	srai	r2,r2,16
 80059f8:	e0bfff05 	stb	r2,-4(fp)
 80059fc:	00820134 	movhi	r2,2052
 8005a00:	10897504 	addi	r2,r2,9684
 8005a04:	10800a17 	ldw	r2,40(r2)
 8005a08:	10800304 	addi	r2,r2,12
 8005a0c:	10800017 	ldw	r2,0(r2)
 8005a10:	1004d63a 	srli	r2,r2,24
 8005a14:	e0bfff45 	stb	r2,-3(fp)
 8005a18:	00820134 	movhi	r2,2052
 8005a1c:	10897504 	addi	r2,r2,9684
 8005a20:	10800e17 	ldw	r2,56(r2)
 8005a24:	10800058 	cmpnei	r2,r2,1
 8005a28:	1000041e 	bne	r2,zero,8005a3c <alt_sys_init+0x220>
 8005a2c:	00820134 	movhi	r2,2052
 8005a30:	10897504 	addi	r2,r2,9684
 8005a34:	10001115 	stw	zero,68(r2)
 8005a38:	00000e06 	br	8005a74 <alt_sys_init+0x258>
 8005a3c:	00820134 	movhi	r2,2052
 8005a40:	10897504 	addi	r2,r2,9684
 8005a44:	10800e17 	ldw	r2,56(r2)
 8005a48:	10800098 	cmpnei	r2,r2,2
 8005a4c:	1000051e 	bne	r2,zero,8005a64 <alt_sys_init+0x248>
 8005a50:	00820134 	movhi	r2,2052
 8005a54:	10897504 	addi	r2,r2,9684
 8005a58:	00c00044 	movi	r3,1
 8005a5c:	10c01115 	stw	r3,68(r2)
 8005a60:	00000406 	br	8005a74 <alt_sys_init+0x258>
 8005a64:	00820134 	movhi	r2,2052
 8005a68:	10897504 	addi	r2,r2,9684
 8005a6c:	00c00084 	movi	r3,2
 8005a70:	10c01115 	stw	r3,68(r2)
 8005a74:	e0bfff03 	ldbu	r2,-4(fp)
 8005a78:	00c00804 	movi	r3,32
 8005a7c:	1885c83a 	sub	r2,r3,r2
 8005a80:	00ffffc4 	movi	r3,-1
 8005a84:	1886d83a 	srl	r3,r3,r2
 8005a88:	00820134 	movhi	r2,2052
 8005a8c:	10897504 	addi	r2,r2,9684
 8005a90:	10c01215 	stw	r3,72(r2)
 8005a94:	e0ffff03 	ldbu	r3,-4(fp)
 8005a98:	00820134 	movhi	r2,2052
 8005a9c:	10897504 	addi	r2,r2,9684
 8005aa0:	10801117 	ldw	r2,68(r2)
 8005aa4:	1887883a 	add	r3,r3,r2
 8005aa8:	00820134 	movhi	r2,2052
 8005aac:	10897504 	addi	r2,r2,9684
 8005ab0:	10c01315 	stw	r3,76(r2)
 8005ab4:	e0bfff43 	ldbu	r2,-3(fp)
 8005ab8:	00c00804 	movi	r3,32
 8005abc:	1885c83a 	sub	r2,r3,r2
 8005ac0:	00ffffc4 	movi	r3,-1
 8005ac4:	1886d83a 	srl	r3,r3,r2
 8005ac8:	00820134 	movhi	r2,2052
 8005acc:	10897504 	addi	r2,r2,9684
 8005ad0:	10c01415 	stw	r3,80(r2)
 8005ad4:	01020134 	movhi	r4,2052
 8005ad8:	21097504 	addi	r4,r4,9684
 8005adc:	80057b00 	call	80057b0 <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_RGB_RESAMPLER_INIT ( VIDEO_RGB_RESAMPLER_0, video_rgb_resampler_0);
 8005ae0:	00820134 	movhi	r2,2052
 8005ae4:	10898a04 	addi	r2,r2,9768
 8005ae8:	10800a17 	ldw	r2,40(r2)
 8005aec:	10800017 	ldw	r2,0(r2)
 8005af0:	10c003cc 	andi	r3,r2,15
 8005af4:	00820134 	movhi	r2,2052
 8005af8:	10898a04 	addi	r2,r2,9768
 8005afc:	10c00b15 	stw	r3,44(r2)
 8005b00:	00820134 	movhi	r2,2052
 8005b04:	10898a04 	addi	r2,r2,9768
 8005b08:	10800a17 	ldw	r2,40(r2)
 8005b0c:	10800017 	ldw	r2,0(r2)
 8005b10:	1005d13a 	srai	r2,r2,4
 8005b14:	10c0004c 	andi	r3,r2,1
 8005b18:	00820134 	movhi	r2,2052
 8005b1c:	10898a04 	addi	r2,r2,9768
 8005b20:	10c00c15 	stw	r3,48(r2)
 8005b24:	00820134 	movhi	r2,2052
 8005b28:	10898a04 	addi	r2,r2,9768
 8005b2c:	10800a17 	ldw	r2,40(r2)
 8005b30:	10800017 	ldw	r2,0(r2)
 8005b34:	1005d17a 	srai	r2,r2,5
 8005b38:	10c0004c 	andi	r3,r2,1
 8005b3c:	00820134 	movhi	r2,2052
 8005b40:	10898a04 	addi	r2,r2,9768
 8005b44:	10c00d15 	stw	r3,52(r2)
 8005b48:	00820134 	movhi	r2,2052
 8005b4c:	10898a04 	addi	r2,r2,9768
 8005b50:	10800a17 	ldw	r2,40(r2)
 8005b54:	10800017 	ldw	r2,0(r2)
 8005b58:	1005d43a 	srai	r2,r2,16
 8005b5c:	10c003cc 	andi	r3,r2,15
 8005b60:	00820134 	movhi	r2,2052
 8005b64:	10898a04 	addi	r2,r2,9768
 8005b68:	10c00e15 	stw	r3,56(r2)
 8005b6c:	00820134 	movhi	r2,2052
 8005b70:	10898a04 	addi	r2,r2,9768
 8005b74:	10800a17 	ldw	r2,40(r2)
 8005b78:	10800017 	ldw	r2,0(r2)
 8005b7c:	1005d53a 	srai	r2,r2,20
 8005b80:	10c0004c 	andi	r3,r2,1
 8005b84:	00820134 	movhi	r2,2052
 8005b88:	10898a04 	addi	r2,r2,9768
 8005b8c:	10c00f15 	stw	r3,60(r2)
 8005b90:	00820134 	movhi	r2,2052
 8005b94:	10898a04 	addi	r2,r2,9768
 8005b98:	10800a17 	ldw	r2,40(r2)
 8005b9c:	10800017 	ldw	r2,0(r2)
 8005ba0:	1005d57a 	srai	r2,r2,21
 8005ba4:	10c0004c 	andi	r3,r2,1
 8005ba8:	00820134 	movhi	r2,2052
 8005bac:	10898a04 	addi	r2,r2,9768
 8005bb0:	10c01015 	stw	r3,64(r2)
 8005bb4:	01020134 	movhi	r4,2052
 8005bb8:	21098a04 	addi	r4,r4,9768
 8005bbc:	80057b00 	call	80057b0 <alt_dev_reg>
}
 8005bc0:	0001883a 	nop
 8005bc4:	e037883a 	mov	sp,fp
 8005bc8:	dfc00117 	ldw	ra,4(sp)
 8005bcc:	df000017 	ldw	fp,0(sp)
 8005bd0:	dec00204 	addi	sp,sp,8
 8005bd4:	f800283a 	ret

08005bd8 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 8005bd8:	defffa04 	addi	sp,sp,-24
 8005bdc:	dfc00515 	stw	ra,20(sp)
 8005be0:	df000415 	stw	fp,16(sp)
 8005be4:	df000404 	addi	fp,sp,16
 8005be8:	e13ffd15 	stw	r4,-12(fp)
 8005bec:	e17ffe15 	stw	r5,-8(fp)
 8005bf0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 8005bf4:	e0bffd17 	ldw	r2,-12(fp)
 8005bf8:	10800017 	ldw	r2,0(r2)
 8005bfc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 8005c00:	e0bffc17 	ldw	r2,-16(fp)
 8005c04:	10c00a04 	addi	r3,r2,40
 8005c08:	e0bffd17 	ldw	r2,-12(fp)
 8005c0c:	10800217 	ldw	r2,8(r2)
 8005c10:	100f883a 	mov	r7,r2
 8005c14:	e1bfff17 	ldw	r6,-4(fp)
 8005c18:	e17ffe17 	ldw	r5,-8(fp)
 8005c1c:	1809883a 	mov	r4,r3
 8005c20:	80062000 	call	8006200 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 8005c24:	e037883a 	mov	sp,fp
 8005c28:	dfc00117 	ldw	ra,4(sp)
 8005c2c:	df000017 	ldw	fp,0(sp)
 8005c30:	dec00204 	addi	sp,sp,8
 8005c34:	f800283a 	ret

08005c38 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 8005c38:	defffa04 	addi	sp,sp,-24
 8005c3c:	dfc00515 	stw	ra,20(sp)
 8005c40:	df000415 	stw	fp,16(sp)
 8005c44:	df000404 	addi	fp,sp,16
 8005c48:	e13ffd15 	stw	r4,-12(fp)
 8005c4c:	e17ffe15 	stw	r5,-8(fp)
 8005c50:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 8005c54:	e0bffd17 	ldw	r2,-12(fp)
 8005c58:	10800017 	ldw	r2,0(r2)
 8005c5c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 8005c60:	e0bffc17 	ldw	r2,-16(fp)
 8005c64:	10c00a04 	addi	r3,r2,40
 8005c68:	e0bffd17 	ldw	r2,-12(fp)
 8005c6c:	10800217 	ldw	r2,8(r2)
 8005c70:	100f883a 	mov	r7,r2
 8005c74:	e1bfff17 	ldw	r6,-4(fp)
 8005c78:	e17ffe17 	ldw	r5,-8(fp)
 8005c7c:	1809883a 	mov	r4,r3
 8005c80:	800641c0 	call	800641c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 8005c84:	e037883a 	mov	sp,fp
 8005c88:	dfc00117 	ldw	ra,4(sp)
 8005c8c:	df000017 	ldw	fp,0(sp)
 8005c90:	dec00204 	addi	sp,sp,8
 8005c94:	f800283a 	ret

08005c98 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 8005c98:	defffc04 	addi	sp,sp,-16
 8005c9c:	dfc00315 	stw	ra,12(sp)
 8005ca0:	df000215 	stw	fp,8(sp)
 8005ca4:	df000204 	addi	fp,sp,8
 8005ca8:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 8005cac:	e0bfff17 	ldw	r2,-4(fp)
 8005cb0:	10800017 	ldw	r2,0(r2)
 8005cb4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 8005cb8:	e0bffe17 	ldw	r2,-8(fp)
 8005cbc:	10c00a04 	addi	r3,r2,40
 8005cc0:	e0bfff17 	ldw	r2,-4(fp)
 8005cc4:	10800217 	ldw	r2,8(r2)
 8005cc8:	100b883a 	mov	r5,r2
 8005ccc:	1809883a 	mov	r4,r3
 8005cd0:	80060a80 	call	80060a8 <altera_avalon_jtag_uart_close>
}
 8005cd4:	e037883a 	mov	sp,fp
 8005cd8:	dfc00117 	ldw	ra,4(sp)
 8005cdc:	df000017 	ldw	fp,0(sp)
 8005ce0:	dec00204 	addi	sp,sp,8
 8005ce4:	f800283a 	ret

08005ce8 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 8005ce8:	defffa04 	addi	sp,sp,-24
 8005cec:	dfc00515 	stw	ra,20(sp)
 8005cf0:	df000415 	stw	fp,16(sp)
 8005cf4:	df000404 	addi	fp,sp,16
 8005cf8:	e13ffd15 	stw	r4,-12(fp)
 8005cfc:	e17ffe15 	stw	r5,-8(fp)
 8005d00:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 8005d04:	e0bffd17 	ldw	r2,-12(fp)
 8005d08:	10800017 	ldw	r2,0(r2)
 8005d0c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 8005d10:	e0bffc17 	ldw	r2,-16(fp)
 8005d14:	10800a04 	addi	r2,r2,40
 8005d18:	e1bfff17 	ldw	r6,-4(fp)
 8005d1c:	e17ffe17 	ldw	r5,-8(fp)
 8005d20:	1009883a 	mov	r4,r2
 8005d24:	80061100 	call	8006110 <altera_avalon_jtag_uart_ioctl>
}
 8005d28:	e037883a 	mov	sp,fp
 8005d2c:	dfc00117 	ldw	ra,4(sp)
 8005d30:	df000017 	ldw	fp,0(sp)
 8005d34:	dec00204 	addi	sp,sp,8
 8005d38:	f800283a 	ret

08005d3c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 8005d3c:	defffa04 	addi	sp,sp,-24
 8005d40:	dfc00515 	stw	ra,20(sp)
 8005d44:	df000415 	stw	fp,16(sp)
 8005d48:	df000404 	addi	fp,sp,16
 8005d4c:	e13ffd15 	stw	r4,-12(fp)
 8005d50:	e17ffe15 	stw	r5,-8(fp)
 8005d54:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 8005d58:	e0bffd17 	ldw	r2,-12(fp)
 8005d5c:	00c00044 	movi	r3,1
 8005d60:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 8005d64:	e0bffd17 	ldw	r2,-12(fp)
 8005d68:	10800017 	ldw	r2,0(r2)
 8005d6c:	10800104 	addi	r2,r2,4
 8005d70:	1007883a 	mov	r3,r2
 8005d74:	e0bffd17 	ldw	r2,-12(fp)
 8005d78:	10800817 	ldw	r2,32(r2)
 8005d7c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 8005d80:	e0bffe17 	ldw	r2,-8(fp)
 8005d84:	e0ffff17 	ldw	r3,-4(fp)
 8005d88:	d8000015 	stw	zero,0(sp)
 8005d8c:	e1fffd17 	ldw	r7,-12(fp)
 8005d90:	01820034 	movhi	r6,2048
 8005d94:	31977f04 	addi	r6,r6,24060
 8005d98:	180b883a 	mov	r5,r3
 8005d9c:	1009883a 	mov	r4,r2
 8005da0:	8007bac0 	call	8007bac <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 8005da4:	e0bffd17 	ldw	r2,-12(fp)
 8005da8:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 8005dac:	e0bffd17 	ldw	r2,-12(fp)
 8005db0:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 8005db4:	d0e6ea17 	ldw	r3,-25688(gp)
 8005db8:	e1fffd17 	ldw	r7,-12(fp)
 8005dbc:	01820034 	movhi	r6,2048
 8005dc0:	31980204 	addi	r6,r6,24584
 8005dc4:	180b883a 	mov	r5,r3
 8005dc8:	1009883a 	mov	r4,r2
 8005dcc:	80077d40 	call	80077d4 <alt_alarm_start>
 8005dd0:	1000040e 	bge	r2,zero,8005de4 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 8005dd4:	e0fffd17 	ldw	r3,-12(fp)
 8005dd8:	00a00034 	movhi	r2,32768
 8005ddc:	10bfffc4 	addi	r2,r2,-1
 8005de0:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 8005de4:	0001883a 	nop
 8005de8:	e037883a 	mov	sp,fp
 8005dec:	dfc00117 	ldw	ra,4(sp)
 8005df0:	df000017 	ldw	fp,0(sp)
 8005df4:	dec00204 	addi	sp,sp,8
 8005df8:	f800283a 	ret

08005dfc <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 8005dfc:	defff804 	addi	sp,sp,-32
 8005e00:	df000715 	stw	fp,28(sp)
 8005e04:	df000704 	addi	fp,sp,28
 8005e08:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 8005e0c:	e0bfff17 	ldw	r2,-4(fp)
 8005e10:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 8005e14:	e0bffb17 	ldw	r2,-20(fp)
 8005e18:	10800017 	ldw	r2,0(r2)
 8005e1c:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 8005e20:	e0bffc17 	ldw	r2,-16(fp)
 8005e24:	10800104 	addi	r2,r2,4
 8005e28:	10800037 	ldwio	r2,0(r2)
 8005e2c:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 8005e30:	e0bffd17 	ldw	r2,-12(fp)
 8005e34:	1080c00c 	andi	r2,r2,768
 8005e38:	10006d26 	beq	r2,zero,8005ff0 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 8005e3c:	e0bffd17 	ldw	r2,-12(fp)
 8005e40:	1080400c 	andi	r2,r2,256
 8005e44:	10003526 	beq	r2,zero,8005f1c <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 8005e48:	00800074 	movhi	r2,1
 8005e4c:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 8005e50:	e0bffb17 	ldw	r2,-20(fp)
 8005e54:	10800a17 	ldw	r2,40(r2)
 8005e58:	10800044 	addi	r2,r2,1
 8005e5c:	1081ffcc 	andi	r2,r2,2047
 8005e60:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 8005e64:	e0bffb17 	ldw	r2,-20(fp)
 8005e68:	10c00b17 	ldw	r3,44(r2)
 8005e6c:	e0bffe17 	ldw	r2,-8(fp)
 8005e70:	18801526 	beq	r3,r2,8005ec8 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 8005e74:	e0bffc17 	ldw	r2,-16(fp)
 8005e78:	10800037 	ldwio	r2,0(r2)
 8005e7c:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 8005e80:	e0bff917 	ldw	r2,-28(fp)
 8005e84:	10a0000c 	andi	r2,r2,32768
 8005e88:	10001126 	beq	r2,zero,8005ed0 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 8005e8c:	e0bffb17 	ldw	r2,-20(fp)
 8005e90:	10800a17 	ldw	r2,40(r2)
 8005e94:	e0fff917 	ldw	r3,-28(fp)
 8005e98:	1809883a 	mov	r4,r3
 8005e9c:	e0fffb17 	ldw	r3,-20(fp)
 8005ea0:	1885883a 	add	r2,r3,r2
 8005ea4:	10800e04 	addi	r2,r2,56
 8005ea8:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 8005eac:	e0bffb17 	ldw	r2,-20(fp)
 8005eb0:	10800a17 	ldw	r2,40(r2)
 8005eb4:	10800044 	addi	r2,r2,1
 8005eb8:	10c1ffcc 	andi	r3,r2,2047
 8005ebc:	e0bffb17 	ldw	r2,-20(fp)
 8005ec0:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 8005ec4:	003fe206 	br	8005e50 <altera_avalon_jtag_uart_irq+0x54>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 8005ec8:	0001883a 	nop
 8005ecc:	00000106 	br	8005ed4 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 8005ed0:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 8005ed4:	e0bff917 	ldw	r2,-28(fp)
 8005ed8:	10bfffec 	andhi	r2,r2,65535
 8005edc:	10000f26 	beq	r2,zero,8005f1c <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 8005ee0:	e0bffb17 	ldw	r2,-20(fp)
 8005ee4:	10c00817 	ldw	r3,32(r2)
 8005ee8:	00bfff84 	movi	r2,-2
 8005eec:	1886703a 	and	r3,r3,r2
 8005ef0:	e0bffb17 	ldw	r2,-20(fp)
 8005ef4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 8005ef8:	e0bffc17 	ldw	r2,-16(fp)
 8005efc:	10800104 	addi	r2,r2,4
 8005f00:	1007883a 	mov	r3,r2
 8005f04:	e0bffb17 	ldw	r2,-20(fp)
 8005f08:	10800817 	ldw	r2,32(r2)
 8005f0c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 8005f10:	e0bffc17 	ldw	r2,-16(fp)
 8005f14:	10800104 	addi	r2,r2,4
 8005f18:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 8005f1c:	e0bffd17 	ldw	r2,-12(fp)
 8005f20:	1080800c 	andi	r2,r2,512
 8005f24:	103fbe26 	beq	r2,zero,8005e20 <altera_avalon_jtag_uart_irq+0x24>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 8005f28:	e0bffd17 	ldw	r2,-12(fp)
 8005f2c:	1004d43a 	srli	r2,r2,16
 8005f30:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 8005f34:	00001406 	br	8005f88 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 8005f38:	e0bffc17 	ldw	r2,-16(fp)
 8005f3c:	e0fffb17 	ldw	r3,-20(fp)
 8005f40:	18c00d17 	ldw	r3,52(r3)
 8005f44:	e13ffb17 	ldw	r4,-20(fp)
 8005f48:	20c7883a 	add	r3,r4,r3
 8005f4c:	18c20e04 	addi	r3,r3,2104
 8005f50:	18c00003 	ldbu	r3,0(r3)
 8005f54:	18c03fcc 	andi	r3,r3,255
 8005f58:	18c0201c 	xori	r3,r3,128
 8005f5c:	18ffe004 	addi	r3,r3,-128
 8005f60:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 8005f64:	e0bffb17 	ldw	r2,-20(fp)
 8005f68:	10800d17 	ldw	r2,52(r2)
 8005f6c:	10800044 	addi	r2,r2,1
 8005f70:	10c1ffcc 	andi	r3,r2,2047
 8005f74:	e0bffb17 	ldw	r2,-20(fp)
 8005f78:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 8005f7c:	e0bffa17 	ldw	r2,-24(fp)
 8005f80:	10bfffc4 	addi	r2,r2,-1
 8005f84:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 8005f88:	e0bffa17 	ldw	r2,-24(fp)
 8005f8c:	10000526 	beq	r2,zero,8005fa4 <altera_avalon_jtag_uart_irq+0x1a8>
 8005f90:	e0bffb17 	ldw	r2,-20(fp)
 8005f94:	10c00d17 	ldw	r3,52(r2)
 8005f98:	e0bffb17 	ldw	r2,-20(fp)
 8005f9c:	10800c17 	ldw	r2,48(r2)
 8005fa0:	18bfe51e 	bne	r3,r2,8005f38 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 8005fa4:	e0bffa17 	ldw	r2,-24(fp)
 8005fa8:	103f9d26 	beq	r2,zero,8005e20 <altera_avalon_jtag_uart_irq+0x24>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 8005fac:	e0bffb17 	ldw	r2,-20(fp)
 8005fb0:	10c00817 	ldw	r3,32(r2)
 8005fb4:	00bfff44 	movi	r2,-3
 8005fb8:	1886703a 	and	r3,r3,r2
 8005fbc:	e0bffb17 	ldw	r2,-20(fp)
 8005fc0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 8005fc4:	e0bffb17 	ldw	r2,-20(fp)
 8005fc8:	10800017 	ldw	r2,0(r2)
 8005fcc:	10800104 	addi	r2,r2,4
 8005fd0:	1007883a 	mov	r3,r2
 8005fd4:	e0bffb17 	ldw	r2,-20(fp)
 8005fd8:	10800817 	ldw	r2,32(r2)
 8005fdc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 8005fe0:	e0bffc17 	ldw	r2,-16(fp)
 8005fe4:	10800104 	addi	r2,r2,4
 8005fe8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 8005fec:	003f8c06 	br	8005e20 <altera_avalon_jtag_uart_irq+0x24>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 8005ff0:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 8005ff4:	0001883a 	nop
 8005ff8:	e037883a 	mov	sp,fp
 8005ffc:	df000017 	ldw	fp,0(sp)
 8006000:	dec00104 	addi	sp,sp,4
 8006004:	f800283a 	ret

08006008 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 8006008:	defff804 	addi	sp,sp,-32
 800600c:	df000715 	stw	fp,28(sp)
 8006010:	df000704 	addi	fp,sp,28
 8006014:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 8006018:	e0bffb17 	ldw	r2,-20(fp)
 800601c:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 8006020:	e0bff917 	ldw	r2,-28(fp)
 8006024:	10800017 	ldw	r2,0(r2)
 8006028:	10800104 	addi	r2,r2,4
 800602c:	10800037 	ldwio	r2,0(r2)
 8006030:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 8006034:	e0bffa17 	ldw	r2,-24(fp)
 8006038:	1081000c 	andi	r2,r2,1024
 800603c:	10000b26 	beq	r2,zero,800606c <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 8006040:	e0bff917 	ldw	r2,-28(fp)
 8006044:	10800017 	ldw	r2,0(r2)
 8006048:	10800104 	addi	r2,r2,4
 800604c:	1007883a 	mov	r3,r2
 8006050:	e0bff917 	ldw	r2,-28(fp)
 8006054:	10800817 	ldw	r2,32(r2)
 8006058:	10810014 	ori	r2,r2,1024
 800605c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 8006060:	e0bff917 	ldw	r2,-28(fp)
 8006064:	10000915 	stw	zero,36(r2)
 8006068:	00000a06 	br	8006094 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 800606c:	e0bff917 	ldw	r2,-28(fp)
 8006070:	10c00917 	ldw	r3,36(r2)
 8006074:	00a00034 	movhi	r2,32768
 8006078:	10bfff04 	addi	r2,r2,-4
 800607c:	10c00536 	bltu	r2,r3,8006094 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 8006080:	e0bff917 	ldw	r2,-28(fp)
 8006084:	10800917 	ldw	r2,36(r2)
 8006088:	10c00044 	addi	r3,r2,1
 800608c:	e0bff917 	ldw	r2,-28(fp)
 8006090:	10c00915 	stw	r3,36(r2)
 8006094:	d0a6ea17 	ldw	r2,-25688(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 8006098:	e037883a 	mov	sp,fp
 800609c:	df000017 	ldw	fp,0(sp)
 80060a0:	dec00104 	addi	sp,sp,4
 80060a4:	f800283a 	ret

080060a8 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 80060a8:	defffd04 	addi	sp,sp,-12
 80060ac:	df000215 	stw	fp,8(sp)
 80060b0:	df000204 	addi	fp,sp,8
 80060b4:	e13ffe15 	stw	r4,-8(fp)
 80060b8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 80060bc:	00000506 	br	80060d4 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 80060c0:	e0bfff17 	ldw	r2,-4(fp)
 80060c4:	1090000c 	andi	r2,r2,16384
 80060c8:	10000226 	beq	r2,zero,80060d4 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 80060cc:	00bffd44 	movi	r2,-11
 80060d0:	00000b06 	br	8006100 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 80060d4:	e0bffe17 	ldw	r2,-8(fp)
 80060d8:	10c00d17 	ldw	r3,52(r2)
 80060dc:	e0bffe17 	ldw	r2,-8(fp)
 80060e0:	10800c17 	ldw	r2,48(r2)
 80060e4:	18800526 	beq	r3,r2,80060fc <altera_avalon_jtag_uart_close+0x54>
 80060e8:	e0bffe17 	ldw	r2,-8(fp)
 80060ec:	10c00917 	ldw	r3,36(r2)
 80060f0:	e0bffe17 	ldw	r2,-8(fp)
 80060f4:	10800117 	ldw	r2,4(r2)
 80060f8:	18bff136 	bltu	r3,r2,80060c0 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 80060fc:	0005883a 	mov	r2,zero
}
 8006100:	e037883a 	mov	sp,fp
 8006104:	df000017 	ldw	fp,0(sp)
 8006108:	dec00104 	addi	sp,sp,4
 800610c:	f800283a 	ret

08006110 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 8006110:	defffa04 	addi	sp,sp,-24
 8006114:	df000515 	stw	fp,20(sp)
 8006118:	df000504 	addi	fp,sp,20
 800611c:	e13ffd15 	stw	r4,-12(fp)
 8006120:	e17ffe15 	stw	r5,-8(fp)
 8006124:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 8006128:	00bff9c4 	movi	r2,-25
 800612c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 8006130:	e0bffe17 	ldw	r2,-8(fp)
 8006134:	10da8060 	cmpeqi	r3,r2,27137
 8006138:	1800031e 	bne	r3,zero,8006148 <altera_avalon_jtag_uart_ioctl+0x38>
 800613c:	109a80a0 	cmpeqi	r2,r2,27138
 8006140:	1000181e 	bne	r2,zero,80061a4 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 8006144:	00002906 	br	80061ec <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 8006148:	e0bffd17 	ldw	r2,-12(fp)
 800614c:	10c00117 	ldw	r3,4(r2)
 8006150:	00a00034 	movhi	r2,32768
 8006154:	10bfffc4 	addi	r2,r2,-1
 8006158:	18802126 	beq	r3,r2,80061e0 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 800615c:	e0bfff17 	ldw	r2,-4(fp)
 8006160:	10800017 	ldw	r2,0(r2)
 8006164:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 8006168:	e0bffc17 	ldw	r2,-16(fp)
 800616c:	10800090 	cmplti	r2,r2,2
 8006170:	1000061e 	bne	r2,zero,800618c <altera_avalon_jtag_uart_ioctl+0x7c>
 8006174:	e0fffc17 	ldw	r3,-16(fp)
 8006178:	00a00034 	movhi	r2,32768
 800617c:	10bfffc4 	addi	r2,r2,-1
 8006180:	18800226 	beq	r3,r2,800618c <altera_avalon_jtag_uart_ioctl+0x7c>
 8006184:	e0bffc17 	ldw	r2,-16(fp)
 8006188:	00000206 	br	8006194 <altera_avalon_jtag_uart_ioctl+0x84>
 800618c:	00a00034 	movhi	r2,32768
 8006190:	10bfff84 	addi	r2,r2,-2
 8006194:	e0fffd17 	ldw	r3,-12(fp)
 8006198:	18800115 	stw	r2,4(r3)
      rc = 0;
 800619c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 80061a0:	00000f06 	br	80061e0 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 80061a4:	e0bffd17 	ldw	r2,-12(fp)
 80061a8:	10c00117 	ldw	r3,4(r2)
 80061ac:	00a00034 	movhi	r2,32768
 80061b0:	10bfffc4 	addi	r2,r2,-1
 80061b4:	18800c26 	beq	r3,r2,80061e8 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 80061b8:	e0bffd17 	ldw	r2,-12(fp)
 80061bc:	10c00917 	ldw	r3,36(r2)
 80061c0:	e0bffd17 	ldw	r2,-12(fp)
 80061c4:	10800117 	ldw	r2,4(r2)
 80061c8:	1885803a 	cmpltu	r2,r3,r2
 80061cc:	10c03fcc 	andi	r3,r2,255
 80061d0:	e0bfff17 	ldw	r2,-4(fp)
 80061d4:	10c00015 	stw	r3,0(r2)
      rc = 0;
 80061d8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 80061dc:	00000206 	br	80061e8 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 80061e0:	0001883a 	nop
 80061e4:	00000106 	br	80061ec <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 80061e8:	0001883a 	nop

  default:
    break;
  }

  return rc;
 80061ec:	e0bffb17 	ldw	r2,-20(fp)
}
 80061f0:	e037883a 	mov	sp,fp
 80061f4:	df000017 	ldw	fp,0(sp)
 80061f8:	dec00104 	addi	sp,sp,4
 80061fc:	f800283a 	ret

08006200 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 8006200:	defff304 	addi	sp,sp,-52
 8006204:	dfc00c15 	stw	ra,48(sp)
 8006208:	df000b15 	stw	fp,44(sp)
 800620c:	df000b04 	addi	fp,sp,44
 8006210:	e13ffc15 	stw	r4,-16(fp)
 8006214:	e17ffd15 	stw	r5,-12(fp)
 8006218:	e1bffe15 	stw	r6,-8(fp)
 800621c:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 8006220:	e0bffd17 	ldw	r2,-12(fp)
 8006224:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 8006228:	00004706 	br	8006348 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 800622c:	e0bffc17 	ldw	r2,-16(fp)
 8006230:	10800a17 	ldw	r2,40(r2)
 8006234:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 8006238:	e0bffc17 	ldw	r2,-16(fp)
 800623c:	10800b17 	ldw	r2,44(r2)
 8006240:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 8006244:	e0fff717 	ldw	r3,-36(fp)
 8006248:	e0bff817 	ldw	r2,-32(fp)
 800624c:	18800536 	bltu	r3,r2,8006264 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 8006250:	e0fff717 	ldw	r3,-36(fp)
 8006254:	e0bff817 	ldw	r2,-32(fp)
 8006258:	1885c83a 	sub	r2,r3,r2
 800625c:	e0bff615 	stw	r2,-40(fp)
 8006260:	00000406 	br	8006274 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 8006264:	00c20004 	movi	r3,2048
 8006268:	e0bff817 	ldw	r2,-32(fp)
 800626c:	1885c83a 	sub	r2,r3,r2
 8006270:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 8006274:	e0bff617 	ldw	r2,-40(fp)
 8006278:	10001e26 	beq	r2,zero,80062f4 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 800627c:	e0fffe17 	ldw	r3,-8(fp)
 8006280:	e0bff617 	ldw	r2,-40(fp)
 8006284:	1880022e 	bgeu	r3,r2,8006290 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 8006288:	e0bffe17 	ldw	r2,-8(fp)
 800628c:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 8006290:	e0bffc17 	ldw	r2,-16(fp)
 8006294:	10c00e04 	addi	r3,r2,56
 8006298:	e0bff817 	ldw	r2,-32(fp)
 800629c:	1885883a 	add	r2,r3,r2
 80062a0:	e1bff617 	ldw	r6,-40(fp)
 80062a4:	100b883a 	mov	r5,r2
 80062a8:	e13ff517 	ldw	r4,-44(fp)
 80062ac:	80024640 	call	8002464 <memcpy>
      ptr   += n;
 80062b0:	e0fff517 	ldw	r3,-44(fp)
 80062b4:	e0bff617 	ldw	r2,-40(fp)
 80062b8:	1885883a 	add	r2,r3,r2
 80062bc:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 80062c0:	e0fffe17 	ldw	r3,-8(fp)
 80062c4:	e0bff617 	ldw	r2,-40(fp)
 80062c8:	1885c83a 	sub	r2,r3,r2
 80062cc:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 80062d0:	e0fff817 	ldw	r3,-32(fp)
 80062d4:	e0bff617 	ldw	r2,-40(fp)
 80062d8:	1885883a 	add	r2,r3,r2
 80062dc:	10c1ffcc 	andi	r3,r2,2047
 80062e0:	e0bffc17 	ldw	r2,-16(fp)
 80062e4:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 80062e8:	e0bffe17 	ldw	r2,-8(fp)
 80062ec:	00bfcf16 	blt	zero,r2,800622c <altera_avalon_jtag_uart_read+0x2c>
 80062f0:	00000106 	br	80062f8 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 80062f4:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 80062f8:	e0fff517 	ldw	r3,-44(fp)
 80062fc:	e0bffd17 	ldw	r2,-12(fp)
 8006300:	1880141e 	bne	r3,r2,8006354 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 8006304:	e0bfff17 	ldw	r2,-4(fp)
 8006308:	1090000c 	andi	r2,r2,16384
 800630c:	1000131e 	bne	r2,zero,800635c <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 8006310:	0001883a 	nop
 8006314:	e0bffc17 	ldw	r2,-16(fp)
 8006318:	10c00a17 	ldw	r3,40(r2)
 800631c:	e0bff717 	ldw	r2,-36(fp)
 8006320:	1880051e 	bne	r3,r2,8006338 <altera_avalon_jtag_uart_read+0x138>
 8006324:	e0bffc17 	ldw	r2,-16(fp)
 8006328:	10c00917 	ldw	r3,36(r2)
 800632c:	e0bffc17 	ldw	r2,-16(fp)
 8006330:	10800117 	ldw	r2,4(r2)
 8006334:	18bff736 	bltu	r3,r2,8006314 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 8006338:	e0bffc17 	ldw	r2,-16(fp)
 800633c:	10c00a17 	ldw	r3,40(r2)
 8006340:	e0bff717 	ldw	r2,-36(fp)
 8006344:	18800726 	beq	r3,r2,8006364 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 8006348:	e0bffe17 	ldw	r2,-8(fp)
 800634c:	00bfb716 	blt	zero,r2,800622c <altera_avalon_jtag_uart_read+0x2c>
 8006350:	00000506 	br	8006368 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 8006354:	0001883a 	nop
 8006358:	00000306 	br	8006368 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 800635c:	0001883a 	nop
 8006360:	00000106 	br	8006368 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 8006364:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 8006368:	e0fff517 	ldw	r3,-44(fp)
 800636c:	e0bffd17 	ldw	r2,-12(fp)
 8006370:	18801826 	beq	r3,r2,80063d4 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8006374:	0005303a 	rdctl	r2,status
 8006378:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800637c:	e0fffb17 	ldw	r3,-20(fp)
 8006380:	00bfff84 	movi	r2,-2
 8006384:	1884703a 	and	r2,r3,r2
 8006388:	1001703a 	wrctl	status,r2
  
  return context;
 800638c:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 8006390:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 8006394:	e0bffc17 	ldw	r2,-16(fp)
 8006398:	10800817 	ldw	r2,32(r2)
 800639c:	10c00054 	ori	r3,r2,1
 80063a0:	e0bffc17 	ldw	r2,-16(fp)
 80063a4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 80063a8:	e0bffc17 	ldw	r2,-16(fp)
 80063ac:	10800017 	ldw	r2,0(r2)
 80063b0:	10800104 	addi	r2,r2,4
 80063b4:	1007883a 	mov	r3,r2
 80063b8:	e0bffc17 	ldw	r2,-16(fp)
 80063bc:	10800817 	ldw	r2,32(r2)
 80063c0:	18800035 	stwio	r2,0(r3)
 80063c4:	e0bffa17 	ldw	r2,-24(fp)
 80063c8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 80063cc:	e0bff917 	ldw	r2,-28(fp)
 80063d0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 80063d4:	e0fff517 	ldw	r3,-44(fp)
 80063d8:	e0bffd17 	ldw	r2,-12(fp)
 80063dc:	18800426 	beq	r3,r2,80063f0 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 80063e0:	e0fff517 	ldw	r3,-44(fp)
 80063e4:	e0bffd17 	ldw	r2,-12(fp)
 80063e8:	1885c83a 	sub	r2,r3,r2
 80063ec:	00000606 	br	8006408 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 80063f0:	e0bfff17 	ldw	r2,-4(fp)
 80063f4:	1090000c 	andi	r2,r2,16384
 80063f8:	10000226 	beq	r2,zero,8006404 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 80063fc:	00bffd44 	movi	r2,-11
 8006400:	00000106 	br	8006408 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 8006404:	00bffec4 	movi	r2,-5
}
 8006408:	e037883a 	mov	sp,fp
 800640c:	dfc00117 	ldw	ra,4(sp)
 8006410:	df000017 	ldw	fp,0(sp)
 8006414:	dec00204 	addi	sp,sp,8
 8006418:	f800283a 	ret

0800641c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 800641c:	defff304 	addi	sp,sp,-52
 8006420:	dfc00c15 	stw	ra,48(sp)
 8006424:	df000b15 	stw	fp,44(sp)
 8006428:	df000b04 	addi	fp,sp,44
 800642c:	e13ffc15 	stw	r4,-16(fp)
 8006430:	e17ffd15 	stw	r5,-12(fp)
 8006434:	e1bffe15 	stw	r6,-8(fp)
 8006438:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 800643c:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 8006440:	e0bffd17 	ldw	r2,-12(fp)
 8006444:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 8006448:	00003706 	br	8006528 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 800644c:	e0bffc17 	ldw	r2,-16(fp)
 8006450:	10800c17 	ldw	r2,48(r2)
 8006454:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 8006458:	e0bffc17 	ldw	r2,-16(fp)
 800645c:	10800d17 	ldw	r2,52(r2)
 8006460:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 8006464:	e0fff917 	ldw	r3,-28(fp)
 8006468:	e0bff517 	ldw	r2,-44(fp)
 800646c:	1880062e 	bgeu	r3,r2,8006488 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 8006470:	e0fff517 	ldw	r3,-44(fp)
 8006474:	e0bff917 	ldw	r2,-28(fp)
 8006478:	1885c83a 	sub	r2,r3,r2
 800647c:	10bfffc4 	addi	r2,r2,-1
 8006480:	e0bff615 	stw	r2,-40(fp)
 8006484:	00000b06 	br	80064b4 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 8006488:	e0bff517 	ldw	r2,-44(fp)
 800648c:	10000526 	beq	r2,zero,80064a4 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 8006490:	00c20004 	movi	r3,2048
 8006494:	e0bff917 	ldw	r2,-28(fp)
 8006498:	1885c83a 	sub	r2,r3,r2
 800649c:	e0bff615 	stw	r2,-40(fp)
 80064a0:	00000406 	br	80064b4 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 80064a4:	00c1ffc4 	movi	r3,2047
 80064a8:	e0bff917 	ldw	r2,-28(fp)
 80064ac:	1885c83a 	sub	r2,r3,r2
 80064b0:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 80064b4:	e0bff617 	ldw	r2,-40(fp)
 80064b8:	10001e26 	beq	r2,zero,8006534 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 80064bc:	e0fffe17 	ldw	r3,-8(fp)
 80064c0:	e0bff617 	ldw	r2,-40(fp)
 80064c4:	1880022e 	bgeu	r3,r2,80064d0 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 80064c8:	e0bffe17 	ldw	r2,-8(fp)
 80064cc:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 80064d0:	e0bffc17 	ldw	r2,-16(fp)
 80064d4:	10c20e04 	addi	r3,r2,2104
 80064d8:	e0bff917 	ldw	r2,-28(fp)
 80064dc:	1885883a 	add	r2,r3,r2
 80064e0:	e1bff617 	ldw	r6,-40(fp)
 80064e4:	e17ffd17 	ldw	r5,-12(fp)
 80064e8:	1009883a 	mov	r4,r2
 80064ec:	80024640 	call	8002464 <memcpy>
      ptr   += n;
 80064f0:	e0fffd17 	ldw	r3,-12(fp)
 80064f4:	e0bff617 	ldw	r2,-40(fp)
 80064f8:	1885883a 	add	r2,r3,r2
 80064fc:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 8006500:	e0fffe17 	ldw	r3,-8(fp)
 8006504:	e0bff617 	ldw	r2,-40(fp)
 8006508:	1885c83a 	sub	r2,r3,r2
 800650c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 8006510:	e0fff917 	ldw	r3,-28(fp)
 8006514:	e0bff617 	ldw	r2,-40(fp)
 8006518:	1885883a 	add	r2,r3,r2
 800651c:	10c1ffcc 	andi	r3,r2,2047
 8006520:	e0bffc17 	ldw	r2,-16(fp)
 8006524:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 8006528:	e0bffe17 	ldw	r2,-8(fp)
 800652c:	00bfc716 	blt	zero,r2,800644c <altera_avalon_jtag_uart_write+0x30>
 8006530:	00000106 	br	8006538 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 8006534:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8006538:	0005303a 	rdctl	r2,status
 800653c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8006540:	e0fffb17 	ldw	r3,-20(fp)
 8006544:	00bfff84 	movi	r2,-2
 8006548:	1884703a 	and	r2,r3,r2
 800654c:	1001703a 	wrctl	status,r2
  
  return context;
 8006550:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 8006554:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 8006558:	e0bffc17 	ldw	r2,-16(fp)
 800655c:	10800817 	ldw	r2,32(r2)
 8006560:	10c00094 	ori	r3,r2,2
 8006564:	e0bffc17 	ldw	r2,-16(fp)
 8006568:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800656c:	e0bffc17 	ldw	r2,-16(fp)
 8006570:	10800017 	ldw	r2,0(r2)
 8006574:	10800104 	addi	r2,r2,4
 8006578:	1007883a 	mov	r3,r2
 800657c:	e0bffc17 	ldw	r2,-16(fp)
 8006580:	10800817 	ldw	r2,32(r2)
 8006584:	18800035 	stwio	r2,0(r3)
 8006588:	e0bffa17 	ldw	r2,-24(fp)
 800658c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8006590:	e0bff817 	ldw	r2,-32(fp)
 8006594:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 8006598:	e0bffe17 	ldw	r2,-8(fp)
 800659c:	0080100e 	bge	zero,r2,80065e0 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 80065a0:	e0bfff17 	ldw	r2,-4(fp)
 80065a4:	1090000c 	andi	r2,r2,16384
 80065a8:	1000101e 	bne	r2,zero,80065ec <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 80065ac:	0001883a 	nop
 80065b0:	e0bffc17 	ldw	r2,-16(fp)
 80065b4:	10c00d17 	ldw	r3,52(r2)
 80065b8:	e0bff517 	ldw	r2,-44(fp)
 80065bc:	1880051e 	bne	r3,r2,80065d4 <altera_avalon_jtag_uart_write+0x1b8>
 80065c0:	e0bffc17 	ldw	r2,-16(fp)
 80065c4:	10c00917 	ldw	r3,36(r2)
 80065c8:	e0bffc17 	ldw	r2,-16(fp)
 80065cc:	10800117 	ldw	r2,4(r2)
 80065d0:	18bff736 	bltu	r3,r2,80065b0 <altera_avalon_jtag_uart_write+0x194>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 80065d4:	e0bffc17 	ldw	r2,-16(fp)
 80065d8:	10800917 	ldw	r2,36(r2)
 80065dc:	1000051e 	bne	r2,zero,80065f4 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 80065e0:	e0bffe17 	ldw	r2,-8(fp)
 80065e4:	00bfd016 	blt	zero,r2,8006528 <altera_avalon_jtag_uart_write+0x10c>
 80065e8:	00000306 	br	80065f8 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 80065ec:	0001883a 	nop
 80065f0:	00000106 	br	80065f8 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 80065f4:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 80065f8:	e0fffd17 	ldw	r3,-12(fp)
 80065fc:	e0bff717 	ldw	r2,-36(fp)
 8006600:	18800426 	beq	r3,r2,8006614 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 8006604:	e0fffd17 	ldw	r3,-12(fp)
 8006608:	e0bff717 	ldw	r2,-36(fp)
 800660c:	1885c83a 	sub	r2,r3,r2
 8006610:	00000606 	br	800662c <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 8006614:	e0bfff17 	ldw	r2,-4(fp)
 8006618:	1090000c 	andi	r2,r2,16384
 800661c:	10000226 	beq	r2,zero,8006628 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 8006620:	00bffd44 	movi	r2,-11
 8006624:	00000106 	br	800662c <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 8006628:	00bffec4 	movi	r2,-5
}
 800662c:	e037883a 	mov	sp,fp
 8006630:	dfc00117 	ldw	ra,4(sp)
 8006634:	df000017 	ldw	fp,0(sp)
 8006638:	dec00204 	addi	sp,sp,8
 800663c:	f800283a 	ret

08006640 <alt_up_char_buffer_init>:
#include <priv/alt_file.h>

#include "altera_up_avalon_video_character_buffer_with_dma.h"
#include "altera_up_avalon_video_character_buffer_with_dma_regs.h"

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
 8006640:	defffc04 	addi	sp,sp,-16
 8006644:	dfc00315 	stw	ra,12(sp)
 8006648:	df000215 	stw	fp,8(sp)
 800664c:	df000204 	addi	fp,sp,8
 8006650:	e13fff15 	stw	r4,-4(fp)
	char * name;
	name = (char *) char_buffer->dev.name;
 8006654:	e0bfff17 	ldw	r2,-4(fp)
 8006658:	10800217 	ldw	r2,8(r2)
 800665c:	e0bffe15 	stw	r2,-8(fp)

	for ( ; (*name) != '\0'; name++) {
 8006660:	00000b06 	br	8006690 <alt_up_char_buffer_init+0x50>
		if (strcmp(name, "_avalon_char_buffer_slave") == 0) {
 8006664:	01420134 	movhi	r5,2052
 8006668:	2942cf04 	addi	r5,r5,2876
 800666c:	e13ffe17 	ldw	r4,-8(fp)
 8006670:	80081540 	call	8008154 <strcmp>
 8006674:	1000031e 	bne	r2,zero,8006684 <alt_up_char_buffer_init+0x44>
			(*name) = '\0';
 8006678:	e0bffe17 	ldw	r2,-8(fp)
 800667c:	10000005 	stb	zero,0(r2)
			break;
 8006680:	00000906 	br	80066a8 <alt_up_char_buffer_init+0x68>

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
	char * name;
	name = (char *) char_buffer->dev.name;

	for ( ; (*name) != '\0'; name++) {
 8006684:	e0bffe17 	ldw	r2,-8(fp)
 8006688:	10800044 	addi	r2,r2,1
 800668c:	e0bffe15 	stw	r2,-8(fp)
 8006690:	e0bffe17 	ldw	r2,-8(fp)
 8006694:	10800003 	ldbu	r2,0(r2)
 8006698:	10803fcc 	andi	r2,r2,255
 800669c:	1080201c 	xori	r2,r2,128
 80066a0:	10bfe004 	addi	r2,r2,-128
 80066a4:	103fef1e 	bne	r2,zero,8006664 <alt_up_char_buffer_init+0x24>
			(*name) = '\0';
			break;
		}
	}
	
	return;
 80066a8:	0001883a 	nop
}
 80066ac:	e037883a 	mov	sp,fp
 80066b0:	dfc00117 	ldw	ra,4(sp)
 80066b4:	df000017 	ldw	fp,0(sp)
 80066b8:	dec00204 	addi	sp,sp,8
 80066bc:	f800283a 	ret

080066c0 <alt_up_char_buffer_open_dev>:

alt_up_char_buffer_dev* alt_up_char_buffer_open_dev(const char* name) {
 80066c0:	defffc04 	addi	sp,sp,-16
 80066c4:	dfc00315 	stw	ra,12(sp)
 80066c8:	df000215 	stw	fp,8(sp)
 80066cc:	df000204 	addi	fp,sp,8
 80066d0:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_char_buffer_dev *dev = (alt_up_char_buffer_dev *)alt_find_dev(name, &alt_dev_list);
 80066d4:	d1600604 	addi	r5,gp,-32744
 80066d8:	e13fff17 	ldw	r4,-4(fp)
 80066dc:	8007ae80 	call	8007ae8 <alt_find_dev>
 80066e0:	e0bffe15 	stw	r2,-8(fp)

  return dev;
 80066e4:	e0bffe17 	ldw	r2,-8(fp)
}
 80066e8:	e037883a 	mov	sp,fp
 80066ec:	dfc00117 	ldw	ra,4(sp)
 80066f0:	df000017 	ldw	fp,0(sp)
 80066f4:	dec00204 	addi	sp,sp,8
 80066f8:	f800283a 	ret

080066fc <alt_up_char_buffer_draw>:

int alt_up_char_buffer_draw(alt_up_char_buffer_dev *char_buffer, unsigned char ch, 
	unsigned int x, unsigned int y) {
 80066fc:	defffa04 	addi	sp,sp,-24
 8006700:	df000515 	stw	fp,20(sp)
 8006704:	df000504 	addi	fp,sp,20
 8006708:	e13ffc15 	stw	r4,-16(fp)
 800670c:	2805883a 	mov	r2,r5
 8006710:	e1bffe15 	stw	r6,-8(fp)
 8006714:	e1ffff15 	stw	r7,-4(fp)
 8006718:	e0bffd05 	stb	r2,-12(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
 800671c:	e0bffc17 	ldw	r2,-16(fp)
 8006720:	10800c17 	ldw	r2,48(r2)
 8006724:	e0fffe17 	ldw	r3,-8(fp)
 8006728:	1880042e 	bgeu	r3,r2,800673c <alt_up_char_buffer_draw+0x40>
 800672c:	e0bffc17 	ldw	r2,-16(fp)
 8006730:	10800d17 	ldw	r2,52(r2)
 8006734:	e0ffff17 	ldw	r3,-4(fp)
 8006738:	18800236 	bltu	r3,r2,8006744 <alt_up_char_buffer_draw+0x48>
		return -1;
 800673c:	00bfffc4 	movi	r2,-1
 8006740:	00001d06 	br	80067b8 <alt_up_char_buffer_draw+0xbc>
	
	unsigned int addr = 0;
 8006744:	e03ffb15 	stw	zero,-20(fp)
	addr |= ((x & char_buffer->x_coord_mask) << char_buffer->x_coord_offset);
 8006748:	e0bffc17 	ldw	r2,-16(fp)
 800674c:	10c00f17 	ldw	r3,60(r2)
 8006750:	e0bffe17 	ldw	r2,-8(fp)
 8006754:	1886703a 	and	r3,r3,r2
 8006758:	e0bffc17 	ldw	r2,-16(fp)
 800675c:	10800e17 	ldw	r2,56(r2)
 8006760:	1884983a 	sll	r2,r3,r2
 8006764:	e0fffb17 	ldw	r3,-20(fp)
 8006768:	1884b03a 	or	r2,r3,r2
 800676c:	e0bffb15 	stw	r2,-20(fp)
	addr |= ((y & char_buffer->y_coord_mask) << char_buffer->y_coord_offset);
 8006770:	e0bffc17 	ldw	r2,-16(fp)
 8006774:	10c01117 	ldw	r3,68(r2)
 8006778:	e0bfff17 	ldw	r2,-4(fp)
 800677c:	1886703a 	and	r3,r3,r2
 8006780:	e0bffc17 	ldw	r2,-16(fp)
 8006784:	10801017 	ldw	r2,64(r2)
 8006788:	1884983a 	sll	r2,r3,r2
 800678c:	e0fffb17 	ldw	r3,-20(fp)
 8006790:	1884b03a 	or	r2,r3,r2
 8006794:	e0bffb15 	stw	r2,-20(fp)
	IOWR_8DIRECT(char_buffer->buffer_base, addr, ch);
 8006798:	e0bffc17 	ldw	r2,-16(fp)
 800679c:	10c00b17 	ldw	r3,44(r2)
 80067a0:	e0bffb17 	ldw	r2,-20(fp)
 80067a4:	1885883a 	add	r2,r3,r2
 80067a8:	1007883a 	mov	r3,r2
 80067ac:	e0bffd03 	ldbu	r2,-12(fp)
 80067b0:	18800025 	stbio	r2,0(r3)

	return 0;
 80067b4:	0005883a 	mov	r2,zero
}
 80067b8:	e037883a 	mov	sp,fp
 80067bc:	df000017 	ldw	fp,0(sp)
 80067c0:	dec00104 	addi	sp,sp,4
 80067c4:	f800283a 	ret

080067c8 <alt_up_char_buffer_string>:

int alt_up_char_buffer_string(alt_up_char_buffer_dev *char_buffer, const char *ptr, 
	unsigned int x, unsigned int y) {
 80067c8:	defffa04 	addi	sp,sp,-24
 80067cc:	df000515 	stw	fp,20(sp)
 80067d0:	df000504 	addi	fp,sp,20
 80067d4:	e13ffc15 	stw	r4,-16(fp)
 80067d8:	e17ffd15 	stw	r5,-12(fp)
 80067dc:	e1bffe15 	stw	r6,-8(fp)
 80067e0:	e1ffff15 	stw	r7,-4(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
 80067e4:	e0bffc17 	ldw	r2,-16(fp)
 80067e8:	10800c17 	ldw	r2,48(r2)
 80067ec:	e0fffe17 	ldw	r3,-8(fp)
 80067f0:	1880042e 	bgeu	r3,r2,8006804 <alt_up_char_buffer_string+0x3c>
 80067f4:	e0bffc17 	ldw	r2,-16(fp)
 80067f8:	10800d17 	ldw	r2,52(r2)
 80067fc:	e0ffff17 	ldw	r3,-4(fp)
 8006800:	18800236 	bltu	r3,r2,800680c <alt_up_char_buffer_string+0x44>
		return -1;
 8006804:	00bfffc4 	movi	r2,-1
 8006808:	00002a06 	br	80068b4 <alt_up_char_buffer_string+0xec>
	
	unsigned int offset = 0;
 800680c:	e03ffb15 	stw	zero,-20(fp)
	offset = (y << char_buffer->y_coord_offset) + x;
 8006810:	e0bffc17 	ldw	r2,-16(fp)
 8006814:	10801017 	ldw	r2,64(r2)
 8006818:	e0ffff17 	ldw	r3,-4(fp)
 800681c:	1886983a 	sll	r3,r3,r2
 8006820:	e0bffe17 	ldw	r2,-8(fp)
 8006824:	1885883a 	add	r2,r3,r2
 8006828:	e0bffb15 	stw	r2,-20(fp)

	while ( *ptr )
 800682c:	00001a06 	br	8006898 <alt_up_char_buffer_string+0xd0>
	{
		IOWR_8DIRECT(char_buffer->buffer_base, offset, *ptr);
 8006830:	e0bffc17 	ldw	r2,-16(fp)
 8006834:	10c00b17 	ldw	r3,44(r2)
 8006838:	e0bffb17 	ldw	r2,-20(fp)
 800683c:	1885883a 	add	r2,r3,r2
 8006840:	1007883a 	mov	r3,r2
 8006844:	e0bffd17 	ldw	r2,-12(fp)
 8006848:	10800003 	ldbu	r2,0(r2)
 800684c:	10803fcc 	andi	r2,r2,255
 8006850:	1080201c 	xori	r2,r2,128
 8006854:	10bfe004 	addi	r2,r2,-128
 8006858:	18800025 	stbio	r2,0(r3)
		++ptr;
 800685c:	e0bffd17 	ldw	r2,-12(fp)
 8006860:	10800044 	addi	r2,r2,1
 8006864:	e0bffd15 	stw	r2,-12(fp)
		if (++x >= char_buffer->x_resolution)
 8006868:	e0bffe17 	ldw	r2,-8(fp)
 800686c:	10800044 	addi	r2,r2,1
 8006870:	e0bffe15 	stw	r2,-8(fp)
 8006874:	e0bffc17 	ldw	r2,-16(fp)
 8006878:	10800c17 	ldw	r2,48(r2)
 800687c:	e0fffe17 	ldw	r3,-8(fp)
 8006880:	18800236 	bltu	r3,r2,800688c <alt_up_char_buffer_string+0xc4>
			return -1;
 8006884:	00bfffc4 	movi	r2,-1
 8006888:	00000a06 	br	80068b4 <alt_up_char_buffer_string+0xec>
		++offset;
 800688c:	e0bffb17 	ldw	r2,-20(fp)
 8006890:	10800044 	addi	r2,r2,1
 8006894:	e0bffb15 	stw	r2,-20(fp)
		return -1;
	
	unsigned int offset = 0;
	offset = (y << char_buffer->y_coord_offset) + x;

	while ( *ptr )
 8006898:	e0bffd17 	ldw	r2,-12(fp)
 800689c:	10800003 	ldbu	r2,0(r2)
 80068a0:	10803fcc 	andi	r2,r2,255
 80068a4:	1080201c 	xori	r2,r2,128
 80068a8:	10bfe004 	addi	r2,r2,-128
 80068ac:	103fe01e 	bne	r2,zero,8006830 <alt_up_char_buffer_string+0x68>
		++ptr;
		if (++x >= char_buffer->x_resolution)
			return -1;
		++offset;
	}
	return 0;
 80068b0:	0005883a 	mov	r2,zero
}
 80068b4:	e037883a 	mov	sp,fp
 80068b8:	df000017 	ldw	fp,0(sp)
 80068bc:	dec00104 	addi	sp,sp,4
 80068c0:	f800283a 	ret

080068c4 <alt_up_char_buffer_clear>:

int alt_up_char_buffer_clear(alt_up_char_buffer_dev *char_buffer) {
 80068c4:	defffe04 	addi	sp,sp,-8
 80068c8:	df000115 	stw	fp,4(sp)
 80068cc:	df000104 	addi	fp,sp,4
 80068d0:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base, 1);
 80068d4:	e0bfff17 	ldw	r2,-4(fp)
 80068d8:	10800a17 	ldw	r2,40(r2)
 80068dc:	10800084 	addi	r2,r2,2
 80068e0:	1007883a 	mov	r3,r2
 80068e4:	00800044 	movi	r2,1
 80068e8:	18800025 	stbio	r2,0(r3)
	while ((IORD_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base) & ALT_UP_CHAR_BUFFER_CLR_SCRN_MSK) >> ALT_UP_CHAR_BUFFER_CLR_SCRN_OFST);
 80068ec:	0001883a 	nop
 80068f0:	e0bfff17 	ldw	r2,-4(fp)
 80068f4:	10800a17 	ldw	r2,40(r2)
 80068f8:	10800084 	addi	r2,r2,2
 80068fc:	10800023 	ldbuio	r2,0(r2)
 8006900:	10803fcc 	andi	r2,r2,255
 8006904:	1080004c 	andi	r2,r2,1
 8006908:	103ff91e 	bne	r2,zero,80068f0 <alt_up_char_buffer_clear+0x2c>
	return 0;
 800690c:	0005883a 	mov	r2,zero
}
 8006910:	e037883a 	mov	sp,fp
 8006914:	df000017 	ldw	fp,0(sp)
 8006918:	dec00104 	addi	sp,sp,4
 800691c:	f800283a 	ret

08006920 <alt_up_pixel_buffer_dma_open_dev>:

#include "altera_up_avalon_video_pixel_buffer_dma.h"

#define ABS(x)	((x >= 0) ? (x) : (-(x)))

alt_up_pixel_buffer_dma_dev* alt_up_pixel_buffer_dma_open_dev(const char* name) {
 8006920:	defffc04 	addi	sp,sp,-16
 8006924:	dfc00315 	stw	ra,12(sp)
 8006928:	df000215 	stw	fp,8(sp)
 800692c:	df000204 	addi	fp,sp,8
 8006930:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_pixel_buffer_dma_dev *dev = (alt_up_pixel_buffer_dma_dev*)alt_find_dev(name, &alt_dev_list);
 8006934:	d1600604 	addi	r5,gp,-32744
 8006938:	e13fff17 	ldw	r4,-4(fp)
 800693c:	8007ae80 	call	8007ae8 <alt_find_dev>
 8006940:	e0bffe15 	stw	r2,-8(fp)

  return dev;
 8006944:	e0bffe17 	ldw	r2,-8(fp)
}
 8006948:	e037883a 	mov	sp,fp
 800694c:	dfc00117 	ldw	ra,4(sp)
 8006950:	df000017 	ldw	fp,0(sp)
 8006954:	dec00204 	addi	sp,sp,8
 8006958:	f800283a 	ret

0800695c <alt_up_pixel_buffer_dma_draw>:

int alt_up_pixel_buffer_dma_draw(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int color, unsigned int x, unsigned int y)
/* This function draws a pixel to the back buffer.
 */
{
 800695c:	defffa04 	addi	sp,sp,-24
 8006960:	df000515 	stw	fp,20(sp)
 8006964:	df000504 	addi	fp,sp,20
 8006968:	e13ffc15 	stw	r4,-16(fp)
 800696c:	e17ffd15 	stw	r5,-12(fp)
 8006970:	e1bffe15 	stw	r6,-8(fp)
 8006974:	e1ffff15 	stw	r7,-4(fp)
	// boundary check
	if (x >= pixel_buffer->x_resolution || y >= pixel_buffer->y_resolution )
 8006978:	e0bffc17 	ldw	r2,-16(fp)
 800697c:	10800f17 	ldw	r2,60(r2)
 8006980:	e0fffe17 	ldw	r3,-8(fp)
 8006984:	1880042e 	bgeu	r3,r2,8006998 <alt_up_pixel_buffer_dma_draw+0x3c>
 8006988:	e0bffc17 	ldw	r2,-16(fp)
 800698c:	10801017 	ldw	r2,64(r2)
 8006990:	e0ffff17 	ldw	r3,-4(fp)
 8006994:	18800236 	bltu	r3,r2,80069a0 <alt_up_pixel_buffer_dma_draw+0x44>
		return -1;
 8006998:	00bfffc4 	movi	r2,-1
 800699c:	00005006 	br	8006ae0 <alt_up_pixel_buffer_dma_draw+0x184>

	unsigned int addr = 0;
 80069a0:	e03ffb15 	stw	zero,-20(fp)
	/* Check the mode VGA Pixel Buffer is using. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 80069a4:	e0bffc17 	ldw	r2,-16(fp)
 80069a8:	10800d17 	ldw	r2,52(r2)
 80069ac:	1000151e 	bne	r2,zero,8006a04 <alt_up_pixel_buffer_dma_draw+0xa8>
		/* For X-Y addressing mode, the address format is | unused | Y | X |. So shift bits for coordinates X and Y into their respective locations. */
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
 80069b0:	e0bffc17 	ldw	r2,-16(fp)
 80069b4:	10c01217 	ldw	r3,72(r2)
 80069b8:	e0bffe17 	ldw	r2,-8(fp)
 80069bc:	1886703a 	and	r3,r3,r2
 80069c0:	e0bffc17 	ldw	r2,-16(fp)
 80069c4:	10801117 	ldw	r2,68(r2)
 80069c8:	1884983a 	sll	r2,r3,r2
 80069cc:	e0fffb17 	ldw	r3,-20(fp)
 80069d0:	1885883a 	add	r2,r3,r2
 80069d4:	e0bffb15 	stw	r2,-20(fp)
		addr += ((y & pixel_buffer->y_coord_mask) << pixel_buffer->y_coord_offset);
 80069d8:	e0bffc17 	ldw	r2,-16(fp)
 80069dc:	10c01417 	ldw	r3,80(r2)
 80069e0:	e0bfff17 	ldw	r2,-4(fp)
 80069e4:	1886703a 	and	r3,r3,r2
 80069e8:	e0bffc17 	ldw	r2,-16(fp)
 80069ec:	10801317 	ldw	r2,76(r2)
 80069f0:	1884983a 	sll	r2,r3,r2
 80069f4:	e0fffb17 	ldw	r3,-20(fp)
 80069f8:	1885883a 	add	r2,r3,r2
 80069fc:	e0bffb15 	stw	r2,-20(fp)
 8006a00:	00001706 	br	8006a60 <alt_up_pixel_buffer_dma_draw+0x104>
	} else {
		/* In a consecutive addressing mode, the pixels are stored in consecutive memory locations. So the address of a pixel at (x,y) can be computed as
		 * (y*x_resolution + x).*/
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
 8006a04:	e0bffc17 	ldw	r2,-16(fp)
 8006a08:	10c01217 	ldw	r3,72(r2)
 8006a0c:	e0bffe17 	ldw	r2,-8(fp)
 8006a10:	1886703a 	and	r3,r3,r2
 8006a14:	e0bffc17 	ldw	r2,-16(fp)
 8006a18:	10801117 	ldw	r2,68(r2)
 8006a1c:	1884983a 	sll	r2,r3,r2
 8006a20:	e0fffb17 	ldw	r3,-20(fp)
 8006a24:	1885883a 	add	r2,r3,r2
 8006a28:	e0bffb15 	stw	r2,-20(fp)
		addr += (((y & pixel_buffer->y_coord_mask) * pixel_buffer->x_resolution) << pixel_buffer->x_coord_offset);
 8006a2c:	e0bffc17 	ldw	r2,-16(fp)
 8006a30:	10c01417 	ldw	r3,80(r2)
 8006a34:	e0bfff17 	ldw	r2,-4(fp)
 8006a38:	1886703a 	and	r3,r3,r2
 8006a3c:	e0bffc17 	ldw	r2,-16(fp)
 8006a40:	10800f17 	ldw	r2,60(r2)
 8006a44:	1887383a 	mul	r3,r3,r2
 8006a48:	e0bffc17 	ldw	r2,-16(fp)
 8006a4c:	10801117 	ldw	r2,68(r2)
 8006a50:	1884983a 	sll	r2,r3,r2
 8006a54:	e0fffb17 	ldw	r3,-20(fp)
 8006a58:	1885883a 	add	r2,r3,r2
 8006a5c:	e0bffb15 	stw	r2,-20(fp)
	}
	/* Now, depending on the color depth, write the pixel color to the specified memory location. */
	if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 8006a60:	e0bffc17 	ldw	r2,-16(fp)
 8006a64:	10800e17 	ldw	r2,56(r2)
 8006a68:	10800058 	cmpnei	r2,r2,1
 8006a6c:	1000081e 	bne	r2,zero,8006a90 <alt_up_pixel_buffer_dma_draw+0x134>
		IOWR_8DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 8006a70:	e0bffc17 	ldw	r2,-16(fp)
 8006a74:	10c00c17 	ldw	r3,48(r2)
 8006a78:	e0bffb17 	ldw	r2,-20(fp)
 8006a7c:	1885883a 	add	r2,r3,r2
 8006a80:	1007883a 	mov	r3,r2
 8006a84:	e0bffd17 	ldw	r2,-12(fp)
 8006a88:	18800025 	stbio	r2,0(r3)
 8006a8c:	00001306 	br	8006adc <alt_up_pixel_buffer_dma_draw+0x180>
	} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 8006a90:	e0bffc17 	ldw	r2,-16(fp)
 8006a94:	10800e17 	ldw	r2,56(r2)
 8006a98:	10800098 	cmpnei	r2,r2,2
 8006a9c:	1000081e 	bne	r2,zero,8006ac0 <alt_up_pixel_buffer_dma_draw+0x164>
		IOWR_16DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 8006aa0:	e0bffc17 	ldw	r2,-16(fp)
 8006aa4:	10c00c17 	ldw	r3,48(r2)
 8006aa8:	e0bffb17 	ldw	r2,-20(fp)
 8006aac:	1885883a 	add	r2,r3,r2
 8006ab0:	1007883a 	mov	r3,r2
 8006ab4:	e0bffd17 	ldw	r2,-12(fp)
 8006ab8:	1880002d 	sthio	r2,0(r3)
 8006abc:	00000706 	br	8006adc <alt_up_pixel_buffer_dma_draw+0x180>
	} else {
		IOWR_32DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 8006ac0:	e0bffc17 	ldw	r2,-16(fp)
 8006ac4:	10c00c17 	ldw	r3,48(r2)
 8006ac8:	e0bffb17 	ldw	r2,-20(fp)
 8006acc:	1885883a 	add	r2,r3,r2
 8006ad0:	1007883a 	mov	r3,r2
 8006ad4:	e0bffd17 	ldw	r2,-12(fp)
 8006ad8:	18800035 	stwio	r2,0(r3)
	}

	return 0;
 8006adc:	0005883a 	mov	r2,zero
}
 8006ae0:	e037883a 	mov	sp,fp
 8006ae4:	df000017 	ldw	fp,0(sp)
 8006ae8:	dec00104 	addi	sp,sp,4
 8006aec:	f800283a 	ret

08006af0 <alt_up_pixel_buffer_dma_change_back_buffer_address>:

int alt_up_pixel_buffer_dma_change_back_buffer_address(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int new_address)
/* This function changes the memory address for the back buffer. */
{
 8006af0:	defffd04 	addi	sp,sp,-12
 8006af4:	df000215 	stw	fp,8(sp)
 8006af8:	df000204 	addi	fp,sp,8
 8006afc:	e13ffe15 	stw	r4,-8(fp)
 8006b00:	e17fff15 	stw	r5,-4(fp)
	IOWR_32DIRECT(pixel_buffer->base, 4, new_address);
 8006b04:	e0bffe17 	ldw	r2,-8(fp)
 8006b08:	10800a17 	ldw	r2,40(r2)
 8006b0c:	10800104 	addi	r2,r2,4
 8006b10:	1007883a 	mov	r3,r2
 8006b14:	e0bfff17 	ldw	r2,-4(fp)
 8006b18:	18800035 	stwio	r2,0(r3)
	pixel_buffer->back_buffer_start_address = IORD_32DIRECT(pixel_buffer->base, 4);
 8006b1c:	e0bffe17 	ldw	r2,-8(fp)
 8006b20:	10800a17 	ldw	r2,40(r2)
 8006b24:	10800104 	addi	r2,r2,4
 8006b28:	10800037 	ldwio	r2,0(r2)
 8006b2c:	1007883a 	mov	r3,r2
 8006b30:	e0bffe17 	ldw	r2,-8(fp)
 8006b34:	10c00c15 	stw	r3,48(r2)
	return 0;
 8006b38:	0005883a 	mov	r2,zero
}
 8006b3c:	e037883a 	mov	sp,fp
 8006b40:	df000017 	ldw	fp,0(sp)
 8006b44:	dec00104 	addi	sp,sp,4
 8006b48:	f800283a 	ret

08006b4c <alt_up_pixel_buffer_dma_swap_buffers>:

int alt_up_pixel_buffer_dma_swap_buffers(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function swaps the front and back buffers. At the next refresh cycle the back buffer will be drawn on the screen
 * and will become the front buffer. */
{
 8006b4c:	defffd04 	addi	sp,sp,-12
 8006b50:	df000215 	stw	fp,8(sp)
 8006b54:	dc000115 	stw	r16,4(sp)
 8006b58:	df000204 	addi	fp,sp,8
 8006b5c:	e13ffe15 	stw	r4,-8(fp)
	register unsigned int temp = pixel_buffer->back_buffer_start_address;
 8006b60:	e0bffe17 	ldw	r2,-8(fp)
 8006b64:	14000c17 	ldw	r16,48(r2)
	IOWR_32DIRECT(pixel_buffer->base, 0, 1);
 8006b68:	e0bffe17 	ldw	r2,-8(fp)
 8006b6c:	10800a17 	ldw	r2,40(r2)
 8006b70:	1007883a 	mov	r3,r2
 8006b74:	00800044 	movi	r2,1
 8006b78:	18800035 	stwio	r2,0(r3)
	pixel_buffer->back_buffer_start_address = pixel_buffer->buffer_start_address;
 8006b7c:	e0bffe17 	ldw	r2,-8(fp)
 8006b80:	10c00b17 	ldw	r3,44(r2)
 8006b84:	e0bffe17 	ldw	r2,-8(fp)
 8006b88:	10c00c15 	stw	r3,48(r2)
	pixel_buffer->buffer_start_address = temp;
 8006b8c:	e0bffe17 	ldw	r2,-8(fp)
 8006b90:	14000b15 	stw	r16,44(r2)
	return 0;
 8006b94:	0005883a 	mov	r2,zero
}
 8006b98:	e6ffff04 	addi	sp,fp,-4
 8006b9c:	df000117 	ldw	fp,4(sp)
 8006ba0:	dc000017 	ldw	r16,0(sp)
 8006ba4:	dec00204 	addi	sp,sp,8
 8006ba8:	f800283a 	ret

08006bac <alt_up_pixel_buffer_dma_check_swap_buffers_status>:
int alt_up_pixel_buffer_dma_check_swap_buffers_status(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function checks if the buffer swap has occured. Since the buffer swap only happens after an entire screen is drawn,
 * it is important to wait for this function to return 0 before proceeding to draw on either buffer. When both front and the back buffers
 * have the same address calling the alt_up_pixel_buffer_dma_swap_buffers(...) function and then waiting for this function to return 0, causes your program to
 * wait for the screen to refresh. */
{
 8006bac:	defffe04 	addi	sp,sp,-8
 8006bb0:	df000115 	stw	fp,4(sp)
 8006bb4:	df000104 	addi	fp,sp,4
 8006bb8:	e13fff15 	stw	r4,-4(fp)
	return (IORD_32DIRECT(pixel_buffer->base, 12) & 0x1);
 8006bbc:	e0bfff17 	ldw	r2,-4(fp)
 8006bc0:	10800a17 	ldw	r2,40(r2)
 8006bc4:	10800304 	addi	r2,r2,12
 8006bc8:	10800037 	ldwio	r2,0(r2)
 8006bcc:	1080004c 	andi	r2,r2,1
}
 8006bd0:	e037883a 	mov	sp,fp
 8006bd4:	df000017 	ldw	fp,0(sp)
 8006bd8:	dec00104 	addi	sp,sp,4
 8006bdc:	f800283a 	ret

08006be0 <alt_up_pixel_buffer_dma_clear_screen>:

void alt_up_pixel_buffer_dma_clear_screen(alt_up_pixel_buffer_dma_dev *pixel_buffer, int backbuffer)
/* This function clears the screen by setting each pixel to a black color. */
{
 8006be0:	defff704 	addi	sp,sp,-36
 8006be4:	df000815 	stw	fp,32(sp)
 8006be8:	dd400715 	stw	r21,28(sp)
 8006bec:	dd000615 	stw	r20,24(sp)
 8006bf0:	dcc00515 	stw	r19,20(sp)
 8006bf4:	dc800415 	stw	r18,16(sp)
 8006bf8:	dc400315 	stw	r17,12(sp)
 8006bfc:	dc000215 	stw	r16,8(sp)
 8006c00:	df000804 	addi	fp,sp,32
 8006c04:	e13ff815 	stw	r4,-32(fp)
 8006c08:	e17ff915 	stw	r5,-28(fp)
	register unsigned int addr;
	register unsigned int limit_x, limit_y;
	
	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 8006c0c:	e0bff917 	ldw	r2,-28(fp)
 8006c10:	10800058 	cmpnei	r2,r2,1
 8006c14:	1000031e 	bne	r2,zero,8006c24 <alt_up_pixel_buffer_dma_clear_screen+0x44>
		addr = pixel_buffer->back_buffer_start_address;
 8006c18:	e0bff817 	ldw	r2,-32(fp)
 8006c1c:	14400c17 	ldw	r17,48(r2)
 8006c20:	00000206 	br	8006c2c <alt_up_pixel_buffer_dma_clear_screen+0x4c>
	else
		addr = pixel_buffer->buffer_start_address;
 8006c24:	e0bff817 	ldw	r2,-32(fp)
 8006c28:	14400b17 	ldw	r17,44(r2)
	limit_x = pixel_buffer->x_resolution;
 8006c2c:	e0bff817 	ldw	r2,-32(fp)
 8006c30:	14000f17 	ldw	r16,60(r2)
	/* In 16 and 32-bit color modes we use twice or four times more memory for the display buffer.*/
	if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 8006c34:	e0bff817 	ldw	r2,-32(fp)
 8006c38:	10800e17 	ldw	r2,56(r2)
 8006c3c:	10800098 	cmpnei	r2,r2,2
 8006c40:	1000031e 	bne	r2,zero,8006c50 <alt_up_pixel_buffer_dma_clear_screen+0x70>
		limit_x = limit_x << 1;
 8006c44:	8405883a 	add	r2,r16,r16
 8006c48:	1021883a 	mov	r16,r2
 8006c4c:	00000306 	br	8006c5c <alt_up_pixel_buffer_dma_clear_screen+0x7c>
	} else {
		limit_x = limit_x << 2;
 8006c50:	8405883a 	add	r2,r16,r16
 8006c54:	1085883a 	add	r2,r2,r2
 8006c58:	1021883a 	mov	r16,r2
	}	
	limit_y = pixel_buffer->y_resolution;
 8006c5c:	e0bff817 	ldw	r2,-32(fp)
 8006c60:	14801017 	ldw	r18,64(r2)

	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 8006c64:	e0bff817 	ldw	r2,-32(fp)
 8006c68:	10800d17 	ldw	r2,52(r2)
 8006c6c:	1000111e 	bne	r2,zero,8006cb4 <alt_up_pixel_buffer_dma_clear_screen+0xd4>
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 8006c70:	e0bff817 	ldw	r2,-32(fp)
 8006c74:	15401317 	ldw	r21,76(r2)

		for (y = 0; y < limit_y; y++)
 8006c78:	0029883a 	mov	r20,zero
 8006c7c:	00000b06 	br	8006cac <alt_up_pixel_buffer_dma_clear_screen+0xcc>
		{
			for (x = 0; x < limit_x; x = x + 4)
 8006c80:	0027883a 	mov	r19,zero
 8006c84:	00000406 	br	8006c98 <alt_up_pixel_buffer_dma_clear_screen+0xb8>
			{
				IOWR_32DIRECT(addr, x, 0);
 8006c88:	9c45883a 	add	r2,r19,r17
 8006c8c:	0007883a 	mov	r3,zero
 8006c90:	10c00035 	stwio	r3,0(r2)
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
		{
			for (x = 0; x < limit_x; x = x + 4)
 8006c94:	9cc00104 	addi	r19,r19,4
 8006c98:	9c3ffb36 	bltu	r19,r16,8006c88 <alt_up_pixel_buffer_dma_clear_screen+0xa8>
			{
				IOWR_32DIRECT(addr, x, 0);
			}
			addr = addr + (1 << offset_y);
 8006c9c:	00800044 	movi	r2,1
 8006ca0:	1544983a 	sll	r2,r2,r21
 8006ca4:	88a3883a 	add	r17,r17,r2
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
 8006ca8:	a5000044 	addi	r20,r20,1
 8006cac:	a4bff436 	bltu	r20,r18,8006c80 <alt_up_pixel_buffer_dma_clear_screen+0xa0>
		for (x = 0; x < limit_y; x = x + 4)
		{
			IOWR_32DIRECT(addr, x, 0);
		}
	}
}
 8006cb0:	00000a06 	br	8006cdc <alt_up_pixel_buffer_dma_clear_screen+0xfc>
			addr = addr + (1 << offset_y);
		}
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	
 8006cb4:	9425383a 	mul	r18,r18,r16

		for (x = 0; x < limit_y; x = x + 4)
 8006cb8:	0021883a 	mov	r16,zero
 8006cbc:	00000506 	br	8006cd4 <alt_up_pixel_buffer_dma_clear_screen+0xf4>
		{
			IOWR_32DIRECT(addr, x, 0);
 8006cc0:	8005883a 	mov	r2,r16
 8006cc4:	1445883a 	add	r2,r2,r17
 8006cc8:	0007883a 	mov	r3,zero
 8006ccc:	10c00035 	stwio	r3,0(r2)
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	

		for (x = 0; x < limit_y; x = x + 4)
 8006cd0:	84000104 	addi	r16,r16,4
 8006cd4:	8005883a 	mov	r2,r16
 8006cd8:	14bff936 	bltu	r2,r18,8006cc0 <alt_up_pixel_buffer_dma_clear_screen+0xe0>
		{
			IOWR_32DIRECT(addr, x, 0);
		}
	}
}
 8006cdc:	0001883a 	nop
 8006ce0:	e6fffa04 	addi	sp,fp,-24
 8006ce4:	df000617 	ldw	fp,24(sp)
 8006ce8:	dd400517 	ldw	r21,20(sp)
 8006cec:	dd000417 	ldw	r20,16(sp)
 8006cf0:	dcc00317 	ldw	r19,12(sp)
 8006cf4:	dc800217 	ldw	r18,8(sp)
 8006cf8:	dc400117 	ldw	r17,4(sp)
 8006cfc:	dc000017 	ldw	r16,0(sp)
 8006d00:	dec00704 	addi	sp,sp,28
 8006d04:	f800283a 	ret

08006d08 <alt_up_pixel_buffer_dma_draw_box>:

void alt_up_pixel_buffer_dma_draw_box(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a filled box. */
{
 8006d08:	defff304 	addi	sp,sp,-52
 8006d0c:	df000c15 	stw	fp,48(sp)
 8006d10:	ddc00b15 	stw	r23,44(sp)
 8006d14:	dd800a15 	stw	r22,40(sp)
 8006d18:	dd400915 	stw	r21,36(sp)
 8006d1c:	dd000815 	stw	r20,32(sp)
 8006d20:	dcc00715 	stw	r19,28(sp)
 8006d24:	dc800615 	stw	r18,24(sp)
 8006d28:	dc400515 	stw	r17,20(sp)
 8006d2c:	dc000415 	stw	r16,16(sp)
 8006d30:	df000c04 	addi	fp,sp,48
 8006d34:	e13ff415 	stw	r4,-48(fp)
 8006d38:	e17ff515 	stw	r5,-44(fp)
 8006d3c:	e1bff615 	stw	r6,-40(fp)
 8006d40:	e1fff715 	stw	r7,-36(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 8006d44:	e0bff417 	ldw	r2,-48(fp)
 8006d48:	14800f17 	ldw	r18,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 8006d4c:	e0bff417 	ldw	r2,-48(fp)
 8006d50:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int l_x = x0;
 8006d54:	e5bff517 	ldw	r22,-44(fp)
	register unsigned int r_x = x1;
 8006d58:	e53ff717 	ldw	r20,-36(fp)
	register unsigned int t_y = y0;
 8006d5c:	e47ff617 	ldw	r17,-40(fp)
	register unsigned int b_y = y1;
 8006d60:	e4c00117 	ldw	r19,4(fp)
	register unsigned int local_color = color;
 8006d64:	e5c00217 	ldw	r23,8(fp)
	
	/* Check coordinates */
	if (l_x > r_x)
 8006d68:	a580032e 	bgeu	r20,r22,8006d78 <alt_up_pixel_buffer_dma_draw_box+0x70>
	{
		temp = l_x;
 8006d6c:	b02b883a 	mov	r21,r22
		l_x = r_x;
 8006d70:	a02d883a 	mov	r22,r20
		r_x = temp;
 8006d74:	a829883a 	mov	r20,r21
	}
	if (t_y > b_y)
 8006d78:	9c40032e 	bgeu	r19,r17,8006d88 <alt_up_pixel_buffer_dma_draw_box+0x80>
	{
		temp = t_y;
 8006d7c:	882b883a 	mov	r21,r17
		t_y = b_y;
 8006d80:	9823883a 	mov	r17,r19
		b_y = temp;
 8006d84:	a827883a 	mov	r19,r21
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
 8006d88:	b480892e 	bgeu	r22,r18,8006fb0 <alt_up_pixel_buffer_dma_draw_box+0x2a8>
 8006d8c:	8c00882e 	bgeu	r17,r16,8006fb0 <alt_up_pixel_buffer_dma_draw_box+0x2a8>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
 8006d90:	a4800136 	bltu	r20,r18,8006d98 <alt_up_pixel_buffer_dma_draw_box+0x90>
	{
		r_x = limit_x - 1;
 8006d94:	953fffc4 	addi	r20,r18,-1
	}
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
 8006d98:	9c000136 	bltu	r19,r16,8006da0 <alt_up_pixel_buffer_dma_draw_box+0x98>
	{
		b_y = limit_y - 1;
 8006d9c:	84ffffc4 	addi	r19,r16,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 8006da0:	e0800317 	ldw	r2,12(fp)
 8006da4:	10800058 	cmpnei	r2,r2,1
 8006da8:	1000031e 	bne	r2,zero,8006db8 <alt_up_pixel_buffer_dma_draw_box+0xb0>
		addr = pixel_buffer->back_buffer_start_address;
 8006dac:	e0bff417 	ldw	r2,-48(fp)
 8006db0:	14000c17 	ldw	r16,48(r2)
 8006db4:	00000206 	br	8006dc0 <alt_up_pixel_buffer_dma_draw_box+0xb8>
	else
		addr = pixel_buffer->buffer_start_address;
 8006db8:	e0bff417 	ldw	r2,-48(fp)
 8006dbc:	14000b17 	ldw	r16,44(r2)

	/* Draw the box using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 8006dc0:	e0bff417 	ldw	r2,-48(fp)
 8006dc4:	10800d17 	ldw	r2,52(r2)
 8006dc8:	10003c1e 	bne	r2,zero,8006ebc <alt_up_pixel_buffer_dma_draw_box+0x1b4>
		/* Draw a box of a given color on the screen using the XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 8006dcc:	e0bff417 	ldw	r2,-48(fp)
 8006dd0:	15401317 	ldw	r21,76(r2)
		addr = addr + (t_y << offset_y);
 8006dd4:	8d44983a 	sll	r2,r17,r21
 8006dd8:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 8006ddc:	e0bff417 	ldw	r2,-48(fp)
 8006de0:	10800e17 	ldw	r2,56(r2)
 8006de4:	10800058 	cmpnei	r2,r2,1
 8006de8:	10000f1e 	bne	r2,zero,8006e28 <alt_up_pixel_buffer_dma_draw_box+0x120>
			for (y = t_y; y <= b_y; y++)
 8006dec:	8825883a 	mov	r18,r17
 8006df0:	00000b06 	br	8006e20 <alt_up_pixel_buffer_dma_draw_box+0x118>
			{
				for (x = l_x; x <= r_x; x++)
 8006df4:	b023883a 	mov	r17,r22
 8006df8:	00000406 	br	8006e0c <alt_up_pixel_buffer_dma_draw_box+0x104>
				{
					IOWR_8DIRECT(addr, x, local_color);
 8006dfc:	8c05883a 	add	r2,r17,r16
 8006e00:	b807883a 	mov	r3,r23
 8006e04:	10c00025 	stbio	r3,0(r2)
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 8006e08:	8c400044 	addi	r17,r17,1
 8006e0c:	a47ffb2e 	bgeu	r20,r17,8006dfc <alt_up_pixel_buffer_dma_draw_box+0xf4>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
 8006e10:	00800044 	movi	r2,1
 8006e14:	1544983a 	sll	r2,r2,r21
 8006e18:	80a1883a 	add	r16,r16,r2
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 8006e1c:	94800044 	addi	r18,r18,1
 8006e20:	9cbff42e 	bgeu	r19,r18,8006df4 <alt_up_pixel_buffer_dma_draw_box+0xec>
 8006e24:	00006306 	br	8006fb4 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 8006e28:	e0bff417 	ldw	r2,-48(fp)
 8006e2c:	10800e17 	ldw	r2,56(r2)
 8006e30:	10800098 	cmpnei	r2,r2,2
 8006e34:	1000101e 	bne	r2,zero,8006e78 <alt_up_pixel_buffer_dma_draw_box+0x170>
			for (y = t_y; y <= b_y; y++)
 8006e38:	8825883a 	mov	r18,r17
 8006e3c:	00000c06 	br	8006e70 <alt_up_pixel_buffer_dma_draw_box+0x168>
			{
				for (x = l_x; x <= r_x; x++)
 8006e40:	b023883a 	mov	r17,r22
 8006e44:	00000506 	br	8006e5c <alt_up_pixel_buffer_dma_draw_box+0x154>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
 8006e48:	8c45883a 	add	r2,r17,r17
 8006e4c:	1405883a 	add	r2,r2,r16
 8006e50:	b807883a 	mov	r3,r23
 8006e54:	10c0002d 	sthio	r3,0(r2)
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 8006e58:	8c400044 	addi	r17,r17,1
 8006e5c:	a47ffa2e 	bgeu	r20,r17,8006e48 <alt_up_pixel_buffer_dma_draw_box+0x140>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + (1 << offset_y);
 8006e60:	00800044 	movi	r2,1
 8006e64:	1544983a 	sll	r2,r2,r21
 8006e68:	80a1883a 	add	r16,r16,r2
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 8006e6c:	94800044 	addi	r18,r18,1
 8006e70:	9cbff32e 	bgeu	r19,r18,8006e40 <alt_up_pixel_buffer_dma_draw_box+0x138>
 8006e74:	00004f06 	br	8006fb4 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 8006e78:	8825883a 	mov	r18,r17
 8006e7c:	00000d06 	br	8006eb4 <alt_up_pixel_buffer_dma_draw_box+0x1ac>
			{
				for (x = l_x; x <= r_x; x++)
 8006e80:	b023883a 	mov	r17,r22
 8006e84:	00000606 	br	8006ea0 <alt_up_pixel_buffer_dma_draw_box+0x198>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
 8006e88:	8c45883a 	add	r2,r17,r17
 8006e8c:	1085883a 	add	r2,r2,r2
 8006e90:	1405883a 	add	r2,r2,r16
 8006e94:	b807883a 	mov	r3,r23
 8006e98:	10c00035 	stwio	r3,0(r2)
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 8006e9c:	8c400044 	addi	r17,r17,1
 8006ea0:	a47ff92e 	bgeu	r20,r17,8006e88 <alt_up_pixel_buffer_dma_draw_box+0x180>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + (1 << offset_y);
 8006ea4:	00800044 	movi	r2,1
 8006ea8:	1544983a 	sll	r2,r2,r21
 8006eac:	80a1883a 	add	r16,r16,r2
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 8006eb0:	94800044 	addi	r18,r18,1
 8006eb4:	9cbff22e 	bgeu	r19,r18,8006e80 <alt_up_pixel_buffer_dma_draw_box+0x178>
 8006eb8:	00003e06 	br	8006fb4 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
	} else {
		/* Draw a box of a given color on the screen using the linear addressing mode. */
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 8006ebc:	e0bff417 	ldw	r2,-48(fp)
 8006ec0:	10800e17 	ldw	r2,56(r2)
 8006ec4:	10800058 	cmpnei	r2,r2,1
 8006ec8:	10000f1e 	bne	r2,zero,8006f08 <alt_up_pixel_buffer_dma_draw_box+0x200>
			addr = addr + t_y * limit_x;
 8006ecc:	8c85383a 	mul	r2,r17,r18
 8006ed0:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 8006ed4:	882b883a 	mov	r21,r17
 8006ed8:	00000906 	br	8006f00 <alt_up_pixel_buffer_dma_draw_box+0x1f8>
			{
				for (x = l_x; x <= r_x; x++)
 8006edc:	b023883a 	mov	r17,r22
 8006ee0:	00000406 	br	8006ef4 <alt_up_pixel_buffer_dma_draw_box+0x1ec>
				{
					IOWR_8DIRECT(addr, x, local_color);
 8006ee4:	8c05883a 	add	r2,r17,r16
 8006ee8:	b807883a 	mov	r3,r23
 8006eec:	10c00025 	stbio	r3,0(r2)
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 8006ef0:	8c400044 	addi	r17,r17,1
 8006ef4:	a47ffb2e 	bgeu	r20,r17,8006ee4 <alt_up_pixel_buffer_dma_draw_box+0x1dc>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
 8006ef8:	84a1883a 	add	r16,r16,r18
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 8006efc:	ad400044 	addi	r21,r21,1
 8006f00:	9d7ff62e 	bgeu	r19,r21,8006edc <alt_up_pixel_buffer_dma_draw_box+0x1d4>
 8006f04:	00002b06 	br	8006fb4 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 8006f08:	e0bff417 	ldw	r2,-48(fp)
 8006f0c:	10800e17 	ldw	r2,56(r2)
 8006f10:	10800098 	cmpnei	r2,r2,2
 8006f14:	1000121e 	bne	r2,zero,8006f60 <alt_up_pixel_buffer_dma_draw_box+0x258>
			limit_x = limit_x << 1;
 8006f18:	9485883a 	add	r2,r18,r18
 8006f1c:	1025883a 	mov	r18,r2
			addr = addr + t_y * limit_x;
 8006f20:	8c85383a 	mul	r2,r17,r18
 8006f24:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 8006f28:	882b883a 	mov	r21,r17
 8006f2c:	00000a06 	br	8006f58 <alt_up_pixel_buffer_dma_draw_box+0x250>
			{
				for (x = l_x; x <= r_x; x++)
 8006f30:	b023883a 	mov	r17,r22
 8006f34:	00000506 	br	8006f4c <alt_up_pixel_buffer_dma_draw_box+0x244>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
 8006f38:	8c45883a 	add	r2,r17,r17
 8006f3c:	1405883a 	add	r2,r2,r16
 8006f40:	b807883a 	mov	r3,r23
 8006f44:	10c0002d 	sthio	r3,0(r2)
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 8006f48:	8c400044 	addi	r17,r17,1
 8006f4c:	a47ffa2e 	bgeu	r20,r17,8006f38 <alt_up_pixel_buffer_dma_draw_box+0x230>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + limit_x;
 8006f50:	84a1883a 	add	r16,r16,r18
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 8006f54:	ad400044 	addi	r21,r21,1
 8006f58:	9d7ff52e 	bgeu	r19,r21,8006f30 <alt_up_pixel_buffer_dma_draw_box+0x228>
 8006f5c:	00001506 	br	8006fb4 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
 8006f60:	9485883a 	add	r2,r18,r18
 8006f64:	1085883a 	add	r2,r2,r2
 8006f68:	1025883a 	mov	r18,r2
			addr = addr + t_y * limit_x;
 8006f6c:	8c85383a 	mul	r2,r17,r18
 8006f70:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 8006f74:	882b883a 	mov	r21,r17
 8006f78:	00000b06 	br	8006fa8 <alt_up_pixel_buffer_dma_draw_box+0x2a0>
			{
				for (x = l_x; x <= r_x; x++)
 8006f7c:	b023883a 	mov	r17,r22
 8006f80:	00000606 	br	8006f9c <alt_up_pixel_buffer_dma_draw_box+0x294>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
 8006f84:	8c45883a 	add	r2,r17,r17
 8006f88:	1085883a 	add	r2,r2,r2
 8006f8c:	1405883a 	add	r2,r2,r16
 8006f90:	b807883a 	mov	r3,r23
 8006f94:	10c00035 	stwio	r3,0(r2)
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 8006f98:	8c400044 	addi	r17,r17,1
 8006f9c:	a47ff92e 	bgeu	r20,r17,8006f84 <alt_up_pixel_buffer_dma_draw_box+0x27c>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + limit_x;
 8006fa0:	84a1883a 	add	r16,r16,r18
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 8006fa4:	ad400044 	addi	r21,r21,1
 8006fa8:	9d7ff42e 	bgeu	r19,r21,8006f7c <alt_up_pixel_buffer_dma_draw_box+0x274>
 8006fac:	00000106 	br	8006fb4 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
		b_y = temp;
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 8006fb0:	0001883a 	nop
				}
				addr = addr + limit_x;
			}
		}
	}
}
 8006fb4:	e6fff804 	addi	sp,fp,-32
 8006fb8:	df000817 	ldw	fp,32(sp)
 8006fbc:	ddc00717 	ldw	r23,28(sp)
 8006fc0:	dd800617 	ldw	r22,24(sp)
 8006fc4:	dd400517 	ldw	r21,20(sp)
 8006fc8:	dd000417 	ldw	r20,16(sp)
 8006fcc:	dcc00317 	ldw	r19,12(sp)
 8006fd0:	dc800217 	ldw	r18,8(sp)
 8006fd4:	dc400117 	ldw	r17,4(sp)
 8006fd8:	dc000017 	ldw	r16,0(sp)
 8006fdc:	dec00904 	addi	sp,sp,36
 8006fe0:	f800283a 	ret

08006fe4 <alt_up_pixel_buffer_dma_draw_hline>:

void alt_up_pixel_buffer_dma_draw_hline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int x1, int y, int color, int backbuffer)
/* This method draws a horizontal line. This method is faster than using the line method because we know the direction of the line. */
{
 8006fe4:	defff404 	addi	sp,sp,-48
 8006fe8:	df000b15 	stw	fp,44(sp)
 8006fec:	dd800a15 	stw	r22,40(sp)
 8006ff0:	dd400915 	stw	r21,36(sp)
 8006ff4:	dd000815 	stw	r20,32(sp)
 8006ff8:	dcc00715 	stw	r19,28(sp)
 8006ffc:	dc800615 	stw	r18,24(sp)
 8007000:	dc400515 	stw	r17,20(sp)
 8007004:	dc000415 	stw	r16,16(sp)
 8007008:	df000b04 	addi	fp,sp,44
 800700c:	e13ff515 	stw	r4,-44(fp)
 8007010:	e17ff615 	stw	r5,-40(fp)
 8007014:	e1bff715 	stw	r6,-36(fp)
 8007018:	e1fff815 	stw	r7,-32(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 800701c:	e0bff517 	ldw	r2,-44(fp)
 8007020:	14800f17 	ldw	r18,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 8007024:	e0bff517 	ldw	r2,-44(fp)
 8007028:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int l_x = x0;
 800702c:	e47ff617 	ldw	r17,-40(fp)
	register unsigned int r_x = x1;
 8007030:	e4fff717 	ldw	r19,-36(fp)
	register unsigned int line_y = y;
 8007034:	e53ff817 	ldw	r20,-32(fp)
	register unsigned int local_color = color;
 8007038:	e5400117 	ldw	r21,4(fp)
	
	/* Check coordinates */
	if (l_x > r_x)
 800703c:	9c40032e 	bgeu	r19,r17,800704c <alt_up_pixel_buffer_dma_draw_hline+0x68>
	{
		temp = l_x;
 8007040:	882d883a 	mov	r22,r17
		l_x = r_x;
 8007044:	9823883a 	mov	r17,r19
		r_x = temp;
 8007048:	b027883a 	mov	r19,r22
	}
	if ((l_x >= limit_x) || (line_y >= limit_y) || (r_x < 0) || (line_y < 0))
 800704c:	8c805d2e 	bgeu	r17,r18,80071c4 <alt_up_pixel_buffer_dma_draw_hline+0x1e0>
 8007050:	a4005c2e 	bgeu	r20,r16,80071c4 <alt_up_pixel_buffer_dma_draw_hline+0x1e0>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
 8007054:	9c800136 	bltu	r19,r18,800705c <alt_up_pixel_buffer_dma_draw_hline+0x78>
	{
		r_x = limit_x - 1;
 8007058:	94ffffc4 	addi	r19,r18,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800705c:	e0800217 	ldw	r2,8(fp)
 8007060:	10800058 	cmpnei	r2,r2,1
 8007064:	1000031e 	bne	r2,zero,8007074 <alt_up_pixel_buffer_dma_draw_hline+0x90>
		addr = pixel_buffer->back_buffer_start_address;
 8007068:	e0bff517 	ldw	r2,-44(fp)
 800706c:	14000c17 	ldw	r16,48(r2)
 8007070:	00000206 	br	800707c <alt_up_pixel_buffer_dma_draw_hline+0x98>
	else
		addr = pixel_buffer->buffer_start_address;
 8007074:	e0bff517 	ldw	r2,-44(fp)
 8007078:	14000b17 	ldw	r16,44(r2)

	/* Draw a horizontal line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800707c:	e0bff517 	ldw	r2,-44(fp)
 8007080:	10800d17 	ldw	r2,52(r2)
 8007084:	1000231e 	bne	r2,zero,8007114 <alt_up_pixel_buffer_dma_draw_hline+0x130>
		/* Draw a horizontal line of a given color on the screen using the XY addressing mode. */
		register unsigned int x;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 8007088:	e0bff517 	ldw	r2,-44(fp)
 800708c:	14801317 	ldw	r18,76(r2)
		addr = addr + (line_y << offset_y);
 8007090:	a484983a 	sll	r2,r20,r18
 8007094:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 8007098:	e0bff517 	ldw	r2,-44(fp)
 800709c:	10800e17 	ldw	r2,56(r2)
 80070a0:	10800058 	cmpnei	r2,r2,1
 80070a4:	1000071e 	bne	r2,zero,80070c4 <alt_up_pixel_buffer_dma_draw_hline+0xe0>
			for (x = l_x; x <= r_x; x++)
 80070a8:	00000406 	br	80070bc <alt_up_pixel_buffer_dma_draw_hline+0xd8>
			{
				IOWR_8DIRECT(addr, x, local_color);
 80070ac:	8c05883a 	add	r2,r17,r16
 80070b0:	a807883a 	mov	r3,r21
 80070b4:	10c00025 	stbio	r3,0(r2)
		addr = addr + (line_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
 80070b8:	8c400044 	addi	r17,r17,1
 80070bc:	9c7ffb2e 	bgeu	r19,r17,80070ac <alt_up_pixel_buffer_dma_draw_hline+0xc8>
 80070c0:	00004106 	br	80071c8 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 80070c4:	e0bff517 	ldw	r2,-44(fp)
 80070c8:	10800e17 	ldw	r2,56(r2)
 80070cc:	10800098 	cmpnei	r2,r2,2
 80070d0:	10000e1e 	bne	r2,zero,800710c <alt_up_pixel_buffer_dma_draw_hline+0x128>
			for (x = l_x; x <= r_x; x++)
 80070d4:	00000506 	br	80070ec <alt_up_pixel_buffer_dma_draw_hline+0x108>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
 80070d8:	8c45883a 	add	r2,r17,r17
 80070dc:	1405883a 	add	r2,r2,r16
 80070e0:	a807883a 	mov	r3,r21
 80070e4:	10c0002d 	sthio	r3,0(r2)
			for (x = l_x; x <= r_x; x++)
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
 80070e8:	8c400044 	addi	r17,r17,1
 80070ec:	9c7ffa2e 	bgeu	r19,r17,80070d8 <alt_up_pixel_buffer_dma_draw_hline+0xf4>
 80070f0:	00003506 	br	80071c8 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
 80070f4:	8c45883a 	add	r2,r17,r17
 80070f8:	1085883a 	add	r2,r2,r2
 80070fc:	1405883a 	add	r2,r2,r16
 8007100:	a807883a 	mov	r3,r21
 8007104:	10c00035 	stwio	r3,0(r2)
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
 8007108:	8c400044 	addi	r17,r17,1
 800710c:	9c7ff92e 	bgeu	r19,r17,80070f4 <alt_up_pixel_buffer_dma_draw_hline+0x110>
 8007110:	00002d06 	br	80071c8 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
	} else {
		/* Draw a horizontal line of a given color on the screen using the linear addressing mode. */
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 8007114:	e0bff517 	ldw	r2,-44(fp)
 8007118:	10800e17 	ldw	r2,56(r2)
 800711c:	10800058 	cmpnei	r2,r2,1
 8007120:	1000091e 	bne	r2,zero,8007148 <alt_up_pixel_buffer_dma_draw_hline+0x164>
			addr = addr + line_y * limit_x;
 8007124:	a485383a 	mul	r2,r20,r18
 8007128:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 800712c:	00000406 	br	8007140 <alt_up_pixel_buffer_dma_draw_hline+0x15c>
			{
				IOWR_8DIRECT(addr, x, local_color);
 8007130:	8c05883a 	add	r2,r17,r16
 8007134:	a807883a 	mov	r3,r21
 8007138:	10c00025 	stbio	r3,0(r2)
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 800713c:	8c400044 	addi	r17,r17,1
 8007140:	9c7ffb2e 	bgeu	r19,r17,8007130 <alt_up_pixel_buffer_dma_draw_hline+0x14c>
 8007144:	00002006 	br	80071c8 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 8007148:	e0bff517 	ldw	r2,-44(fp)
 800714c:	10800e17 	ldw	r2,56(r2)
 8007150:	10800098 	cmpnei	r2,r2,2
 8007154:	10000c1e 	bne	r2,zero,8007188 <alt_up_pixel_buffer_dma_draw_hline+0x1a4>
			limit_x = limit_x << 1;
 8007158:	9485883a 	add	r2,r18,r18
 800715c:	1025883a 	mov	r18,r2
			addr = addr + line_y * limit_x;
 8007160:	a485383a 	mul	r2,r20,r18
 8007164:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 8007168:	00000506 	br	8007180 <alt_up_pixel_buffer_dma_draw_hline+0x19c>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
 800716c:	8c45883a 	add	r2,r17,r17
 8007170:	1405883a 	add	r2,r2,r16
 8007174:	a807883a 	mov	r3,r21
 8007178:	10c0002d 	sthio	r3,0(r2)
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 800717c:	8c400044 	addi	r17,r17,1
 8007180:	9c7ffa2e 	bgeu	r19,r17,800716c <alt_up_pixel_buffer_dma_draw_hline+0x188>
 8007184:	00001006 	br	80071c8 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			limit_x = limit_x << 2;
 8007188:	9485883a 	add	r2,r18,r18
 800718c:	1085883a 	add	r2,r2,r2
 8007190:	1025883a 	mov	r18,r2
			addr = addr + line_y * limit_x;
 8007194:	a485383a 	mul	r2,r20,r18
 8007198:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 800719c:	00000606 	br	80071b8 <alt_up_pixel_buffer_dma_draw_hline+0x1d4>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
 80071a0:	8c45883a 	add	r2,r17,r17
 80071a4:	1085883a 	add	r2,r2,r2
 80071a8:	1405883a 	add	r2,r2,r16
 80071ac:	a807883a 	mov	r3,r21
 80071b0:	10c00035 	stwio	r3,0(r2)
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 80071b4:	8c400044 	addi	r17,r17,1
 80071b8:	9c7ff92e 	bgeu	r19,r17,80071a0 <alt_up_pixel_buffer_dma_draw_hline+0x1bc>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
			}
			addr = addr + limit_x;
 80071bc:	84a1883a 	add	r16,r16,r18
 80071c0:	00000106 	br	80071c8 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
		r_x = temp;
	}
	if ((l_x >= limit_x) || (line_y >= limit_y) || (r_x < 0) || (line_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 80071c4:	0001883a 	nop
				IOWR_32DIRECT(addr, x << 2, local_color);
			}
			addr = addr + limit_x;
		}
	}
}
 80071c8:	e6fff904 	addi	sp,fp,-28
 80071cc:	df000717 	ldw	fp,28(sp)
 80071d0:	dd800617 	ldw	r22,24(sp)
 80071d4:	dd400517 	ldw	r21,20(sp)
 80071d8:	dd000417 	ldw	r20,16(sp)
 80071dc:	dcc00317 	ldw	r19,12(sp)
 80071e0:	dc800217 	ldw	r18,8(sp)
 80071e4:	dc400117 	ldw	r17,4(sp)
 80071e8:	dc000017 	ldw	r16,0(sp)
 80071ec:	dec00804 	addi	sp,sp,32
 80071f0:	f800283a 	ret

080071f4 <alt_up_pixel_buffer_dma_draw_vline>:


void alt_up_pixel_buffer_dma_draw_vline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x, int y0, int y1, int color, int backbuffer)
/* This method draws a vertical line. This method is faster than using the line method because we know the direction of the line. */

{
 80071f4:	defff404 	addi	sp,sp,-48
 80071f8:	df000b15 	stw	fp,44(sp)
 80071fc:	dd800a15 	stw	r22,40(sp)
 8007200:	dd400915 	stw	r21,36(sp)
 8007204:	dd000815 	stw	r20,32(sp)
 8007208:	dcc00715 	stw	r19,28(sp)
 800720c:	dc800615 	stw	r18,24(sp)
 8007210:	dc400515 	stw	r17,20(sp)
 8007214:	dc000415 	stw	r16,16(sp)
 8007218:	df000b04 	addi	fp,sp,44
 800721c:	e13ff515 	stw	r4,-44(fp)
 8007220:	e17ff615 	stw	r5,-40(fp)
 8007224:	e1bff715 	stw	r6,-36(fp)
 8007228:	e1fff815 	stw	r7,-32(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 800722c:	e0bff517 	ldw	r2,-44(fp)
 8007230:	14400f17 	ldw	r17,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 8007234:	e0bff517 	ldw	r2,-44(fp)
 8007238:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int line_x = x;
 800723c:	e4bff617 	ldw	r18,-40(fp)
	register unsigned int t_y = y0;
 8007240:	e53ff717 	ldw	r20,-36(fp)
	register unsigned int b_y = y1;
 8007244:	e4fff817 	ldw	r19,-32(fp)
	register unsigned int local_color = color;
 8007248:	e5800117 	ldw	r22,4(fp)
	
	/* Check coordinates */
	if (t_y > b_y)
 800724c:	9d00032e 	bgeu	r19,r20,800725c <alt_up_pixel_buffer_dma_draw_vline+0x68>
	{
		temp = t_y;
 8007250:	a02b883a 	mov	r21,r20
		t_y = b_y;
 8007254:	9829883a 	mov	r20,r19
		b_y = temp;
 8007258:	a827883a 	mov	r19,r21
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
 800725c:	94406c2e 	bgeu	r18,r17,8007410 <alt_up_pixel_buffer_dma_draw_vline+0x21c>
 8007260:	a4006b2e 	bgeu	r20,r16,8007410 <alt_up_pixel_buffer_dma_draw_vline+0x21c>
	/* Clip the box and draw only within the confines of the screen. */
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
 8007264:	9c000136 	bltu	r19,r16,800726c <alt_up_pixel_buffer_dma_draw_vline+0x78>
	{
		b_y = limit_y - 1;
 8007268:	84ffffc4 	addi	r19,r16,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800726c:	e0800217 	ldw	r2,8(fp)
 8007270:	10800058 	cmpnei	r2,r2,1
 8007274:	1000031e 	bne	r2,zero,8007284 <alt_up_pixel_buffer_dma_draw_vline+0x90>
		addr = pixel_buffer->back_buffer_start_address;
 8007278:	e0bff517 	ldw	r2,-44(fp)
 800727c:	14000c17 	ldw	r16,48(r2)
 8007280:	00000206 	br	800728c <alt_up_pixel_buffer_dma_draw_vline+0x98>
	else
		addr = pixel_buffer->buffer_start_address;
 8007284:	e0bff517 	ldw	r2,-44(fp)
 8007288:	14000b17 	ldw	r16,44(r2)

	/* Draw the vertical line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800728c:	e0bff517 	ldw	r2,-44(fp)
 8007290:	10800d17 	ldw	r2,52(r2)
 8007294:	1000301e 	bne	r2,zero,8007358 <alt_up_pixel_buffer_dma_draw_vline+0x164>
		/* Draw a vertical line of a given color on the screen using the XY addressing mode. */
		register unsigned int y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 8007298:	e0bff517 	ldw	r2,-44(fp)
 800729c:	15401317 	ldw	r21,76(r2)
		addr = addr + (t_y << offset_y);
 80072a0:	a544983a 	sll	r2,r20,r21
 80072a4:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 80072a8:	e0bff517 	ldw	r2,-44(fp)
 80072ac:	10800e17 	ldw	r2,56(r2)
 80072b0:	10800058 	cmpnei	r2,r2,1
 80072b4:	10000b1e 	bne	r2,zero,80072e4 <alt_up_pixel_buffer_dma_draw_vline+0xf0>
			for (y = t_y; y <= b_y; y++)
 80072b8:	a023883a 	mov	r17,r20
 80072bc:	00000706 	br	80072dc <alt_up_pixel_buffer_dma_draw_vline+0xe8>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
 80072c0:	9405883a 	add	r2,r18,r16
 80072c4:	b007883a 	mov	r3,r22
 80072c8:	10c00025 	stbio	r3,0(r2)
				addr = addr + (1 << offset_y);
 80072cc:	00800044 	movi	r2,1
 80072d0:	1544983a 	sll	r2,r2,r21
 80072d4:	80a1883a 	add	r16,r16,r2
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 80072d8:	8c400044 	addi	r17,r17,1
 80072dc:	9c7ff82e 	bgeu	r19,r17,80072c0 <alt_up_pixel_buffer_dma_draw_vline+0xcc>
 80072e0:	00004c06 	br	8007414 <alt_up_pixel_buffer_dma_draw_vline+0x220>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 80072e4:	e0bff517 	ldw	r2,-44(fp)
 80072e8:	10800e17 	ldw	r2,56(r2)
 80072ec:	10800098 	cmpnei	r2,r2,2
 80072f0:	10000c1e 	bne	r2,zero,8007324 <alt_up_pixel_buffer_dma_draw_vline+0x130>
			for (y = t_y; y <= b_y; y++)
 80072f4:	a023883a 	mov	r17,r20
 80072f8:	00000806 	br	800731c <alt_up_pixel_buffer_dma_draw_vline+0x128>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
 80072fc:	9485883a 	add	r2,r18,r18
 8007300:	1405883a 	add	r2,r2,r16
 8007304:	b007883a 	mov	r3,r22
 8007308:	10c0002d 	sthio	r3,0(r2)
				addr = addr + (1 << offset_y);
 800730c:	00800044 	movi	r2,1
 8007310:	1544983a 	sll	r2,r2,r21
 8007314:	80a1883a 	add	r16,r16,r2
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 8007318:	8c400044 	addi	r17,r17,1
 800731c:	9c7ff72e 	bgeu	r19,r17,80072fc <alt_up_pixel_buffer_dma_draw_vline+0x108>
 8007320:	00003c06 	br	8007414 <alt_up_pixel_buffer_dma_draw_vline+0x220>
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 8007324:	a023883a 	mov	r17,r20
 8007328:	00000906 	br	8007350 <alt_up_pixel_buffer_dma_draw_vline+0x15c>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
 800732c:	9485883a 	add	r2,r18,r18
 8007330:	1085883a 	add	r2,r2,r2
 8007334:	1405883a 	add	r2,r2,r16
 8007338:	b007883a 	mov	r3,r22
 800733c:	10c00035 	stwio	r3,0(r2)
				addr = addr + (1 << offset_y);
 8007340:	00800044 	movi	r2,1
 8007344:	1544983a 	sll	r2,r2,r21
 8007348:	80a1883a 	add	r16,r16,r2
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800734c:	8c400044 	addi	r17,r17,1
 8007350:	9c7ff62e 	bgeu	r19,r17,800732c <alt_up_pixel_buffer_dma_draw_vline+0x138>
 8007354:	00002f06 	br	8007414 <alt_up_pixel_buffer_dma_draw_vline+0x220>
	} else {
		/* Draw a vertical line of a given color on the screen using the linear addressing mode. */
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 8007358:	e0bff517 	ldw	r2,-44(fp)
 800735c:	10800e17 	ldw	r2,56(r2)
 8007360:	10800058 	cmpnei	r2,r2,1
 8007364:	10000a1e 	bne	r2,zero,8007390 <alt_up_pixel_buffer_dma_draw_vline+0x19c>
			addr = addr + t_y * limit_x;
 8007368:	a445383a 	mul	r2,r20,r17
 800736c:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 8007370:	00000506 	br	8007388 <alt_up_pixel_buffer_dma_draw_vline+0x194>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
 8007374:	9405883a 	add	r2,r18,r16
 8007378:	b007883a 	mov	r3,r22
 800737c:	10c00025 	stbio	r3,0(r2)
				addr = addr + limit_x;
 8007380:	8461883a 	add	r16,r16,r17
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 8007384:	a5000044 	addi	r20,r20,1
 8007388:	9d3ffa2e 	bgeu	r19,r20,8007374 <alt_up_pixel_buffer_dma_draw_vline+0x180>
 800738c:	00002106 	br	8007414 <alt_up_pixel_buffer_dma_draw_vline+0x220>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 8007390:	e0bff517 	ldw	r2,-44(fp)
 8007394:	10800e17 	ldw	r2,56(r2)
 8007398:	10800098 	cmpnei	r2,r2,2
 800739c:	10000d1e 	bne	r2,zero,80073d4 <alt_up_pixel_buffer_dma_draw_vline+0x1e0>
			limit_x = limit_x << 1;
 80073a0:	8c45883a 	add	r2,r17,r17
 80073a4:	1023883a 	mov	r17,r2
			addr = addr + t_y * limit_x;
 80073a8:	a445383a 	mul	r2,r20,r17
 80073ac:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 80073b0:	00000606 	br	80073cc <alt_up_pixel_buffer_dma_draw_vline+0x1d8>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
 80073b4:	9485883a 	add	r2,r18,r18
 80073b8:	1405883a 	add	r2,r2,r16
 80073bc:	b007883a 	mov	r3,r22
 80073c0:	10c0002d 	sthio	r3,0(r2)
				addr = addr + limit_x;
 80073c4:	8461883a 	add	r16,r16,r17
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 80073c8:	a5000044 	addi	r20,r20,1
 80073cc:	9d3ff92e 	bgeu	r19,r20,80073b4 <alt_up_pixel_buffer_dma_draw_vline+0x1c0>
 80073d0:	00001006 	br	8007414 <alt_up_pixel_buffer_dma_draw_vline+0x220>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
 80073d4:	8c45883a 	add	r2,r17,r17
 80073d8:	1085883a 	add	r2,r2,r2
 80073dc:	1023883a 	mov	r17,r2
			addr = addr + t_y * limit_x;
 80073e0:	a445383a 	mul	r2,r20,r17
 80073e4:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 80073e8:	00000706 	br	8007408 <alt_up_pixel_buffer_dma_draw_vline+0x214>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
 80073ec:	9485883a 	add	r2,r18,r18
 80073f0:	1085883a 	add	r2,r2,r2
 80073f4:	1405883a 	add	r2,r2,r16
 80073f8:	b007883a 	mov	r3,r22
 80073fc:	10c00035 	stwio	r3,0(r2)
				addr = addr + limit_x;
 8007400:	8461883a 	add	r16,r16,r17
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 8007404:	a5000044 	addi	r20,r20,1
 8007408:	9d3ff82e 	bgeu	r19,r20,80073ec <alt_up_pixel_buffer_dma_draw_vline+0x1f8>
 800740c:	00000106 	br	8007414 <alt_up_pixel_buffer_dma_draw_vline+0x220>
		b_y = temp;
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 8007410:	0001883a 	nop
				IOWR_32DIRECT(addr, line_x << 2, local_color);
				addr = addr + limit_x;
			}
		}
	}
}
 8007414:	e6fff904 	addi	sp,fp,-28
 8007418:	df000717 	ldw	fp,28(sp)
 800741c:	dd800617 	ldw	r22,24(sp)
 8007420:	dd400517 	ldw	r21,20(sp)
 8007424:	dd000417 	ldw	r20,16(sp)
 8007428:	dcc00317 	ldw	r19,12(sp)
 800742c:	dc800217 	ldw	r18,8(sp)
 8007430:	dc400117 	ldw	r17,4(sp)
 8007434:	dc000017 	ldw	r16,0(sp)
 8007438:	dec00804 	addi	sp,sp,32
 800743c:	f800283a 	ret

08007440 <alt_up_pixel_buffer_dma_draw_rectangle>:

void alt_up_pixel_buffer_dma_draw_rectangle(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
{
 8007440:	defff804 	addi	sp,sp,-32
 8007444:	dfc00715 	stw	ra,28(sp)
 8007448:	df000615 	stw	fp,24(sp)
 800744c:	df000604 	addi	fp,sp,24
 8007450:	e13ffc15 	stw	r4,-16(fp)
 8007454:	e17ffd15 	stw	r5,-12(fp)
 8007458:	e1bffe15 	stw	r6,-8(fp)
 800745c:	e1ffff15 	stw	r7,-4(fp)
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y0, color, backbuffer);
 8007460:	e0800417 	ldw	r2,16(fp)
 8007464:	d8800115 	stw	r2,4(sp)
 8007468:	e0800317 	ldw	r2,12(fp)
 800746c:	d8800015 	stw	r2,0(sp)
 8007470:	e1fffe17 	ldw	r7,-8(fp)
 8007474:	e1bfff17 	ldw	r6,-4(fp)
 8007478:	e17ffd17 	ldw	r5,-12(fp)
 800747c:	e13ffc17 	ldw	r4,-16(fp)
 8007480:	8006fe40 	call	8006fe4 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y1, color, backbuffer);
 8007484:	e0800417 	ldw	r2,16(fp)
 8007488:	d8800115 	stw	r2,4(sp)
 800748c:	e0800317 	ldw	r2,12(fp)
 8007490:	d8800015 	stw	r2,0(sp)
 8007494:	e1c00217 	ldw	r7,8(fp)
 8007498:	e1bfff17 	ldw	r6,-4(fp)
 800749c:	e17ffd17 	ldw	r5,-12(fp)
 80074a0:	e13ffc17 	ldw	r4,-16(fp)
 80074a4:	8006fe40 	call	8006fe4 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x0, y0, y1, color, backbuffer);
 80074a8:	e0800417 	ldw	r2,16(fp)
 80074ac:	d8800115 	stw	r2,4(sp)
 80074b0:	e0800317 	ldw	r2,12(fp)
 80074b4:	d8800015 	stw	r2,0(sp)
 80074b8:	e1c00217 	ldw	r7,8(fp)
 80074bc:	e1bffe17 	ldw	r6,-8(fp)
 80074c0:	e17ffd17 	ldw	r5,-12(fp)
 80074c4:	e13ffc17 	ldw	r4,-16(fp)
 80074c8:	80071f40 	call	80071f4 <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x1, y0, y1, color, backbuffer);
 80074cc:	e0800417 	ldw	r2,16(fp)
 80074d0:	d8800115 	stw	r2,4(sp)
 80074d4:	e0800317 	ldw	r2,12(fp)
 80074d8:	d8800015 	stw	r2,0(sp)
 80074dc:	e1c00217 	ldw	r7,8(fp)
 80074e0:	e1bffe17 	ldw	r6,-8(fp)
 80074e4:	e17fff17 	ldw	r5,-4(fp)
 80074e8:	e13ffc17 	ldw	r4,-16(fp)
 80074ec:	80071f40 	call	80071f4 <alt_up_pixel_buffer_dma_draw_vline>
}
 80074f0:	0001883a 	nop
 80074f4:	e037883a 	mov	sp,fp
 80074f8:	dfc00117 	ldw	ra,4(sp)
 80074fc:	df000017 	ldw	fp,0(sp)
 8007500:	dec00204 	addi	sp,sp,8
 8007504:	f800283a 	ret

08007508 <helper_plot_pixel>:

void helper_plot_pixel(register unsigned int buffer_start, register int line_size, register int x, register int y, register int color, register int mode)
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
 8007508:	deffff04 	addi	sp,sp,-4
 800750c:	df000015 	stw	fp,0(sp)
 8007510:	d839883a 	mov	fp,sp
 8007514:	2005883a 	mov	r2,r4
 8007518:	3007883a 	mov	r3,r6
 800751c:	3809883a 	mov	r4,r7
 8007520:	e1800117 	ldw	r6,4(fp)
 8007524:	e1c00217 	ldw	r7,8(fp)
	if (mode == 0)
 8007528:	3800051e 	bne	r7,zero,8007540 <helper_plot_pixel+0x38>
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
 800752c:	2909383a 	mul	r4,r5,r4
 8007530:	20c7883a 	add	r3,r4,r3
 8007534:	1885883a 	add	r2,r3,r2
 8007538:	11800025 	stbio	r6,0(r2)
	else if (mode == 1)
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
}
 800753c:	00000e06 	br	8007578 <helper_plot_pixel+0x70>
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
	if (mode == 0)
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
	else if (mode == 1)
 8007540:	39c00058 	cmpnei	r7,r7,1
 8007544:	3800061e 	bne	r7,zero,8007560 <helper_plot_pixel+0x58>
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
 8007548:	2909383a 	mul	r4,r5,r4
 800754c:	20c7883a 	add	r3,r4,r3
 8007550:	18c7883a 	add	r3,r3,r3
 8007554:	1885883a 	add	r2,r3,r2
 8007558:	1180002d 	sthio	r6,0(r2)
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
}
 800755c:	00000606 	br	8007578 <helper_plot_pixel+0x70>
	if (mode == 0)
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
	else if (mode == 1)
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
 8007560:	2909383a 	mul	r4,r5,r4
 8007564:	20c7883a 	add	r3,r4,r3
 8007568:	18c7883a 	add	r3,r3,r3
 800756c:	18c7883a 	add	r3,r3,r3
 8007570:	1885883a 	add	r2,r3,r2
 8007574:	11800035 	stwio	r6,0(r2)
}
 8007578:	0001883a 	nop
 800757c:	e037883a 	mov	sp,fp
 8007580:	df000017 	ldw	fp,0(sp)
 8007584:	dec00104 	addi	sp,sp,4
 8007588:	f800283a 	ret

0800758c <alt_up_pixel_buffer_dma_draw_line>:

void alt_up_pixel_buffer_dma_draw_line(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a line between points (x0, y0) and (x1, y1). The function does not check if it draws a pixel within screen boundaries.
 * users should ensure that the line is drawn within the screen boundaries. */
{
 800758c:	deffeb04 	addi	sp,sp,-84
 8007590:	dfc01415 	stw	ra,80(sp)
 8007594:	df001315 	stw	fp,76(sp)
 8007598:	ddc01215 	stw	r23,72(sp)
 800759c:	dd801115 	stw	r22,68(sp)
 80075a0:	dd401015 	stw	r21,64(sp)
 80075a4:	dd000f15 	stw	r20,60(sp)
 80075a8:	dcc00e15 	stw	r19,56(sp)
 80075ac:	dc800d15 	stw	r18,52(sp)
 80075b0:	dc400c15 	stw	r17,48(sp)
 80075b4:	dc000b15 	stw	r16,44(sp)
 80075b8:	df001304 	addi	fp,sp,76
 80075bc:	e13fef15 	stw	r4,-68(fp)
 80075c0:	e17ff015 	stw	r5,-64(fp)
 80075c4:	e1bff115 	stw	r6,-60(fp)
 80075c8:	e1fff215 	stw	r7,-56(fp)
	register int x_0 = x0;
 80075cc:	e47ff017 	ldw	r17,-64(fp)
	register int y_0 = y0;
 80075d0:	e4fff117 	ldw	r19,-60(fp)
	register int x_1 = x1;
 80075d4:	e4bff217 	ldw	r18,-56(fp)
	register int y_1 = y1;
 80075d8:	e5000217 	ldw	r20,8(fp)
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
 80075dc:	a4c5c83a 	sub	r2,r20,r19
 80075e0:	1000010e 	bge	r2,zero,80075e8 <alt_up_pixel_buffer_dma_draw_line+0x5c>
 80075e4:	0085c83a 	sub	r2,zero,r2
 80075e8:	1007883a 	mov	r3,r2
 80075ec:	9445c83a 	sub	r2,r18,r17
 80075f0:	1000010e 	bge	r2,zero,80075f8 <alt_up_pixel_buffer_dma_draw_line+0x6c>
 80075f4:	0085c83a 	sub	r2,zero,r2
 80075f8:	10c4803a 	cmplt	r2,r2,r3
 80075fc:	e0bff305 	stb	r2,-52(fp)
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
 8007600:	e0bfef17 	ldw	r2,-68(fp)
 8007604:	10800e17 	ldw	r2,56(r2)
 8007608:	10800060 	cmpeqi	r2,r2,1
 800760c:	1000081e 	bne	r2,zero,8007630 <alt_up_pixel_buffer_dma_draw_line+0xa4>
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
 8007610:	e0bfef17 	ldw	r2,-68(fp)
 8007614:	10800e17 	ldw	r2,56(r2)
 8007618:	10800098 	cmpnei	r2,r2,2
 800761c:	1000021e 	bne	r2,zero,8007628 <alt_up_pixel_buffer_dma_draw_line+0x9c>
 8007620:	00800044 	movi	r2,1
 8007624:	00000306 	br	8007634 <alt_up_pixel_buffer_dma_draw_line+0xa8>
 8007628:	00800084 	movi	r2,2
 800762c:	00000106 	br	8007634 <alt_up_pixel_buffer_dma_draw_line+0xa8>
	register int y_0 = y0;
	register int x_1 = x1;
	register int y_1 = y1;
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
 8007630:	0005883a 	mov	r2,zero
 8007634:	e0bff415 	stw	r2,-48(fp)
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
	register int line_color = color;
 8007638:	e0800317 	ldw	r2,12(fp)
 800763c:	e0bff515 	stw	r2,-44(fp)
	register unsigned int buffer_start;
	register int line_size = (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) ? (1 << (pixel_buffer->y_coord_offset-color_mode)) : pixel_buffer->x_resolution;
 8007640:	e0bfef17 	ldw	r2,-68(fp)
 8007644:	10800d17 	ldw	r2,52(r2)
 8007648:	1000071e 	bne	r2,zero,8007668 <alt_up_pixel_buffer_dma_draw_line+0xdc>
 800764c:	e0bfef17 	ldw	r2,-68(fp)
 8007650:	10801317 	ldw	r2,76(r2)
 8007654:	e0fff417 	ldw	r3,-48(fp)
 8007658:	10c5c83a 	sub	r2,r2,r3
 800765c:	00c00044 	movi	r3,1
 8007660:	1884983a 	sll	r2,r3,r2
 8007664:	00000206 	br	8007670 <alt_up_pixel_buffer_dma_draw_line+0xe4>
 8007668:	e0bfef17 	ldw	r2,-68(fp)
 800766c:	10800f17 	ldw	r2,60(r2)
 8007670:	e0bff615 	stw	r2,-40(fp)

	if (backbuffer == 1)
 8007674:	e0800417 	ldw	r2,16(fp)
 8007678:	10800058 	cmpnei	r2,r2,1
 800767c:	1000031e 	bne	r2,zero,800768c <alt_up_pixel_buffer_dma_draw_line+0x100>
		buffer_start = pixel_buffer->back_buffer_start_address;
 8007680:	e0bfef17 	ldw	r2,-68(fp)
 8007684:	15c00c17 	ldw	r23,48(r2)
 8007688:	00000206 	br	8007694 <alt_up_pixel_buffer_dma_draw_line+0x108>
	else
		buffer_start = pixel_buffer->buffer_start_address;
 800768c:	e0bfef17 	ldw	r2,-68(fp)
 8007690:	15c00b17 	ldw	r23,44(r2)

	/* Preprocessing inputs */
	if (steep > 0) {
 8007694:	e0bff307 	ldb	r2,-52(fp)
 8007698:	0080060e 	bge	zero,r2,80076b4 <alt_up_pixel_buffer_dma_draw_line+0x128>
		// Swap x_0 and y_0
		error = x_0;
 800769c:	8821883a 	mov	r16,r17
		x_0 = y_0;
 80076a0:	9823883a 	mov	r17,r19
		y_0 = error;
 80076a4:	8027883a 	mov	r19,r16
		// Swap x_1 and y_1
		error = x_1;
 80076a8:	9021883a 	mov	r16,r18
		x_1 = y_1;
 80076ac:	a025883a 	mov	r18,r20
		y_1 = error;
 80076b0:	8029883a 	mov	r20,r16
	}
	if (x_0 > x_1) {
 80076b4:	9440060e 	bge	r18,r17,80076d0 <alt_up_pixel_buffer_dma_draw_line+0x144>
		// Swap x_0 and x_1
		error = x_0;
 80076b8:	8821883a 	mov	r16,r17
		x_0 = x_1;
 80076bc:	9023883a 	mov	r17,r18
		x_1 = error;
 80076c0:	8025883a 	mov	r18,r16
		// Swap y_0 and y_1
		error = y_0;
 80076c4:	9821883a 	mov	r16,r19
		y_0 = y_1;
 80076c8:	a027883a 	mov	r19,r20
		y_1 = error;
 80076cc:	8029883a 	mov	r20,r16
	}

	/* Setup local variables */
	deltax = x_1 - x_0;
 80076d0:	946bc83a 	sub	r21,r18,r17
	deltay = ABS(y_1 - y_0);
 80076d4:	a4c5c83a 	sub	r2,r20,r19
 80076d8:	1000010e 	bge	r2,zero,80076e0 <alt_up_pixel_buffer_dma_draw_line+0x154>
 80076dc:	0085c83a 	sub	r2,zero,r2
 80076e0:	e0bff715 	stw	r2,-36(fp)
	error = -(deltax / 2); 
 80076e4:	a804d7fa 	srli	r2,r21,31
 80076e8:	1545883a 	add	r2,r2,r21
 80076ec:	1005d07a 	srai	r2,r2,1
 80076f0:	00a1c83a 	sub	r16,zero,r2
	y = y_0;
 80076f4:	982d883a 	mov	r22,r19
	if (y_0 < y_1)
 80076f8:	9d00020e 	bge	r19,r20,8007704 <alt_up_pixel_buffer_dma_draw_line+0x178>
		ystep = 1;
 80076fc:	04c00044 	movi	r19,1
 8007700:	00000106 	br	8007708 <alt_up_pixel_buffer_dma_draw_line+0x17c>
	else
		ystep = -1;
 8007704:	04ffffc4 	movi	r19,-1

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
 8007708:	e0bff307 	ldb	r2,-52(fp)
 800770c:	10800058 	cmpnei	r2,r2,1
 8007710:	1000211e 	bne	r2,zero,8007798 <alt_up_pixel_buffer_dma_draw_line+0x20c>
	{
		for (x=x_0; x <= x_1; x++) {
 8007714:	00000f06 	br	8007754 <alt_up_pixel_buffer_dma_draw_line+0x1c8>
			helper_plot_pixel(buffer_start, line_size, y, x, line_color, color_mode);
 8007718:	e0bff417 	ldw	r2,-48(fp)
 800771c:	d8800115 	stw	r2,4(sp)
 8007720:	e0bff517 	ldw	r2,-44(fp)
 8007724:	d8800015 	stw	r2,0(sp)
 8007728:	880f883a 	mov	r7,r17
 800772c:	b00d883a 	mov	r6,r22
 8007730:	e17ff617 	ldw	r5,-40(fp)
 8007734:	b809883a 	mov	r4,r23
 8007738:	80075080 	call	8007508 <helper_plot_pixel>
			error = error + deltay;
 800773c:	e0bff717 	ldw	r2,-36(fp)
 8007740:	80a1883a 	add	r16,r16,r2
			if (error > 0) {
 8007744:	0400020e 	bge	zero,r16,8007750 <alt_up_pixel_buffer_dma_draw_line+0x1c4>
				y = y + ystep;
 8007748:	b4ed883a 	add	r22,r22,r19
				error = error - deltax;
 800774c:	8561c83a 	sub	r16,r16,r21

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
	{
		for (x=x_0; x <= x_1; x++) {
 8007750:	8c400044 	addi	r17,r17,1
 8007754:	947ff00e 	bge	r18,r17,8007718 <alt_up_pixel_buffer_dma_draw_line+0x18c>
				y = y + ystep;
				error = error - deltax;
			}
		}
	}
}
 8007758:	00001006 	br	800779c <alt_up_pixel_buffer_dma_draw_line+0x210>
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
			helper_plot_pixel(buffer_start, line_size, x, y, line_color, color_mode);
 800775c:	e0bff417 	ldw	r2,-48(fp)
 8007760:	d8800115 	stw	r2,4(sp)
 8007764:	e0bff517 	ldw	r2,-44(fp)
 8007768:	d8800015 	stw	r2,0(sp)
 800776c:	b00f883a 	mov	r7,r22
 8007770:	880d883a 	mov	r6,r17
 8007774:	e17ff617 	ldw	r5,-40(fp)
 8007778:	b809883a 	mov	r4,r23
 800777c:	80075080 	call	8007508 <helper_plot_pixel>
			error = error + deltay;
 8007780:	e0bff717 	ldw	r2,-36(fp)
 8007784:	80a1883a 	add	r16,r16,r2
			if (error > 0) {
 8007788:	0400020e 	bge	zero,r16,8007794 <alt_up_pixel_buffer_dma_draw_line+0x208>
				y = y + ystep;
 800778c:	b4ed883a 	add	r22,r22,r19
				error = error - deltax;
 8007790:	8561c83a 	sub	r16,r16,r21
			}
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
 8007794:	8c400044 	addi	r17,r17,1
 8007798:	947ff00e 	bge	r18,r17,800775c <alt_up_pixel_buffer_dma_draw_line+0x1d0>
				y = y + ystep;
				error = error - deltax;
			}
		}
	}
}
 800779c:	0001883a 	nop
 80077a0:	e6fff804 	addi	sp,fp,-32
 80077a4:	dfc00917 	ldw	ra,36(sp)
 80077a8:	df000817 	ldw	fp,32(sp)
 80077ac:	ddc00717 	ldw	r23,28(sp)
 80077b0:	dd800617 	ldw	r22,24(sp)
 80077b4:	dd400517 	ldw	r21,20(sp)
 80077b8:	dd000417 	ldw	r20,16(sp)
 80077bc:	dcc00317 	ldw	r19,12(sp)
 80077c0:	dc800217 	ldw	r18,8(sp)
 80077c4:	dc400117 	ldw	r17,4(sp)
 80077c8:	dc000017 	ldw	r16,0(sp)
 80077cc:	dec00a04 	addi	sp,sp,40
 80077d0:	f800283a 	ret

080077d4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 80077d4:	defff504 	addi	sp,sp,-44
 80077d8:	df000a15 	stw	fp,40(sp)
 80077dc:	df000a04 	addi	fp,sp,40
 80077e0:	e13ffc15 	stw	r4,-16(fp)
 80077e4:	e17ffd15 	stw	r5,-12(fp)
 80077e8:	e1bffe15 	stw	r6,-8(fp)
 80077ec:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 80077f0:	e03ff615 	stw	zero,-40(fp)
 80077f4:	d0a6ea17 	ldw	r2,-25688(gp)
  
  if (alt_ticks_per_second ())
 80077f8:	10003c26 	beq	r2,zero,80078ec <alt_alarm_start+0x118>
  {
    if (alarm)
 80077fc:	e0bffc17 	ldw	r2,-16(fp)
 8007800:	10003826 	beq	r2,zero,80078e4 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 8007804:	e0bffc17 	ldw	r2,-16(fp)
 8007808:	e0fffe17 	ldw	r3,-8(fp)
 800780c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 8007810:	e0bffc17 	ldw	r2,-16(fp)
 8007814:	e0ffff17 	ldw	r3,-4(fp)
 8007818:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800781c:	0005303a 	rdctl	r2,status
 8007820:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8007824:	e0fff917 	ldw	r3,-28(fp)
 8007828:	00bfff84 	movi	r2,-2
 800782c:	1884703a 	and	r2,r3,r2
 8007830:	1001703a 	wrctl	status,r2
  
  return context;
 8007834:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 8007838:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 800783c:	d0a6eb17 	ldw	r2,-25684(gp)
      
      current_nticks = alt_nticks();
 8007840:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 8007844:	e0fffd17 	ldw	r3,-12(fp)
 8007848:	e0bff617 	ldw	r2,-40(fp)
 800784c:	1885883a 	add	r2,r3,r2
 8007850:	10c00044 	addi	r3,r2,1
 8007854:	e0bffc17 	ldw	r2,-16(fp)
 8007858:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 800785c:	e0bffc17 	ldw	r2,-16(fp)
 8007860:	10c00217 	ldw	r3,8(r2)
 8007864:	e0bff617 	ldw	r2,-40(fp)
 8007868:	1880042e 	bgeu	r3,r2,800787c <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 800786c:	e0bffc17 	ldw	r2,-16(fp)
 8007870:	00c00044 	movi	r3,1
 8007874:	10c00405 	stb	r3,16(r2)
 8007878:	00000206 	br	8007884 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 800787c:	e0bffc17 	ldw	r2,-16(fp)
 8007880:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 8007884:	e0bffc17 	ldw	r2,-16(fp)
 8007888:	d0e00b04 	addi	r3,gp,-32724
 800788c:	e0fffa15 	stw	r3,-24(fp)
 8007890:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 8007894:	e0bffb17 	ldw	r2,-20(fp)
 8007898:	e0fffa17 	ldw	r3,-24(fp)
 800789c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 80078a0:	e0bffa17 	ldw	r2,-24(fp)
 80078a4:	10c00017 	ldw	r3,0(r2)
 80078a8:	e0bffb17 	ldw	r2,-20(fp)
 80078ac:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 80078b0:	e0bffa17 	ldw	r2,-24(fp)
 80078b4:	10800017 	ldw	r2,0(r2)
 80078b8:	e0fffb17 	ldw	r3,-20(fp)
 80078bc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 80078c0:	e0bffa17 	ldw	r2,-24(fp)
 80078c4:	e0fffb17 	ldw	r3,-20(fp)
 80078c8:	10c00015 	stw	r3,0(r2)
 80078cc:	e0bff817 	ldw	r2,-32(fp)
 80078d0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 80078d4:	e0bff717 	ldw	r2,-36(fp)
 80078d8:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 80078dc:	0005883a 	mov	r2,zero
 80078e0:	00000306 	br	80078f0 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 80078e4:	00bffa84 	movi	r2,-22
 80078e8:	00000106 	br	80078f0 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 80078ec:	00bfde84 	movi	r2,-134
  }
}
 80078f0:	e037883a 	mov	sp,fp
 80078f4:	df000017 	ldw	fp,0(sp)
 80078f8:	dec00104 	addi	sp,sp,4
 80078fc:	f800283a 	ret

08007900 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 8007900:	defffe04 	addi	sp,sp,-8
 8007904:	df000115 	stw	fp,4(sp)
 8007908:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 800790c:	e03fff15 	stw	zero,-4(fp)
 8007910:	00000506 	br	8007928 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 8007914:	e0bfff17 	ldw	r2,-4(fp)
 8007918:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 800791c:	e0bfff17 	ldw	r2,-4(fp)
 8007920:	10800804 	addi	r2,r2,32
 8007924:	e0bfff15 	stw	r2,-4(fp)
 8007928:	e0bfff17 	ldw	r2,-4(fp)
 800792c:	10820030 	cmpltui	r2,r2,2048
 8007930:	103ff81e 	bne	r2,zero,8007914 <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 8007934:	0001883a 	nop
 8007938:	e037883a 	mov	sp,fp
 800793c:	df000017 	ldw	fp,0(sp)
 8007940:	dec00104 	addi	sp,sp,4
 8007944:	f800283a 	ret

08007948 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8007948:	defffe04 	addi	sp,sp,-8
 800794c:	dfc00115 	stw	ra,4(sp)
 8007950:	df000015 	stw	fp,0(sp)
 8007954:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8007958:	d0a00917 	ldw	r2,-32732(gp)
 800795c:	10000326 	beq	r2,zero,800796c <alt_get_errno+0x24>
 8007960:	d0a00917 	ldw	r2,-32732(gp)
 8007964:	103ee83a 	callr	r2
 8007968:	00000106 	br	8007970 <alt_get_errno+0x28>
 800796c:	d0a6e604 	addi	r2,gp,-25704
}
 8007970:	e037883a 	mov	sp,fp
 8007974:	dfc00117 	ldw	ra,4(sp)
 8007978:	df000017 	ldw	fp,0(sp)
 800797c:	dec00204 	addi	sp,sp,8
 8007980:	f800283a 	ret

08007984 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 8007984:	defffa04 	addi	sp,sp,-24
 8007988:	dfc00515 	stw	ra,20(sp)
 800798c:	df000415 	stw	fp,16(sp)
 8007990:	df000404 	addi	fp,sp,16
 8007994:	e13ffe15 	stw	r4,-8(fp)
 8007998:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 800799c:	e0bffe17 	ldw	r2,-8(fp)
 80079a0:	10000326 	beq	r2,zero,80079b0 <alt_dev_llist_insert+0x2c>
 80079a4:	e0bffe17 	ldw	r2,-8(fp)
 80079a8:	10800217 	ldw	r2,8(r2)
 80079ac:	1000061e 	bne	r2,zero,80079c8 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 80079b0:	80079480 	call	8007948 <alt_get_errno>
 80079b4:	1007883a 	mov	r3,r2
 80079b8:	00800584 	movi	r2,22
 80079bc:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 80079c0:	00bffa84 	movi	r2,-22
 80079c4:	00001306 	br	8007a14 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 80079c8:	e0bffe17 	ldw	r2,-8(fp)
 80079cc:	e0ffff17 	ldw	r3,-4(fp)
 80079d0:	e0fffc15 	stw	r3,-16(fp)
 80079d4:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 80079d8:	e0bffd17 	ldw	r2,-12(fp)
 80079dc:	e0fffc17 	ldw	r3,-16(fp)
 80079e0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 80079e4:	e0bffc17 	ldw	r2,-16(fp)
 80079e8:	10c00017 	ldw	r3,0(r2)
 80079ec:	e0bffd17 	ldw	r2,-12(fp)
 80079f0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 80079f4:	e0bffc17 	ldw	r2,-16(fp)
 80079f8:	10800017 	ldw	r2,0(r2)
 80079fc:	e0fffd17 	ldw	r3,-12(fp)
 8007a00:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 8007a04:	e0bffc17 	ldw	r2,-16(fp)
 8007a08:	e0fffd17 	ldw	r3,-12(fp)
 8007a0c:	10c00015 	stw	r3,0(r2)

  return 0;  
 8007a10:	0005883a 	mov	r2,zero
}
 8007a14:	e037883a 	mov	sp,fp
 8007a18:	dfc00117 	ldw	ra,4(sp)
 8007a1c:	df000017 	ldw	fp,0(sp)
 8007a20:	dec00204 	addi	sp,sp,8
 8007a24:	f800283a 	ret

08007a28 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 8007a28:	defffd04 	addi	sp,sp,-12
 8007a2c:	dfc00215 	stw	ra,8(sp)
 8007a30:	df000115 	stw	fp,4(sp)
 8007a34:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 8007a38:	00820074 	movhi	r2,2049
 8007a3c:	10a18804 	addi	r2,r2,-31200
 8007a40:	e0bfff15 	stw	r2,-4(fp)
 8007a44:	00000606 	br	8007a60 <_do_ctors+0x38>
        (*ctor) (); 
 8007a48:	e0bfff17 	ldw	r2,-4(fp)
 8007a4c:	10800017 	ldw	r2,0(r2)
 8007a50:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 8007a54:	e0bfff17 	ldw	r2,-4(fp)
 8007a58:	10bfff04 	addi	r2,r2,-4
 8007a5c:	e0bfff15 	stw	r2,-4(fp)
 8007a60:	e0ffff17 	ldw	r3,-4(fp)
 8007a64:	00820074 	movhi	r2,2049
 8007a68:	10a18904 	addi	r2,r2,-31196
 8007a6c:	18bff62e 	bgeu	r3,r2,8007a48 <_do_ctors+0x20>
        (*ctor) (); 
}
 8007a70:	0001883a 	nop
 8007a74:	e037883a 	mov	sp,fp
 8007a78:	dfc00117 	ldw	ra,4(sp)
 8007a7c:	df000017 	ldw	fp,0(sp)
 8007a80:	dec00204 	addi	sp,sp,8
 8007a84:	f800283a 	ret

08007a88 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 8007a88:	defffd04 	addi	sp,sp,-12
 8007a8c:	dfc00215 	stw	ra,8(sp)
 8007a90:	df000115 	stw	fp,4(sp)
 8007a94:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 8007a98:	00820074 	movhi	r2,2049
 8007a9c:	10a18804 	addi	r2,r2,-31200
 8007aa0:	e0bfff15 	stw	r2,-4(fp)
 8007aa4:	00000606 	br	8007ac0 <_do_dtors+0x38>
        (*dtor) (); 
 8007aa8:	e0bfff17 	ldw	r2,-4(fp)
 8007aac:	10800017 	ldw	r2,0(r2)
 8007ab0:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 8007ab4:	e0bfff17 	ldw	r2,-4(fp)
 8007ab8:	10bfff04 	addi	r2,r2,-4
 8007abc:	e0bfff15 	stw	r2,-4(fp)
 8007ac0:	e0ffff17 	ldw	r3,-4(fp)
 8007ac4:	00820074 	movhi	r2,2049
 8007ac8:	10a18904 	addi	r2,r2,-31196
 8007acc:	18bff62e 	bgeu	r3,r2,8007aa8 <_do_dtors+0x20>
        (*dtor) (); 
}
 8007ad0:	0001883a 	nop
 8007ad4:	e037883a 	mov	sp,fp
 8007ad8:	dfc00117 	ldw	ra,4(sp)
 8007adc:	df000017 	ldw	fp,0(sp)
 8007ae0:	dec00204 	addi	sp,sp,8
 8007ae4:	f800283a 	ret

08007ae8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 8007ae8:	defffa04 	addi	sp,sp,-24
 8007aec:	dfc00515 	stw	ra,20(sp)
 8007af0:	df000415 	stw	fp,16(sp)
 8007af4:	df000404 	addi	fp,sp,16
 8007af8:	e13ffe15 	stw	r4,-8(fp)
 8007afc:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 8007b00:	e0bfff17 	ldw	r2,-4(fp)
 8007b04:	10800017 	ldw	r2,0(r2)
 8007b08:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 8007b0c:	e13ffe17 	ldw	r4,-8(fp)
 8007b10:	80005300 	call	8000530 <strlen>
 8007b14:	10800044 	addi	r2,r2,1
 8007b18:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 8007b1c:	00000d06 	br	8007b54 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 8007b20:	e0bffc17 	ldw	r2,-16(fp)
 8007b24:	10800217 	ldw	r2,8(r2)
 8007b28:	e0fffd17 	ldw	r3,-12(fp)
 8007b2c:	180d883a 	mov	r6,r3
 8007b30:	e17ffe17 	ldw	r5,-8(fp)
 8007b34:	1009883a 	mov	r4,r2
 8007b38:	80080200 	call	8008020 <memcmp>
 8007b3c:	1000021e 	bne	r2,zero,8007b48 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 8007b40:	e0bffc17 	ldw	r2,-16(fp)
 8007b44:	00000706 	br	8007b64 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 8007b48:	e0bffc17 	ldw	r2,-16(fp)
 8007b4c:	10800017 	ldw	r2,0(r2)
 8007b50:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 8007b54:	e0fffc17 	ldw	r3,-16(fp)
 8007b58:	e0bfff17 	ldw	r2,-4(fp)
 8007b5c:	18bff01e 	bne	r3,r2,8007b20 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 8007b60:	0005883a 	mov	r2,zero
}
 8007b64:	e037883a 	mov	sp,fp
 8007b68:	dfc00117 	ldw	ra,4(sp)
 8007b6c:	df000017 	ldw	fp,0(sp)
 8007b70:	dec00204 	addi	sp,sp,8
 8007b74:	f800283a 	ret

08007b78 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 8007b78:	defffe04 	addi	sp,sp,-8
 8007b7c:	dfc00115 	stw	ra,4(sp)
 8007b80:	df000015 	stw	fp,0(sp)
 8007b84:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 8007b88:	01440004 	movi	r5,4096
 8007b8c:	0009883a 	mov	r4,zero
 8007b90:	8007e700 	call	8007e70 <alt_icache_flush>
#endif
}
 8007b94:	0001883a 	nop
 8007b98:	e037883a 	mov	sp,fp
 8007b9c:	dfc00117 	ldw	ra,4(sp)
 8007ba0:	df000017 	ldw	fp,0(sp)
 8007ba4:	dec00204 	addi	sp,sp,8
 8007ba8:	f800283a 	ret

08007bac <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 8007bac:	defff904 	addi	sp,sp,-28
 8007bb0:	dfc00615 	stw	ra,24(sp)
 8007bb4:	df000515 	stw	fp,20(sp)
 8007bb8:	df000504 	addi	fp,sp,20
 8007bbc:	e13ffc15 	stw	r4,-16(fp)
 8007bc0:	e17ffd15 	stw	r5,-12(fp)
 8007bc4:	e1bffe15 	stw	r6,-8(fp)
 8007bc8:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 8007bcc:	e0800217 	ldw	r2,8(fp)
 8007bd0:	d8800015 	stw	r2,0(sp)
 8007bd4:	e1ffff17 	ldw	r7,-4(fp)
 8007bd8:	e1bffe17 	ldw	r6,-8(fp)
 8007bdc:	e17ffd17 	ldw	r5,-12(fp)
 8007be0:	e13ffc17 	ldw	r4,-16(fp)
 8007be4:	8007d5c0 	call	8007d5c <alt_iic_isr_register>
}  
 8007be8:	e037883a 	mov	sp,fp
 8007bec:	dfc00117 	ldw	ra,4(sp)
 8007bf0:	df000017 	ldw	fp,0(sp)
 8007bf4:	dec00204 	addi	sp,sp,8
 8007bf8:	f800283a 	ret

08007bfc <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 8007bfc:	defff904 	addi	sp,sp,-28
 8007c00:	df000615 	stw	fp,24(sp)
 8007c04:	df000604 	addi	fp,sp,24
 8007c08:	e13ffe15 	stw	r4,-8(fp)
 8007c0c:	e17fff15 	stw	r5,-4(fp)
 8007c10:	e0bfff17 	ldw	r2,-4(fp)
 8007c14:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8007c18:	0005303a 	rdctl	r2,status
 8007c1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8007c20:	e0fffb17 	ldw	r3,-20(fp)
 8007c24:	00bfff84 	movi	r2,-2
 8007c28:	1884703a 	and	r2,r3,r2
 8007c2c:	1001703a 	wrctl	status,r2
  
  return context;
 8007c30:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 8007c34:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 8007c38:	00c00044 	movi	r3,1
 8007c3c:	e0bffa17 	ldw	r2,-24(fp)
 8007c40:	1884983a 	sll	r2,r3,r2
 8007c44:	1007883a 	mov	r3,r2
 8007c48:	d0a6ec17 	ldw	r2,-25680(gp)
 8007c4c:	1884b03a 	or	r2,r3,r2
 8007c50:	d0a6ec15 	stw	r2,-25680(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 8007c54:	d0a6ec17 	ldw	r2,-25680(gp)
 8007c58:	100170fa 	wrctl	ienable,r2
 8007c5c:	e0bffc17 	ldw	r2,-16(fp)
 8007c60:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8007c64:	e0bffd17 	ldw	r2,-12(fp)
 8007c68:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 8007c6c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 8007c70:	0001883a 	nop
}
 8007c74:	e037883a 	mov	sp,fp
 8007c78:	df000017 	ldw	fp,0(sp)
 8007c7c:	dec00104 	addi	sp,sp,4
 8007c80:	f800283a 	ret

08007c84 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 8007c84:	defff904 	addi	sp,sp,-28
 8007c88:	df000615 	stw	fp,24(sp)
 8007c8c:	df000604 	addi	fp,sp,24
 8007c90:	e13ffe15 	stw	r4,-8(fp)
 8007c94:	e17fff15 	stw	r5,-4(fp)
 8007c98:	e0bfff17 	ldw	r2,-4(fp)
 8007c9c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8007ca0:	0005303a 	rdctl	r2,status
 8007ca4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8007ca8:	e0fffb17 	ldw	r3,-20(fp)
 8007cac:	00bfff84 	movi	r2,-2
 8007cb0:	1884703a 	and	r2,r3,r2
 8007cb4:	1001703a 	wrctl	status,r2
  
  return context;
 8007cb8:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 8007cbc:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 8007cc0:	00c00044 	movi	r3,1
 8007cc4:	e0bffa17 	ldw	r2,-24(fp)
 8007cc8:	1884983a 	sll	r2,r3,r2
 8007ccc:	0084303a 	nor	r2,zero,r2
 8007cd0:	1007883a 	mov	r3,r2
 8007cd4:	d0a6ec17 	ldw	r2,-25680(gp)
 8007cd8:	1884703a 	and	r2,r3,r2
 8007cdc:	d0a6ec15 	stw	r2,-25680(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 8007ce0:	d0a6ec17 	ldw	r2,-25680(gp)
 8007ce4:	100170fa 	wrctl	ienable,r2
 8007ce8:	e0bffc17 	ldw	r2,-16(fp)
 8007cec:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8007cf0:	e0bffd17 	ldw	r2,-12(fp)
 8007cf4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 8007cf8:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 8007cfc:	0001883a 	nop
}
 8007d00:	e037883a 	mov	sp,fp
 8007d04:	df000017 	ldw	fp,0(sp)
 8007d08:	dec00104 	addi	sp,sp,4
 8007d0c:	f800283a 	ret

08007d10 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 8007d10:	defffc04 	addi	sp,sp,-16
 8007d14:	df000315 	stw	fp,12(sp)
 8007d18:	df000304 	addi	fp,sp,12
 8007d1c:	e13ffe15 	stw	r4,-8(fp)
 8007d20:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 8007d24:	000530fa 	rdctl	r2,ienable
 8007d28:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 8007d2c:	00c00044 	movi	r3,1
 8007d30:	e0bfff17 	ldw	r2,-4(fp)
 8007d34:	1884983a 	sll	r2,r3,r2
 8007d38:	1007883a 	mov	r3,r2
 8007d3c:	e0bffd17 	ldw	r2,-12(fp)
 8007d40:	1884703a 	and	r2,r3,r2
 8007d44:	1004c03a 	cmpne	r2,r2,zero
 8007d48:	10803fcc 	andi	r2,r2,255
}
 8007d4c:	e037883a 	mov	sp,fp
 8007d50:	df000017 	ldw	fp,0(sp)
 8007d54:	dec00104 	addi	sp,sp,4
 8007d58:	f800283a 	ret

08007d5c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 8007d5c:	defff504 	addi	sp,sp,-44
 8007d60:	dfc00a15 	stw	ra,40(sp)
 8007d64:	df000915 	stw	fp,36(sp)
 8007d68:	df000904 	addi	fp,sp,36
 8007d6c:	e13ffc15 	stw	r4,-16(fp)
 8007d70:	e17ffd15 	stw	r5,-12(fp)
 8007d74:	e1bffe15 	stw	r6,-8(fp)
 8007d78:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 8007d7c:	00bffa84 	movi	r2,-22
 8007d80:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 8007d84:	e0bffd17 	ldw	r2,-12(fp)
 8007d88:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 8007d8c:	e0bff817 	ldw	r2,-32(fp)
 8007d90:	10800808 	cmpgei	r2,r2,32
 8007d94:	1000271e 	bne	r2,zero,8007e34 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8007d98:	0005303a 	rdctl	r2,status
 8007d9c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8007da0:	e0fffb17 	ldw	r3,-20(fp)
 8007da4:	00bfff84 	movi	r2,-2
 8007da8:	1884703a 	and	r2,r3,r2
 8007dac:	1001703a 	wrctl	status,r2
  
  return context;
 8007db0:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 8007db4:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 8007db8:	00820134 	movhi	r2,2052
 8007dbc:	10909404 	addi	r2,r2,16976
 8007dc0:	e0fff817 	ldw	r3,-32(fp)
 8007dc4:	180690fa 	slli	r3,r3,3
 8007dc8:	10c5883a 	add	r2,r2,r3
 8007dcc:	e0fffe17 	ldw	r3,-8(fp)
 8007dd0:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 8007dd4:	00820134 	movhi	r2,2052
 8007dd8:	10909404 	addi	r2,r2,16976
 8007ddc:	e0fff817 	ldw	r3,-32(fp)
 8007de0:	180690fa 	slli	r3,r3,3
 8007de4:	10c5883a 	add	r2,r2,r3
 8007de8:	10800104 	addi	r2,r2,4
 8007dec:	e0ffff17 	ldw	r3,-4(fp)
 8007df0:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 8007df4:	e0bffe17 	ldw	r2,-8(fp)
 8007df8:	10000526 	beq	r2,zero,8007e10 <alt_iic_isr_register+0xb4>
 8007dfc:	e0bff817 	ldw	r2,-32(fp)
 8007e00:	100b883a 	mov	r5,r2
 8007e04:	e13ffc17 	ldw	r4,-16(fp)
 8007e08:	8007bfc0 	call	8007bfc <alt_ic_irq_enable>
 8007e0c:	00000406 	br	8007e20 <alt_iic_isr_register+0xc4>
 8007e10:	e0bff817 	ldw	r2,-32(fp)
 8007e14:	100b883a 	mov	r5,r2
 8007e18:	e13ffc17 	ldw	r4,-16(fp)
 8007e1c:	8007c840 	call	8007c84 <alt_ic_irq_disable>
 8007e20:	e0bff715 	stw	r2,-36(fp)
 8007e24:	e0bffa17 	ldw	r2,-24(fp)
 8007e28:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8007e2c:	e0bff917 	ldw	r2,-28(fp)
 8007e30:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 8007e34:	e0bff717 	ldw	r2,-36(fp)
}
 8007e38:	e037883a 	mov	sp,fp
 8007e3c:	dfc00117 	ldw	ra,4(sp)
 8007e40:	df000017 	ldw	fp,0(sp)
 8007e44:	dec00204 	addi	sp,sp,8
 8007e48:	f800283a 	ret

08007e4c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 8007e4c:	deffff04 	addi	sp,sp,-4
 8007e50:	df000015 	stw	fp,0(sp)
 8007e54:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 8007e58:	000170fa 	wrctl	ienable,zero
}
 8007e5c:	0001883a 	nop
 8007e60:	e037883a 	mov	sp,fp
 8007e64:	df000017 	ldw	fp,0(sp)
 8007e68:	dec00104 	addi	sp,sp,4
 8007e6c:	f800283a 	ret

08007e70 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 8007e70:	defffb04 	addi	sp,sp,-20
 8007e74:	df000415 	stw	fp,16(sp)
 8007e78:	df000404 	addi	fp,sp,16
 8007e7c:	e13ffe15 	stw	r4,-8(fp)
 8007e80:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 8007e84:	e0bfff17 	ldw	r2,-4(fp)
 8007e88:	10840070 	cmpltui	r2,r2,4097
 8007e8c:	1000021e 	bne	r2,zero,8007e98 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 8007e90:	00840004 	movi	r2,4096
 8007e94:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 8007e98:	e0fffe17 	ldw	r3,-8(fp)
 8007e9c:	e0bfff17 	ldw	r2,-4(fp)
 8007ea0:	1885883a 	add	r2,r3,r2
 8007ea4:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 8007ea8:	e0bffe17 	ldw	r2,-8(fp)
 8007eac:	e0bffc15 	stw	r2,-16(fp)
 8007eb0:	00000506 	br	8007ec8 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 8007eb4:	e0bffc17 	ldw	r2,-16(fp)
 8007eb8:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 8007ebc:	e0bffc17 	ldw	r2,-16(fp)
 8007ec0:	10800804 	addi	r2,r2,32
 8007ec4:	e0bffc15 	stw	r2,-16(fp)
 8007ec8:	e0fffc17 	ldw	r3,-16(fp)
 8007ecc:	e0bffd17 	ldw	r2,-12(fp)
 8007ed0:	18bff836 	bltu	r3,r2,8007eb4 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 8007ed4:	e0bffe17 	ldw	r2,-8(fp)
 8007ed8:	108007cc 	andi	r2,r2,31
 8007edc:	10000226 	beq	r2,zero,8007ee8 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 8007ee0:	e0bffc17 	ldw	r2,-16(fp)
 8007ee4:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 8007ee8:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 8007eec:	0001883a 	nop
 8007ef0:	e037883a 	mov	sp,fp
 8007ef4:	df000017 	ldw	fp,0(sp)
 8007ef8:	dec00104 	addi	sp,sp,4
 8007efc:	f800283a 	ret

08007f00 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 8007f00:	defffe04 	addi	sp,sp,-8
 8007f04:	df000115 	stw	fp,4(sp)
 8007f08:	df000104 	addi	fp,sp,4
 8007f0c:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 8007f10:	e0bfff17 	ldw	r2,-4(fp)
 8007f14:	10bffe84 	addi	r2,r2,-6
 8007f18:	10c00428 	cmpgeui	r3,r2,16
 8007f1c:	18001a1e 	bne	r3,zero,8007f88 <alt_exception_cause_generated_bad_addr+0x88>
 8007f20:	100690ba 	slli	r3,r2,2
 8007f24:	00820034 	movhi	r2,2048
 8007f28:	109fce04 	addi	r2,r2,32568
 8007f2c:	1885883a 	add	r2,r3,r2
 8007f30:	10800017 	ldw	r2,0(r2)
 8007f34:	1000683a 	jmp	r2
 8007f38:	08007f78 	rdprs	zero,at,509
 8007f3c:	08007f78 	rdprs	zero,at,509
 8007f40:	08007f88 	cmpgei	zero,at,510
 8007f44:	08007f88 	cmpgei	zero,at,510
 8007f48:	08007f88 	cmpgei	zero,at,510
 8007f4c:	08007f78 	rdprs	zero,at,509
 8007f50:	08007f80 	call	8007f8 <__alt_mem_sdram_controller_0-0x77ff808>
 8007f54:	08007f88 	cmpgei	zero,at,510
 8007f58:	08007f78 	rdprs	zero,at,509
 8007f5c:	08007f78 	rdprs	zero,at,509
 8007f60:	08007f88 	cmpgei	zero,at,510
 8007f64:	08007f78 	rdprs	zero,at,509
 8007f68:	08007f80 	call	8007f8 <__alt_mem_sdram_controller_0-0x77ff808>
 8007f6c:	08007f88 	cmpgei	zero,at,510
 8007f70:	08007f88 	cmpgei	zero,at,510
 8007f74:	08007f78 	rdprs	zero,at,509
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 8007f78:	00800044 	movi	r2,1
 8007f7c:	00000306 	br	8007f8c <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 8007f80:	0005883a 	mov	r2,zero
 8007f84:	00000106 	br	8007f8c <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
 8007f88:	0005883a 	mov	r2,zero
  }
}
 8007f8c:	e037883a 	mov	sp,fp
 8007f90:	df000017 	ldw	fp,0(sp)
 8007f94:	dec00104 	addi	sp,sp,4
 8007f98:	f800283a 	ret

08007f9c <atexit>:

int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
 8007f9c:	defffd04 	addi	sp,sp,-12
 8007fa0:	dfc00215 	stw	ra,8(sp)
 8007fa4:	df000115 	stw	fp,4(sp)
 8007fa8:	df000104 	addi	fp,sp,4
 8007fac:	e13fff15 	stw	r4,-4(fp)
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
 8007fb0:	000f883a 	mov	r7,zero
 8007fb4:	000d883a 	mov	r6,zero
 8007fb8:	e17fff17 	ldw	r5,-4(fp)
 8007fbc:	0009883a 	mov	r4,zero
 8007fc0:	80082940 	call	8008294 <__register_exitproc>
}
 8007fc4:	e037883a 	mov	sp,fp
 8007fc8:	dfc00117 	ldw	ra,4(sp)
 8007fcc:	df000017 	ldw	fp,0(sp)
 8007fd0:	dec00204 	addi	sp,sp,8
 8007fd4:	f800283a 	ret

08007fd8 <exit>:
 */

void
_DEFUN (exit, (code),
	int code)
{
 8007fd8:	defffd04 	addi	sp,sp,-12
 8007fdc:	dfc00215 	stw	ra,8(sp)
 8007fe0:	df000115 	stw	fp,4(sp)
 8007fe4:	df000104 	addi	fp,sp,4
 8007fe8:	e13fff15 	stw	r4,-4(fp)
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs _PARAMS ((int, _PTR)) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
 8007fec:	000b883a 	mov	r5,zero
 8007ff0:	e13fff17 	ldw	r4,-4(fp)
 8007ff4:	80084040 	call	8008404 <__call_exitprocs>

#ifndef WANT_SMALL_STDIO				/* AlteraSpecific */
  if (_GLOBAL_REENT->__cleanup)
 8007ff8:	d0a00117 	ldw	r2,-32764(gp)
 8007ffc:	10800f17 	ldw	r2,60(r2)
 8008000:	10000526 	beq	r2,zero,8008018 <exit+0x40>
    (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
 8008004:	d0a00117 	ldw	r2,-32764(gp)
 8008008:	10800f17 	ldw	r2,60(r2)
 800800c:	d0e00117 	ldw	r3,-32764(gp)
 8008010:	1809883a 	mov	r4,r3
 8008014:	103ee83a 	callr	r2
#endif							/* AlteraSpecific */
  _exit (code);
 8008018:	e13fff17 	ldw	r4,-4(fp)
 800801c:	80085f00 	call	80085f0 <_exit>

08008020 <memcmp>:
int
_DEFUN (memcmp, (m1, m2, n),
	_CONST _PTR m1 _AND
	_CONST _PTR m2 _AND
	size_t n)
{
 8008020:	defff804 	addi	sp,sp,-32
 8008024:	df000715 	stw	fp,28(sp)
 8008028:	df000704 	addi	fp,sp,28
 800802c:	e13ffd15 	stw	r4,-12(fp)
 8008030:	e17ffe15 	stw	r5,-8(fp)
 8008034:	e1bfff15 	stw	r6,-4(fp)
      s1++;
      s2++;
    }
  return 0;
#else  
  unsigned char *s1 = (unsigned char *) m1;
 8008038:	e0bffd17 	ldw	r2,-12(fp)
 800803c:	e0bff915 	stw	r2,-28(fp)
  unsigned char *s2 = (unsigned char *) m2;
 8008040:	e0bffe17 	ldw	r2,-8(fp)
 8008044:	e0bffa15 	stw	r2,-24(fp)
  unsigned long *a2;

  /* If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.  */
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
 8008048:	e0bfff17 	ldw	r2,-4(fp)
 800804c:	10800130 	cmpltui	r2,r2,4
 8008050:	1000371e 	bne	r2,zero,8008130 <memcmp+0x110>
 8008054:	e0fff917 	ldw	r3,-28(fp)
 8008058:	e0bffa17 	ldw	r2,-24(fp)
 800805c:	1884b03a 	or	r2,r3,r2
 8008060:	108000cc 	andi	r2,r2,3
 8008064:	1000321e 	bne	r2,zero,8008130 <memcmp+0x110>
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
 8008068:	e0bff917 	ldw	r2,-28(fp)
 800806c:	e0bffb15 	stw	r2,-20(fp)
      a2 = (unsigned long*) s2;
 8008070:	e0bffa17 	ldw	r2,-24(fp)
 8008074:	e0bffc15 	stw	r2,-16(fp)
      while (n >= LBLOCKSIZE)
 8008078:	00000e06 	br	80080b4 <memcmp+0x94>
        {
          if (*a1 != *a2) 
 800807c:	e0bffb17 	ldw	r2,-20(fp)
 8008080:	10c00017 	ldw	r3,0(r2)
 8008084:	e0bffc17 	ldw	r2,-16(fp)
 8008088:	10800017 	ldw	r2,0(r2)
 800808c:	18800d1e 	bne	r3,r2,80080c4 <memcmp+0xa4>
   	    break;
          a1++;
 8008090:	e0bffb17 	ldw	r2,-20(fp)
 8008094:	10800104 	addi	r2,r2,4
 8008098:	e0bffb15 	stw	r2,-20(fp)
          a2++;
 800809c:	e0bffc17 	ldw	r2,-16(fp)
 80080a0:	10800104 	addi	r2,r2,4
 80080a4:	e0bffc15 	stw	r2,-16(fp)
          n -= LBLOCKSIZE;
 80080a8:	e0bfff17 	ldw	r2,-4(fp)
 80080ac:	10bfff04 	addi	r2,r2,-4
 80080b0:	e0bfff15 	stw	r2,-4(fp)
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
      a2 = (unsigned long*) s2;
      while (n >= LBLOCKSIZE)
 80080b4:	e0bfff17 	ldw	r2,-4(fp)
 80080b8:	10800128 	cmpgeui	r2,r2,4
 80080bc:	103fef1e 	bne	r2,zero,800807c <memcmp+0x5c>
 80080c0:	00000106 	br	80080c8 <memcmp+0xa8>
        {
          if (*a1 != *a2) 
   	    break;
 80080c4:	0001883a 	nop
          n -= LBLOCKSIZE;
        }

      /* check m mod LBLOCKSIZE remaining characters */

      s1 = (unsigned char*)a1;
 80080c8:	e0bffb17 	ldw	r2,-20(fp)
 80080cc:	e0bff915 	stw	r2,-28(fp)
      s2 = (unsigned char*)a2;
 80080d0:	e0bffc17 	ldw	r2,-16(fp)
 80080d4:	e0bffa15 	stw	r2,-24(fp)
    }

  while (n--)
 80080d8:	00001506 	br	8008130 <memcmp+0x110>
    {
      if (*s1 != *s2)
 80080dc:	e0bff917 	ldw	r2,-28(fp)
 80080e0:	10c00003 	ldbu	r3,0(r2)
 80080e4:	e0bffa17 	ldw	r2,-24(fp)
 80080e8:	10800003 	ldbu	r2,0(r2)
 80080ec:	18c03fcc 	andi	r3,r3,255
 80080f0:	10803fcc 	andi	r2,r2,255
 80080f4:	18800826 	beq	r3,r2,8008118 <memcmp+0xf8>
	return *s1 - *s2;
 80080f8:	e0bff917 	ldw	r2,-28(fp)
 80080fc:	10800003 	ldbu	r2,0(r2)
 8008100:	10c03fcc 	andi	r3,r2,255
 8008104:	e0bffa17 	ldw	r2,-24(fp)
 8008108:	10800003 	ldbu	r2,0(r2)
 800810c:	10803fcc 	andi	r2,r2,255
 8008110:	1885c83a 	sub	r2,r3,r2
 8008114:	00000b06 	br	8008144 <memcmp+0x124>
      s1++;
 8008118:	e0bff917 	ldw	r2,-28(fp)
 800811c:	10800044 	addi	r2,r2,1
 8008120:	e0bff915 	stw	r2,-28(fp)
      s2++;
 8008124:	e0bffa17 	ldw	r2,-24(fp)
 8008128:	10800044 	addi	r2,r2,1
 800812c:	e0bffa15 	stw	r2,-24(fp)

      s1 = (unsigned char*)a1;
      s2 = (unsigned char*)a2;
    }

  while (n--)
 8008130:	e0bfff17 	ldw	r2,-4(fp)
 8008134:	10ffffc4 	addi	r3,r2,-1
 8008138:	e0ffff15 	stw	r3,-4(fp)
 800813c:	103fe71e 	bne	r2,zero,80080dc <memcmp+0xbc>
	return *s1 - *s2;
      s1++;
      s2++;
    }

  return 0;
 8008140:	0005883a 	mov	r2,zero
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 8008144:	e037883a 	mov	sp,fp
 8008148:	df000017 	ldw	fp,0(sp)
 800814c:	dec00104 	addi	sp,sp,4
 8008150:	f800283a 	ret

08008154 <strcmp>:

int
_DEFUN (strcmp, (s1, s2),
	_CONST char *s1 _AND
	_CONST char *s2)
{ 
 8008154:	defffb04 	addi	sp,sp,-20
 8008158:	df000415 	stw	fp,16(sp)
 800815c:	df000404 	addi	fp,sp,16
 8008160:	e13ffe15 	stw	r4,-8(fp)
 8008164:	e17fff15 	stw	r5,-4(fp)
#else
  unsigned long *a1;
  unsigned long *a2;

  /* If s1 or s2 are unaligned, then compare bytes. */
  if (!UNALIGNED (s1, s2))
 8008168:	e0fffe17 	ldw	r3,-8(fp)
 800816c:	e0bfff17 	ldw	r2,-4(fp)
 8008170:	1884b03a 	or	r2,r3,r2
 8008174:	108000cc 	andi	r2,r2,3
 8008178:	10002a1e 	bne	r2,zero,8008224 <strcmp+0xd0>
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
 800817c:	e0bffe17 	ldw	r2,-8(fp)
 8008180:	e0bffc15 	stw	r2,-16(fp)
      a2 = (unsigned long*)s2;
 8008184:	e0bfff17 	ldw	r2,-4(fp)
 8008188:	e0bffd15 	stw	r2,-12(fp)
      while (*a1 == *a2)
 800818c:	00001506 	br	80081e4 <strcmp+0x90>
        {
          /* To get here, *a1 == *a2, thus if we find a null in *a1,
	     then the strings must be equal, so return zero.  */
          if (DETECTNULL (*a1))
 8008190:	e0bffc17 	ldw	r2,-16(fp)
 8008194:	10c00017 	ldw	r3,0(r2)
 8008198:	00bfbff4 	movhi	r2,65279
 800819c:	10bfbfc4 	addi	r2,r2,-257
 80081a0:	1887883a 	add	r3,r3,r2
 80081a4:	e0bffc17 	ldw	r2,-16(fp)
 80081a8:	10800017 	ldw	r2,0(r2)
 80081ac:	0084303a 	nor	r2,zero,r2
 80081b0:	1886703a 	and	r3,r3,r2
 80081b4:	00a02074 	movhi	r2,32897
 80081b8:	10a02004 	addi	r2,r2,-32640
 80081bc:	1884703a 	and	r2,r3,r2
 80081c0:	10000226 	beq	r2,zero,80081cc <strcmp+0x78>
	    return 0;
 80081c4:	0005883a 	mov	r2,zero
 80081c8:	00002e06 	br	8008284 <strcmp+0x130>

          a1++;
 80081cc:	e0bffc17 	ldw	r2,-16(fp)
 80081d0:	10800104 	addi	r2,r2,4
 80081d4:	e0bffc15 	stw	r2,-16(fp)
          a2++;
 80081d8:	e0bffd17 	ldw	r2,-12(fp)
 80081dc:	10800104 	addi	r2,r2,4
 80081e0:	e0bffd15 	stw	r2,-12(fp)
  if (!UNALIGNED (s1, s2))
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
      a2 = (unsigned long*)s2;
      while (*a1 == *a2)
 80081e4:	e0bffc17 	ldw	r2,-16(fp)
 80081e8:	10c00017 	ldw	r3,0(r2)
 80081ec:	e0bffd17 	ldw	r2,-12(fp)
 80081f0:	10800017 	ldw	r2,0(r2)
 80081f4:	18bfe626 	beq	r3,r2,8008190 <strcmp+0x3c>
          a1++;
          a2++;
        }

      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
 80081f8:	e0bffc17 	ldw	r2,-16(fp)
 80081fc:	e0bffe15 	stw	r2,-8(fp)
      s2 = (char*)a2;
 8008200:	e0bffd17 	ldw	r2,-12(fp)
 8008204:	e0bfff15 	stw	r2,-4(fp)
    }

  while (*s1 != '\0' && *s1 == *s2)
 8008208:	00000606 	br	8008224 <strcmp+0xd0>
    {
      s1++;
 800820c:	e0bffe17 	ldw	r2,-8(fp)
 8008210:	10800044 	addi	r2,r2,1
 8008214:	e0bffe15 	stw	r2,-8(fp)
      s2++;
 8008218:	e0bfff17 	ldw	r2,-4(fp)
 800821c:	10800044 	addi	r2,r2,1
 8008220:	e0bfff15 	stw	r2,-4(fp)
      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
      s2 = (char*)a2;
    }

  while (*s1 != '\0' && *s1 == *s2)
 8008224:	e0bffe17 	ldw	r2,-8(fp)
 8008228:	10800003 	ldbu	r2,0(r2)
 800822c:	10803fcc 	andi	r2,r2,255
 8008230:	1080201c 	xori	r2,r2,128
 8008234:	10bfe004 	addi	r2,r2,-128
 8008238:	10000b26 	beq	r2,zero,8008268 <strcmp+0x114>
 800823c:	e0bffe17 	ldw	r2,-8(fp)
 8008240:	10c00003 	ldbu	r3,0(r2)
 8008244:	e0bfff17 	ldw	r2,-4(fp)
 8008248:	10800003 	ldbu	r2,0(r2)
 800824c:	18c03fcc 	andi	r3,r3,255
 8008250:	18c0201c 	xori	r3,r3,128
 8008254:	18ffe004 	addi	r3,r3,-128
 8008258:	10803fcc 	andi	r2,r2,255
 800825c:	1080201c 	xori	r2,r2,128
 8008260:	10bfe004 	addi	r2,r2,-128
 8008264:	18bfe926 	beq	r3,r2,800820c <strcmp+0xb8>
    {
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 8008268:	e0bffe17 	ldw	r2,-8(fp)
 800826c:	10800003 	ldbu	r2,0(r2)
 8008270:	10c03fcc 	andi	r3,r2,255
 8008274:	e0bfff17 	ldw	r2,-4(fp)
 8008278:	10800003 	ldbu	r2,0(r2)
 800827c:	10803fcc 	andi	r2,r2,255
 8008280:	1885c83a 	sub	r2,r3,r2
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 8008284:	e037883a 	mov	sp,fp
 8008288:	df000017 	ldw	fp,0(sp)
 800828c:	dec00104 	addi	sp,sp,4
 8008290:	f800283a 	ret

08008294 <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
 8008294:	defff804 	addi	sp,sp,-32
 8008298:	dfc00715 	stw	ra,28(sp)
 800829c:	df000615 	stw	fp,24(sp)
 80082a0:	dc000515 	stw	r16,20(sp)
 80082a4:	df000604 	addi	fp,sp,24
 80082a8:	e13ffb15 	stw	r4,-20(fp)
 80082ac:	e17ffc15 	stw	r5,-16(fp)
 80082b0:	e1bffd15 	stw	r6,-12(fp)
 80082b4:	e1fffe15 	stw	r7,-8(fp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
 80082b8:	d0a00117 	ldw	r2,-32764(gp)
 80082bc:	14005217 	ldw	r16,328(r2)
  if (p == NULL)
 80082c0:	8000041e 	bne	r16,zero,80082d4 <__register_exitproc+0x40>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
 80082c4:	d0a00117 	ldw	r2,-32764(gp)
 80082c8:	d0e00117 	ldw	r3,-32764(gp)
 80082cc:	1c005304 	addi	r16,r3,332
 80082d0:	14005215 	stw	r16,328(r2)
  if (p->_ind >= _ATEXIT_SIZE)
 80082d4:	80800117 	ldw	r2,4(r16)
 80082d8:	10800810 	cmplti	r2,r2,32
 80082dc:	1000131e 	bne	r2,zero,800832c <__register_exitproc+0x98>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
 80082e0:	00800034 	movhi	r2,0
 80082e4:	10800004 	addi	r2,r2,0
 80082e8:	1000021e 	bne	r2,zero,80082f4 <__register_exitproc+0x60>
	return -1;
 80082ec:	00bfffc4 	movi	r2,-1
 80082f0:	00003e06 	br	80083ec <__register_exitproc+0x158>

      p = (struct _atexit *) malloc (sizeof *p);
 80082f4:	01006404 	movi	r4,400
 80082f8:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>
 80082fc:	1021883a 	mov	r16,r2
      if (p == NULL)
 8008300:	8000021e 	bne	r16,zero,800830c <__register_exitproc+0x78>
	{
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
 8008304:	00bfffc4 	movi	r2,-1
 8008308:	00003806 	br	80083ec <__register_exitproc+0x158>
	}
      p->_ind = 0;
 800830c:	80000115 	stw	zero,4(r16)
      p->_next = _GLOBAL_ATEXIT;
 8008310:	d0a00117 	ldw	r2,-32764(gp)
 8008314:	10805217 	ldw	r2,328(r2)
 8008318:	80800015 	stw	r2,0(r16)
      _GLOBAL_ATEXIT = p;
 800831c:	d0a00117 	ldw	r2,-32764(gp)
 8008320:	14005215 	stw	r16,328(r2)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
 8008324:	80006215 	stw	zero,392(r16)
      p->_on_exit_args._is_cxa = 0;
 8008328:	80006315 	stw	zero,396(r16)
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
 800832c:	e0bffb17 	ldw	r2,-20(fp)
 8008330:	10002426 	beq	r2,zero,80083c4 <__register_exitproc+0x130>
	  args->_fntypes = 0;
	  args->_is_cxa = 0;
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
 8008334:	80802204 	addi	r2,r16,136
 8008338:	e0bffa15 	stw	r2,-24(fp)
#endif
      args->_fnargs[p->_ind] = arg;
 800833c:	80800117 	ldw	r2,4(r16)
 8008340:	e0fffa17 	ldw	r3,-24(fp)
 8008344:	1085883a 	add	r2,r2,r2
 8008348:	1085883a 	add	r2,r2,r2
 800834c:	1885883a 	add	r2,r3,r2
 8008350:	e0fffd17 	ldw	r3,-12(fp)
 8008354:	10c00015 	stw	r3,0(r2)
      args->_fntypes |= (1 << p->_ind);
 8008358:	e0bffa17 	ldw	r2,-24(fp)
 800835c:	10804017 	ldw	r2,256(r2)
 8008360:	80c00117 	ldw	r3,4(r16)
 8008364:	01000044 	movi	r4,1
 8008368:	20c6983a 	sll	r3,r4,r3
 800836c:	10c6b03a 	or	r3,r2,r3
 8008370:	e0bffa17 	ldw	r2,-24(fp)
 8008374:	10c04015 	stw	r3,256(r2)
      args->_dso_handle[p->_ind] = d;
 8008378:	80800117 	ldw	r2,4(r16)
 800837c:	e0fffa17 	ldw	r3,-24(fp)
 8008380:	10800804 	addi	r2,r2,32
 8008384:	1085883a 	add	r2,r2,r2
 8008388:	1085883a 	add	r2,r2,r2
 800838c:	1885883a 	add	r2,r3,r2
 8008390:	e0fffe17 	ldw	r3,-8(fp)
 8008394:	10c00015 	stw	r3,0(r2)
      if (type == __et_cxa)
 8008398:	e0bffb17 	ldw	r2,-20(fp)
 800839c:	10800098 	cmpnei	r2,r2,2
 80083a0:	1000081e 	bne	r2,zero,80083c4 <__register_exitproc+0x130>
	args->_is_cxa |= (1 << p->_ind);
 80083a4:	e0bffa17 	ldw	r2,-24(fp)
 80083a8:	10804117 	ldw	r2,260(r2)
 80083ac:	80c00117 	ldw	r3,4(r16)
 80083b0:	01000044 	movi	r4,1
 80083b4:	20c6983a 	sll	r3,r4,r3
 80083b8:	10c6b03a 	or	r3,r2,r3
 80083bc:	e0bffa17 	ldw	r2,-24(fp)
 80083c0:	10c04115 	stw	r3,260(r2)
    }
  p->_fns[p->_ind++] = fn;
 80083c4:	80800117 	ldw	r2,4(r16)
 80083c8:	10c00044 	addi	r3,r2,1
 80083cc:	80c00115 	stw	r3,4(r16)
 80083d0:	10800084 	addi	r2,r2,2
 80083d4:	1085883a 	add	r2,r2,r2
 80083d8:	1085883a 	add	r2,r2,r2
 80083dc:	8085883a 	add	r2,r16,r2
 80083e0:	e0fffc17 	ldw	r3,-16(fp)
 80083e4:	10c00015 	stw	r3,0(r2)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
 80083e8:	0005883a 	mov	r2,zero
}
 80083ec:	e6ffff04 	addi	sp,fp,-4
 80083f0:	dfc00217 	ldw	ra,8(sp)
 80083f4:	df000117 	ldw	fp,4(sp)
 80083f8:	dc000017 	ldw	r16,0(sp)
 80083fc:	dec00304 	addi	sp,sp,12
 8008400:	f800283a 	ret

08008404 <__call_exitprocs>:
 */

void 
_DEFUN (__call_exitprocs, (code, d),
	int code _AND _PTR d)
{
 8008404:	defff504 	addi	sp,sp,-44
 8008408:	dfc00a15 	stw	ra,40(sp)
 800840c:	df000915 	stw	fp,36(sp)
 8008410:	dc800815 	stw	r18,32(sp)
 8008414:	dc400715 	stw	r17,28(sp)
 8008418:	dc000615 	stw	r16,24(sp)
 800841c:	df000904 	addi	fp,sp,36
 8008420:	e13ffb15 	stw	r4,-20(fp)
 8008424:	e17ffc15 	stw	r5,-16(fp)
  __lock_acquire_recursive(__atexit_lock);
#endif

 restart:

  p = _GLOBAL_ATEXIT;
 8008428:	d0a00117 	ldw	r2,-32764(gp)
 800842c:	14005217 	ldw	r16,328(r2)
  lastp = &_GLOBAL_ATEXIT;
 8008430:	d0a00117 	ldw	r2,-32764(gp)
 8008434:	10805204 	addi	r2,r2,328
 8008438:	e0bff715 	stw	r2,-36(fp)
  while (p)
 800843c:	00006006 	br	80085c0 <__call_exitprocs+0x1bc>
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
 8008440:	84802204 	addi	r18,r16,136
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 8008444:	80800117 	ldw	r2,4(r16)
 8008448:	147fffc4 	addi	r17,r2,-1
 800844c:	00004a06 	br	8008578 <__call_exitprocs+0x174>
	{
	  int ind;

	  i = 1 << n;
 8008450:	00800044 	movi	r2,1
 8008454:	1444983a 	sll	r2,r2,r17
 8008458:	e0bff815 	stw	r2,-32(fp)

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
 800845c:	e0bffc17 	ldw	r2,-16(fp)
 8008460:	10000826 	beq	r2,zero,8008484 <__call_exitprocs+0x80>
 8008464:	90004026 	beq	r18,zero,8008568 <__call_exitprocs+0x164>
 8008468:	88800804 	addi	r2,r17,32
 800846c:	1085883a 	add	r2,r2,r2
 8008470:	1085883a 	add	r2,r2,r2
 8008474:	9085883a 	add	r2,r18,r2
 8008478:	10c00017 	ldw	r3,0(r2)
 800847c:	e0bffc17 	ldw	r2,-16(fp)
 8008480:	1880391e 	bne	r3,r2,8008568 <__call_exitprocs+0x164>
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
 8008484:	88800084 	addi	r2,r17,2
 8008488:	1085883a 	add	r2,r2,r2
 800848c:	1085883a 	add	r2,r2,r2
 8008490:	8085883a 	add	r2,r16,r2
 8008494:	10800017 	ldw	r2,0(r2)
 8008498:	e0bff915 	stw	r2,-28(fp)
	  if (n == p->_ind - 1)
 800849c:	80800117 	ldw	r2,4(r16)
 80084a0:	10bfffc4 	addi	r2,r2,-1
 80084a4:	1440041e 	bne	r2,r17,80084b8 <__call_exitprocs+0xb4>
	    p->_ind--;
 80084a8:	80800117 	ldw	r2,4(r16)
 80084ac:	10bfffc4 	addi	r2,r2,-1
 80084b0:	80800115 	stw	r2,4(r16)
 80084b4:	00000506 	br	80084cc <__call_exitprocs+0xc8>
	  else
	    p->_fns[n] = NULL;
 80084b8:	88800084 	addi	r2,r17,2
 80084bc:	1085883a 	add	r2,r2,r2
 80084c0:	1085883a 	add	r2,r2,r2
 80084c4:	8085883a 	add	r2,r16,r2
 80084c8:	10000015 	stw	zero,0(r2)

	  /* Skip functions that have already been called.  */
	  if (!fn)
 80084cc:	e0bff917 	ldw	r2,-28(fp)
 80084d0:	10002726 	beq	r2,zero,8008570 <__call_exitprocs+0x16c>
	    continue;

	  ind = p->_ind;
 80084d4:	80800117 	ldw	r2,4(r16)
 80084d8:	e0bffa15 	stw	r2,-24(fp)

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
 80084dc:	90000426 	beq	r18,zero,80084f0 <__call_exitprocs+0xec>
 80084e0:	90c04017 	ldw	r3,256(r18)
 80084e4:	e0bff817 	ldw	r2,-32(fp)
 80084e8:	1884703a 	and	r2,r3,r2
 80084ec:	1000031e 	bne	r2,zero,80084fc <__call_exitprocs+0xf8>
	    fn ();
 80084f0:	e0bff917 	ldw	r2,-28(fp)
 80084f4:	103ee83a 	callr	r2
 80084f8:	00001406 	br	800854c <__call_exitprocs+0x148>
	  else if ((args->_is_cxa & i) == 0)
 80084fc:	90c04117 	ldw	r3,260(r18)
 8008500:	e0bff817 	ldw	r2,-32(fp)
 8008504:	1884703a 	and	r2,r3,r2
 8008508:	1000091e 	bne	r2,zero,8008530 <__call_exitprocs+0x12c>
	    (*((void (*)(int, _PTR)) fn))(code, args->_fnargs[n]);
 800850c:	8c45883a 	add	r2,r17,r17
 8008510:	1085883a 	add	r2,r2,r2
 8008514:	9085883a 	add	r2,r18,r2
 8008518:	10c00017 	ldw	r3,0(r2)
 800851c:	e0bff917 	ldw	r2,-28(fp)
 8008520:	180b883a 	mov	r5,r3
 8008524:	e13ffb17 	ldw	r4,-20(fp)
 8008528:	103ee83a 	callr	r2
 800852c:	00000706 	br	800854c <__call_exitprocs+0x148>
	  else
	    (*((void (*)(_PTR)) fn))(args->_fnargs[n]);
 8008530:	8c45883a 	add	r2,r17,r17
 8008534:	1085883a 	add	r2,r2,r2
 8008538:	9085883a 	add	r2,r18,r2
 800853c:	10c00017 	ldw	r3,0(r2)
 8008540:	e0bff917 	ldw	r2,-28(fp)
 8008544:	1809883a 	mov	r4,r3
 8008548:	103ee83a 	callr	r2

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
 800854c:	80c00117 	ldw	r3,4(r16)
 8008550:	e0bffa17 	ldw	r2,-24(fp)
 8008554:	18bfb41e 	bne	r3,r2,8008428 <__call_exitprocs+0x24>
 8008558:	e0bff717 	ldw	r2,-36(fp)
 800855c:	10800017 	ldw	r2,0(r2)
 8008560:	143fb11e 	bne	r2,r16,8008428 <__call_exitprocs+0x24>
 8008564:	00000306 	br	8008574 <__call_exitprocs+0x170>

	  i = 1 << n;

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
	    continue;
 8008568:	0001883a 	nop
 800856c:	00000106 	br	8008574 <__call_exitprocs+0x170>
	  else
	    p->_fns[n] = NULL;

	  /* Skip functions that have already been called.  */
	  if (!fn)
	    continue;
 8008570:	0001883a 	nop
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 8008574:	8c7fffc4 	addi	r17,r17,-1
 8008578:	883fb50e 	bge	r17,zero,8008450 <__call_exitprocs+0x4c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
 800857c:	00800034 	movhi	r2,0
 8008580:	10800004 	addi	r2,r2,0
 8008584:	10001026 	beq	r2,zero,80085c8 <__call_exitprocs+0x1c4>
	break;

      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
 8008588:	80800117 	ldw	r2,4(r16)
 800858c:	10000a1e 	bne	r2,zero,80085b8 <__call_exitprocs+0x1b4>
 8008590:	80800017 	ldw	r2,0(r16)
 8008594:	10000826 	beq	r2,zero,80085b8 <__call_exitprocs+0x1b4>
	{
	  /* Remove empty block from the list.  */
	  *lastp = p->_next;
 8008598:	80c00017 	ldw	r3,0(r16)
 800859c:	e0bff717 	ldw	r2,-36(fp)
 80085a0:	10c00015 	stw	r3,0(r2)
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
 80085a4:	8009883a 	mov	r4,r16
 80085a8:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>
	  p = *lastp;
 80085ac:	e0bff717 	ldw	r2,-36(fp)
 80085b0:	14000017 	ldw	r16,0(r2)
 80085b4:	00000206 	br	80085c0 <__call_exitprocs+0x1bc>
	}
      else
	{
	  lastp = &p->_next;
 80085b8:	e43ff715 	stw	r16,-36(fp)
	  p = p->_next;
 80085bc:	84000017 	ldw	r16,0(r16)

 restart:

  p = _GLOBAL_ATEXIT;
  lastp = &_GLOBAL_ATEXIT;
  while (p)
 80085c0:	803f9f1e 	bne	r16,zero,8008440 <__call_exitprocs+0x3c>
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
 80085c4:	00000106 	br	80085cc <__call_exitprocs+0x1c8>
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
	break;
 80085c8:	0001883a 	nop
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
 80085cc:	0001883a 	nop
 80085d0:	e6fffd04 	addi	sp,fp,-12
 80085d4:	dfc00417 	ldw	ra,16(sp)
 80085d8:	df000317 	ldw	fp,12(sp)
 80085dc:	dc800217 	ldw	r18,8(sp)
 80085e0:	dc400117 	ldw	r17,4(sp)
 80085e4:	dc000017 	ldw	r16,0(sp)
 80085e8:	dec00504 	addi	sp,sp,20
 80085ec:	f800283a 	ret

080085f0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 80085f0:	defffd04 	addi	sp,sp,-12
 80085f4:	df000215 	stw	fp,8(sp)
 80085f8:	df000204 	addi	fp,sp,8
 80085fc:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 8008600:	0001883a 	nop
 8008604:	e0bfff17 	ldw	r2,-4(fp)
 8008608:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 800860c:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 8008610:	10000226 	beq	r2,zero,800861c <_exit+0x2c>
    ALT_SIM_FAIL();
 8008614:	002af070 	cmpltui	zero,zero,43969
 8008618:	00000106 	br	8008620 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 800861c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 8008620:	003fff06 	br	8008620 <_exit+0x30>
