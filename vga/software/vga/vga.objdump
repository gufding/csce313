
vga.elf:     file format elf32-littlenios2
vga.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000244

Program Header:
    LOAD off    0x00001000 vaddr 0x08000000 paddr 0x08000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x08000020 paddr 0x08000020 align 2**12
         filesz 0x00046644 memsz 0x00046644 flags r-x
    LOAD off    0x00047664 vaddr 0x08046664 paddr 0x080482b8 align 2**12
         filesz 0x00001c54 memsz 0x00001c54 flags rw-
    LOAD off    0x00049f0c vaddr 0x08049f0c paddr 0x08049f0c align 2**12
         filesz 0x00000000 memsz 0x00000160 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  08000000  08000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000224  08000020  08000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000dc00  08000244  08000244  00001244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00038820  0800de44  0800de44  0000ee44  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001c54  08046664  080482b8  00047664  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000160  08049f0c  08049f0c  00049f0c  2**2
                  ALLOC, SMALL_DATA
  6 .sdram_controller_0 00000000  0804a06c  0804a06c  000492b8  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000492b8  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000cc8  00000000  00000000  000492e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00018d24  00000000  00000000  00049fa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00006b73  00000000  00000000  00062ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00008d28  00000000  00000000  0006983f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001ddc  00000000  00000000  00072568  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003a63  00000000  00000000  00074344  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000048f2  00000000  00000000  00077da7  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000030  00000000  00000000  0007c69c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000cd0  00000000  00000000  0007c6d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0008037a  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  0008037d  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00080389  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0008038a  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   00000004  00000000  00000000  0008038b  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    00000004  00000000  00000000  0008038f  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   00000004  00000000  00000000  00080393  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000b  00000000  00000000  00080397  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000001a  00000000  00000000  000803a2  2**0
                  CONTENTS, READONLY
 26 .jdi          00005174  00000000  00000000  000803bc  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0006f578  00000000  00000000  00085530  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
08000000 l    d  .entry	00000000 .entry
08000020 l    d  .exceptions	00000000 .exceptions
08000244 l    d  .text	00000000 .text
0800de44 l    d  .rodata	00000000 .rodata
08046664 l    d  .rwdata	00000000 .rwdata
08049f0c l    d  .bss	00000000 .bss
0804a06c l    d  .sdram_controller_0	00000000 .sdram_controller_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../vga_bsp//obj/HAL/src/crt0.o
0800028c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 myfile.c
00000000 l    df *ABS*	00000000 s_cos.c
00000000 l    df *ABS*	00000000 s_sin.c
00000000 l    df *ABS*	00000000 e_rem_pio2.c
080462cc l     O .rodata	00000108 two_over_pi
080463d4 l     O .rodata	00000080 npio2_hw
08048178 l     O .rwdata	00000008 zero
08048180 l     O .rwdata	00000008 half
08048188 l     O .rwdata	00000008 two24
08048190 l     O .rwdata	00000008 invpio2
08048198 l     O .rwdata	00000008 pio2_1
080481a0 l     O .rwdata	00000008 pio2_1t
080481a8 l     O .rwdata	00000008 pio2_2
080481b0 l     O .rwdata	00000008 pio2_2t
080481b8 l     O .rwdata	00000008 pio2_3
080481c0 l     O .rwdata	00000008 pio2_3t
00000000 l    df *ABS*	00000000 k_cos.c
080481c8 l     O .rwdata	00000008 one
080481d0 l     O .rwdata	00000008 C1
080481d8 l     O .rwdata	00000008 C2
080481e0 l     O .rwdata	00000008 C3
080481e8 l     O .rwdata	00000008 C4
080481f0 l     O .rwdata	00000008 C5
080481f8 l     O .rwdata	00000008 C6
00000000 l    df *ABS*	00000000 k_rem_pio2.c
08046454 l     O .rodata	00000010 init_jk
08046464 l     O .rodata	00000040 PIo2
08048200 l     O .rwdata	00000008 zero
08048208 l     O .rwdata	00000008 one
08048210 l     O .rwdata	00000008 two24
08048218 l     O .rwdata	00000008 twon24
00000000 l    df *ABS*	00000000 k_sin.c
08048220 l     O .rwdata	00000008 half
08048228 l     O .rwdata	00000008 S1
08048230 l     O .rwdata	00000008 S2
08048238 l     O .rwdata	00000008 S3
08048240 l     O .rwdata	00000008 S4
08048248 l     O .rwdata	00000008 S5
08048250 l     O .rwdata	00000008 S6
00000000 l    df *ABS*	00000000 s_fabs.c
00000000 l    df *ABS*	00000000 s_floor.c
08048258 l     O .rwdata	00000008 huge
00000000 l    df *ABS*	00000000 s_scalbn.c
08048260 l     O .rwdata	00000008 two54
08048268 l     O .rwdata	00000008 twom54
08048270 l     O .rwdata	00000008 huge
08048278 l     O .rwdata	00000008 tiny
00000000 l    df *ABS*	00000000 s_copysign.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 findfp.c
08005ff8 l     F .text	000000f4 std
08049f0c l     O .bss	00000004 __sfp_lock
08049f10 l     O .bss	00000004 __sinit_lock
080064f4 l     F .text	00000024 __fp_lock
08006518 l     F .text	00000024 __fp_unlock
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
08046664 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
08006d4c l     F .text	000003b4 malloc_extend_top
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 alt_close.c
0800a504 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
0800a610 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0800a63c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
0800a728 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
0800a808 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0800a8f4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0800aaac l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
080482a8 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
0800acf8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0800ae2c l     F .text	00000034 alt_dev_reg
08047038 l     O .rwdata	00001060 jtag_uart_0
08048098 l     O .rwdata	00000048 video_character_buffer_with_dma_0
080480e0 l     O .rwdata	00000054 video_pixel_buffer_dma_0
08048134 l     O .rwdata	00000044 video_rgb_resampler_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0800b478 l     F .text	0000020c altera_avalon_jtag_uart_irq
0800b684 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_character_buffer_with_dma.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_pixel_buffer_dma.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0800cfc4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
08049f40 l     O .bss	00000004 __atexit_lock
00000000 l    df *ABS*	00000000 alt_exit.c
08049f3c g     O .bss	00000004 alt_instruction_exception_handler
0800a4a4 g     F .text	00000060 _isatty_r
0800aa04 g     F .text	00000060 alt_main
0800c870 g     F .text	0000024c alt_up_pixel_buffer_dma_draw_vline
08005db4 g     F .text	00000118 _puts_r
08049f6c g     O .bss	00000100 alt_irq
08003670 g     F .text	00000088 fabs
0800a130 g     F .text	00000070 _lseek_r
080482b8 g       *ABS*	00000000 __flash_rwdata_start
0800496c g     F .text	00000088 .hidden __eqdf2
0804a06c g       *ABS*	00000000 __alt_heap_start
0800915c g     F .text	000000a0 __sseek
0800639c g     F .text	000000d8 __sinit
0800be44 g     F .text	000000fc alt_up_char_buffer_string
080060ec g     F .text	000000a4 __sfmoreglue
0800aa88 g     F .text	00000024 __malloc_unlock
0800bd78 g     F .text	000000cc alt_up_char_buffer_draw
08007fc0 g     F .text	00000208 memmove
08006368 g     F .text	00000034 _cleanup
0800bfd8 g     F .text	00000194 alt_up_pixel_buffer_dma_draw
080049f4 g     F .text	000000dc .hidden __gtdf2
0800d66c g     F .text	00000024 altera_nios2_gen2_irq_init
0800bf9c g     F .text	0000003c alt_up_pixel_buffer_dma_open_dev
08000000 g     F .entry	0000001c __reset
08000020 g       *ABS*	00000000 __flash_exceptions_start
0800a43c g     F .text	00000068 _fstat_r
08049f20 g     O .bss	00000004 errno
080036f8 g     F .text	00000344 floor
08009078 g     F .text	00000030 __seofread
08049f28 g     O .bss	00000004 alt_argv
08050178 g       *ABS*	00000000 _gp
0800c16c g     F .text	0000005c alt_up_pixel_buffer_dma_change_back_buffer_address
08046eb8 g     O .rwdata	00000180 alt_fd_list
08000c1c g     F .text	00000ce4 __ieee754_rem_pio2
0800d164 g     F .text	00000090 alt_find_dev
08007e38 g     F .text	00000188 memcpy
0800bf40 g     F .text	0000005c alt_up_char_buffer_clear
08006324 g     F .text	00000044 _cleanup_r
08005b64 g     F .text	000000dc .hidden __floatsidf
0800de44 g       *ABS*	00000000 __DTOR_END__
08005ecc g     F .text	00000038 puts
0800d720 g     F .text	0000009c alt_exception_cause_generated_bad_addr
0800c228 g     F .text	00000034 alt_up_pixel_buffer_dma_check_swap_buffers_status
0800b87c g     F .text	0000021c altera_avalon_jtag_uart_read
08004004 g     F .text	00000064 .hidden __udivsi3
0800a764 g     F .text	000000a4 isatty
0800c660 g     F .text	00000210 alt_up_pixel_buffer_dma_draw_hline
08001900 g     F .text	00000534 __kernel_cos
08003e98 g     F .text	00000074 .hidden __fixunsdfsi
0800d690 g     F .text	00000090 alt_icache_flush
08049f14 g     O .bss	00000004 __malloc_top_pad
080065bc g     F .text	000005dc __sfvwrite_r
08008f7c g     F .text	00000060 _sbrk_r
0800cb84 g     F .text	00000084 helper_plot_pixel
0800a3cc g     F .text	00000070 _read_r
080482a0 g     O .rwdata	00000004 alt_max_fd
080094c0 g     F .text	0000012c _fclose_r
080099b0 g     F .text	00000054 fflush
08049f18 g     O .bss	00000004 __malloc_max_sbrked_mem
0800322c g     F .text	00000444 __kernel_sin
08005c40 g     F .text	00000110 .hidden __extendsfdf2
080040c0 g     F .text	000008ac .hidden __adddf3
0800c25c g     F .text	00000128 alt_up_pixel_buffer_dma_clear_screen
0800a930 g     F .text	000000d4 lseek
08000000 g       *ABS*	00000000 __alt_mem_sdram_controller_0
08048284 g     O .rwdata	00000004 _global_impure_ptr
0800838c g     F .text	00000bf0 _realloc_r
0804a06c g       *ABS*	00000000 __bss_end
0800d3d8 g     F .text	000000f0 alt_iic_isr_register
0800c384 g     F .text	000002dc alt_up_pixel_buffer_dma_draw_box
0800d564 g     F .text	00000108 alt_tick
0800653c g     F .text	00000040 __fp_lock_all
0800d38c g     F .text	0000004c alt_ic_irq_enabled
0800d4c8 g     F .text	0000009c alt_alarm_stop
0800deca g     O .rodata	00038401 myimage
08049f30 g     O .bss	00000004 alt_irq_active
080000fc g     F .exceptions	000000d4 alt_irq_handler
08046e90 g     O .rwdata	00000028 alt_dev_null
08001e34 g     F .text	000013f8 __kernel_rem_pio2
0800cf7c g     F .text	00000048 alt_dcache_flush_all
0800cabc g     F .text	000000c8 alt_up_pixel_buffer_dma_draw_rectangle
08005ae4 g     F .text	00000080 .hidden __fixdfsi
080482b8 g       *ABS*	00000000 __ram_rwdata_end
08048298 g     O .rwdata	00000008 alt_dev_list
0800ad34 g     F .text	000000f8 write
0800cc08 g     F .text	00000248 alt_up_pixel_buffer_dma_draw_line
08046664 g       *ABS*	00000000 __ram_rodata_end
0800a678 g     F .text	000000b0 fstat
08004068 g     F .text	00000058 .hidden __umodsi3
0804a06c g       *ABS*	00000000 end
0800bcbc g     F .text	00000080 alt_up_char_buffer_init
0800b3b8 g     F .text	000000c0 altera_avalon_jtag_uart_init
080001d0 g     F .exceptions	00000074 alt_instruction_exception_entry
0800de44 g       *ABS*	00000000 __CTOR_LIST__
10000000 g       *ABS*	00000000 __alt_stack_pointer
08005d50 g     F .text	00000064 .hidden __clzsi2
0800ba98 g     F .text	00000224 altera_avalon_jtag_uart_write
08000830 g     F .text	000001f4 cos
08006474 g     F .text	00000020 __sfp_lock_acquire
08007c7c g     F .text	000001bc memchr
08009a04 g     F .text	00000560 _free_r
0800dc24 g     F .text	000001ec __call_exitprocs
0804828c g     O .rwdata	00000004 __malloc_sbrk_base
08000244 g     F .text	0000004c _start
08049f34 g     O .bss	00000004 _alt_tick_rate
08000a24 g     F .text	000001f8 sin
08049f38 g     O .bss	00000004 _alt_nticks
0800aae8 g     F .text	000000fc read
08000300 g     F .text	000003c0 displayImage
0800ae98 g     F .text	000003bc alt_sys_init
0800dab4 g     F .text	00000170 __register_exitproc
0800b724 g     F .text	00000068 altera_avalon_jtag_uart_close
08046664 g       *ABS*	00000000 __ram_rwdata_start
0800de44 g       *ABS*	00000000 __ram_rodata_start
08049f44 g     O .bss	00000028 __malloc_current_mallinfo
0800b254 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
08000290 g     F .text	00000070 printOnScreen
08009460 g     F .text	00000060 _close_r
0800d840 g     F .text	00000134 memcmp
0800b314 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0804a06c g       *ABS*	00000000 __alt_stack_base
0800b364 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
080092c0 g     F .text	000001a0 __swsetup_r
08006190 g     F .text	00000194 __sfp
08046a88 g     O .rwdata	00000408 __malloc_av_
080064d4 g     F .text	00000020 __sinit_lock_release
08004ad0 g     F .text	00000718 .hidden __muldf3
08008fdc g     F .text	0000009c __sread
0800d000 g     F .text	000000a4 alt_dev_llist_insert
0800aa64 g     F .text	00000024 __malloc_lock
0800ac48 g     F .text	000000b0 sbrk
08009928 g     F .text	00000088 _fflush_r
08049f0c g       *ABS*	00000000 __bss_start
080081c8 g     F .text	000001c4 memset
080006c0 g     F .text	00000170 main
08049f2c g     O .bss	00000004 alt_envp
08049f1c g     O .bss	00000004 __malloc_max_total_mem
0800c1c8 g     F .text	00000060 alt_up_pixel_buffer_dma_swap_buffers
0800bd3c g     F .text	0000003c alt_up_char_buffer_open_dev
0800b2b4 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
080091fc g     F .text	00000054 __sclose
10000000 g       *ABS*	00000000 __alt_heap_limit
080095ec g     F .text	00000038 fclose
08007100 g     F .text	00000b7c _malloc_r
080482a4 g     O .rwdata	00000004 alt_errno
08006b98 g     F .text	000000d8 _fwalk
08003f0c g     F .text	00000084 .hidden __divsi3
08009f64 g     F .text	000001cc _malloc_trim_r
0800de44 g       *ABS*	00000000 __CTOR_END__
0800d974 g     F .text	00000140 strcmp
0800de44 g       *ABS*	00000000 __flash_rodata_start
0800de44 g       *ABS*	00000000 __DTOR_LIST__
08003de4 g     F .text	000000b4 copysign
0800496c g     F .text	00000088 .hidden __nedf2
0800ae60 g     F .text	00000038 alt_irq_init
0800abe4 g     F .text	00000064 alt_release_fd
080464a4 g     O .rodata	00000100 .hidden __clz_tab
0800d7bc g     F .text	0000003c atexit
08009250 g     F .text	00000070 _write_r
08048280 g     O .rwdata	00000004 _impure_ptr
08049f24 g     O .bss	00000004 alt_argc
08009624 g     F .text	00000304 __sflush_r
08003a3c g     F .text	000003a8 scalbn
0800d104 g     F .text	00000060 _do_dtors
08000020 g       .exceptions	00000000 alt_irq_entry
0800657c g     F .text	00000040 __fp_unlock_all
08048290 g     O .rwdata	00000008 alt_fs_list
08000020 g       *ABS*	00000000 __ram_exceptions_start
0800d228 g     F .text	00000050 alt_ic_isr_register
080482b8 g       *ABS*	00000000 _edata
0804a06c g       *ABS*	00000000 _end
08000244 g       *ABS*	00000000 __ram_exceptions_end
0800b78c g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0800d300 g     F .text	0000008c alt_ic_irq_disable
080090a8 g     F .text	000000b4 __swrite
08048288 g     O .rwdata	00000004 __malloc_trim_threshold
0800d7f8 g     F .text	00000048 exit
08006c70 g     F .text	000000dc _fwalk_reent
08003f90 g     F .text	00000074 .hidden __modsi3
10000000 g       *ABS*	00000000 __alt_data_end
08000020 g     F .exceptions	00000000 alt_exception
08006494 g     F .text	00000020 __sfp_lock_release
0800de10 g     F .text	00000034 _exit
0800ce50 g     F .text	0000012c alt_alarm_start
0800a1a0 g     F .text	0000022c __smakebuf_r
08005f04 g     F .text	000000f4 strlen
080049f4 g     F .text	000000dc .hidden __gedf2
0800d1f4 g     F .text	00000034 alt_icache_flush_all
080482ac g     O .rwdata	00000004 alt_priority_mask
0800d278 g     F .text	00000088 alt_ic_irq_enable
080051e8 g     F .text	000008fc .hidden __subdf3
080482b0 g     O .rwdata	00000008 alt_alarm_list
0800d0a4 g     F .text	00000060 _do_ctors
0800a540 g     F .text	000000d0 close
0800a870 g     F .text	00000084 alt_load
080064b4 g     F .text	00000020 __sinit_lock_acquire



Disassembly of section .entry:

08000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 8000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 8000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 8000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 800000c:	00bffd16 	blt	zero,r2,8000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 8000010:	00420034 	movhi	at,2048
    ori r1, r1, %lo(_start)
 8000014:	08409114 	ori	at,at,580
    jmp r1
 8000018:	0800683a 	jmp	at
 800001c:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>

Disassembly of section .exceptions:

08000020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8000020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8000024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8000028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 800002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8000030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8000034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8000038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 800003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8000040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8000044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8000048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 800004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8000050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8000054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8000058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 800005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 8000060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 8000064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 8000068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 800006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 8000070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 8000074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 8000078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 800007c:	10000326 	beq	r2,zero,800008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 8000080:	20000226 	beq	r4,zero,800008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 8000084:	80000fc0 	call	80000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 8000088:	00000706 	br	80000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 800008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 8000090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 8000094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 8000098:	80001d00 	call	80001d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 800009c:	1000021e 	bne	r2,zero,80000a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 80000a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 80000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 80000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 80000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 80000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 80000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 80000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 80000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 80000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 80000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 80000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 80000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 80000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 80000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 80000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 80000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 80000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 80000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 80000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 80000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 80000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 80000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 80000f8:	ef80083a 	eret

080000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 80000fc:	defff904 	addi	sp,sp,-28
 8000100:	dfc00615 	stw	ra,24(sp)
 8000104:	df000515 	stw	fp,20(sp)
 8000108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 800010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8000110:	0005313a 	rdctl	r2,ipending
 8000114:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8000118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 800011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8000120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8000124:	00800044 	movi	r2,1
 8000128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 800012c:	e0fffb17 	ldw	r3,-20(fp)
 8000130:	e0bffc17 	ldw	r2,-16(fp)
 8000134:	1884703a 	and	r2,r3,r2
 8000138:	10001426 	beq	r2,zero,800018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 800013c:	00820174 	movhi	r2,2053
 8000140:	10a7db04 	addi	r2,r2,-24724
 8000144:	e0fffd17 	ldw	r3,-12(fp)
 8000148:	180690fa 	slli	r3,r3,3
 800014c:	10c5883a 	add	r2,r2,r3
 8000150:	10c00017 	ldw	r3,0(r2)
 8000154:	00820174 	movhi	r2,2053
 8000158:	10a7db04 	addi	r2,r2,-24724
 800015c:	e13ffd17 	ldw	r4,-12(fp)
 8000160:	200890fa 	slli	r4,r4,3
 8000164:	1105883a 	add	r2,r2,r4
 8000168:	10800104 	addi	r2,r2,4
 800016c:	10800017 	ldw	r2,0(r2)
 8000170:	1009883a 	mov	r4,r2
 8000174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 8000178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 800017c:	0005313a 	rdctl	r2,ipending
 8000180:	e0bfff15 	stw	r2,-4(fp)

  return active;
 8000184:	e0bfff17 	ldw	r2,-4(fp)
 8000188:	00000706 	br	80001a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 800018c:	e0bffc17 	ldw	r2,-16(fp)
 8000190:	1085883a 	add	r2,r2,r2
 8000194:	e0bffc15 	stw	r2,-16(fp)
      i++;
 8000198:	e0bffd17 	ldw	r2,-12(fp)
 800019c:	10800044 	addi	r2,r2,1
 80001a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 80001a4:	003fe106 	br	800012c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 80001a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 80001ac:	e0bffb17 	ldw	r2,-20(fp)
 80001b0:	103fdb1e 	bne	r2,zero,8000120 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 80001b4:	0001883a 	nop
}
 80001b8:	0001883a 	nop
 80001bc:	e037883a 	mov	sp,fp
 80001c0:	dfc00117 	ldw	ra,4(sp)
 80001c4:	df000017 	ldw	fp,0(sp)
 80001c8:	dec00204 	addi	sp,sp,8
 80001cc:	f800283a 	ret

080001d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 80001d0:	defffb04 	addi	sp,sp,-20
 80001d4:	dfc00415 	stw	ra,16(sp)
 80001d8:	df000315 	stw	fp,12(sp)
 80001dc:	df000304 	addi	fp,sp,12
 80001e0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
 80001e4:	000531fa 	rdctl	r2,exception
 80001e8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
 80001ec:	e0bffd17 	ldw	r2,-12(fp)
 80001f0:	10801f0c 	andi	r2,r2,124
 80001f4:	1004d0ba 	srli	r2,r2,2
 80001f8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
 80001fc:	0005333a 	rdctl	r2,badaddr
 8000200:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 8000204:	d0a77117 	ldw	r2,-25148(gp)
 8000208:	10000726 	beq	r2,zero,8000228 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 800020c:	d0a77117 	ldw	r2,-25148(gp)
 8000210:	e0fffd17 	ldw	r3,-12(fp)
 8000214:	e1bffe17 	ldw	r6,-8(fp)
 8000218:	e17fff17 	ldw	r5,-4(fp)
 800021c:	1809883a 	mov	r4,r3
 8000220:	103ee83a 	callr	r2
 8000224:	00000206 	br	8000230 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 8000228:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 800022c:	0005883a 	mov	r2,zero
}
 8000230:	e037883a 	mov	sp,fp
 8000234:	dfc00117 	ldw	ra,4(sp)
 8000238:	df000017 	ldw	fp,0(sp)
 800023c:	dec00204 	addi	sp,sp,8
 8000240:	f800283a 	ret

Disassembly of section .text:

08000244 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 8000244:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 8000248:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 800024c:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 8000250:	00bffd16 	blt	zero,r2,8000248 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8000254:	06c40034 	movhi	sp,4096
    ori sp, sp, %lo(__alt_stack_pointer)
 8000258:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 800025c:	06820174 	movhi	gp,2053
    ori gp, gp, %lo(_gp)
 8000260:	d6805e14 	ori	gp,gp,376
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8000264:	00820134 	movhi	r2,2052
    ori r2, r2, %lo(__bss_start)
 8000268:	10a7c314 	ori	r2,r2,40716

    movhi r3, %hi(__bss_end)
 800026c:	00c20134 	movhi	r3,2052
    ori r3, r3, %lo(__bss_end)
 8000270:	18e81b14 	ori	r3,r3,41068

    beq r2, r3, 1f
 8000274:	10c00326 	beq	r2,r3,8000284 <_start+0x40>

0:
    stw zero, (r2)
 8000278:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 800027c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 8000280:	10fffd36 	bltu	r2,r3,8000278 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 8000284:	800a8700 	call	800a870 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8000288:	800aa040 	call	800aa04 <alt_main>

0800028c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 800028c:	003fff06 	br	800028c <alt_after_alt_main>

08000290 <printOnScreen>:
/*void measuringFrameRate() {
  alt_u32 ticks_per_second = alt_ticks_per_second();
  alt_u32 current_tick = 0, prev_tick = alt_nticks();
}*/

void printOnScreen(alt_up_char_buffer_dev *char_buf, char *message) {
 8000290:	defffc04 	addi	sp,sp,-16
 8000294:	dfc00315 	stw	ra,12(sp)
 8000298:	df000215 	stw	fp,8(sp)
 800029c:	df000204 	addi	fp,sp,8
 80002a0:	e13ffe15 	stw	r4,-8(fp)
 80002a4:	e17fff15 	stw	r5,-4(fp)
  char_buf = alt_up_char_buffer_open_dev("/dev/video_character_buffer_with_dma_0");
 80002a8:	01020074 	movhi	r4,2049
 80002ac:	21379104 	addi	r4,r4,-8636
 80002b0:	800bd3c0 	call	800bd3c <alt_up_char_buffer_open_dev>
 80002b4:	e0bffe15 	stw	r2,-8(fp)
  if (!char_buf) printf("error opening character buffer\n");
 80002b8:	e0bffe17 	ldw	r2,-8(fp)
 80002bc:	1000031e 	bne	r2,zero,80002cc <printOnScreen+0x3c>
 80002c0:	01020074 	movhi	r4,2049
 80002c4:	21379b04 	addi	r4,r4,-8596
 80002c8:	8005ecc0 	call	8005ecc <puts>
  alt_up_char_buffer_clear(char_buf);
 80002cc:	e13ffe17 	ldw	r4,-8(fp)
 80002d0:	800bf400 	call	800bf40 <alt_up_char_buffer_clear>
  alt_up_char_buffer_string(char_buf, message, 35, 50);
 80002d4:	01c00c84 	movi	r7,50
 80002d8:	018008c4 	movi	r6,35
 80002dc:	e17fff17 	ldw	r5,-4(fp)
 80002e0:	e13ffe17 	ldw	r4,-8(fp)
 80002e4:	800be440 	call	800be44 <alt_up_char_buffer_string>
}
 80002e8:	0001883a 	nop
 80002ec:	e037883a 	mov	sp,fp
 80002f0:	dfc00117 	ldw	ra,4(sp)
 80002f4:	df000017 	ldw	fp,0(sp)
 80002f8:	dec00204 	addi	sp,sp,8
 80002fc:	f800283a 	ret

08000300 <displayImage>:

void displayImage (alt_u8 *image_array, int screen_width, int screen_height, float angle) {
 8000300:	defff004 	addi	sp,sp,-64
 8000304:	dfc00f15 	stw	ra,60(sp)
 8000308:	df000e15 	stw	fp,56(sp)
 800030c:	dd400d15 	stw	r21,52(sp)
 8000310:	dd000c15 	stw	r20,48(sp)
 8000314:	dcc00b15 	stw	r19,44(sp)
 8000318:	dc800a15 	stw	r18,40(sp)
 800031c:	dc400915 	stw	r17,36(sp)
 8000320:	dc000815 	stw	r16,32(sp)
 8000324:	df000e04 	addi	fp,sp,56
 8000328:	e13ff615 	stw	r4,-40(fp)
 800032c:	e17ff715 	stw	r5,-36(fp)
 8000330:	e1bff815 	stw	r6,-32(fp)
 8000334:	e1fff915 	stw	r7,-28(fp)
  alt_up_pixel_buffer_dma_dev *pix_buf;
  pix_buf = alt_up_pixel_buffer_dma_open_dev("/dev/video_pixel_buffer_dma_0");
 8000338:	01020074 	movhi	r4,2049
 800033c:	2137a304 	addi	r4,r4,-8564
 8000340:	800bf9c0 	call	800bf9c <alt_up_pixel_buffer_dma_open_dev>
 8000344:	e0bff415 	stw	r2,-48(fp)
  alt_up_pixel_buffer_dma_clear_screen(pix_buf, 0);
 8000348:	000b883a 	mov	r5,zero
 800034c:	e13ff417 	ldw	r4,-48(fp)
 8000350:	800c25c0 	call	800c25c <alt_up_pixel_buffer_dma_clear_screen>
  
  // Display the image at the angle given
  alt_u16 r;
  alt_u16 c;
  for (int i = 0; i < screen_height; i++) {
 8000354:	e03ff215 	stw	zero,-56(fp)
 8000358:	0000ca06 	br	8000684 <displayImage+0x384>
    for (int j = 0; j < screen_width; j++) {
 800035c:	e03ff315 	stw	zero,-52(fp)
 8000360:	0000c206 	br	800066c <displayImage+0x36c>
      // Get the translated image by coordinates for row and colmn
      r = ((j-160)*sin(angle))+((i-120)*cos(angle));
 8000364:	e0bff317 	ldw	r2,-52(fp)
 8000368:	10bfd804 	addi	r2,r2,-160
 800036c:	1009883a 	mov	r4,r2
 8000370:	8005b640 	call	8005b64 <__floatsidf>
 8000374:	1025883a 	mov	r18,r2
 8000378:	1827883a 	mov	r19,r3
 800037c:	e13ff917 	ldw	r4,-28(fp)
 8000380:	8005c400 	call	8005c40 <__extendsfdf2>
 8000384:	100b883a 	mov	r5,r2
 8000388:	180d883a 	mov	r6,r3
 800038c:	2809883a 	mov	r4,r5
 8000390:	300b883a 	mov	r5,r6
 8000394:	8000a240 	call	8000a24 <sin>
 8000398:	1009883a 	mov	r4,r2
 800039c:	180b883a 	mov	r5,r3
 80003a0:	200d883a 	mov	r6,r4
 80003a4:	280f883a 	mov	r7,r5
 80003a8:	9009883a 	mov	r4,r18
 80003ac:	980b883a 	mov	r5,r19
 80003b0:	8004ad00 	call	8004ad0 <__muldf3>
 80003b4:	1009883a 	mov	r4,r2
 80003b8:	180b883a 	mov	r5,r3
 80003bc:	2025883a 	mov	r18,r4
 80003c0:	2827883a 	mov	r19,r5
 80003c4:	e0bff217 	ldw	r2,-56(fp)
 80003c8:	10bfe204 	addi	r2,r2,-120
 80003cc:	1009883a 	mov	r4,r2
 80003d0:	8005b640 	call	8005b64 <__floatsidf>
 80003d4:	1029883a 	mov	r20,r2
 80003d8:	182b883a 	mov	r21,r3
 80003dc:	e13ff917 	ldw	r4,-28(fp)
 80003e0:	8005c400 	call	8005c40 <__extendsfdf2>
 80003e4:	100b883a 	mov	r5,r2
 80003e8:	180d883a 	mov	r6,r3
 80003ec:	2809883a 	mov	r4,r5
 80003f0:	300b883a 	mov	r5,r6
 80003f4:	80008300 	call	8000830 <cos>
 80003f8:	1009883a 	mov	r4,r2
 80003fc:	180b883a 	mov	r5,r3
 8000400:	200d883a 	mov	r6,r4
 8000404:	280f883a 	mov	r7,r5
 8000408:	a009883a 	mov	r4,r20
 800040c:	a80b883a 	mov	r5,r21
 8000410:	8004ad00 	call	8004ad0 <__muldf3>
 8000414:	1009883a 	mov	r4,r2
 8000418:	180b883a 	mov	r5,r3
 800041c:	2005883a 	mov	r2,r4
 8000420:	2807883a 	mov	r3,r5
 8000424:	100d883a 	mov	r6,r2
 8000428:	180f883a 	mov	r7,r3
 800042c:	9009883a 	mov	r4,r18
 8000430:	980b883a 	mov	r5,r19
 8000434:	80040c00 	call	80040c0 <__adddf3>
 8000438:	1009883a 	mov	r4,r2
 800043c:	180b883a 	mov	r5,r3
 8000440:	2005883a 	mov	r2,r4
 8000444:	2807883a 	mov	r3,r5
 8000448:	1009883a 	mov	r4,r2
 800044c:	180b883a 	mov	r5,r3
 8000450:	8003e980 	call	8003e98 <__fixunsdfsi>
 8000454:	e0bff50d 	sth	r2,-44(fp)
      c = ((j-160)*cos(angle))+((i-120)*(-sin(angle)));
 8000458:	e0bff317 	ldw	r2,-52(fp)
 800045c:	10bfd804 	addi	r2,r2,-160
 8000460:	1009883a 	mov	r4,r2
 8000464:	8005b640 	call	8005b64 <__floatsidf>
 8000468:	1025883a 	mov	r18,r2
 800046c:	1827883a 	mov	r19,r3
 8000470:	e13ff917 	ldw	r4,-28(fp)
 8000474:	8005c400 	call	8005c40 <__extendsfdf2>
 8000478:	100b883a 	mov	r5,r2
 800047c:	180d883a 	mov	r6,r3
 8000480:	2809883a 	mov	r4,r5
 8000484:	300b883a 	mov	r5,r6
 8000488:	80008300 	call	8000830 <cos>
 800048c:	1009883a 	mov	r4,r2
 8000490:	180b883a 	mov	r5,r3
 8000494:	200d883a 	mov	r6,r4
 8000498:	280f883a 	mov	r7,r5
 800049c:	9009883a 	mov	r4,r18
 80004a0:	980b883a 	mov	r5,r19
 80004a4:	8004ad00 	call	8004ad0 <__muldf3>
 80004a8:	1009883a 	mov	r4,r2
 80004ac:	180b883a 	mov	r5,r3
 80004b0:	2025883a 	mov	r18,r4
 80004b4:	2827883a 	mov	r19,r5
 80004b8:	e0bff217 	ldw	r2,-56(fp)
 80004bc:	10bfe204 	addi	r2,r2,-120
 80004c0:	1009883a 	mov	r4,r2
 80004c4:	8005b640 	call	8005b64 <__floatsidf>
 80004c8:	1029883a 	mov	r20,r2
 80004cc:	182b883a 	mov	r21,r3
 80004d0:	e13ff917 	ldw	r4,-28(fp)
 80004d4:	8005c400 	call	8005c40 <__extendsfdf2>
 80004d8:	100b883a 	mov	r5,r2
 80004dc:	180d883a 	mov	r6,r3
 80004e0:	2809883a 	mov	r4,r5
 80004e4:	300b883a 	mov	r5,r6
 80004e8:	8000a240 	call	8000a24 <sin>
 80004ec:	1009883a 	mov	r4,r2
 80004f0:	180b883a 	mov	r5,r3
 80004f4:	2021883a 	mov	r16,r4
 80004f8:	2c60003c 	xorhi	r17,r5,32768
 80004fc:	800d883a 	mov	r6,r16
 8000500:	880f883a 	mov	r7,r17
 8000504:	a009883a 	mov	r4,r20
 8000508:	a80b883a 	mov	r5,r21
 800050c:	8004ad00 	call	8004ad0 <__muldf3>
 8000510:	1009883a 	mov	r4,r2
 8000514:	180b883a 	mov	r5,r3
 8000518:	2005883a 	mov	r2,r4
 800051c:	2807883a 	mov	r3,r5
 8000520:	100d883a 	mov	r6,r2
 8000524:	180f883a 	mov	r7,r3
 8000528:	9009883a 	mov	r4,r18
 800052c:	980b883a 	mov	r5,r19
 8000530:	80040c00 	call	80040c0 <__adddf3>
 8000534:	1009883a 	mov	r4,r2
 8000538:	180b883a 	mov	r5,r3
 800053c:	2005883a 	mov	r2,r4
 8000540:	2807883a 	mov	r3,r5
 8000544:	1009883a 	mov	r4,r2
 8000548:	180b883a 	mov	r5,r3
 800054c:	8003e980 	call	8003e98 <__fixunsdfsi>
 8000550:	e0bff58d 	sth	r2,-42(fp)
      // Get the coordinates back to top left of screen
      r += 120;  // Width of screen divided by 2 to get back to original coordinate
 8000554:	e0bff50b 	ldhu	r2,-44(fp)
 8000558:	10801e04 	addi	r2,r2,120
 800055c:	e0bff50d 	sth	r2,-44(fp)
      c += 160;  // Heigh of screen divided by 2 to get back to original coordinate
 8000560:	e0bff58b 	ldhu	r2,-42(fp)
 8000564:	10802804 	addi	r2,r2,160
 8000568:	e0bff58d 	sth	r2,-42(fp)
      r = roundf(r);
 800056c:	e0bff50b 	ldhu	r2,-44(fp)
 8000570:	1005feb2 	custom	250,r2,r2,zero
 8000574:	1005fe72 	custom	249,r2,r2,zero
 8000578:	e0bff50d 	sth	r2,-44(fp)
      c = roundf(c);
 800057c:	e0bff58b 	ldhu	r2,-42(fp)
 8000580:	1005feb2 	custom	250,r2,r2,zero
 8000584:	1005fe72 	custom	249,r2,r2,zero
 8000588:	e0bff58d 	sth	r2,-42(fp)
   
      // Draw the image
      alt_up_pixel_buffer_dma_draw(pix_buf,
       (myimage[(i*screen_width+j)*3+0] << 16) +
 800058c:	e0fff217 	ldw	r3,-56(fp)
 8000590:	e0bff717 	ldw	r2,-36(fp)
 8000594:	1887383a 	mul	r3,r3,r2
 8000598:	e0bff317 	ldw	r2,-52(fp)
 800059c:	1887883a 	add	r3,r3,r2
 80005a0:	1805883a 	mov	r2,r3
 80005a4:	1085883a 	add	r2,r2,r2
 80005a8:	10c7883a 	add	r3,r2,r3
 80005ac:	00820074 	movhi	r2,2049
 80005b0:	10b7b284 	addi	r2,r2,-8502
 80005b4:	10c5883a 	add	r2,r2,r3
 80005b8:	10800003 	ldbu	r2,0(r2)
 80005bc:	10803fcc 	andi	r2,r2,255
 80005c0:	1008943a 	slli	r4,r2,16
       (myimage[(i*screen_width+j)*3+1] << 8) + 
 80005c4:	e0fff217 	ldw	r3,-56(fp)
 80005c8:	e0bff717 	ldw	r2,-36(fp)
 80005cc:	1887383a 	mul	r3,r3,r2
 80005d0:	e0bff317 	ldw	r2,-52(fp)
 80005d4:	1887883a 	add	r3,r3,r2
 80005d8:	1805883a 	mov	r2,r3
 80005dc:	1085883a 	add	r2,r2,r2
 80005e0:	10c5883a 	add	r2,r2,r3
 80005e4:	10c00044 	addi	r3,r2,1
 80005e8:	00820074 	movhi	r2,2049
 80005ec:	10b7b284 	addi	r2,r2,-8502
 80005f0:	10c5883a 	add	r2,r2,r3
 80005f4:	10800003 	ldbu	r2,0(r2)
 80005f8:	10803fcc 	andi	r2,r2,255
 80005fc:	1004923a 	slli	r2,r2,8
      r = roundf(r);
      c = roundf(c);
   
      // Draw the image
      alt_up_pixel_buffer_dma_draw(pix_buf,
       (myimage[(i*screen_width+j)*3+0] << 16) +
 8000600:	2089883a 	add	r4,r4,r2
       (myimage[(i*screen_width+j)*3+1] << 8) + 
       (myimage[(i*screen_width+j)*3+2]), (int)c, (int)r);
 8000604:	e0fff217 	ldw	r3,-56(fp)
 8000608:	e0bff717 	ldw	r2,-36(fp)
 800060c:	1887383a 	mul	r3,r3,r2
 8000610:	e0bff317 	ldw	r2,-52(fp)
 8000614:	1887883a 	add	r3,r3,r2
 8000618:	1805883a 	mov	r2,r3
 800061c:	1085883a 	add	r2,r2,r2
 8000620:	10c5883a 	add	r2,r2,r3
 8000624:	10c00084 	addi	r3,r2,2
 8000628:	00820074 	movhi	r2,2049
 800062c:	10b7b284 	addi	r2,r2,-8502
 8000630:	10c5883a 	add	r2,r2,r3
 8000634:	10800003 	ldbu	r2,0(r2)
      c = roundf(c);
   
      // Draw the image
      alt_up_pixel_buffer_dma_draw(pix_buf,
       (myimage[(i*screen_width+j)*3+0] << 16) +
       (myimage[(i*screen_width+j)*3+1] << 8) + 
 8000638:	10803fcc 	andi	r2,r2,255
 800063c:	2085883a 	add	r2,r4,r2
      c += 160;  // Heigh of screen divided by 2 to get back to original coordinate
      r = roundf(r);
      c = roundf(c);
   
      // Draw the image
      alt_up_pixel_buffer_dma_draw(pix_buf,
 8000640:	1009883a 	mov	r4,r2
 8000644:	e0bff58b 	ldhu	r2,-42(fp)
 8000648:	e0fff50b 	ldhu	r3,-44(fp)
 800064c:	180f883a 	mov	r7,r3
 8000650:	100d883a 	mov	r6,r2
 8000654:	200b883a 	mov	r5,r4
 8000658:	e13ff417 	ldw	r4,-48(fp)
 800065c:	800bfd80 	call	800bfd8 <alt_up_pixel_buffer_dma_draw>
  
  // Display the image at the angle given
  alt_u16 r;
  alt_u16 c;
  for (int i = 0; i < screen_height; i++) {
    for (int j = 0; j < screen_width; j++) {
 8000660:	e0bff317 	ldw	r2,-52(fp)
 8000664:	10800044 	addi	r2,r2,1
 8000668:	e0bff315 	stw	r2,-52(fp)
 800066c:	e0fff317 	ldw	r3,-52(fp)
 8000670:	e0bff717 	ldw	r2,-36(fp)
 8000674:	18bf3b16 	blt	r3,r2,8000364 <displayImage+0x64>
  alt_up_pixel_buffer_dma_clear_screen(pix_buf, 0);
  
  // Display the image at the angle given
  alt_u16 r;
  alt_u16 c;
  for (int i = 0; i < screen_height; i++) {
 8000678:	e0bff217 	ldw	r2,-56(fp)
 800067c:	10800044 	addi	r2,r2,1
 8000680:	e0bff215 	stw	r2,-56(fp)
 8000684:	e0fff217 	ldw	r3,-56(fp)
 8000688:	e0bff817 	ldw	r2,-32(fp)
 800068c:	18bf3316 	blt	r3,r2,800035c <displayImage+0x5c>
       (myimage[(i*screen_width+j)*3+0] << 16) +
       (myimage[(i*screen_width+j)*3+1] << 8) + 
       (myimage[(i*screen_width+j)*3+2]), (int)c, (int)r);
    }
  }  
}
 8000690:	0001883a 	nop
 8000694:	e6fffa04 	addi	sp,fp,-24
 8000698:	dfc00717 	ldw	ra,28(sp)
 800069c:	df000617 	ldw	fp,24(sp)
 80006a0:	dd400517 	ldw	r21,20(sp)
 80006a4:	dd000417 	ldw	r20,16(sp)
 80006a8:	dcc00317 	ldw	r19,12(sp)
 80006ac:	dc800217 	ldw	r18,8(sp)
 80006b0:	dc400117 	ldw	r17,4(sp)
 80006b4:	dc000017 	ldw	r16,0(sp)
 80006b8:	dec00804 	addi	sp,sp,32
 80006bc:	f800283a 	ret

080006c0 <main>:

int main() {  
 80006c0:	deffee04 	addi	sp,sp,-72
 80006c4:	dfc01115 	stw	ra,68(sp)
 80006c8:	df001015 	stw	fp,64(sp)
 80006cc:	df001004 	addi	fp,sp,64
  myimage[230401];  // Picture file in an array
  alt_up_char_buffer_dev *char_buf;
  
  // Angles used for rotating screen. In radians
  float angles[13] = {0, PI/6, PI/3, PI/2, (2*PI)/3, (5*PI)/6, PI,
 80006d0:	e03ff315 	stw	zero,-52(fp)
 80006d4:	008fc1b4 	movhi	r2,16134
 80006d8:	1082a404 	addi	r2,r2,2704
 80006dc:	e0bff415 	stw	r2,-48(fp)
 80006e0:	008fe1b4 	movhi	r2,16262
 80006e4:	1082a404 	addi	r2,r2,2704
 80006e8:	e0bff515 	stw	r2,-44(fp)
 80006ec:	008ff274 	movhi	r2,16329
 80006f0:	1083f604 	addi	r2,r2,4056
 80006f4:	e0bff615 	stw	r2,-40(fp)
 80006f8:	009001b4 	movhi	r2,16390
 80006fc:	1082a404 	addi	r2,r2,2704
 8000700:	e0bff715 	stw	r2,-36(fp)
 8000704:	00900a34 	movhi	r2,16424
 8000708:	10a34d04 	addi	r2,r2,-29388
 800070c:	e0bff815 	stw	r2,-32(fp)
 8000710:	00901274 	movhi	r2,16457
 8000714:	1083f604 	addi	r2,r2,4056
 8000718:	e0bff915 	stw	r2,-28(fp)
 800071c:	00901af4 	movhi	r2,16491
 8000720:	10a49f04 	addi	r2,r2,-28036
 8000724:	e0bffa15 	stw	r2,-24(fp)
 8000728:	009021b4 	movhi	r2,16518
 800072c:	1082a404 	addi	r2,r2,2704
 8000730:	e0bffb15 	stw	r2,-20(fp)
 8000734:	009025f4 	movhi	r2,16535
 8000738:	10b2f884 	addi	r2,r2,-13342
 800073c:	e0bffc15 	stw	r2,-16(fp)
 8000740:	00902a34 	movhi	r2,16552
 8000744:	10a34d04 	addi	r2,r2,-29388
 8000748:	e0bffd15 	stw	r2,-12(fp)
 800074c:	00902e34 	movhi	r2,16568
 8000750:	1093a184 	addi	r2,r2,20102
 8000754:	e0bffe15 	stw	r2,-8(fp)
 8000758:	00903274 	movhi	r2,16585
 800075c:	1083f604 	addi	r2,r2,4056
 8000760:	e0bfff15 	stw	r2,-4(fp)
                     (7*PI)/6, (4*PI)/3, (3*PI)/2, (5*PI)/3, (11*PI)/6, 2*PI};
  while(1) {
    // Clockwise rotation
    for (int i = 0; i < 13; i++) {
 8000764:	e03ff015 	stw	zero,-64(fp)
 8000768:	00001406 	br	80007bc <main+0xfc>
      printOnScreen(char_buf, "Clockwise");
 800076c:	01420074 	movhi	r5,2049
 8000770:	2977ab04 	addi	r5,r5,-8532
 8000774:	e13ff217 	ldw	r4,-56(fp)
 8000778:	80002900 	call	8000290 <printOnScreen>
      displayImage(myimage, 320, 240, angles[i]);
 800077c:	e0bff017 	ldw	r2,-64(fp)
 8000780:	1085883a 	add	r2,r2,r2
 8000784:	1085883a 	add	r2,r2,r2
 8000788:	e0fff004 	addi	r3,fp,-64
 800078c:	1885883a 	add	r2,r3,r2
 8000790:	10800304 	addi	r2,r2,12
 8000794:	10c00017 	ldw	r3,0(r2)
 8000798:	180f883a 	mov	r7,r3
 800079c:	01803c04 	movi	r6,240
 80007a0:	01405004 	movi	r5,320
 80007a4:	01020074 	movhi	r4,2049
 80007a8:	2137b284 	addi	r4,r4,-8502
 80007ac:	80003000 	call	8000300 <displayImage>
  // Angles used for rotating screen. In radians
  float angles[13] = {0, PI/6, PI/3, PI/2, (2*PI)/3, (5*PI)/6, PI,
                     (7*PI)/6, (4*PI)/3, (3*PI)/2, (5*PI)/3, (11*PI)/6, 2*PI};
  while(1) {
    // Clockwise rotation
    for (int i = 0; i < 13; i++) {
 80007b0:	e0bff017 	ldw	r2,-64(fp)
 80007b4:	10800044 	addi	r2,r2,1
 80007b8:	e0bff015 	stw	r2,-64(fp)
 80007bc:	e0bff017 	ldw	r2,-64(fp)
 80007c0:	10800350 	cmplti	r2,r2,13
 80007c4:	103fe91e 	bne	r2,zero,800076c <main+0xac>
      printOnScreen(char_buf, "Clockwise");
      displayImage(myimage, 320, 240, angles[i]);
    }
    // Couner-clockwise rotation
    for (int i = 11; i > 0; i--) {
 80007c8:	008002c4 	movi	r2,11
 80007cc:	e0bff115 	stw	r2,-60(fp)
 80007d0:	00001406 	br	8000824 <main+0x164>
      printOnScreen(char_buf, "Counter-clockwise");
 80007d4:	01420074 	movhi	r5,2049
 80007d8:	2977ae04 	addi	r5,r5,-8520
 80007dc:	e13ff217 	ldw	r4,-56(fp)
 80007e0:	80002900 	call	8000290 <printOnScreen>
      displayImage(myimage, 320, 240, angles[i]);
 80007e4:	e0bff117 	ldw	r2,-60(fp)
 80007e8:	1085883a 	add	r2,r2,r2
 80007ec:	1085883a 	add	r2,r2,r2
 80007f0:	e0fff004 	addi	r3,fp,-64
 80007f4:	1885883a 	add	r2,r3,r2
 80007f8:	10800304 	addi	r2,r2,12
 80007fc:	10c00017 	ldw	r3,0(r2)
 8000800:	180f883a 	mov	r7,r3
 8000804:	01803c04 	movi	r6,240
 8000808:	01405004 	movi	r5,320
 800080c:	01020074 	movhi	r4,2049
 8000810:	2137b284 	addi	r4,r4,-8502
 8000814:	80003000 	call	8000300 <displayImage>
    for (int i = 0; i < 13; i++) {
      printOnScreen(char_buf, "Clockwise");
      displayImage(myimage, 320, 240, angles[i]);
    }
    // Couner-clockwise rotation
    for (int i = 11; i > 0; i--) {
 8000818:	e0bff117 	ldw	r2,-60(fp)
 800081c:	10bfffc4 	addi	r2,r2,-1
 8000820:	e0bff115 	stw	r2,-60(fp)
 8000824:	e0bff117 	ldw	r2,-60(fp)
 8000828:	00bfea16 	blt	zero,r2,80007d4 <main+0x114>
      printOnScreen(char_buf, "Counter-clockwise");
      displayImage(myimage, 320, 240, angles[i]);
    }
  }    
 800082c:	003fcd06 	br	8000764 <main+0xa4>

08000830 <cos>:
	double cos(double x)
#else
	double cos(x)
	double x;
#endif
{
 8000830:	deffef04 	addi	sp,sp,-68
 8000834:	dfc01015 	stw	ra,64(sp)
 8000838:	df000f15 	stw	fp,60(sp)
 800083c:	dc400e15 	stw	r17,56(sp)
 8000840:	dc000d15 	stw	r16,52(sp)
 8000844:	df000f04 	addi	fp,sp,60
 8000848:	e13ffc15 	stw	r4,-16(fp)
 800084c:	e17ffd15 	stw	r5,-12(fp)
	double y[2],z=0.0;
 8000850:	e03ff215 	stw	zero,-56(fp)
 8000854:	e03ff315 	stw	zero,-52(fp)
	__int32_t n,ix;

    /* High word of x. */
	GET_HIGH_WORD(ix,x);
 8000858:	e0bffc17 	ldw	r2,-16(fp)
 800085c:	e0bffa15 	stw	r2,-24(fp)
 8000860:	e0bffd17 	ldw	r2,-12(fp)
 8000864:	e0bffb15 	stw	r2,-20(fp)
 8000868:	e0bffb17 	ldw	r2,-20(fp)
 800086c:	e0bff415 	stw	r2,-48(fp)

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
 8000870:	e0fff417 	ldw	r3,-48(fp)
 8000874:	00a00034 	movhi	r2,32768
 8000878:	10bfffc4 	addi	r2,r2,-1
 800087c:	1884703a 	and	r2,r3,r2
 8000880:	e0bff415 	stw	r2,-48(fp)
	if(ix <= 0x3fe921fb) return __kernel_cos(x,z);
 8000884:	e0fff417 	ldw	r3,-48(fp)
 8000888:	008ffa74 	movhi	r2,16361
 800088c:	10887ec4 	addi	r2,r2,8699
 8000890:	10c00816 	blt	r2,r3,80008b4 <cos+0x84>
 8000894:	e1bff217 	ldw	r6,-56(fp)
 8000898:	e1fff317 	ldw	r7,-52(fp)
 800089c:	e13ffc17 	ldw	r4,-16(fp)
 80008a0:	e17ffd17 	ldw	r5,-12(fp)
 80008a4:	80019000 	call	8001900 <__kernel_cos>
 80008a8:	1021883a 	mov	r16,r2
 80008ac:	1823883a 	mov	r17,r3
 80008b0:	00005106 	br	80009f8 <cos+0x1c8>

    /* cos(Inf or NaN) is NaN */
	else if (ix>=0x7ff00000) return x-x;
 80008b4:	e0fff417 	ldw	r3,-48(fp)
 80008b8:	009ffc34 	movhi	r2,32752
 80008bc:	18800a16 	blt	r3,r2,80008e8 <cos+0xb8>
 80008c0:	e1bffc17 	ldw	r6,-16(fp)
 80008c4:	e1fffd17 	ldw	r7,-12(fp)
 80008c8:	e13ffc17 	ldw	r4,-16(fp)
 80008cc:	e17ffd17 	ldw	r5,-12(fp)
 80008d0:	80051e80 	call	80051e8 <__subdf3>
 80008d4:	1009883a 	mov	r4,r2
 80008d8:	180b883a 	mov	r5,r3
 80008dc:	2021883a 	mov	r16,r4
 80008e0:	2823883a 	mov	r17,r5
 80008e4:	00004406 	br	80009f8 <cos+0x1c8>

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2(x,y);
 80008e8:	e0bff604 	addi	r2,fp,-40
 80008ec:	100d883a 	mov	r6,r2
 80008f0:	e13ffc17 	ldw	r4,-16(fp)
 80008f4:	e17ffd17 	ldw	r5,-12(fp)
 80008f8:	8000c1c0 	call	8000c1c <__ieee754_rem_pio2>
 80008fc:	e0bff515 	stw	r2,-44(fp)
	    switch(n&3) {
 8000900:	e0bff517 	ldw	r2,-44(fp)
 8000904:	108000cc 	andi	r2,r2,3
 8000908:	10c00060 	cmpeqi	r3,r2,1
 800090c:	18000f1e 	bne	r3,zero,800094c <cos+0x11c>
 8000910:	10c000a0 	cmpeqi	r3,r2,2
 8000914:	18001d1e 	bne	r3,zero,800098c <cos+0x15c>
 8000918:	10002a1e 	bne	r2,zero,80009c4 <cos+0x194>
		case 0: return  __kernel_cos(y[0],y[1]);
 800091c:	e0bff617 	ldw	r2,-40(fp)
 8000920:	e0fff717 	ldw	r3,-36(fp)
 8000924:	e13ff817 	ldw	r4,-32(fp)
 8000928:	e17ff917 	ldw	r5,-28(fp)
 800092c:	200d883a 	mov	r6,r4
 8000930:	280f883a 	mov	r7,r5
 8000934:	1009883a 	mov	r4,r2
 8000938:	180b883a 	mov	r5,r3
 800093c:	80019000 	call	8001900 <__kernel_cos>
 8000940:	1021883a 	mov	r16,r2
 8000944:	1823883a 	mov	r17,r3
 8000948:	00002b06 	br	80009f8 <cos+0x1c8>
		case 1: return -__kernel_sin(y[0],y[1],1);
 800094c:	e0bff617 	ldw	r2,-40(fp)
 8000950:	e0fff717 	ldw	r3,-36(fp)
 8000954:	e13ff817 	ldw	r4,-32(fp)
 8000958:	e17ff917 	ldw	r5,-28(fp)
 800095c:	01800044 	movi	r6,1
 8000960:	d9800015 	stw	r6,0(sp)
 8000964:	200d883a 	mov	r6,r4
 8000968:	280f883a 	mov	r7,r5
 800096c:	1009883a 	mov	r4,r2
 8000970:	180b883a 	mov	r5,r3
 8000974:	800322c0 	call	800322c <__kernel_sin>
 8000978:	1009883a 	mov	r4,r2
 800097c:	180b883a 	mov	r5,r3
 8000980:	2021883a 	mov	r16,r4
 8000984:	2c60003c 	xorhi	r17,r5,32768
 8000988:	00001b06 	br	80009f8 <cos+0x1c8>
		case 2: return -__kernel_cos(y[0],y[1]);
 800098c:	e0bff617 	ldw	r2,-40(fp)
 8000990:	e0fff717 	ldw	r3,-36(fp)
 8000994:	e13ff817 	ldw	r4,-32(fp)
 8000998:	e17ff917 	ldw	r5,-28(fp)
 800099c:	200d883a 	mov	r6,r4
 80009a0:	280f883a 	mov	r7,r5
 80009a4:	1009883a 	mov	r4,r2
 80009a8:	180b883a 	mov	r5,r3
 80009ac:	80019000 	call	8001900 <__kernel_cos>
 80009b0:	1009883a 	mov	r4,r2
 80009b4:	180b883a 	mov	r5,r3
 80009b8:	2021883a 	mov	r16,r4
 80009bc:	2c60003c 	xorhi	r17,r5,32768
 80009c0:	00000d06 	br	80009f8 <cos+0x1c8>
		default:
		        return  __kernel_sin(y[0],y[1],1);
 80009c4:	e0bff617 	ldw	r2,-40(fp)
 80009c8:	e0fff717 	ldw	r3,-36(fp)
 80009cc:	e13ff817 	ldw	r4,-32(fp)
 80009d0:	e17ff917 	ldw	r5,-28(fp)
 80009d4:	01800044 	movi	r6,1
 80009d8:	d9800015 	stw	r6,0(sp)
 80009dc:	200d883a 	mov	r6,r4
 80009e0:	280f883a 	mov	r7,r5
 80009e4:	1009883a 	mov	r4,r2
 80009e8:	180b883a 	mov	r5,r3
 80009ec:	800322c0 	call	800322c <__kernel_sin>
 80009f0:	1021883a 	mov	r16,r2
 80009f4:	1823883a 	mov	r17,r3
 80009f8:	8007883a 	mov	r3,r16
 80009fc:	8809883a 	mov	r4,r17
	    }
	}
}
 8000a00:	1805883a 	mov	r2,r3
 8000a04:	2007883a 	mov	r3,r4
 8000a08:	e6fffe04 	addi	sp,fp,-8
 8000a0c:	dfc00317 	ldw	ra,12(sp)
 8000a10:	df000217 	ldw	fp,8(sp)
 8000a14:	dc400117 	ldw	r17,4(sp)
 8000a18:	dc000017 	ldw	r16,0(sp)
 8000a1c:	dec00404 	addi	sp,sp,16
 8000a20:	f800283a 	ret

08000a24 <sin>:
	double sin(double x)
#else
	double sin(x)
	double x;
#endif
{
 8000a24:	deffef04 	addi	sp,sp,-68
 8000a28:	dfc01015 	stw	ra,64(sp)
 8000a2c:	df000f15 	stw	fp,60(sp)
 8000a30:	dc400e15 	stw	r17,56(sp)
 8000a34:	dc000d15 	stw	r16,52(sp)
 8000a38:	df000f04 	addi	fp,sp,60
 8000a3c:	e13ffc15 	stw	r4,-16(fp)
 8000a40:	e17ffd15 	stw	r5,-12(fp)
	double y[2],z=0.0;
 8000a44:	e03ff215 	stw	zero,-56(fp)
 8000a48:	e03ff315 	stw	zero,-52(fp)
	__int32_t n,ix;

    /* High word of x. */
	GET_HIGH_WORD(ix,x);
 8000a4c:	e0bffc17 	ldw	r2,-16(fp)
 8000a50:	e0bffa15 	stw	r2,-24(fp)
 8000a54:	e0bffd17 	ldw	r2,-12(fp)
 8000a58:	e0bffb15 	stw	r2,-20(fp)
 8000a5c:	e0bffb17 	ldw	r2,-20(fp)
 8000a60:	e0bff415 	stw	r2,-48(fp)

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
 8000a64:	e0fff417 	ldw	r3,-48(fp)
 8000a68:	00a00034 	movhi	r2,32768
 8000a6c:	10bfffc4 	addi	r2,r2,-1
 8000a70:	1884703a 	and	r2,r3,r2
 8000a74:	e0bff415 	stw	r2,-48(fp)
	if(ix <= 0x3fe921fb) return __kernel_sin(x,z,0);
 8000a78:	e0fff417 	ldw	r3,-48(fp)
 8000a7c:	008ffa74 	movhi	r2,16361
 8000a80:	10887ec4 	addi	r2,r2,8699
 8000a84:	10c00916 	blt	r2,r3,8000aac <sin+0x88>
 8000a88:	d8000015 	stw	zero,0(sp)
 8000a8c:	e1bff217 	ldw	r6,-56(fp)
 8000a90:	e1fff317 	ldw	r7,-52(fp)
 8000a94:	e13ffc17 	ldw	r4,-16(fp)
 8000a98:	e17ffd17 	ldw	r5,-12(fp)
 8000a9c:	800322c0 	call	800322c <__kernel_sin>
 8000aa0:	1021883a 	mov	r16,r2
 8000aa4:	1823883a 	mov	r17,r3
 8000aa8:	00005106 	br	8000bf0 <sin+0x1cc>

    /* sin(Inf or NaN) is NaN */
	else if (ix>=0x7ff00000) return x-x;
 8000aac:	e0fff417 	ldw	r3,-48(fp)
 8000ab0:	009ffc34 	movhi	r2,32752
 8000ab4:	18800a16 	blt	r3,r2,8000ae0 <sin+0xbc>
 8000ab8:	e1bffc17 	ldw	r6,-16(fp)
 8000abc:	e1fffd17 	ldw	r7,-12(fp)
 8000ac0:	e13ffc17 	ldw	r4,-16(fp)
 8000ac4:	e17ffd17 	ldw	r5,-12(fp)
 8000ac8:	80051e80 	call	80051e8 <__subdf3>
 8000acc:	1009883a 	mov	r4,r2
 8000ad0:	180b883a 	mov	r5,r3
 8000ad4:	2021883a 	mov	r16,r4
 8000ad8:	2823883a 	mov	r17,r5
 8000adc:	00004406 	br	8000bf0 <sin+0x1cc>

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2(x,y);
 8000ae0:	e0bff604 	addi	r2,fp,-40
 8000ae4:	100d883a 	mov	r6,r2
 8000ae8:	e13ffc17 	ldw	r4,-16(fp)
 8000aec:	e17ffd17 	ldw	r5,-12(fp)
 8000af0:	8000c1c0 	call	8000c1c <__ieee754_rem_pio2>
 8000af4:	e0bff515 	stw	r2,-44(fp)
	    switch(n&3) {
 8000af8:	e0bff517 	ldw	r2,-44(fp)
 8000afc:	108000cc 	andi	r2,r2,3
 8000b00:	10c00060 	cmpeqi	r3,r2,1
 8000b04:	1800111e 	bne	r3,zero,8000b4c <sin+0x128>
 8000b08:	10c000a0 	cmpeqi	r3,r2,2
 8000b0c:	18001b1e 	bne	r3,zero,8000b7c <sin+0x158>
 8000b10:	10002a1e 	bne	r2,zero,8000bbc <sin+0x198>
		case 0: return  __kernel_sin(y[0],y[1],1);
 8000b14:	e0bff617 	ldw	r2,-40(fp)
 8000b18:	e0fff717 	ldw	r3,-36(fp)
 8000b1c:	e13ff817 	ldw	r4,-32(fp)
 8000b20:	e17ff917 	ldw	r5,-28(fp)
 8000b24:	01800044 	movi	r6,1
 8000b28:	d9800015 	stw	r6,0(sp)
 8000b2c:	200d883a 	mov	r6,r4
 8000b30:	280f883a 	mov	r7,r5
 8000b34:	1009883a 	mov	r4,r2
 8000b38:	180b883a 	mov	r5,r3
 8000b3c:	800322c0 	call	800322c <__kernel_sin>
 8000b40:	1021883a 	mov	r16,r2
 8000b44:	1823883a 	mov	r17,r3
 8000b48:	00002906 	br	8000bf0 <sin+0x1cc>
		case 1: return  __kernel_cos(y[0],y[1]);
 8000b4c:	e0bff617 	ldw	r2,-40(fp)
 8000b50:	e0fff717 	ldw	r3,-36(fp)
 8000b54:	e13ff817 	ldw	r4,-32(fp)
 8000b58:	e17ff917 	ldw	r5,-28(fp)
 8000b5c:	200d883a 	mov	r6,r4
 8000b60:	280f883a 	mov	r7,r5
 8000b64:	1009883a 	mov	r4,r2
 8000b68:	180b883a 	mov	r5,r3
 8000b6c:	80019000 	call	8001900 <__kernel_cos>
 8000b70:	1021883a 	mov	r16,r2
 8000b74:	1823883a 	mov	r17,r3
 8000b78:	00001d06 	br	8000bf0 <sin+0x1cc>
		case 2: return -__kernel_sin(y[0],y[1],1);
 8000b7c:	e0bff617 	ldw	r2,-40(fp)
 8000b80:	e0fff717 	ldw	r3,-36(fp)
 8000b84:	e13ff817 	ldw	r4,-32(fp)
 8000b88:	e17ff917 	ldw	r5,-28(fp)
 8000b8c:	01800044 	movi	r6,1
 8000b90:	d9800015 	stw	r6,0(sp)
 8000b94:	200d883a 	mov	r6,r4
 8000b98:	280f883a 	mov	r7,r5
 8000b9c:	1009883a 	mov	r4,r2
 8000ba0:	180b883a 	mov	r5,r3
 8000ba4:	800322c0 	call	800322c <__kernel_sin>
 8000ba8:	1009883a 	mov	r4,r2
 8000bac:	180b883a 	mov	r5,r3
 8000bb0:	2021883a 	mov	r16,r4
 8000bb4:	2c60003c 	xorhi	r17,r5,32768
 8000bb8:	00000d06 	br	8000bf0 <sin+0x1cc>
		default:
			return -__kernel_cos(y[0],y[1]);
 8000bbc:	e0bff617 	ldw	r2,-40(fp)
 8000bc0:	e0fff717 	ldw	r3,-36(fp)
 8000bc4:	e13ff817 	ldw	r4,-32(fp)
 8000bc8:	e17ff917 	ldw	r5,-28(fp)
 8000bcc:	200d883a 	mov	r6,r4
 8000bd0:	280f883a 	mov	r7,r5
 8000bd4:	1009883a 	mov	r4,r2
 8000bd8:	180b883a 	mov	r5,r3
 8000bdc:	80019000 	call	8001900 <__kernel_cos>
 8000be0:	1009883a 	mov	r4,r2
 8000be4:	180b883a 	mov	r5,r3
 8000be8:	2021883a 	mov	r16,r4
 8000bec:	2c60003c 	xorhi	r17,r5,32768
 8000bf0:	8007883a 	mov	r3,r16
 8000bf4:	8809883a 	mov	r4,r17
	    }
	}
}
 8000bf8:	1805883a 	mov	r2,r3
 8000bfc:	2007883a 	mov	r3,r4
 8000c00:	e6fffe04 	addi	sp,fp,-8
 8000c04:	dfc00317 	ldw	ra,12(sp)
 8000c08:	df000217 	ldw	fp,8(sp)
 8000c0c:	dc400117 	ldw	r17,4(sp)
 8000c10:	dc000017 	ldw	r16,0(sp)
 8000c14:	dec00404 	addi	sp,sp,16
 8000c18:	f800283a 	ret

08000c1c <__ieee754_rem_pio2>:
	__int32_t __ieee754_rem_pio2(double x, double *y)
#else
	__int32_t __ieee754_rem_pio2(x,y)
	double x,y[];
#endif
{
 8000c1c:	deffcc04 	addi	sp,sp,-208
 8000c20:	dfc03315 	stw	ra,204(sp)
 8000c24:	df003215 	stw	fp,200(sp)
 8000c28:	ddc03115 	stw	r23,196(sp)
 8000c2c:	dd803015 	stw	r22,192(sp)
 8000c30:	dd402f15 	stw	r21,188(sp)
 8000c34:	dd002e15 	stw	r20,184(sp)
 8000c38:	dcc02d15 	stw	r19,180(sp)
 8000c3c:	dc802c15 	stw	r18,176(sp)
 8000c40:	dc402b15 	stw	r17,172(sp)
 8000c44:	dc002a15 	stw	r16,168(sp)
 8000c48:	df003204 	addi	fp,sp,200
 8000c4c:	e13ff515 	stw	r4,-44(fp)
 8000c50:	e17ff615 	stw	r5,-40(fp)
 8000c54:	e1bff715 	stw	r6,-36(fp)
	double z = 0.0,w,t,r,fn;
 8000c58:	e03fd015 	stw	zero,-192(fp)
 8000c5c:	e03fd115 	stw	zero,-188(fp)
	double tx[3];
	__int32_t i,j,n,ix,hx;
	int e0,nx;
	__uint32_t low;

	GET_HIGH_WORD(hx,x);		/* high word of x */
 8000c60:	e0bff517 	ldw	r2,-44(fp)
 8000c64:	e0bfe915 	stw	r2,-92(fp)
 8000c68:	e0bff617 	ldw	r2,-40(fp)
 8000c6c:	e0bfea15 	stw	r2,-88(fp)
 8000c70:	e0bfea17 	ldw	r2,-88(fp)
 8000c74:	e0bfd815 	stw	r2,-160(fp)
	ix = hx&0x7fffffff;
 8000c78:	e0ffd817 	ldw	r3,-160(fp)
 8000c7c:	00a00034 	movhi	r2,32768
 8000c80:	10bfffc4 	addi	r2,r2,-1
 8000c84:	1884703a 	and	r2,r3,r2
 8000c88:	e0bfd915 	stw	r2,-156(fp)
	if(ix<=0x3fe921fb)   /* |x| ~<= pi/4 , no need for reduction */
 8000c8c:	e0ffd917 	ldw	r3,-156(fp)
 8000c90:	008ffa74 	movhi	r2,16361
 8000c94:	10887ec4 	addi	r2,r2,8699
 8000c98:	10c00b16 	blt	r2,r3,8000cc8 <__ieee754_rem_pio2+0xac>
	    {y[0] = x; y[1] = 0; return 0;}
 8000c9c:	e0bff717 	ldw	r2,-36(fp)
 8000ca0:	e0fff517 	ldw	r3,-44(fp)
 8000ca4:	10c00015 	stw	r3,0(r2)
 8000ca8:	e0fff617 	ldw	r3,-40(fp)
 8000cac:	10c00115 	stw	r3,4(r2)
 8000cb0:	e0bff717 	ldw	r2,-36(fp)
 8000cb4:	10800204 	addi	r2,r2,8
 8000cb8:	10000015 	stw	zero,0(r2)
 8000cbc:	10000115 	stw	zero,4(r2)
 8000cc0:	0005883a 	mov	r2,zero
 8000cc4:	00030106 	br	80018cc <__ieee754_rem_pio2+0xcb0>
	if(ix<0x4002d97c) {  /* |x| < 3pi/4, special case with n=+-1 */
 8000cc8:	e0ffd917 	ldw	r3,-156(fp)
 8000ccc:	009000f4 	movhi	r2,16387
 8000cd0:	10b65ec4 	addi	r2,r2,-9861
 8000cd4:	10c0f416 	blt	r2,r3,80010a8 <__ieee754_rem_pio2+0x48c>
	    if(hx>0) { 
 8000cd8:	e0bfd817 	ldw	r2,-160(fp)
 8000cdc:	0080790e 	bge	zero,r2,8000ec4 <__ieee754_rem_pio2+0x2a8>
		z = x - pio2_1;
 8000ce0:	00951034 	movhi	r2,21568
 8000ce4:	00cffe74 	movhi	r3,16377
 8000ce8:	18c87ec4 	addi	r3,r3,8699
 8000cec:	100d883a 	mov	r6,r2
 8000cf0:	180f883a 	mov	r7,r3
 8000cf4:	e13ff517 	ldw	r4,-44(fp)
 8000cf8:	e17ff617 	ldw	r5,-40(fp)
 8000cfc:	80051e80 	call	80051e8 <__subdf3>
 8000d00:	1009883a 	mov	r4,r2
 8000d04:	180b883a 	mov	r5,r3
 8000d08:	e13fd015 	stw	r4,-192(fp)
 8000d0c:	e17fd115 	stw	r5,-188(fp)
		if(ix!=0x3ff921fb) { 	/* 33+53 bit pi is good enough */
 8000d10:	e0ffd917 	ldw	r3,-156(fp)
 8000d14:	008ffe74 	movhi	r2,16377
 8000d18:	10887ec4 	addi	r2,r2,8699
 8000d1c:	18802e26 	beq	r3,r2,8000dd8 <__ieee754_rem_pio2+0x1bc>
		    y[0] = z - pio2_1t;
 8000d20:	008698b4 	movhi	r2,6754
 8000d24:	1098cc44 	addi	r2,r2,25393
 8000d28:	00cf7474 	movhi	r3,15825
 8000d2c:	18ed1844 	addi	r3,r3,-19359
 8000d30:	100d883a 	mov	r6,r2
 8000d34:	180f883a 	mov	r7,r3
 8000d38:	e13fd017 	ldw	r4,-192(fp)
 8000d3c:	e17fd117 	ldw	r5,-188(fp)
 8000d40:	80051e80 	call	80051e8 <__subdf3>
 8000d44:	1009883a 	mov	r4,r2
 8000d48:	180b883a 	mov	r5,r3
 8000d4c:	2005883a 	mov	r2,r4
 8000d50:	2807883a 	mov	r3,r5
 8000d54:	e13ff717 	ldw	r4,-36(fp)
 8000d58:	20800015 	stw	r2,0(r4)
 8000d5c:	20c00115 	stw	r3,4(r4)
		    y[1] = (z-y[0])-pio2_1t;
 8000d60:	e0bff717 	ldw	r2,-36(fp)
 8000d64:	14000204 	addi	r16,r2,8
 8000d68:	e13ff717 	ldw	r4,-36(fp)
 8000d6c:	20800017 	ldw	r2,0(r4)
 8000d70:	20c00117 	ldw	r3,4(r4)
 8000d74:	100d883a 	mov	r6,r2
 8000d78:	180f883a 	mov	r7,r3
 8000d7c:	e13fd017 	ldw	r4,-192(fp)
 8000d80:	e17fd117 	ldw	r5,-188(fp)
 8000d84:	80051e80 	call	80051e8 <__subdf3>
 8000d88:	1009883a 	mov	r4,r2
 8000d8c:	180b883a 	mov	r5,r3
 8000d90:	2011883a 	mov	r8,r4
 8000d94:	2813883a 	mov	r9,r5
 8000d98:	008698b4 	movhi	r2,6754
 8000d9c:	1098cc44 	addi	r2,r2,25393
 8000da0:	00cf7474 	movhi	r3,15825
 8000da4:	18ed1844 	addi	r3,r3,-19359
 8000da8:	100d883a 	mov	r6,r2
 8000dac:	180f883a 	mov	r7,r3
 8000db0:	4009883a 	mov	r4,r8
 8000db4:	480b883a 	mov	r5,r9
 8000db8:	80051e80 	call	80051e8 <__subdf3>
 8000dbc:	1009883a 	mov	r4,r2
 8000dc0:	180b883a 	mov	r5,r3
 8000dc4:	2005883a 	mov	r2,r4
 8000dc8:	2807883a 	mov	r3,r5
 8000dcc:	80800015 	stw	r2,0(r16)
 8000dd0:	80c00115 	stw	r3,4(r16)
 8000dd4:	00003906 	br	8000ebc <__ieee754_rem_pio2+0x2a0>
		} else {		/* near pi/2, use 33+33+53 bit pi */
		    z -= pio2_2;
 8000dd8:	00869834 	movhi	r2,6752
 8000ddc:	00cf7474 	movhi	r3,15825
 8000de0:	18ed1844 	addi	r3,r3,-19359
 8000de4:	100d883a 	mov	r6,r2
 8000de8:	180f883a 	mov	r7,r3
 8000dec:	e13fd017 	ldw	r4,-192(fp)
 8000df0:	e17fd117 	ldw	r5,-188(fp)
 8000df4:	80051e80 	call	80051e8 <__subdf3>
 8000df8:	1009883a 	mov	r4,r2
 8000dfc:	180b883a 	mov	r5,r3
 8000e00:	e13fd015 	stw	r4,-192(fp)
 8000e04:	e17fd115 	stw	r5,-188(fp)
		    y[0] = z - pio2_2t;
 8000e08:	008b80f4 	movhi	r2,11779
 8000e0c:	109c1cc4 	addi	r2,r2,28787
 8000e10:	00cee8f4 	movhi	r3,15267
 8000e14:	18c66284 	addi	r3,r3,6538
 8000e18:	100d883a 	mov	r6,r2
 8000e1c:	180f883a 	mov	r7,r3
 8000e20:	e13fd017 	ldw	r4,-192(fp)
 8000e24:	e17fd117 	ldw	r5,-188(fp)
 8000e28:	80051e80 	call	80051e8 <__subdf3>
 8000e2c:	1009883a 	mov	r4,r2
 8000e30:	180b883a 	mov	r5,r3
 8000e34:	2005883a 	mov	r2,r4
 8000e38:	2807883a 	mov	r3,r5
 8000e3c:	e13ff717 	ldw	r4,-36(fp)
 8000e40:	20800015 	stw	r2,0(r4)
 8000e44:	20c00115 	stw	r3,4(r4)
		    y[1] = (z-y[0])-pio2_2t;
 8000e48:	e0bff717 	ldw	r2,-36(fp)
 8000e4c:	14000204 	addi	r16,r2,8
 8000e50:	e13ff717 	ldw	r4,-36(fp)
 8000e54:	20800017 	ldw	r2,0(r4)
 8000e58:	20c00117 	ldw	r3,4(r4)
 8000e5c:	100d883a 	mov	r6,r2
 8000e60:	180f883a 	mov	r7,r3
 8000e64:	e13fd017 	ldw	r4,-192(fp)
 8000e68:	e17fd117 	ldw	r5,-188(fp)
 8000e6c:	80051e80 	call	80051e8 <__subdf3>
 8000e70:	1009883a 	mov	r4,r2
 8000e74:	180b883a 	mov	r5,r3
 8000e78:	2011883a 	mov	r8,r4
 8000e7c:	2813883a 	mov	r9,r5
 8000e80:	008b80f4 	movhi	r2,11779
 8000e84:	109c1cc4 	addi	r2,r2,28787
 8000e88:	00cee8f4 	movhi	r3,15267
 8000e8c:	18c66284 	addi	r3,r3,6538
 8000e90:	100d883a 	mov	r6,r2
 8000e94:	180f883a 	mov	r7,r3
 8000e98:	4009883a 	mov	r4,r8
 8000e9c:	480b883a 	mov	r5,r9
 8000ea0:	80051e80 	call	80051e8 <__subdf3>
 8000ea4:	1009883a 	mov	r4,r2
 8000ea8:	180b883a 	mov	r5,r3
 8000eac:	2005883a 	mov	r2,r4
 8000eb0:	2807883a 	mov	r3,r5
 8000eb4:	80800015 	stw	r2,0(r16)
 8000eb8:	80c00115 	stw	r3,4(r16)
		}
		return 1;
 8000ebc:	00800044 	movi	r2,1
 8000ec0:	00028206 	br	80018cc <__ieee754_rem_pio2+0xcb0>
	    } else {	/* negative x */
		z = x + pio2_1;
 8000ec4:	00951034 	movhi	r2,21568
 8000ec8:	00cffe74 	movhi	r3,16377
 8000ecc:	18c87ec4 	addi	r3,r3,8699
 8000ed0:	100d883a 	mov	r6,r2
 8000ed4:	180f883a 	mov	r7,r3
 8000ed8:	e13ff517 	ldw	r4,-44(fp)
 8000edc:	e17ff617 	ldw	r5,-40(fp)
 8000ee0:	80040c00 	call	80040c0 <__adddf3>
 8000ee4:	1009883a 	mov	r4,r2
 8000ee8:	180b883a 	mov	r5,r3
 8000eec:	e13fd015 	stw	r4,-192(fp)
 8000ef0:	e17fd115 	stw	r5,-188(fp)
		if(ix!=0x3ff921fb) { 	/* 33+53 bit pi is good enough */
 8000ef4:	e0ffd917 	ldw	r3,-156(fp)
 8000ef8:	008ffe74 	movhi	r2,16377
 8000efc:	10887ec4 	addi	r2,r2,8699
 8000f00:	18802e26 	beq	r3,r2,8000fbc <__ieee754_rem_pio2+0x3a0>
		    y[0] = z + pio2_1t;
 8000f04:	008698b4 	movhi	r2,6754
 8000f08:	1098cc44 	addi	r2,r2,25393
 8000f0c:	00cf7474 	movhi	r3,15825
 8000f10:	18ed1844 	addi	r3,r3,-19359
 8000f14:	e1bfd017 	ldw	r6,-192(fp)
 8000f18:	e1ffd117 	ldw	r7,-188(fp)
 8000f1c:	1009883a 	mov	r4,r2
 8000f20:	180b883a 	mov	r5,r3
 8000f24:	80040c00 	call	80040c0 <__adddf3>
 8000f28:	1009883a 	mov	r4,r2
 8000f2c:	180b883a 	mov	r5,r3
 8000f30:	2005883a 	mov	r2,r4
 8000f34:	2807883a 	mov	r3,r5
 8000f38:	e13ff717 	ldw	r4,-36(fp)
 8000f3c:	20800015 	stw	r2,0(r4)
 8000f40:	20c00115 	stw	r3,4(r4)
		    y[1] = (z-y[0])+pio2_1t;
 8000f44:	e0bff717 	ldw	r2,-36(fp)
 8000f48:	14000204 	addi	r16,r2,8
 8000f4c:	e13ff717 	ldw	r4,-36(fp)
 8000f50:	20800017 	ldw	r2,0(r4)
 8000f54:	20c00117 	ldw	r3,4(r4)
 8000f58:	100d883a 	mov	r6,r2
 8000f5c:	180f883a 	mov	r7,r3
 8000f60:	e13fd017 	ldw	r4,-192(fp)
 8000f64:	e17fd117 	ldw	r5,-188(fp)
 8000f68:	80051e80 	call	80051e8 <__subdf3>
 8000f6c:	1009883a 	mov	r4,r2
 8000f70:	180b883a 	mov	r5,r3
 8000f74:	2011883a 	mov	r8,r4
 8000f78:	2813883a 	mov	r9,r5
 8000f7c:	008698b4 	movhi	r2,6754
 8000f80:	1098cc44 	addi	r2,r2,25393
 8000f84:	00cf7474 	movhi	r3,15825
 8000f88:	18ed1844 	addi	r3,r3,-19359
 8000f8c:	100d883a 	mov	r6,r2
 8000f90:	180f883a 	mov	r7,r3
 8000f94:	4009883a 	mov	r4,r8
 8000f98:	480b883a 	mov	r5,r9
 8000f9c:	80040c00 	call	80040c0 <__adddf3>
 8000fa0:	1009883a 	mov	r4,r2
 8000fa4:	180b883a 	mov	r5,r3
 8000fa8:	2005883a 	mov	r2,r4
 8000fac:	2807883a 	mov	r3,r5
 8000fb0:	80800015 	stw	r2,0(r16)
 8000fb4:	80c00115 	stw	r3,4(r16)
 8000fb8:	00003906 	br	80010a0 <__ieee754_rem_pio2+0x484>
		} else {		/* near pi/2, use 33+33+53 bit pi */
		    z += pio2_2;
 8000fbc:	00869834 	movhi	r2,6752
 8000fc0:	00cf7474 	movhi	r3,15825
 8000fc4:	18ed1844 	addi	r3,r3,-19359
 8000fc8:	100d883a 	mov	r6,r2
 8000fcc:	180f883a 	mov	r7,r3
 8000fd0:	e13fd017 	ldw	r4,-192(fp)
 8000fd4:	e17fd117 	ldw	r5,-188(fp)
 8000fd8:	80040c00 	call	80040c0 <__adddf3>
 8000fdc:	1009883a 	mov	r4,r2
 8000fe0:	180b883a 	mov	r5,r3
 8000fe4:	e13fd015 	stw	r4,-192(fp)
 8000fe8:	e17fd115 	stw	r5,-188(fp)
		    y[0] = z + pio2_2t;
 8000fec:	008b80f4 	movhi	r2,11779
 8000ff0:	109c1cc4 	addi	r2,r2,28787
 8000ff4:	00cee8f4 	movhi	r3,15267
 8000ff8:	18c66284 	addi	r3,r3,6538
 8000ffc:	e1bfd017 	ldw	r6,-192(fp)
 8001000:	e1ffd117 	ldw	r7,-188(fp)
 8001004:	1009883a 	mov	r4,r2
 8001008:	180b883a 	mov	r5,r3
 800100c:	80040c00 	call	80040c0 <__adddf3>
 8001010:	1009883a 	mov	r4,r2
 8001014:	180b883a 	mov	r5,r3
 8001018:	2005883a 	mov	r2,r4
 800101c:	2807883a 	mov	r3,r5
 8001020:	e13ff717 	ldw	r4,-36(fp)
 8001024:	20800015 	stw	r2,0(r4)
 8001028:	20c00115 	stw	r3,4(r4)
		    y[1] = (z-y[0])+pio2_2t;
 800102c:	e0bff717 	ldw	r2,-36(fp)
 8001030:	14000204 	addi	r16,r2,8
 8001034:	e13ff717 	ldw	r4,-36(fp)
 8001038:	20800017 	ldw	r2,0(r4)
 800103c:	20c00117 	ldw	r3,4(r4)
 8001040:	100d883a 	mov	r6,r2
 8001044:	180f883a 	mov	r7,r3
 8001048:	e13fd017 	ldw	r4,-192(fp)
 800104c:	e17fd117 	ldw	r5,-188(fp)
 8001050:	80051e80 	call	80051e8 <__subdf3>
 8001054:	1009883a 	mov	r4,r2
 8001058:	180b883a 	mov	r5,r3
 800105c:	2011883a 	mov	r8,r4
 8001060:	2813883a 	mov	r9,r5
 8001064:	008b80f4 	movhi	r2,11779
 8001068:	109c1cc4 	addi	r2,r2,28787
 800106c:	00cee8f4 	movhi	r3,15267
 8001070:	18c66284 	addi	r3,r3,6538
 8001074:	100d883a 	mov	r6,r2
 8001078:	180f883a 	mov	r7,r3
 800107c:	4009883a 	mov	r4,r8
 8001080:	480b883a 	mov	r5,r9
 8001084:	80040c00 	call	80040c0 <__adddf3>
 8001088:	1009883a 	mov	r4,r2
 800108c:	180b883a 	mov	r5,r3
 8001090:	2005883a 	mov	r2,r4
 8001094:	2807883a 	mov	r3,r5
 8001098:	80800015 	stw	r2,0(r16)
 800109c:	80c00115 	stw	r3,4(r16)
		}
		return -1;
 80010a0:	00bfffc4 	movi	r2,-1
 80010a4:	00020906 	br	80018cc <__ieee754_rem_pio2+0xcb0>
	    }
	}
	if(ix<=0x413921fb) { /* |x| ~<= 2^19*(pi/2), medium size */
 80010a8:	e0ffd917 	ldw	r3,-156(fp)
 80010ac:	00904e74 	movhi	r2,16697
 80010b0:	10887ec4 	addi	r2,r2,8699
 80010b4:	10c15e16 	blt	r2,r3,8001630 <__ieee754_rem_pio2+0xa14>
	    t  = fabs(x);
 80010b8:	e13ff517 	ldw	r4,-44(fp)
 80010bc:	e17ff617 	ldw	r5,-40(fp)
 80010c0:	80036700 	call	8003670 <fabs>
 80010c4:	e0bfda15 	stw	r2,-152(fp)
 80010c8:	e0ffdb15 	stw	r3,-148(fp)
	    n  = (__int32_t) (t*invpio2+half);
 80010cc:	009b72b4 	movhi	r2,28106
 80010d0:	10b220c4 	addi	r2,r2,-14205
 80010d4:	00cff934 	movhi	r3,16356
 80010d8:	18d7cc04 	addi	r3,r3,24368
 80010dc:	e1bfda17 	ldw	r6,-152(fp)
 80010e0:	e1ffdb17 	ldw	r7,-148(fp)
 80010e4:	1009883a 	mov	r4,r2
 80010e8:	180b883a 	mov	r5,r3
 80010ec:	8004ad00 	call	8004ad0 <__muldf3>
 80010f0:	1009883a 	mov	r4,r2
 80010f4:	180b883a 	mov	r5,r3
 80010f8:	2011883a 	mov	r8,r4
 80010fc:	2813883a 	mov	r9,r5
 8001100:	0005883a 	mov	r2,zero
 8001104:	00cff834 	movhi	r3,16352
 8001108:	100d883a 	mov	r6,r2
 800110c:	180f883a 	mov	r7,r3
 8001110:	4009883a 	mov	r4,r8
 8001114:	480b883a 	mov	r5,r9
 8001118:	80040c00 	call	80040c0 <__adddf3>
 800111c:	1009883a 	mov	r4,r2
 8001120:	180b883a 	mov	r5,r3
 8001124:	2005883a 	mov	r2,r4
 8001128:	2807883a 	mov	r3,r5
 800112c:	1009883a 	mov	r4,r2
 8001130:	180b883a 	mov	r5,r3
 8001134:	8005ae40 	call	8005ae4 <__fixdfsi>
 8001138:	e0bfdc15 	stw	r2,-144(fp)
	    fn = (double)n;
 800113c:	e13fdc17 	ldw	r4,-144(fp)
 8001140:	8005b640 	call	8005b64 <__floatsidf>
 8001144:	1009883a 	mov	r4,r2
 8001148:	180b883a 	mov	r5,r3
 800114c:	e13fdd15 	stw	r4,-140(fp)
 8001150:	e17fde15 	stw	r5,-136(fp)
	    r  = t-fn*pio2_1;
 8001154:	00951034 	movhi	r2,21568
 8001158:	00cffe74 	movhi	r3,16377
 800115c:	18c87ec4 	addi	r3,r3,8699
 8001160:	e1bfdd17 	ldw	r6,-140(fp)
 8001164:	e1ffde17 	ldw	r7,-136(fp)
 8001168:	1009883a 	mov	r4,r2
 800116c:	180b883a 	mov	r5,r3
 8001170:	8004ad00 	call	8004ad0 <__muldf3>
 8001174:	1009883a 	mov	r4,r2
 8001178:	180b883a 	mov	r5,r3
 800117c:	2005883a 	mov	r2,r4
 8001180:	2807883a 	mov	r3,r5
 8001184:	100d883a 	mov	r6,r2
 8001188:	180f883a 	mov	r7,r3
 800118c:	e13fda17 	ldw	r4,-152(fp)
 8001190:	e17fdb17 	ldw	r5,-148(fp)
 8001194:	80051e80 	call	80051e8 <__subdf3>
 8001198:	1009883a 	mov	r4,r2
 800119c:	180b883a 	mov	r5,r3
 80011a0:	e13fd415 	stw	r4,-176(fp)
 80011a4:	e17fd515 	stw	r5,-172(fp)
	    w  = fn*pio2_1t;	/* 1st round good to 85 bit */
 80011a8:	008698b4 	movhi	r2,6754
 80011ac:	1098cc44 	addi	r2,r2,25393
 80011b0:	00cf7474 	movhi	r3,15825
 80011b4:	18ed1844 	addi	r3,r3,-19359
 80011b8:	100d883a 	mov	r6,r2
 80011bc:	180f883a 	mov	r7,r3
 80011c0:	e13fdd17 	ldw	r4,-140(fp)
 80011c4:	e17fde17 	ldw	r5,-136(fp)
 80011c8:	8004ad00 	call	8004ad0 <__muldf3>
 80011cc:	1009883a 	mov	r4,r2
 80011d0:	180b883a 	mov	r5,r3
 80011d4:	e13fd215 	stw	r4,-184(fp)
 80011d8:	e17fd315 	stw	r5,-180(fp)
	    if(n<32&&ix!=npio2_hw[n-1]) {	
 80011dc:	e0bfdc17 	ldw	r2,-144(fp)
 80011e0:	10800808 	cmpgei	r2,r2,32
 80011e4:	1000171e 	bne	r2,zero,8001244 <__ieee754_rem_pio2+0x628>
 80011e8:	e0bfdc17 	ldw	r2,-144(fp)
 80011ec:	10ffffc4 	addi	r3,r2,-1
 80011f0:	00820134 	movhi	r2,2052
 80011f4:	1098f504 	addi	r2,r2,25556
 80011f8:	18c7883a 	add	r3,r3,r3
 80011fc:	18c7883a 	add	r3,r3,r3
 8001200:	10c5883a 	add	r2,r2,r3
 8001204:	10c00017 	ldw	r3,0(r2)
 8001208:	e0bfd917 	ldw	r2,-156(fp)
 800120c:	18800d26 	beq	r3,r2,8001244 <__ieee754_rem_pio2+0x628>
		y[0] = r-w;	/* quick check no cancellation */
 8001210:	e1bfd217 	ldw	r6,-184(fp)
 8001214:	e1ffd317 	ldw	r7,-180(fp)
 8001218:	e13fd417 	ldw	r4,-176(fp)
 800121c:	e17fd517 	ldw	r5,-172(fp)
 8001220:	80051e80 	call	80051e8 <__subdf3>
 8001224:	1009883a 	mov	r4,r2
 8001228:	180b883a 	mov	r5,r3
 800122c:	2005883a 	mov	r2,r4
 8001230:	2807883a 	mov	r3,r5
 8001234:	e13ff717 	ldw	r4,-36(fp)
 8001238:	20800015 	stw	r2,0(r4)
 800123c:	20c00115 	stw	r3,4(r4)
 8001240:	0000c906 	br	8001568 <__ieee754_rem_pio2+0x94c>
	    } else {
	        __uint32_t high;
	        j  = ix>>20;
 8001244:	e0bfd917 	ldw	r2,-156(fp)
 8001248:	1005d53a 	srai	r2,r2,20
 800124c:	e0bfdf15 	stw	r2,-132(fp)
	        y[0] = r-w; 
 8001250:	e1bfd217 	ldw	r6,-184(fp)
 8001254:	e1ffd317 	ldw	r7,-180(fp)
 8001258:	e13fd417 	ldw	r4,-176(fp)
 800125c:	e17fd517 	ldw	r5,-172(fp)
 8001260:	80051e80 	call	80051e8 <__subdf3>
 8001264:	1009883a 	mov	r4,r2
 8001268:	180b883a 	mov	r5,r3
 800126c:	2005883a 	mov	r2,r4
 8001270:	2807883a 	mov	r3,r5
 8001274:	e13ff717 	ldw	r4,-36(fp)
 8001278:	20800015 	stw	r2,0(r4)
 800127c:	20c00115 	stw	r3,4(r4)
		GET_HIGH_WORD(high,y[0]);
 8001280:	e13ff717 	ldw	r4,-36(fp)
 8001284:	20800017 	ldw	r2,0(r4)
 8001288:	20c00117 	ldw	r3,4(r4)
 800128c:	e0bfeb15 	stw	r2,-84(fp)
 8001290:	e0ffec15 	stw	r3,-80(fp)
 8001294:	e0bfec17 	ldw	r2,-80(fp)
 8001298:	e0bfe015 	stw	r2,-128(fp)
	        i = j-((high>>20)&0x7ff);
 800129c:	e0ffdf17 	ldw	r3,-132(fp)
 80012a0:	e0bfe017 	ldw	r2,-128(fp)
 80012a4:	1004d53a 	srli	r2,r2,20
 80012a8:	1081ffcc 	andi	r2,r2,2047
 80012ac:	1885c83a 	sub	r2,r3,r2
 80012b0:	e0bfd615 	stw	r2,-168(fp)
	        if(i>16) {  /* 2nd iteration needed, good to 118 */
 80012b4:	e0bfd617 	ldw	r2,-168(fp)
 80012b8:	10800450 	cmplti	r2,r2,17
 80012bc:	1000aa1e 	bne	r2,zero,8001568 <__ieee754_rem_pio2+0x94c>
		    t  = r;
 80012c0:	e0bfd417 	ldw	r2,-176(fp)
 80012c4:	e0bfda15 	stw	r2,-152(fp)
 80012c8:	e0bfd517 	ldw	r2,-172(fp)
 80012cc:	e0bfdb15 	stw	r2,-148(fp)
		    w  = fn*pio2_2;	
 80012d0:	00869834 	movhi	r2,6752
 80012d4:	00cf7474 	movhi	r3,15825
 80012d8:	18ed1844 	addi	r3,r3,-19359
 80012dc:	100d883a 	mov	r6,r2
 80012e0:	180f883a 	mov	r7,r3
 80012e4:	e13fdd17 	ldw	r4,-140(fp)
 80012e8:	e17fde17 	ldw	r5,-136(fp)
 80012ec:	8004ad00 	call	8004ad0 <__muldf3>
 80012f0:	1009883a 	mov	r4,r2
 80012f4:	180b883a 	mov	r5,r3
 80012f8:	e13fd215 	stw	r4,-184(fp)
 80012fc:	e17fd315 	stw	r5,-180(fp)
		    r  = t-w;
 8001300:	e1bfd217 	ldw	r6,-184(fp)
 8001304:	e1ffd317 	ldw	r7,-180(fp)
 8001308:	e13fda17 	ldw	r4,-152(fp)
 800130c:	e17fdb17 	ldw	r5,-148(fp)
 8001310:	80051e80 	call	80051e8 <__subdf3>
 8001314:	1009883a 	mov	r4,r2
 8001318:	180b883a 	mov	r5,r3
 800131c:	e13fd415 	stw	r4,-176(fp)
 8001320:	e17fd515 	stw	r5,-172(fp)
		    w  = fn*pio2_2t-((t-r)-w);	
 8001324:	008b80f4 	movhi	r2,11779
 8001328:	109c1cc4 	addi	r2,r2,28787
 800132c:	00cee8f4 	movhi	r3,15267
 8001330:	18c66284 	addi	r3,r3,6538
 8001334:	e1bfdd17 	ldw	r6,-140(fp)
 8001338:	e1ffde17 	ldw	r7,-136(fp)
 800133c:	1009883a 	mov	r4,r2
 8001340:	180b883a 	mov	r5,r3
 8001344:	8004ad00 	call	8004ad0 <__muldf3>
 8001348:	1009883a 	mov	r4,r2
 800134c:	180b883a 	mov	r5,r3
 8001350:	2021883a 	mov	r16,r4
 8001354:	2823883a 	mov	r17,r5
 8001358:	e1bfd417 	ldw	r6,-176(fp)
 800135c:	e1ffd517 	ldw	r7,-172(fp)
 8001360:	e13fda17 	ldw	r4,-152(fp)
 8001364:	e17fdb17 	ldw	r5,-148(fp)
 8001368:	80051e80 	call	80051e8 <__subdf3>
 800136c:	1009883a 	mov	r4,r2
 8001370:	180b883a 	mov	r5,r3
 8001374:	2005883a 	mov	r2,r4
 8001378:	2807883a 	mov	r3,r5
 800137c:	e1bfd217 	ldw	r6,-184(fp)
 8001380:	e1ffd317 	ldw	r7,-180(fp)
 8001384:	1009883a 	mov	r4,r2
 8001388:	180b883a 	mov	r5,r3
 800138c:	80051e80 	call	80051e8 <__subdf3>
 8001390:	1009883a 	mov	r4,r2
 8001394:	180b883a 	mov	r5,r3
 8001398:	2005883a 	mov	r2,r4
 800139c:	2807883a 	mov	r3,r5
 80013a0:	100d883a 	mov	r6,r2
 80013a4:	180f883a 	mov	r7,r3
 80013a8:	8009883a 	mov	r4,r16
 80013ac:	880b883a 	mov	r5,r17
 80013b0:	80051e80 	call	80051e8 <__subdf3>
 80013b4:	1009883a 	mov	r4,r2
 80013b8:	180b883a 	mov	r5,r3
 80013bc:	e13fd215 	stw	r4,-184(fp)
 80013c0:	e17fd315 	stw	r5,-180(fp)
		    y[0] = r-w;
 80013c4:	e1bfd217 	ldw	r6,-184(fp)
 80013c8:	e1ffd317 	ldw	r7,-180(fp)
 80013cc:	e13fd417 	ldw	r4,-176(fp)
 80013d0:	e17fd517 	ldw	r5,-172(fp)
 80013d4:	80051e80 	call	80051e8 <__subdf3>
 80013d8:	1009883a 	mov	r4,r2
 80013dc:	180b883a 	mov	r5,r3
 80013e0:	2005883a 	mov	r2,r4
 80013e4:	2807883a 	mov	r3,r5
 80013e8:	e13ff717 	ldw	r4,-36(fp)
 80013ec:	20800015 	stw	r2,0(r4)
 80013f0:	20c00115 	stw	r3,4(r4)
		    GET_HIGH_WORD(high,y[0]);
 80013f4:	e13ff717 	ldw	r4,-36(fp)
 80013f8:	20800017 	ldw	r2,0(r4)
 80013fc:	20c00117 	ldw	r3,4(r4)
 8001400:	e0bfed15 	stw	r2,-76(fp)
 8001404:	e0ffee15 	stw	r3,-72(fp)
 8001408:	e0bfee17 	ldw	r2,-72(fp)
 800140c:	e0bfe015 	stw	r2,-128(fp)
		    i = j-((high>>20)&0x7ff);
 8001410:	e0ffdf17 	ldw	r3,-132(fp)
 8001414:	e0bfe017 	ldw	r2,-128(fp)
 8001418:	1004d53a 	srli	r2,r2,20
 800141c:	1081ffcc 	andi	r2,r2,2047
 8001420:	1885c83a 	sub	r2,r3,r2
 8001424:	e0bfd615 	stw	r2,-168(fp)
		    if(i>49)  {	/* 3rd iteration need, 151 bits acc */
 8001428:	e0bfd617 	ldw	r2,-168(fp)
 800142c:	10800c90 	cmplti	r2,r2,50
 8001430:	10004d1e 	bne	r2,zero,8001568 <__ieee754_rem_pio2+0x94c>
		    	t  = r;	/* will cover all possible cases */
 8001434:	e0bfd417 	ldw	r2,-176(fp)
 8001438:	e0bfda15 	stw	r2,-152(fp)
 800143c:	e0bfd517 	ldw	r2,-172(fp)
 8001440:	e0bfdb15 	stw	r2,-148(fp)
		    	w  = fn*pio2_3;	
 8001444:	008b8034 	movhi	r2,11776
 8001448:	00cee8f4 	movhi	r3,15267
 800144c:	18c66284 	addi	r3,r3,6538
 8001450:	100d883a 	mov	r6,r2
 8001454:	180f883a 	mov	r7,r3
 8001458:	e13fdd17 	ldw	r4,-140(fp)
 800145c:	e17fde17 	ldw	r5,-136(fp)
 8001460:	8004ad00 	call	8004ad0 <__muldf3>
 8001464:	1009883a 	mov	r4,r2
 8001468:	180b883a 	mov	r5,r3
 800146c:	e13fd215 	stw	r4,-184(fp)
 8001470:	e17fd315 	stw	r5,-180(fp)
		    	r  = t-w;
 8001474:	e1bfd217 	ldw	r6,-184(fp)
 8001478:	e1ffd317 	ldw	r7,-180(fp)
 800147c:	e13fda17 	ldw	r4,-152(fp)
 8001480:	e17fdb17 	ldw	r5,-148(fp)
 8001484:	80051e80 	call	80051e8 <__subdf3>
 8001488:	1009883a 	mov	r4,r2
 800148c:	180b883a 	mov	r5,r3
 8001490:	e13fd415 	stw	r4,-176(fp)
 8001494:	e17fd515 	stw	r5,-172(fp)
		    	w  = fn*pio2_3t-((t-r)-w);	
 8001498:	00894834 	movhi	r2,9504
 800149c:	10927044 	addi	r2,r2,18881
 80014a0:	00ce5f34 	movhi	r3,14716
 80014a4:	18e0e684 	addi	r3,r3,-31846
 80014a8:	e1bfdd17 	ldw	r6,-140(fp)
 80014ac:	e1ffde17 	ldw	r7,-136(fp)
 80014b0:	1009883a 	mov	r4,r2
 80014b4:	180b883a 	mov	r5,r3
 80014b8:	8004ad00 	call	8004ad0 <__muldf3>
 80014bc:	1009883a 	mov	r4,r2
 80014c0:	180b883a 	mov	r5,r3
 80014c4:	2021883a 	mov	r16,r4
 80014c8:	2823883a 	mov	r17,r5
 80014cc:	e1bfd417 	ldw	r6,-176(fp)
 80014d0:	e1ffd517 	ldw	r7,-172(fp)
 80014d4:	e13fda17 	ldw	r4,-152(fp)
 80014d8:	e17fdb17 	ldw	r5,-148(fp)
 80014dc:	80051e80 	call	80051e8 <__subdf3>
 80014e0:	1009883a 	mov	r4,r2
 80014e4:	180b883a 	mov	r5,r3
 80014e8:	2005883a 	mov	r2,r4
 80014ec:	2807883a 	mov	r3,r5
 80014f0:	e1bfd217 	ldw	r6,-184(fp)
 80014f4:	e1ffd317 	ldw	r7,-180(fp)
 80014f8:	1009883a 	mov	r4,r2
 80014fc:	180b883a 	mov	r5,r3
 8001500:	80051e80 	call	80051e8 <__subdf3>
 8001504:	1009883a 	mov	r4,r2
 8001508:	180b883a 	mov	r5,r3
 800150c:	2005883a 	mov	r2,r4
 8001510:	2807883a 	mov	r3,r5
 8001514:	100d883a 	mov	r6,r2
 8001518:	180f883a 	mov	r7,r3
 800151c:	8009883a 	mov	r4,r16
 8001520:	880b883a 	mov	r5,r17
 8001524:	80051e80 	call	80051e8 <__subdf3>
 8001528:	1009883a 	mov	r4,r2
 800152c:	180b883a 	mov	r5,r3
 8001530:	e13fd215 	stw	r4,-184(fp)
 8001534:	e17fd315 	stw	r5,-180(fp)
		    	y[0] = r-w;
 8001538:	e1bfd217 	ldw	r6,-184(fp)
 800153c:	e1ffd317 	ldw	r7,-180(fp)
 8001540:	e13fd417 	ldw	r4,-176(fp)
 8001544:	e17fd517 	ldw	r5,-172(fp)
 8001548:	80051e80 	call	80051e8 <__subdf3>
 800154c:	1009883a 	mov	r4,r2
 8001550:	180b883a 	mov	r5,r3
 8001554:	2005883a 	mov	r2,r4
 8001558:	2807883a 	mov	r3,r5
 800155c:	e13ff717 	ldw	r4,-36(fp)
 8001560:	20800015 	stw	r2,0(r4)
 8001564:	20c00115 	stw	r3,4(r4)
		    }
		}
	    }
	    y[1] = (r-y[0])-w;
 8001568:	e0bff717 	ldw	r2,-36(fp)
 800156c:	14000204 	addi	r16,r2,8
 8001570:	e13ff717 	ldw	r4,-36(fp)
 8001574:	20800017 	ldw	r2,0(r4)
 8001578:	20c00117 	ldw	r3,4(r4)
 800157c:	100d883a 	mov	r6,r2
 8001580:	180f883a 	mov	r7,r3
 8001584:	e13fd417 	ldw	r4,-176(fp)
 8001588:	e17fd517 	ldw	r5,-172(fp)
 800158c:	80051e80 	call	80051e8 <__subdf3>
 8001590:	1009883a 	mov	r4,r2
 8001594:	180b883a 	mov	r5,r3
 8001598:	2005883a 	mov	r2,r4
 800159c:	2807883a 	mov	r3,r5
 80015a0:	e1bfd217 	ldw	r6,-184(fp)
 80015a4:	e1ffd317 	ldw	r7,-180(fp)
 80015a8:	1009883a 	mov	r4,r2
 80015ac:	180b883a 	mov	r5,r3
 80015b0:	80051e80 	call	80051e8 <__subdf3>
 80015b4:	1009883a 	mov	r4,r2
 80015b8:	180b883a 	mov	r5,r3
 80015bc:	2005883a 	mov	r2,r4
 80015c0:	2807883a 	mov	r3,r5
 80015c4:	80800015 	stw	r2,0(r16)
 80015c8:	80c00115 	stw	r3,4(r16)
	    if(hx<0) 	{y[0] = -y[0]; y[1] = -y[1]; return -n;}
 80015cc:	e0bfd817 	ldw	r2,-160(fp)
 80015d0:	1000150e 	bge	r2,zero,8001628 <__ieee754_rem_pio2+0xa0c>
 80015d4:	e13ff717 	ldw	r4,-36(fp)
 80015d8:	20800017 	ldw	r2,0(r4)
 80015dc:	20c00117 	ldw	r3,4(r4)
 80015e0:	102d883a 	mov	r22,r2
 80015e4:	1de0003c 	xorhi	r23,r3,32768
 80015e8:	e0bff717 	ldw	r2,-36(fp)
 80015ec:	15800015 	stw	r22,0(r2)
 80015f0:	15c00115 	stw	r23,4(r2)
 80015f4:	e0bff717 	ldw	r2,-36(fp)
 80015f8:	11000204 	addi	r4,r2,8
 80015fc:	e0bff717 	ldw	r2,-36(fp)
 8001600:	11400204 	addi	r5,r2,8
 8001604:	28800017 	ldw	r2,0(r5)
 8001608:	28c00117 	ldw	r3,4(r5)
 800160c:	1029883a 	mov	r20,r2
 8001610:	1d60003c 	xorhi	r21,r3,32768
 8001614:	25000015 	stw	r20,0(r4)
 8001618:	25400115 	stw	r21,4(r4)
 800161c:	e0bfdc17 	ldw	r2,-144(fp)
 8001620:	0085c83a 	sub	r2,zero,r2
 8001624:	0000a906 	br	80018cc <__ieee754_rem_pio2+0xcb0>
	    else	 return n;
 8001628:	e0bfdc17 	ldw	r2,-144(fp)
 800162c:	0000a706 	br	80018cc <__ieee754_rem_pio2+0xcb0>
	}
    /* 
     * all other (large) arguments
     */
	if(ix>=0x7ff00000) {		/* x is inf or NaN */
 8001630:	e0ffd917 	ldw	r3,-156(fp)
 8001634:	009ffc34 	movhi	r2,32752
 8001638:	18801416 	blt	r3,r2,800168c <__ieee754_rem_pio2+0xa70>
	    y[0]=y[1]=x-x; return 0;
 800163c:	e0bff717 	ldw	r2,-36(fp)
 8001640:	14000204 	addi	r16,r2,8
 8001644:	e1bff517 	ldw	r6,-44(fp)
 8001648:	e1fff617 	ldw	r7,-40(fp)
 800164c:	e13ff517 	ldw	r4,-44(fp)
 8001650:	e17ff617 	ldw	r5,-40(fp)
 8001654:	80051e80 	call	80051e8 <__subdf3>
 8001658:	1009883a 	mov	r4,r2
 800165c:	180b883a 	mov	r5,r3
 8001660:	2005883a 	mov	r2,r4
 8001664:	2807883a 	mov	r3,r5
 8001668:	80800015 	stw	r2,0(r16)
 800166c:	80c00115 	stw	r3,4(r16)
 8001670:	80800017 	ldw	r2,0(r16)
 8001674:	80c00117 	ldw	r3,4(r16)
 8001678:	e13ff717 	ldw	r4,-36(fp)
 800167c:	20800015 	stw	r2,0(r4)
 8001680:	20c00115 	stw	r3,4(r4)
 8001684:	0005883a 	mov	r2,zero
 8001688:	00009006 	br	80018cc <__ieee754_rem_pio2+0xcb0>
	}
    /* set z = scalbn(|x|,ilogb(x)-23) */
	GET_LOW_WORD(low,x);
 800168c:	e0bff517 	ldw	r2,-44(fp)
 8001690:	e0bfef15 	stw	r2,-68(fp)
 8001694:	e0bff617 	ldw	r2,-40(fp)
 8001698:	e0bff015 	stw	r2,-64(fp)
 800169c:	e0bfef17 	ldw	r2,-68(fp)
 80016a0:	e0bfe115 	stw	r2,-124(fp)
	SET_LOW_WORD(z,low);
 80016a4:	e0bfd017 	ldw	r2,-192(fp)
 80016a8:	e0bff115 	stw	r2,-60(fp)
 80016ac:	e0bfd117 	ldw	r2,-188(fp)
 80016b0:	e0bff215 	stw	r2,-56(fp)
 80016b4:	e0bfe117 	ldw	r2,-124(fp)
 80016b8:	e0bff115 	stw	r2,-60(fp)
 80016bc:	e0bff117 	ldw	r2,-60(fp)
 80016c0:	e0bfd015 	stw	r2,-192(fp)
 80016c4:	e0bff217 	ldw	r2,-56(fp)
 80016c8:	e0bfd115 	stw	r2,-188(fp)
	e0 	= (int)((ix>>20)-1046);	/* e0 = ilogb(z)-23; */
 80016cc:	e0bfd917 	ldw	r2,-156(fp)
 80016d0:	1005d53a 	srai	r2,r2,20
 80016d4:	10befa84 	addi	r2,r2,-1046
 80016d8:	e0bfe215 	stw	r2,-120(fp)
	SET_HIGH_WORD(z, ix - ((__int32_t)e0<<20));
 80016dc:	e0bfd017 	ldw	r2,-192(fp)
 80016e0:	e0bff315 	stw	r2,-52(fp)
 80016e4:	e0bfd117 	ldw	r2,-188(fp)
 80016e8:	e0bff415 	stw	r2,-48(fp)
 80016ec:	e0bfe217 	ldw	r2,-120(fp)
 80016f0:	1004953a 	slli	r2,r2,20
 80016f4:	e0ffd917 	ldw	r3,-156(fp)
 80016f8:	1885c83a 	sub	r2,r3,r2
 80016fc:	e0bff415 	stw	r2,-48(fp)
 8001700:	e0bff317 	ldw	r2,-52(fp)
 8001704:	e0bfd015 	stw	r2,-192(fp)
 8001708:	e0bff417 	ldw	r2,-48(fp)
 800170c:	e0bfd115 	stw	r2,-188(fp)
	for(i=0;i<2;i++) {
 8001710:	e03fd615 	stw	zero,-168(fp)
 8001714:	00002c06 	br	80017c8 <__ieee754_rem_pio2+0xbac>
		tx[i] = (double)((__int32_t)(z));
 8001718:	e13fd017 	ldw	r4,-192(fp)
 800171c:	e17fd117 	ldw	r5,-188(fp)
 8001720:	8005ae40 	call	8005ae4 <__fixdfsi>
 8001724:	1009883a 	mov	r4,r2
 8001728:	8005b640 	call	8005b64 <__floatsidf>
 800172c:	1009883a 	mov	r4,r2
 8001730:	180b883a 	mov	r5,r3
 8001734:	e0bfd617 	ldw	r2,-168(fp)
 8001738:	100490fa 	slli	r2,r2,3
 800173c:	e0ffd004 	addi	r3,fp,-192
 8001740:	1885883a 	add	r2,r3,r2
 8001744:	10801304 	addi	r2,r2,76
 8001748:	11000015 	stw	r4,0(r2)
 800174c:	11400115 	stw	r5,4(r2)
		z     = (z-tx[i])*two24;
 8001750:	e0bfd617 	ldw	r2,-168(fp)
 8001754:	100490fa 	slli	r2,r2,3
 8001758:	e0ffd004 	addi	r3,fp,-192
 800175c:	1885883a 	add	r2,r3,r2
 8001760:	11001304 	addi	r4,r2,76
 8001764:	20800017 	ldw	r2,0(r4)
 8001768:	20c00117 	ldw	r3,4(r4)
 800176c:	100d883a 	mov	r6,r2
 8001770:	180f883a 	mov	r7,r3
 8001774:	e13fd017 	ldw	r4,-192(fp)
 8001778:	e17fd117 	ldw	r5,-188(fp)
 800177c:	80051e80 	call	80051e8 <__subdf3>
 8001780:	1009883a 	mov	r4,r2
 8001784:	180b883a 	mov	r5,r3
 8001788:	2011883a 	mov	r8,r4
 800178c:	2813883a 	mov	r9,r5
 8001790:	0005883a 	mov	r2,zero
 8001794:	00d05c34 	movhi	r3,16752
 8001798:	100d883a 	mov	r6,r2
 800179c:	180f883a 	mov	r7,r3
 80017a0:	4009883a 	mov	r4,r8
 80017a4:	480b883a 	mov	r5,r9
 80017a8:	8004ad00 	call	8004ad0 <__muldf3>
 80017ac:	1009883a 	mov	r4,r2
 80017b0:	180b883a 	mov	r5,r3
 80017b4:	e13fd015 	stw	r4,-192(fp)
 80017b8:	e17fd115 	stw	r5,-188(fp)
    /* set z = scalbn(|x|,ilogb(x)-23) */
	GET_LOW_WORD(low,x);
	SET_LOW_WORD(z,low);
	e0 	= (int)((ix>>20)-1046);	/* e0 = ilogb(z)-23; */
	SET_HIGH_WORD(z, ix - ((__int32_t)e0<<20));
	for(i=0;i<2;i++) {
 80017bc:	e0bfd617 	ldw	r2,-168(fp)
 80017c0:	10800044 	addi	r2,r2,1
 80017c4:	e0bfd615 	stw	r2,-168(fp)
 80017c8:	e0bfd617 	ldw	r2,-168(fp)
 80017cc:	10800090 	cmplti	r2,r2,2
 80017d0:	103fd11e 	bne	r2,zero,8001718 <__ieee754_rem_pio2+0xafc>
		tx[i] = (double)((__int32_t)(z));
		z     = (z-tx[i])*two24;
	}
	tx[2] = z;
 80017d4:	e0bfd017 	ldw	r2,-192(fp)
 80017d8:	e0bfe715 	stw	r2,-100(fp)
 80017dc:	e0bfd117 	ldw	r2,-188(fp)
 80017e0:	e0bfe815 	stw	r2,-96(fp)
	nx = 3;
 80017e4:	008000c4 	movi	r2,3
 80017e8:	e0bfd715 	stw	r2,-164(fp)
	while(tx[nx-1]==zero) nx--;	/* skip zero term */
 80017ec:	00000306 	br	80017fc <__ieee754_rem_pio2+0xbe0>
 80017f0:	e0bfd717 	ldw	r2,-164(fp)
 80017f4:	10bfffc4 	addi	r2,r2,-1
 80017f8:	e0bfd715 	stw	r2,-164(fp)
 80017fc:	e0bfd717 	ldw	r2,-164(fp)
 8001800:	10bfffc4 	addi	r2,r2,-1
 8001804:	100490fa 	slli	r2,r2,3
 8001808:	e0ffd004 	addi	r3,fp,-192
 800180c:	1885883a 	add	r2,r3,r2
 8001810:	11001304 	addi	r4,r2,76
 8001814:	20800017 	ldw	r2,0(r4)
 8001818:	20c00117 	ldw	r3,4(r4)
 800181c:	0009883a 	mov	r4,zero
 8001820:	000b883a 	mov	r5,zero
 8001824:	200d883a 	mov	r6,r4
 8001828:	280f883a 	mov	r7,r5
 800182c:	1009883a 	mov	r4,r2
 8001830:	180b883a 	mov	r5,r3
 8001834:	800496c0 	call	800496c <__eqdf2>
 8001838:	103fed26 	beq	r2,zero,80017f0 <__ieee754_rem_pio2+0xbd4>
	n  =  __kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);
 800183c:	e0ffe304 	addi	r3,fp,-116
 8001840:	00820134 	movhi	r2,2052
 8001844:	1098b304 	addi	r2,r2,25292
 8001848:	d8800115 	stw	r2,4(sp)
 800184c:	00800084 	movi	r2,2
 8001850:	d8800015 	stw	r2,0(sp)
 8001854:	e1ffd717 	ldw	r7,-164(fp)
 8001858:	e1bfe217 	ldw	r6,-120(fp)
 800185c:	e17ff717 	ldw	r5,-36(fp)
 8001860:	1809883a 	mov	r4,r3
 8001864:	8001e340 	call	8001e34 <__kernel_rem_pio2>
 8001868:	e0bfdc15 	stw	r2,-144(fp)
	if(hx<0) {y[0] = -y[0]; y[1] = -y[1]; return -n;}
 800186c:	e0bfd817 	ldw	r2,-160(fp)
 8001870:	1000150e 	bge	r2,zero,80018c8 <__ieee754_rem_pio2+0xcac>
 8001874:	e13ff717 	ldw	r4,-36(fp)
 8001878:	20800017 	ldw	r2,0(r4)
 800187c:	20c00117 	ldw	r3,4(r4)
 8001880:	1025883a 	mov	r18,r2
 8001884:	1ce0003c 	xorhi	r19,r3,32768
 8001888:	e0bff717 	ldw	r2,-36(fp)
 800188c:	14800015 	stw	r18,0(r2)
 8001890:	14c00115 	stw	r19,4(r2)
 8001894:	e0bff717 	ldw	r2,-36(fp)
 8001898:	11000204 	addi	r4,r2,8
 800189c:	e0bff717 	ldw	r2,-36(fp)
 80018a0:	11400204 	addi	r5,r2,8
 80018a4:	28800017 	ldw	r2,0(r5)
 80018a8:	28c00117 	ldw	r3,4(r5)
 80018ac:	1021883a 	mov	r16,r2
 80018b0:	1c60003c 	xorhi	r17,r3,32768
 80018b4:	24000015 	stw	r16,0(r4)
 80018b8:	24400115 	stw	r17,4(r4)
 80018bc:	e0bfdc17 	ldw	r2,-144(fp)
 80018c0:	0085c83a 	sub	r2,zero,r2
 80018c4:	00000106 	br	80018cc <__ieee754_rem_pio2+0xcb0>
	return n;
 80018c8:	e0bfdc17 	ldw	r2,-144(fp)
}
 80018cc:	e6fff804 	addi	sp,fp,-32
 80018d0:	dfc00917 	ldw	ra,36(sp)
 80018d4:	df000817 	ldw	fp,32(sp)
 80018d8:	ddc00717 	ldw	r23,28(sp)
 80018dc:	dd800617 	ldw	r22,24(sp)
 80018e0:	dd400517 	ldw	r21,20(sp)
 80018e4:	dd000417 	ldw	r20,16(sp)
 80018e8:	dcc00317 	ldw	r19,12(sp)
 80018ec:	dc800217 	ldw	r18,8(sp)
 80018f0:	dc400117 	ldw	r17,4(sp)
 80018f4:	dc000017 	ldw	r16,0(sp)
 80018f8:	dec00a04 	addi	sp,sp,40
 80018fc:	f800283a 	ret

08001900 <__kernel_cos>:
	double __kernel_cos(double x, double y)
#else
	double __kernel_cos(x, y)
	double x,y;
#endif
{
 8001900:	deffe504 	addi	sp,sp,-108
 8001904:	dfc01a15 	stw	ra,104(sp)
 8001908:	df001915 	stw	fp,100(sp)
 800190c:	dd401815 	stw	r21,96(sp)
 8001910:	dd001715 	stw	r20,92(sp)
 8001914:	dcc01615 	stw	r19,88(sp)
 8001918:	dc801515 	stw	r18,84(sp)
 800191c:	dc401415 	stw	r17,80(sp)
 8001920:	dc001315 	stw	r16,76(sp)
 8001924:	df001904 	addi	fp,sp,100
 8001928:	e13ff615 	stw	r4,-40(fp)
 800192c:	e17ff715 	stw	r5,-36(fp)
 8001930:	e1bff815 	stw	r6,-32(fp)
 8001934:	e1fff915 	stw	r7,-28(fp)
	double a,hz,z,r,qx;
	__int32_t ix;
	GET_HIGH_WORD(ix,x);
 8001938:	e0bff617 	ldw	r2,-40(fp)
 800193c:	e0bff215 	stw	r2,-56(fp)
 8001940:	e0bff717 	ldw	r2,-36(fp)
 8001944:	e0bff315 	stw	r2,-52(fp)
 8001948:	e0bff317 	ldw	r2,-52(fp)
 800194c:	e0bfe915 	stw	r2,-92(fp)
	ix &= 0x7fffffff;			/* ix = |x|'s high word*/
 8001950:	e0ffe917 	ldw	r3,-92(fp)
 8001954:	00a00034 	movhi	r2,32768
 8001958:	10bfffc4 	addi	r2,r2,-1
 800195c:	1884703a 	and	r2,r3,r2
 8001960:	e0bfe915 	stw	r2,-92(fp)
	if(ix<0x3e400000) {			/* if x < 2**27 */
 8001964:	e0ffe917 	ldw	r3,-92(fp)
 8001968:	008f9034 	movhi	r2,15936
 800196c:	1880070e 	bge	r3,r2,800198c <__kernel_cos+0x8c>
	    if(((int)x)==0) return one;		/* generate inexact */
 8001970:	e13ff617 	ldw	r4,-40(fp)
 8001974:	e17ff717 	ldw	r5,-36(fp)
 8001978:	8005ae40 	call	8005ae4 <__fixdfsi>
 800197c:	1000031e 	bne	r2,zero,800198c <__kernel_cos+0x8c>
 8001980:	0005883a 	mov	r2,zero
 8001984:	00cffc34 	movhi	r3,16368
 8001988:	00011b06 	br	8001df8 <__kernel_cos+0x4f8>
	}
	z  = x*x;
 800198c:	e1bff617 	ldw	r6,-40(fp)
 8001990:	e1fff717 	ldw	r7,-36(fp)
 8001994:	e13ff617 	ldw	r4,-40(fp)
 8001998:	e17ff717 	ldw	r5,-36(fp)
 800199c:	8004ad00 	call	8004ad0 <__muldf3>
 80019a0:	1009883a 	mov	r4,r2
 80019a4:	180b883a 	mov	r5,r3
 80019a8:	e13fea15 	stw	r4,-88(fp)
 80019ac:	e17feb15 	stw	r5,-84(fp)
	r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
 80019b0:	00afa234 	movhi	r2,48776
 80019b4:	108e3504 	addi	r2,r2,14548
 80019b8:	00ef6a74 	movhi	r3,48553
 80019bc:	18feba44 	addi	r3,r3,-1303
 80019c0:	e1bfea17 	ldw	r6,-88(fp)
 80019c4:	e1ffeb17 	ldw	r7,-84(fp)
 80019c8:	1009883a 	mov	r4,r2
 80019cc:	180b883a 	mov	r5,r3
 80019d0:	8004ad00 	call	8004ad0 <__muldf3>
 80019d4:	1009883a 	mov	r4,r2
 80019d8:	180b883a 	mov	r5,r3
 80019dc:	2011883a 	mov	r8,r4
 80019e0:	2813883a 	mov	r9,r5
 80019e4:	00af6d74 	movhi	r2,48565
 80019e8:	10ac7104 	addi	r2,r2,-20028
 80019ec:	00cf88b4 	movhi	r3,15906
 80019f0:	18fba784 	addi	r3,r3,-4450
 80019f4:	100d883a 	mov	r6,r2
 80019f8:	180f883a 	mov	r7,r3
 80019fc:	4009883a 	mov	r4,r8
 8001a00:	480b883a 	mov	r5,r9
 8001a04:	80040c00 	call	80040c0 <__adddf3>
 8001a08:	1009883a 	mov	r4,r2
 8001a0c:	180b883a 	mov	r5,r3
 8001a10:	2005883a 	mov	r2,r4
 8001a14:	2807883a 	mov	r3,r5
 8001a18:	e1bfea17 	ldw	r6,-88(fp)
 8001a1c:	e1ffeb17 	ldw	r7,-84(fp)
 8001a20:	1009883a 	mov	r4,r2
 8001a24:	180b883a 	mov	r5,r3
 8001a28:	8004ad00 	call	8004ad0 <__muldf3>
 8001a2c:	1009883a 	mov	r4,r2
 8001a30:	180b883a 	mov	r5,r3
 8001a34:	2011883a 	mov	r8,r4
 8001a38:	2813883a 	mov	r9,r5
 8001a3c:	00a02734 	movhi	r2,32924
 8001a40:	1094ab44 	addi	r2,r2,21165
 8001a44:	00efa4b4 	movhi	r3,48786
 8001a48:	18df93c4 	addi	r3,r3,32335
 8001a4c:	100d883a 	mov	r6,r2
 8001a50:	180f883a 	mov	r7,r3
 8001a54:	4009883a 	mov	r4,r8
 8001a58:	480b883a 	mov	r5,r9
 8001a5c:	80040c00 	call	80040c0 <__adddf3>
 8001a60:	1009883a 	mov	r4,r2
 8001a64:	180b883a 	mov	r5,r3
 8001a68:	2005883a 	mov	r2,r4
 8001a6c:	2807883a 	mov	r3,r5
 8001a70:	e1bfea17 	ldw	r6,-88(fp)
 8001a74:	e1ffeb17 	ldw	r7,-84(fp)
 8001a78:	1009883a 	mov	r4,r2
 8001a7c:	180b883a 	mov	r5,r3
 8001a80:	8004ad00 	call	8004ad0 <__muldf3>
 8001a84:	1009883a 	mov	r4,r2
 8001a88:	180b883a 	mov	r5,r3
 8001a8c:	2011883a 	mov	r8,r4
 8001a90:	2813883a 	mov	r9,r5
 8001a94:	008672f4 	movhi	r2,6603
 8001a98:	10856404 	addi	r2,r2,5520
 8001a9c:	00cfbeb4 	movhi	r3,16122
 8001aa0:	18c06804 	addi	r3,r3,416
 8001aa4:	100d883a 	mov	r6,r2
 8001aa8:	180f883a 	mov	r7,r3
 8001aac:	4009883a 	mov	r4,r8
 8001ab0:	480b883a 	mov	r5,r9
 8001ab4:	80040c00 	call	80040c0 <__adddf3>
 8001ab8:	1009883a 	mov	r4,r2
 8001abc:	180b883a 	mov	r5,r3
 8001ac0:	2005883a 	mov	r2,r4
 8001ac4:	2807883a 	mov	r3,r5
 8001ac8:	e1bfea17 	ldw	r6,-88(fp)
 8001acc:	e1ffeb17 	ldw	r7,-84(fp)
 8001ad0:	1009883a 	mov	r4,r2
 8001ad4:	180b883a 	mov	r5,r3
 8001ad8:	8004ad00 	call	8004ad0 <__muldf3>
 8001adc:	1009883a 	mov	r4,r2
 8001ae0:	180b883a 	mov	r5,r3
 8001ae4:	2011883a 	mov	r8,r4
 8001ae8:	2813883a 	mov	r9,r5
 8001aec:	0085b074 	movhi	r2,5825
 8001af0:	10945dc4 	addi	r2,r2,20855
 8001af4:	00efd5f4 	movhi	r3,48983
 8001af8:	18f05b04 	addi	r3,r3,-16020
 8001afc:	100d883a 	mov	r6,r2
 8001b00:	180f883a 	mov	r7,r3
 8001b04:	4009883a 	mov	r4,r8
 8001b08:	480b883a 	mov	r5,r9
 8001b0c:	80040c00 	call	80040c0 <__adddf3>
 8001b10:	1009883a 	mov	r4,r2
 8001b14:	180b883a 	mov	r5,r3
 8001b18:	2005883a 	mov	r2,r4
 8001b1c:	2807883a 	mov	r3,r5
 8001b20:	e1bfea17 	ldw	r6,-88(fp)
 8001b24:	e1ffeb17 	ldw	r7,-84(fp)
 8001b28:	1009883a 	mov	r4,r2
 8001b2c:	180b883a 	mov	r5,r3
 8001b30:	8004ad00 	call	8004ad0 <__muldf3>
 8001b34:	1009883a 	mov	r4,r2
 8001b38:	180b883a 	mov	r5,r3
 8001b3c:	2011883a 	mov	r8,r4
 8001b40:	2813883a 	mov	r9,r5
 8001b44:	00955574 	movhi	r2,21845
 8001b48:	10955304 	addi	r2,r2,21836
 8001b4c:	00cfe974 	movhi	r3,16293
 8001b50:	18d55544 	addi	r3,r3,21845
 8001b54:	100d883a 	mov	r6,r2
 8001b58:	180f883a 	mov	r7,r3
 8001b5c:	4009883a 	mov	r4,r8
 8001b60:	480b883a 	mov	r5,r9
 8001b64:	80040c00 	call	80040c0 <__adddf3>
 8001b68:	1009883a 	mov	r4,r2
 8001b6c:	180b883a 	mov	r5,r3
 8001b70:	2005883a 	mov	r2,r4
 8001b74:	2807883a 	mov	r3,r5
 8001b78:	e1bfea17 	ldw	r6,-88(fp)
 8001b7c:	e1ffeb17 	ldw	r7,-84(fp)
 8001b80:	1009883a 	mov	r4,r2
 8001b84:	180b883a 	mov	r5,r3
 8001b88:	8004ad00 	call	8004ad0 <__muldf3>
 8001b8c:	1009883a 	mov	r4,r2
 8001b90:	180b883a 	mov	r5,r3
 8001b94:	e13fec15 	stw	r4,-80(fp)
 8001b98:	e17fed15 	stw	r5,-76(fp)
	if(ix < 0x3FD33333) 			/* if |x| < 0.3 */ 
 8001b9c:	e0ffe917 	ldw	r3,-92(fp)
 8001ba0:	008ff4f4 	movhi	r2,16339
 8001ba4:	108ccc84 	addi	r2,r2,13106
 8001ba8:	10c03916 	blt	r2,r3,8001c90 <__kernel_cos+0x390>
	    return one - (0.5*z - (z*r - x*y));
 8001bac:	0021883a 	mov	r16,zero
 8001bb0:	044ffc34 	movhi	r17,16368
 8001bb4:	000d883a 	mov	r6,zero
 8001bb8:	01cff834 	movhi	r7,16352
 8001bbc:	e13fea17 	ldw	r4,-88(fp)
 8001bc0:	e17feb17 	ldw	r5,-84(fp)
 8001bc4:	8004ad00 	call	8004ad0 <__muldf3>
 8001bc8:	1009883a 	mov	r4,r2
 8001bcc:	180b883a 	mov	r5,r3
 8001bd0:	2025883a 	mov	r18,r4
 8001bd4:	2827883a 	mov	r19,r5
 8001bd8:	e1bfec17 	ldw	r6,-80(fp)
 8001bdc:	e1ffed17 	ldw	r7,-76(fp)
 8001be0:	e13fea17 	ldw	r4,-88(fp)
 8001be4:	e17feb17 	ldw	r5,-84(fp)
 8001be8:	8004ad00 	call	8004ad0 <__muldf3>
 8001bec:	1009883a 	mov	r4,r2
 8001bf0:	180b883a 	mov	r5,r3
 8001bf4:	2029883a 	mov	r20,r4
 8001bf8:	282b883a 	mov	r21,r5
 8001bfc:	e1bff817 	ldw	r6,-32(fp)
 8001c00:	e1fff917 	ldw	r7,-28(fp)
 8001c04:	e13ff617 	ldw	r4,-40(fp)
 8001c08:	e17ff717 	ldw	r5,-36(fp)
 8001c0c:	8004ad00 	call	8004ad0 <__muldf3>
 8001c10:	1009883a 	mov	r4,r2
 8001c14:	180b883a 	mov	r5,r3
 8001c18:	2005883a 	mov	r2,r4
 8001c1c:	2807883a 	mov	r3,r5
 8001c20:	100d883a 	mov	r6,r2
 8001c24:	180f883a 	mov	r7,r3
 8001c28:	a009883a 	mov	r4,r20
 8001c2c:	a80b883a 	mov	r5,r21
 8001c30:	80051e80 	call	80051e8 <__subdf3>
 8001c34:	1009883a 	mov	r4,r2
 8001c38:	180b883a 	mov	r5,r3
 8001c3c:	2005883a 	mov	r2,r4
 8001c40:	2807883a 	mov	r3,r5
 8001c44:	100d883a 	mov	r6,r2
 8001c48:	180f883a 	mov	r7,r3
 8001c4c:	9009883a 	mov	r4,r18
 8001c50:	980b883a 	mov	r5,r19
 8001c54:	80051e80 	call	80051e8 <__subdf3>
 8001c58:	1009883a 	mov	r4,r2
 8001c5c:	180b883a 	mov	r5,r3
 8001c60:	2005883a 	mov	r2,r4
 8001c64:	2807883a 	mov	r3,r5
 8001c68:	100d883a 	mov	r6,r2
 8001c6c:	180f883a 	mov	r7,r3
 8001c70:	8009883a 	mov	r4,r16
 8001c74:	880b883a 	mov	r5,r17
 8001c78:	80051e80 	call	80051e8 <__subdf3>
 8001c7c:	1009883a 	mov	r4,r2
 8001c80:	180b883a 	mov	r5,r3
 8001c84:	2005883a 	mov	r2,r4
 8001c88:	2807883a 	mov	r3,r5
 8001c8c:	00005a06 	br	8001df8 <__kernel_cos+0x4f8>
	else {
	    if(ix > 0x3fe90000) {		/* x > 0.78125 */
 8001c90:	e0bfe917 	ldw	r2,-92(fp)
 8001c94:	00cffa74 	movhi	r3,16361
 8001c98:	1880040e 	bge	r3,r2,8001cac <__kernel_cos+0x3ac>
		qx = 0.28125;
 8001c9c:	e03fe715 	stw	zero,-100(fp)
 8001ca0:	008ff4b4 	movhi	r2,16338
 8001ca4:	e0bfe815 	stw	r2,-96(fp)
 8001ca8:	00000906 	br	8001cd0 <__kernel_cos+0x3d0>
	    } else {
	        INSERT_WORDS(qx,ix-0x00200000,0);	/* x/4 */
 8001cac:	e0ffe917 	ldw	r3,-92(fp)
 8001cb0:	00bff834 	movhi	r2,65504
 8001cb4:	1885883a 	add	r2,r3,r2
 8001cb8:	e0bff515 	stw	r2,-44(fp)
 8001cbc:	e03ff415 	stw	zero,-48(fp)
 8001cc0:	e0bff417 	ldw	r2,-48(fp)
 8001cc4:	e0bfe715 	stw	r2,-100(fp)
 8001cc8:	e0bff517 	ldw	r2,-44(fp)
 8001ccc:	e0bfe815 	stw	r2,-96(fp)
	    }
	    hz = 0.5*z-qx;
 8001cd0:	000d883a 	mov	r6,zero
 8001cd4:	01cff834 	movhi	r7,16352
 8001cd8:	e13fea17 	ldw	r4,-88(fp)
 8001cdc:	e17feb17 	ldw	r5,-84(fp)
 8001ce0:	8004ad00 	call	8004ad0 <__muldf3>
 8001ce4:	1009883a 	mov	r4,r2
 8001ce8:	180b883a 	mov	r5,r3
 8001cec:	2005883a 	mov	r2,r4
 8001cf0:	2807883a 	mov	r3,r5
 8001cf4:	e1bfe717 	ldw	r6,-100(fp)
 8001cf8:	e1ffe817 	ldw	r7,-96(fp)
 8001cfc:	1009883a 	mov	r4,r2
 8001d00:	180b883a 	mov	r5,r3
 8001d04:	80051e80 	call	80051e8 <__subdf3>
 8001d08:	1009883a 	mov	r4,r2
 8001d0c:	180b883a 	mov	r5,r3
 8001d10:	e13fee15 	stw	r4,-72(fp)
 8001d14:	e17fef15 	stw	r5,-68(fp)
	    a  = one-qx;
 8001d18:	0005883a 	mov	r2,zero
 8001d1c:	00cffc34 	movhi	r3,16368
 8001d20:	e1bfe717 	ldw	r6,-100(fp)
 8001d24:	e1ffe817 	ldw	r7,-96(fp)
 8001d28:	1009883a 	mov	r4,r2
 8001d2c:	180b883a 	mov	r5,r3
 8001d30:	80051e80 	call	80051e8 <__subdf3>
 8001d34:	1009883a 	mov	r4,r2
 8001d38:	180b883a 	mov	r5,r3
 8001d3c:	e13ff015 	stw	r4,-64(fp)
 8001d40:	e17ff115 	stw	r5,-60(fp)
	    return a - (hz - (z*r-x*y));
 8001d44:	e1bfec17 	ldw	r6,-80(fp)
 8001d48:	e1ffed17 	ldw	r7,-76(fp)
 8001d4c:	e13fea17 	ldw	r4,-88(fp)
 8001d50:	e17feb17 	ldw	r5,-84(fp)
 8001d54:	8004ad00 	call	8004ad0 <__muldf3>
 8001d58:	1009883a 	mov	r4,r2
 8001d5c:	180b883a 	mov	r5,r3
 8001d60:	2021883a 	mov	r16,r4
 8001d64:	2823883a 	mov	r17,r5
 8001d68:	e1bff817 	ldw	r6,-32(fp)
 8001d6c:	e1fff917 	ldw	r7,-28(fp)
 8001d70:	e13ff617 	ldw	r4,-40(fp)
 8001d74:	e17ff717 	ldw	r5,-36(fp)
 8001d78:	8004ad00 	call	8004ad0 <__muldf3>
 8001d7c:	1009883a 	mov	r4,r2
 8001d80:	180b883a 	mov	r5,r3
 8001d84:	2005883a 	mov	r2,r4
 8001d88:	2807883a 	mov	r3,r5
 8001d8c:	100d883a 	mov	r6,r2
 8001d90:	180f883a 	mov	r7,r3
 8001d94:	8009883a 	mov	r4,r16
 8001d98:	880b883a 	mov	r5,r17
 8001d9c:	80051e80 	call	80051e8 <__subdf3>
 8001da0:	1009883a 	mov	r4,r2
 8001da4:	180b883a 	mov	r5,r3
 8001da8:	2005883a 	mov	r2,r4
 8001dac:	2807883a 	mov	r3,r5
 8001db0:	100d883a 	mov	r6,r2
 8001db4:	180f883a 	mov	r7,r3
 8001db8:	e13fee17 	ldw	r4,-72(fp)
 8001dbc:	e17fef17 	ldw	r5,-68(fp)
 8001dc0:	80051e80 	call	80051e8 <__subdf3>
 8001dc4:	1009883a 	mov	r4,r2
 8001dc8:	180b883a 	mov	r5,r3
 8001dcc:	2005883a 	mov	r2,r4
 8001dd0:	2807883a 	mov	r3,r5
 8001dd4:	100d883a 	mov	r6,r2
 8001dd8:	180f883a 	mov	r7,r3
 8001ddc:	e13ff017 	ldw	r4,-64(fp)
 8001de0:	e17ff117 	ldw	r5,-60(fp)
 8001de4:	80051e80 	call	80051e8 <__subdf3>
 8001de8:	1009883a 	mov	r4,r2
 8001dec:	180b883a 	mov	r5,r3
 8001df0:	2005883a 	mov	r2,r4
 8001df4:	2807883a 	mov	r3,r5
 8001df8:	1009883a 	mov	r4,r2
 8001dfc:	180b883a 	mov	r5,r3
	}
}
 8001e00:	2005883a 	mov	r2,r4
 8001e04:	2807883a 	mov	r3,r5
 8001e08:	e6fffa04 	addi	sp,fp,-24
 8001e0c:	dfc00717 	ldw	ra,28(sp)
 8001e10:	df000617 	ldw	fp,24(sp)
 8001e14:	dd400517 	ldw	r21,20(sp)
 8001e18:	dd000417 	ldw	r20,16(sp)
 8001e1c:	dcc00317 	ldw	r19,12(sp)
 8001e20:	dc800217 	ldw	r18,8(sp)
 8001e24:	dc400117 	ldw	r17,4(sp)
 8001e28:	dc000017 	ldw	r16,0(sp)
 8001e2c:	dec00804 	addi	sp,sp,32
 8001e30:	f800283a 	ret

08001e34 <__kernel_rem_pio2>:
	int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const __int32_t *ipio2) 
#else
	int __kernel_rem_pio2(x,y,e0,nx,prec,ipio2) 	
	double x[], y[]; int e0,nx,prec; __int32_t ipio2[];
#endif
{
 8001e34:	deff5004 	addi	sp,sp,-704
 8001e38:	dfc0af15 	stw	ra,700(sp)
 8001e3c:	df00ae15 	stw	fp,696(sp)
 8001e40:	ddc0ad15 	stw	r23,692(sp)
 8001e44:	dd80ac15 	stw	r22,688(sp)
 8001e48:	dd40ab15 	stw	r21,684(sp)
 8001e4c:	dd00aa15 	stw	r20,680(sp)
 8001e50:	dcc0a915 	stw	r19,676(sp)
 8001e54:	dc80a815 	stw	r18,672(sp)
 8001e58:	dc40a715 	stw	r17,668(sp)
 8001e5c:	dc00a615 	stw	r16,664(sp)
 8001e60:	df00ae04 	addi	fp,sp,696
 8001e64:	e13fef15 	stw	r4,-68(fp)
 8001e68:	e17ff015 	stw	r5,-64(fp)
 8001e6c:	e1bff115 	stw	r6,-60(fp)
 8001e70:	e1fff215 	stw	r7,-56(fp)
	__int32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
	double z,fw,f[20],fq[20],q[20];

    /* initialize jk*/
	jk = init_jk[prec];
 8001e74:	00820134 	movhi	r2,2052
 8001e78:	10991504 	addi	r2,r2,25684
 8001e7c:	e0c00217 	ldw	r3,8(fp)
 8001e80:	18c7883a 	add	r3,r3,r3
 8001e84:	18c7883a 	add	r3,r3,r3
 8001e88:	10c5883a 	add	r2,r2,r3
 8001e8c:	10800017 	ldw	r2,0(r2)
 8001e90:	e0bf5f15 	stw	r2,-644(fp)
	jp = jk;
 8001e94:	e0bf5f17 	ldw	r2,-644(fp)
 8001e98:	e0bf6015 	stw	r2,-640(fp)

    /* determine jx,jv,q0, note that 3>q0 */
	jx =  nx-1;
 8001e9c:	e0bff217 	ldw	r2,-56(fp)
 8001ea0:	10bfffc4 	addi	r2,r2,-1
 8001ea4:	e0bf6115 	stw	r2,-636(fp)
	jv = (e0-3)/24; if(jv<0) jv=0;
 8001ea8:	e0bff117 	ldw	r2,-60(fp)
 8001eac:	10bfff44 	addi	r2,r2,-3
 8001eb0:	01400604 	movi	r5,24
 8001eb4:	1009883a 	mov	r4,r2
 8001eb8:	8003f0c0 	call	8003f0c <__divsi3>
 8001ebc:	e0bf5315 	stw	r2,-692(fp)
 8001ec0:	e0bf5317 	ldw	r2,-692(fp)
 8001ec4:	1000010e 	bge	r2,zero,8001ecc <__kernel_rem_pio2+0x98>
 8001ec8:	e03f5315 	stw	zero,-692(fp)
	q0 =  e0-24*(jv+1);
 8001ecc:	e0bf5317 	ldw	r2,-692(fp)
 8001ed0:	10800044 	addi	r2,r2,1
 8001ed4:	10fffa24 	muli	r3,r2,-24
 8001ed8:	e0bff117 	ldw	r2,-60(fp)
 8001edc:	1885883a 	add	r2,r3,r2
 8001ee0:	e0bf5915 	stw	r2,-668(fp)

    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
 8001ee4:	e0ff5317 	ldw	r3,-692(fp)
 8001ee8:	e0bf6117 	ldw	r2,-636(fp)
 8001eec:	1885c83a 	sub	r2,r3,r2
 8001ef0:	e0bf5715 	stw	r2,-676(fp)
 8001ef4:	e0ff6117 	ldw	r3,-636(fp)
 8001ef8:	e0bf5f17 	ldw	r2,-644(fp)
 8001efc:	1885883a 	add	r2,r3,r2
 8001f00:	e0bf6215 	stw	r2,-632(fp)
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];
 8001f04:	e03f5615 	stw	zero,-680(fp)
 8001f08:	00001d06 	br	8001f80 <__kernel_rem_pio2+0x14c>
 8001f0c:	e0bf5717 	ldw	r2,-676(fp)
 8001f10:	10000c16 	blt	r2,zero,8001f44 <__kernel_rem_pio2+0x110>
 8001f14:	e0bf5717 	ldw	r2,-676(fp)
 8001f18:	1085883a 	add	r2,r2,r2
 8001f1c:	1085883a 	add	r2,r2,r2
 8001f20:	1007883a 	mov	r3,r2
 8001f24:	e0800317 	ldw	r2,12(fp)
 8001f28:	10c5883a 	add	r2,r2,r3
 8001f2c:	10800017 	ldw	r2,0(r2)
 8001f30:	1009883a 	mov	r4,r2
 8001f34:	8005b640 	call	8005b64 <__floatsidf>
 8001f38:	1009883a 	mov	r4,r2
 8001f3c:	180b883a 	mov	r5,r3
 8001f40:	00000206 	br	8001f4c <__kernel_rem_pio2+0x118>
 8001f44:	0009883a 	mov	r4,zero
 8001f48:	000b883a 	mov	r5,zero
 8001f4c:	e0bf5617 	ldw	r2,-680(fp)
 8001f50:	100490fa 	slli	r2,r2,3
 8001f54:	e0ff5204 	addi	r3,fp,-696
 8001f58:	1885883a 	add	r2,r3,r2
 8001f5c:	10802504 	addi	r2,r2,148
 8001f60:	11000015 	stw	r4,0(r2)
 8001f64:	11400115 	stw	r5,4(r2)
 8001f68:	e0bf5617 	ldw	r2,-680(fp)
 8001f6c:	10800044 	addi	r2,r2,1
 8001f70:	e0bf5615 	stw	r2,-680(fp)
 8001f74:	e0bf5717 	ldw	r2,-676(fp)
 8001f78:	10800044 	addi	r2,r2,1
 8001f7c:	e0bf5715 	stw	r2,-676(fp)
 8001f80:	e0bf5617 	ldw	r2,-680(fp)
 8001f84:	e0ff6217 	ldw	r3,-632(fp)
 8001f88:	18bfe00e 	bge	r3,r2,8001f0c <__kernel_rem_pio2+0xd8>

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
 8001f8c:	e03f5615 	stw	zero,-680(fp)
 8001f90:	00003906 	br	8002078 <__kernel_rem_pio2+0x244>
	    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
 8001f94:	e03f5715 	stw	zero,-676(fp)
 8001f98:	e03f5d15 	stw	zero,-652(fp)
 8001f9c:	e03f5e15 	stw	zero,-648(fp)
 8001fa0:	00002606 	br	800203c <__kernel_rem_pio2+0x208>
 8001fa4:	e0bf5717 	ldw	r2,-676(fp)
 8001fa8:	100490fa 	slli	r2,r2,3
 8001fac:	e0ffef17 	ldw	r3,-68(fp)
 8001fb0:	1889883a 	add	r4,r3,r2
 8001fb4:	20800017 	ldw	r2,0(r4)
 8001fb8:	20c00117 	ldw	r3,4(r4)
 8001fbc:	e17f6117 	ldw	r5,-636(fp)
 8001fc0:	e13f5617 	ldw	r4,-680(fp)
 8001fc4:	290b883a 	add	r5,r5,r4
 8001fc8:	e13f5717 	ldw	r4,-676(fp)
 8001fcc:	2909c83a 	sub	r4,r5,r4
 8001fd0:	200890fa 	slli	r4,r4,3
 8001fd4:	e17f5204 	addi	r5,fp,-696
 8001fd8:	2909883a 	add	r4,r5,r4
 8001fdc:	21802504 	addi	r6,r4,148
 8001fe0:	31000017 	ldw	r4,0(r6)
 8001fe4:	31400117 	ldw	r5,4(r6)
 8001fe8:	200d883a 	mov	r6,r4
 8001fec:	280f883a 	mov	r7,r5
 8001ff0:	1009883a 	mov	r4,r2
 8001ff4:	180b883a 	mov	r5,r3
 8001ff8:	8004ad00 	call	8004ad0 <__muldf3>
 8001ffc:	1009883a 	mov	r4,r2
 8002000:	180b883a 	mov	r5,r3
 8002004:	2005883a 	mov	r2,r4
 8002008:	2807883a 	mov	r3,r5
 800200c:	100d883a 	mov	r6,r2
 8002010:	180f883a 	mov	r7,r3
 8002014:	e13f5d17 	ldw	r4,-652(fp)
 8002018:	e17f5e17 	ldw	r5,-648(fp)
 800201c:	80040c00 	call	80040c0 <__adddf3>
 8002020:	1009883a 	mov	r4,r2
 8002024:	180b883a 	mov	r5,r3
 8002028:	e13f5d15 	stw	r4,-652(fp)
 800202c:	e17f5e15 	stw	r5,-648(fp)
 8002030:	e0bf5717 	ldw	r2,-676(fp)
 8002034:	10800044 	addi	r2,r2,1
 8002038:	e0bf5715 	stw	r2,-676(fp)
 800203c:	e0bf5717 	ldw	r2,-676(fp)
 8002040:	e0ff6117 	ldw	r3,-636(fp)
 8002044:	18bfd70e 	bge	r3,r2,8001fa4 <__kernel_rem_pio2+0x170>
 8002048:	e0bf5617 	ldw	r2,-680(fp)
 800204c:	100490fa 	slli	r2,r2,3
 8002050:	e0ff5204 	addi	r3,fp,-696
 8002054:	1885883a 	add	r2,r3,r2
 8002058:	10807504 	addi	r2,r2,468
 800205c:	e0ff5d17 	ldw	r3,-652(fp)
 8002060:	10c00015 	stw	r3,0(r2)
 8002064:	e0ff5e17 	ldw	r3,-648(fp)
 8002068:	10c00115 	stw	r3,4(r2)
    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
 800206c:	e0bf5617 	ldw	r2,-680(fp)
 8002070:	10800044 	addi	r2,r2,1
 8002074:	e0bf5615 	stw	r2,-680(fp)
 8002078:	e0bf5617 	ldw	r2,-680(fp)
 800207c:	e0ff5f17 	ldw	r3,-644(fp)
 8002080:	18bfc40e 	bge	r3,r2,8001f94 <__kernel_rem_pio2+0x160>
	    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
	}

	jz = jk;
 8002084:	e0bf5f17 	ldw	r2,-644(fp)
 8002088:	e0bf5215 	stw	r2,-696(fp)
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
 800208c:	e03f5615 	stw	zero,-680(fp)
 8002090:	e0bf5217 	ldw	r2,-696(fp)
 8002094:	e0bf5715 	stw	r2,-676(fp)
 8002098:	e0bf5217 	ldw	r2,-696(fp)
 800209c:	100490fa 	slli	r2,r2,3
 80020a0:	e13f5204 	addi	r4,fp,-696
 80020a4:	2085883a 	add	r2,r4,r2
 80020a8:	10807504 	addi	r2,r2,468
 80020ac:	10c00017 	ldw	r3,0(r2)
 80020b0:	e0ff5b15 	stw	r3,-660(fp)
 80020b4:	10800117 	ldw	r2,4(r2)
 80020b8:	e0bf5c15 	stw	r2,-656(fp)
 80020bc:	00004a06 	br	80021e8 <__kernel_rem_pio2+0x3b4>
	    fw    =  (double)((__int32_t)(twon24* z));
 80020c0:	0005883a 	mov	r2,zero
 80020c4:	00cf9c34 	movhi	r3,15984
 80020c8:	e1bf5b17 	ldw	r6,-660(fp)
 80020cc:	e1ff5c17 	ldw	r7,-656(fp)
 80020d0:	1009883a 	mov	r4,r2
 80020d4:	180b883a 	mov	r5,r3
 80020d8:	8004ad00 	call	8004ad0 <__muldf3>
 80020dc:	1009883a 	mov	r4,r2
 80020e0:	180b883a 	mov	r5,r3
 80020e4:	2005883a 	mov	r2,r4
 80020e8:	2807883a 	mov	r3,r5
 80020ec:	1009883a 	mov	r4,r2
 80020f0:	180b883a 	mov	r5,r3
 80020f4:	8005ae40 	call	8005ae4 <__fixdfsi>
 80020f8:	1009883a 	mov	r4,r2
 80020fc:	8005b640 	call	8005b64 <__floatsidf>
 8002100:	1009883a 	mov	r4,r2
 8002104:	180b883a 	mov	r5,r3
 8002108:	e13f5d15 	stw	r4,-652(fp)
 800210c:	e17f5e15 	stw	r5,-648(fp)
	    iq[i] =  (__int32_t)(z-two24*fw);
 8002110:	0005883a 	mov	r2,zero
 8002114:	00d05c34 	movhi	r3,16752
 8002118:	e1bf5d17 	ldw	r6,-652(fp)
 800211c:	e1ff5e17 	ldw	r7,-648(fp)
 8002120:	1009883a 	mov	r4,r2
 8002124:	180b883a 	mov	r5,r3
 8002128:	8004ad00 	call	8004ad0 <__muldf3>
 800212c:	1009883a 	mov	r4,r2
 8002130:	180b883a 	mov	r5,r3
 8002134:	2005883a 	mov	r2,r4
 8002138:	2807883a 	mov	r3,r5
 800213c:	100d883a 	mov	r6,r2
 8002140:	180f883a 	mov	r7,r3
 8002144:	e13f5b17 	ldw	r4,-660(fp)
 8002148:	e17f5c17 	ldw	r5,-656(fp)
 800214c:	80051e80 	call	80051e8 <__subdf3>
 8002150:	1009883a 	mov	r4,r2
 8002154:	180b883a 	mov	r5,r3
 8002158:	2005883a 	mov	r2,r4
 800215c:	2807883a 	mov	r3,r5
 8002160:	1009883a 	mov	r4,r2
 8002164:	180b883a 	mov	r5,r3
 8002168:	8005ae40 	call	8005ae4 <__fixdfsi>
 800216c:	1007883a 	mov	r3,r2
 8002170:	e0bf5617 	ldw	r2,-680(fp)
 8002174:	1085883a 	add	r2,r2,r2
 8002178:	1085883a 	add	r2,r2,r2
 800217c:	e17f5204 	addi	r5,fp,-696
 8002180:	2885883a 	add	r2,r5,r2
 8002184:	10801104 	addi	r2,r2,68
 8002188:	10c00015 	stw	r3,0(r2)
	    z     =  q[j-1]+fw;
 800218c:	e0bf5717 	ldw	r2,-676(fp)
 8002190:	10bfffc4 	addi	r2,r2,-1
 8002194:	100490fa 	slli	r2,r2,3
 8002198:	e0ff5204 	addi	r3,fp,-696
 800219c:	1885883a 	add	r2,r3,r2
 80021a0:	11007504 	addi	r4,r2,468
 80021a4:	20800017 	ldw	r2,0(r4)
 80021a8:	20c00117 	ldw	r3,4(r4)
 80021ac:	e1bf5d17 	ldw	r6,-652(fp)
 80021b0:	e1ff5e17 	ldw	r7,-648(fp)
 80021b4:	1009883a 	mov	r4,r2
 80021b8:	180b883a 	mov	r5,r3
 80021bc:	80040c00 	call	80040c0 <__adddf3>
 80021c0:	1009883a 	mov	r4,r2
 80021c4:	180b883a 	mov	r5,r3
 80021c8:	e13f5b15 	stw	r4,-660(fp)
 80021cc:	e17f5c15 	stw	r5,-656(fp)
	}

	jz = jk;
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
 80021d0:	e0bf5617 	ldw	r2,-680(fp)
 80021d4:	10800044 	addi	r2,r2,1
 80021d8:	e0bf5615 	stw	r2,-680(fp)
 80021dc:	e0bf5717 	ldw	r2,-676(fp)
 80021e0:	10bfffc4 	addi	r2,r2,-1
 80021e4:	e0bf5715 	stw	r2,-676(fp)
 80021e8:	e0bf5717 	ldw	r2,-676(fp)
 80021ec:	00bfb416 	blt	zero,r2,80020c0 <__kernel_rem_pio2+0x28c>
	    iq[i] =  (__int32_t)(z-two24*fw);
	    z     =  q[j-1]+fw;
	}

    /* compute n */
	z  = scalbn(z,(int)q0);		/* actual value of z */
 80021f0:	e1bf5917 	ldw	r6,-668(fp)
 80021f4:	e13f5b17 	ldw	r4,-660(fp)
 80021f8:	e17f5c17 	ldw	r5,-656(fp)
 80021fc:	8003a3c0 	call	8003a3c <scalbn>
 8002200:	e0bf5b15 	stw	r2,-660(fp)
 8002204:	e0ff5c15 	stw	r3,-656(fp)
	z -= 8.0*floor(z*0.125);		/* trim off integer >= 8 */
 8002208:	000d883a 	mov	r6,zero
 800220c:	01cff034 	movhi	r7,16320
 8002210:	e13f5b17 	ldw	r4,-660(fp)
 8002214:	e17f5c17 	ldw	r5,-656(fp)
 8002218:	8004ad00 	call	8004ad0 <__muldf3>
 800221c:	1009883a 	mov	r4,r2
 8002220:	180b883a 	mov	r5,r3
 8002224:	2005883a 	mov	r2,r4
 8002228:	2807883a 	mov	r3,r5
 800222c:	1009883a 	mov	r4,r2
 8002230:	180b883a 	mov	r5,r3
 8002234:	80036f80 	call	80036f8 <floor>
 8002238:	1011883a 	mov	r8,r2
 800223c:	1813883a 	mov	r9,r3
 8002240:	000d883a 	mov	r6,zero
 8002244:	01d00834 	movhi	r7,16416
 8002248:	4009883a 	mov	r4,r8
 800224c:	480b883a 	mov	r5,r9
 8002250:	8004ad00 	call	8004ad0 <__muldf3>
 8002254:	1009883a 	mov	r4,r2
 8002258:	180b883a 	mov	r5,r3
 800225c:	2005883a 	mov	r2,r4
 8002260:	2807883a 	mov	r3,r5
 8002264:	100d883a 	mov	r6,r2
 8002268:	180f883a 	mov	r7,r3
 800226c:	e13f5b17 	ldw	r4,-660(fp)
 8002270:	e17f5c17 	ldw	r5,-656(fp)
 8002274:	80051e80 	call	80051e8 <__subdf3>
 8002278:	1009883a 	mov	r4,r2
 800227c:	180b883a 	mov	r5,r3
 8002280:	e13f5b15 	stw	r4,-660(fp)
 8002284:	e17f5c15 	stw	r5,-656(fp)
	n  = (__int32_t) z;
 8002288:	e13f5b17 	ldw	r4,-660(fp)
 800228c:	e17f5c17 	ldw	r5,-656(fp)
 8002290:	8005ae40 	call	8005ae4 <__fixdfsi>
 8002294:	e0bf5515 	stw	r2,-684(fp)
	z -= (double)n;
 8002298:	e13f5517 	ldw	r4,-684(fp)
 800229c:	8005b640 	call	8005b64 <__floatsidf>
 80022a0:	1009883a 	mov	r4,r2
 80022a4:	180b883a 	mov	r5,r3
 80022a8:	200d883a 	mov	r6,r4
 80022ac:	280f883a 	mov	r7,r5
 80022b0:	e13f5b17 	ldw	r4,-660(fp)
 80022b4:	e17f5c17 	ldw	r5,-656(fp)
 80022b8:	80051e80 	call	80051e8 <__subdf3>
 80022bc:	1009883a 	mov	r4,r2
 80022c0:	180b883a 	mov	r5,r3
 80022c4:	e13f5b15 	stw	r4,-660(fp)
 80022c8:	e17f5c15 	stw	r5,-656(fp)
	ih = 0;
 80022cc:	e03f5a15 	stw	zero,-664(fp)
	if(q0>0) {	/* need iq[jz-1] to determine n */
 80022d0:	e0bf5917 	ldw	r2,-668(fp)
 80022d4:	0080350e 	bge	zero,r2,80023ac <__kernel_rem_pio2+0x578>
	    i  = (iq[jz-1]>>(24-q0)); n += i;
 80022d8:	e0bf5217 	ldw	r2,-696(fp)
 80022dc:	10bfffc4 	addi	r2,r2,-1
 80022e0:	1085883a 	add	r2,r2,r2
 80022e4:	1085883a 	add	r2,r2,r2
 80022e8:	e13f5204 	addi	r4,fp,-696
 80022ec:	2085883a 	add	r2,r4,r2
 80022f0:	10801104 	addi	r2,r2,68
 80022f4:	10c00017 	ldw	r3,0(r2)
 80022f8:	01000604 	movi	r4,24
 80022fc:	e0bf5917 	ldw	r2,-668(fp)
 8002300:	2085c83a 	sub	r2,r4,r2
 8002304:	1885d83a 	sra	r2,r3,r2
 8002308:	e0bf5615 	stw	r2,-680(fp)
 800230c:	e0ff5517 	ldw	r3,-684(fp)
 8002310:	e0bf5617 	ldw	r2,-680(fp)
 8002314:	1885883a 	add	r2,r3,r2
 8002318:	e0bf5515 	stw	r2,-684(fp)
	    iq[jz-1] -= i<<(24-q0);
 800231c:	e0bf5217 	ldw	r2,-696(fp)
 8002320:	10bfffc4 	addi	r2,r2,-1
 8002324:	e0ff5217 	ldw	r3,-696(fp)
 8002328:	18ffffc4 	addi	r3,r3,-1
 800232c:	18c7883a 	add	r3,r3,r3
 8002330:	18c7883a 	add	r3,r3,r3
 8002334:	e17f5204 	addi	r5,fp,-696
 8002338:	28c7883a 	add	r3,r5,r3
 800233c:	18c01104 	addi	r3,r3,68
 8002340:	19000017 	ldw	r4,0(r3)
 8002344:	01400604 	movi	r5,24
 8002348:	e0ff5917 	ldw	r3,-668(fp)
 800234c:	28c7c83a 	sub	r3,r5,r3
 8002350:	e17f5617 	ldw	r5,-680(fp)
 8002354:	28c6983a 	sll	r3,r5,r3
 8002358:	20c7c83a 	sub	r3,r4,r3
 800235c:	1085883a 	add	r2,r2,r2
 8002360:	1085883a 	add	r2,r2,r2
 8002364:	e13f5204 	addi	r4,fp,-696
 8002368:	2085883a 	add	r2,r4,r2
 800236c:	10801104 	addi	r2,r2,68
 8002370:	10c00015 	stw	r3,0(r2)
	    ih = iq[jz-1]>>(23-q0);
 8002374:	e0bf5217 	ldw	r2,-696(fp)
 8002378:	10bfffc4 	addi	r2,r2,-1
 800237c:	1085883a 	add	r2,r2,r2
 8002380:	1085883a 	add	r2,r2,r2
 8002384:	e17f5204 	addi	r5,fp,-696
 8002388:	2885883a 	add	r2,r5,r2
 800238c:	10801104 	addi	r2,r2,68
 8002390:	10c00017 	ldw	r3,0(r2)
 8002394:	010005c4 	movi	r4,23
 8002398:	e0bf5917 	ldw	r2,-668(fp)
 800239c:	2085c83a 	sub	r2,r4,r2
 80023a0:	1885d83a 	sra	r2,r3,r2
 80023a4:	e0bf5a15 	stw	r2,-664(fp)
 80023a8:	00001506 	br	8002400 <__kernel_rem_pio2+0x5cc>
	} 
	else if(q0==0) ih = iq[jz-1]>>23;
 80023ac:	e0bf5917 	ldw	r2,-668(fp)
 80023b0:	10000b1e 	bne	r2,zero,80023e0 <__kernel_rem_pio2+0x5ac>
 80023b4:	e0bf5217 	ldw	r2,-696(fp)
 80023b8:	10bfffc4 	addi	r2,r2,-1
 80023bc:	1085883a 	add	r2,r2,r2
 80023c0:	1085883a 	add	r2,r2,r2
 80023c4:	e0ff5204 	addi	r3,fp,-696
 80023c8:	1885883a 	add	r2,r3,r2
 80023cc:	10801104 	addi	r2,r2,68
 80023d0:	10800017 	ldw	r2,0(r2)
 80023d4:	1005d5fa 	srai	r2,r2,23
 80023d8:	e0bf5a15 	stw	r2,-664(fp)
 80023dc:	00000806 	br	8002400 <__kernel_rem_pio2+0x5cc>
	else if(z>=0.5) ih=2;
 80023e0:	000d883a 	mov	r6,zero
 80023e4:	01cff834 	movhi	r7,16352
 80023e8:	e13f5b17 	ldw	r4,-660(fp)
 80023ec:	e17f5c17 	ldw	r5,-656(fp)
 80023f0:	80049f40 	call	80049f4 <__gedf2>
 80023f4:	10000216 	blt	r2,zero,8002400 <__kernel_rem_pio2+0x5cc>
 80023f8:	00800084 	movi	r2,2
 80023fc:	e0bf5a15 	stw	r2,-664(fp)

	if(ih>0) {	/* q > 0.5 */
 8002400:	e0bf5a17 	ldw	r2,-664(fp)
 8002404:	0080810e 	bge	zero,r2,800260c <__kernel_rem_pio2+0x7d8>
	    n += 1; carry = 0;
 8002408:	e0bf5517 	ldw	r2,-684(fp)
 800240c:	10800044 	addi	r2,r2,1
 8002410:	e0bf5515 	stw	r2,-684(fp)
 8002414:	e03f5415 	stw	zero,-688(fp)
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
 8002418:	e03f5615 	stw	zero,-680(fp)
 800241c:	00002706 	br	80024bc <__kernel_rem_pio2+0x688>
		j = iq[i];
 8002420:	e0bf5617 	ldw	r2,-680(fp)
 8002424:	1085883a 	add	r2,r2,r2
 8002428:	1085883a 	add	r2,r2,r2
 800242c:	e13f5204 	addi	r4,fp,-696
 8002430:	2085883a 	add	r2,r4,r2
 8002434:	10801104 	addi	r2,r2,68
 8002438:	10800017 	ldw	r2,0(r2)
 800243c:	e0bf5715 	stw	r2,-676(fp)
		if(carry==0) {
 8002440:	e0bf5417 	ldw	r2,-688(fp)
 8002444:	10000f1e 	bne	r2,zero,8002484 <__kernel_rem_pio2+0x650>
		    if(j!=0) {
 8002448:	e0bf5717 	ldw	r2,-676(fp)
 800244c:	10001826 	beq	r2,zero,80024b0 <__kernel_rem_pio2+0x67c>
			carry = 1; iq[i] = 0x1000000- j;
 8002450:	00800044 	movi	r2,1
 8002454:	e0bf5415 	stw	r2,-688(fp)
 8002458:	00c04034 	movhi	r3,256
 800245c:	e0bf5717 	ldw	r2,-676(fp)
 8002460:	1887c83a 	sub	r3,r3,r2
 8002464:	e0bf5617 	ldw	r2,-680(fp)
 8002468:	1085883a 	add	r2,r2,r2
 800246c:	1085883a 	add	r2,r2,r2
 8002470:	e17f5204 	addi	r5,fp,-696
 8002474:	2885883a 	add	r2,r5,r2
 8002478:	10801104 	addi	r2,r2,68
 800247c:	10c00015 	stw	r3,0(r2)
 8002480:	00000b06 	br	80024b0 <__kernel_rem_pio2+0x67c>
		    }
		} else  iq[i] = 0xffffff - j;
 8002484:	00804034 	movhi	r2,256
 8002488:	10bfffc4 	addi	r2,r2,-1
 800248c:	e0ff5717 	ldw	r3,-676(fp)
 8002490:	10c7c83a 	sub	r3,r2,r3
 8002494:	e0bf5617 	ldw	r2,-680(fp)
 8002498:	1085883a 	add	r2,r2,r2
 800249c:	1085883a 	add	r2,r2,r2
 80024a0:	e13f5204 	addi	r4,fp,-696
 80024a4:	2085883a 	add	r2,r4,r2
 80024a8:	10801104 	addi	r2,r2,68
 80024ac:	10c00015 	stw	r3,0(r2)
	else if(q0==0) ih = iq[jz-1]>>23;
	else if(z>=0.5) ih=2;

	if(ih>0) {	/* q > 0.5 */
	    n += 1; carry = 0;
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
 80024b0:	e0bf5617 	ldw	r2,-680(fp)
 80024b4:	10800044 	addi	r2,r2,1
 80024b8:	e0bf5615 	stw	r2,-680(fp)
 80024bc:	e0ff5617 	ldw	r3,-680(fp)
 80024c0:	e0bf5217 	ldw	r2,-696(fp)
 80024c4:	18bfd616 	blt	r3,r2,8002420 <__kernel_rem_pio2+0x5ec>
		    if(j!=0) {
			carry = 1; iq[i] = 0x1000000- j;
		    }
		} else  iq[i] = 0xffffff - j;
	    }
	    if(q0>0) {		/* rare case: chance is 1 in 12 */
 80024c8:	e0bf5917 	ldw	r2,-668(fp)
 80024cc:	00802e0e 	bge	zero,r2,8002588 <__kernel_rem_pio2+0x754>
	        switch(q0) {
 80024d0:	e0bf5917 	ldw	r2,-668(fp)
 80024d4:	10c00060 	cmpeqi	r3,r2,1
 80024d8:	1800031e 	bne	r3,zero,80024e8 <__kernel_rem_pio2+0x6b4>
 80024dc:	108000a0 	cmpeqi	r2,r2,2
 80024e0:	1000151e 	bne	r2,zero,8002538 <__kernel_rem_pio2+0x704>
 80024e4:	00002806 	br	8002588 <__kernel_rem_pio2+0x754>
	        case 1:
	    	   iq[jz-1] &= 0x7fffff; break;
 80024e8:	e0bf5217 	ldw	r2,-696(fp)
 80024ec:	10ffffc4 	addi	r3,r2,-1
 80024f0:	e0bf5217 	ldw	r2,-696(fp)
 80024f4:	10bfffc4 	addi	r2,r2,-1
 80024f8:	1085883a 	add	r2,r2,r2
 80024fc:	1085883a 	add	r2,r2,r2
 8002500:	e17f5204 	addi	r5,fp,-696
 8002504:	2885883a 	add	r2,r5,r2
 8002508:	10801104 	addi	r2,r2,68
 800250c:	11000017 	ldw	r4,0(r2)
 8002510:	00802034 	movhi	r2,128
 8002514:	10bfffc4 	addi	r2,r2,-1
 8002518:	2088703a 	and	r4,r4,r2
 800251c:	18c5883a 	add	r2,r3,r3
 8002520:	1085883a 	add	r2,r2,r2
 8002524:	e0ff5204 	addi	r3,fp,-696
 8002528:	1885883a 	add	r2,r3,r2
 800252c:	10801104 	addi	r2,r2,68
 8002530:	11000015 	stw	r4,0(r2)
 8002534:	00001406 	br	8002588 <__kernel_rem_pio2+0x754>
	    	case 2:
	    	   iq[jz-1] &= 0x3fffff; break;
 8002538:	e0bf5217 	ldw	r2,-696(fp)
 800253c:	10ffffc4 	addi	r3,r2,-1
 8002540:	e0bf5217 	ldw	r2,-696(fp)
 8002544:	10bfffc4 	addi	r2,r2,-1
 8002548:	1085883a 	add	r2,r2,r2
 800254c:	1085883a 	add	r2,r2,r2
 8002550:	e13f5204 	addi	r4,fp,-696
 8002554:	2085883a 	add	r2,r4,r2
 8002558:	10801104 	addi	r2,r2,68
 800255c:	11000017 	ldw	r4,0(r2)
 8002560:	00801034 	movhi	r2,64
 8002564:	10bfffc4 	addi	r2,r2,-1
 8002568:	2088703a 	and	r4,r4,r2
 800256c:	18c5883a 	add	r2,r3,r3
 8002570:	1085883a 	add	r2,r2,r2
 8002574:	e17f5204 	addi	r5,fp,-696
 8002578:	2885883a 	add	r2,r5,r2
 800257c:	10801104 	addi	r2,r2,68
 8002580:	11000015 	stw	r4,0(r2)
 8002584:	0001883a 	nop
	        }
	    }
	    if(ih==2) {
 8002588:	e0bf5a17 	ldw	r2,-664(fp)
 800258c:	10800098 	cmpnei	r2,r2,2
 8002590:	10001e1e 	bne	r2,zero,800260c <__kernel_rem_pio2+0x7d8>
		z = one - z;
 8002594:	0005883a 	mov	r2,zero
 8002598:	00cffc34 	movhi	r3,16368
 800259c:	e1bf5b17 	ldw	r6,-660(fp)
 80025a0:	e1ff5c17 	ldw	r7,-656(fp)
 80025a4:	1009883a 	mov	r4,r2
 80025a8:	180b883a 	mov	r5,r3
 80025ac:	80051e80 	call	80051e8 <__subdf3>
 80025b0:	1009883a 	mov	r4,r2
 80025b4:	180b883a 	mov	r5,r3
 80025b8:	e13f5b15 	stw	r4,-660(fp)
 80025bc:	e17f5c15 	stw	r5,-656(fp)
		if(carry!=0) z -= scalbn(one,(int)q0);
 80025c0:	e0bf5417 	ldw	r2,-688(fp)
 80025c4:	10001126 	beq	r2,zero,800260c <__kernel_rem_pio2+0x7d8>
 80025c8:	0005883a 	mov	r2,zero
 80025cc:	00cffc34 	movhi	r3,16368
 80025d0:	e1bf5917 	ldw	r6,-668(fp)
 80025d4:	1009883a 	mov	r4,r2
 80025d8:	180b883a 	mov	r5,r3
 80025dc:	8003a3c0 	call	8003a3c <scalbn>
 80025e0:	1009883a 	mov	r4,r2
 80025e4:	180b883a 	mov	r5,r3
 80025e8:	200d883a 	mov	r6,r4
 80025ec:	280f883a 	mov	r7,r5
 80025f0:	e13f5b17 	ldw	r4,-660(fp)
 80025f4:	e17f5c17 	ldw	r5,-656(fp)
 80025f8:	80051e80 	call	80051e8 <__subdf3>
 80025fc:	1009883a 	mov	r4,r2
 8002600:	180b883a 	mov	r5,r3
 8002604:	e13f5b15 	stw	r4,-660(fp)
 8002608:	e17f5c15 	stw	r5,-656(fp)
	    }
	}

    /* check if recomputation is needed */
	if(z==zero) {
 800260c:	0005883a 	mov	r2,zero
 8002610:	0007883a 	mov	r3,zero
 8002614:	100d883a 	mov	r6,r2
 8002618:	180f883a 	mov	r7,r3
 800261c:	e13f5b17 	ldw	r4,-660(fp)
 8002620:	e17f5c17 	ldw	r5,-656(fp)
 8002624:	800496c0 	call	800496c <__eqdf2>
 8002628:	1000861e 	bne	r2,zero,8002844 <__kernel_rem_pio2+0xa10>
	    j = 0;
 800262c:	e03f5715 	stw	zero,-676(fp)
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
 8002630:	e0bf5217 	ldw	r2,-696(fp)
 8002634:	10bfffc4 	addi	r2,r2,-1
 8002638:	e0bf5615 	stw	r2,-680(fp)
 800263c:	00000d06 	br	8002674 <__kernel_rem_pio2+0x840>
 8002640:	e0bf5617 	ldw	r2,-680(fp)
 8002644:	1085883a 	add	r2,r2,r2
 8002648:	1085883a 	add	r2,r2,r2
 800264c:	e0ff5204 	addi	r3,fp,-696
 8002650:	1885883a 	add	r2,r3,r2
 8002654:	10801104 	addi	r2,r2,68
 8002658:	10800017 	ldw	r2,0(r2)
 800265c:	e0ff5717 	ldw	r3,-676(fp)
 8002660:	1884b03a 	or	r2,r3,r2
 8002664:	e0bf5715 	stw	r2,-676(fp)
 8002668:	e0bf5617 	ldw	r2,-680(fp)
 800266c:	10bfffc4 	addi	r2,r2,-1
 8002670:	e0bf5615 	stw	r2,-680(fp)
 8002674:	e0ff5617 	ldw	r3,-680(fp)
 8002678:	e0bf5f17 	ldw	r2,-644(fp)
 800267c:	18bff00e 	bge	r3,r2,8002640 <__kernel_rem_pio2+0x80c>
	    if(j==0) { /* need recomputation */
 8002680:	e0bf5717 	ldw	r2,-676(fp)
 8002684:	10006f1e 	bne	r2,zero,8002844 <__kernel_rem_pio2+0xa10>
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */
 8002688:	00800044 	movi	r2,1
 800268c:	e0bf5815 	stw	r2,-672(fp)
 8002690:	00000306 	br	80026a0 <__kernel_rem_pio2+0x86c>
 8002694:	e0bf5817 	ldw	r2,-672(fp)
 8002698:	10800044 	addi	r2,r2,1
 800269c:	e0bf5815 	stw	r2,-672(fp)
 80026a0:	e0ff5f17 	ldw	r3,-644(fp)
 80026a4:	e0bf5817 	ldw	r2,-672(fp)
 80026a8:	1885c83a 	sub	r2,r3,r2
 80026ac:	1085883a 	add	r2,r2,r2
 80026b0:	1085883a 	add	r2,r2,r2
 80026b4:	e13f5204 	addi	r4,fp,-696
 80026b8:	2085883a 	add	r2,r4,r2
 80026bc:	10801104 	addi	r2,r2,68
 80026c0:	10800017 	ldw	r2,0(r2)
 80026c4:	103ff326 	beq	r2,zero,8002694 <__kernel_rem_pio2+0x860>

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
 80026c8:	e0bf5217 	ldw	r2,-696(fp)
 80026cc:	10800044 	addi	r2,r2,1
 80026d0:	e0bf5615 	stw	r2,-680(fp)
 80026d4:	00005106 	br	800281c <__kernel_rem_pio2+0x9e8>
		    f[jx+i] = (double) ipio2[jv+i];
 80026d8:	e0ff6117 	ldw	r3,-636(fp)
 80026dc:	e0bf5617 	ldw	r2,-680(fp)
 80026e0:	1885883a 	add	r2,r3,r2
 80026e4:	e0bff315 	stw	r2,-52(fp)
 80026e8:	e0ff5317 	ldw	r3,-692(fp)
 80026ec:	e0bf5617 	ldw	r2,-680(fp)
 80026f0:	1885883a 	add	r2,r3,r2
 80026f4:	1085883a 	add	r2,r2,r2
 80026f8:	1085883a 	add	r2,r2,r2
 80026fc:	1007883a 	mov	r3,r2
 8002700:	e0800317 	ldw	r2,12(fp)
 8002704:	10c5883a 	add	r2,r2,r3
 8002708:	10800017 	ldw	r2,0(r2)
 800270c:	1009883a 	mov	r4,r2
 8002710:	8005b640 	call	8005b64 <__floatsidf>
 8002714:	1009883a 	mov	r4,r2
 8002718:	180b883a 	mov	r5,r3
 800271c:	e0fff317 	ldw	r3,-52(fp)
 8002720:	180490fa 	slli	r2,r3,3
 8002724:	e0ff5204 	addi	r3,fp,-696
 8002728:	1885883a 	add	r2,r3,r2
 800272c:	10802504 	addi	r2,r2,148
 8002730:	11000015 	stw	r4,0(r2)
 8002734:	11400115 	stw	r5,4(r2)
		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
 8002738:	e03f5715 	stw	zero,-676(fp)
 800273c:	e03f5d15 	stw	zero,-652(fp)
 8002740:	e03f5e15 	stw	zero,-648(fp)
 8002744:	00002606 	br	80027e0 <__kernel_rem_pio2+0x9ac>
 8002748:	e0bf5717 	ldw	r2,-676(fp)
 800274c:	100490fa 	slli	r2,r2,3
 8002750:	e0ffef17 	ldw	r3,-68(fp)
 8002754:	1889883a 	add	r4,r3,r2
 8002758:	20800017 	ldw	r2,0(r4)
 800275c:	20c00117 	ldw	r3,4(r4)
 8002760:	e17f6117 	ldw	r5,-636(fp)
 8002764:	e13f5617 	ldw	r4,-680(fp)
 8002768:	290b883a 	add	r5,r5,r4
 800276c:	e13f5717 	ldw	r4,-676(fp)
 8002770:	2909c83a 	sub	r4,r5,r4
 8002774:	200890fa 	slli	r4,r4,3
 8002778:	e17f5204 	addi	r5,fp,-696
 800277c:	2909883a 	add	r4,r5,r4
 8002780:	21802504 	addi	r6,r4,148
 8002784:	31000017 	ldw	r4,0(r6)
 8002788:	31400117 	ldw	r5,4(r6)
 800278c:	200d883a 	mov	r6,r4
 8002790:	280f883a 	mov	r7,r5
 8002794:	1009883a 	mov	r4,r2
 8002798:	180b883a 	mov	r5,r3
 800279c:	8004ad00 	call	8004ad0 <__muldf3>
 80027a0:	1009883a 	mov	r4,r2
 80027a4:	180b883a 	mov	r5,r3
 80027a8:	2005883a 	mov	r2,r4
 80027ac:	2807883a 	mov	r3,r5
 80027b0:	100d883a 	mov	r6,r2
 80027b4:	180f883a 	mov	r7,r3
 80027b8:	e13f5d17 	ldw	r4,-652(fp)
 80027bc:	e17f5e17 	ldw	r5,-648(fp)
 80027c0:	80040c00 	call	80040c0 <__adddf3>
 80027c4:	1009883a 	mov	r4,r2
 80027c8:	180b883a 	mov	r5,r3
 80027cc:	e13f5d15 	stw	r4,-652(fp)
 80027d0:	e17f5e15 	stw	r5,-648(fp)
 80027d4:	e0bf5717 	ldw	r2,-676(fp)
 80027d8:	10800044 	addi	r2,r2,1
 80027dc:	e0bf5715 	stw	r2,-676(fp)
 80027e0:	e0bf5717 	ldw	r2,-676(fp)
 80027e4:	e0ff6117 	ldw	r3,-636(fp)
 80027e8:	18bfd70e 	bge	r3,r2,8002748 <__kernel_rem_pio2+0x914>
		    q[i] = fw;
 80027ec:	e0bf5617 	ldw	r2,-680(fp)
 80027f0:	100490fa 	slli	r2,r2,3
 80027f4:	e0ff5204 	addi	r3,fp,-696
 80027f8:	1885883a 	add	r2,r3,r2
 80027fc:	10807504 	addi	r2,r2,468
 8002800:	e0ff5d17 	ldw	r3,-652(fp)
 8002804:	10c00015 	stw	r3,0(r2)
 8002808:	e0ff5e17 	ldw	r3,-648(fp)
 800280c:	10c00115 	stw	r3,4(r2)
	    j = 0;
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
	    if(j==0) { /* need recomputation */
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
 8002810:	e0bf5617 	ldw	r2,-680(fp)
 8002814:	10800044 	addi	r2,r2,1
 8002818:	e0bf5615 	stw	r2,-680(fp)
 800281c:	e0ff5217 	ldw	r3,-696(fp)
 8002820:	e0bf5817 	ldw	r2,-672(fp)
 8002824:	1887883a 	add	r3,r3,r2
 8002828:	e0bf5617 	ldw	r2,-680(fp)
 800282c:	18bfaa0e 	bge	r3,r2,80026d8 <__kernel_rem_pio2+0x8a4>
		    f[jx+i] = (double) ipio2[jv+i];
		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
		    q[i] = fw;
		}
		jz += k;
 8002830:	e0ff5217 	ldw	r3,-696(fp)
 8002834:	e0bf5817 	ldw	r2,-672(fp)
 8002838:	1885883a 	add	r2,r3,r2
 800283c:	e0bf5215 	stw	r2,-696(fp)
		goto recompute;
 8002840:	003e1206 	br	800208c <__kernel_rem_pio2+0x258>
	    }
	}

    /* chop off zero terms */
	if(z==0.0) {
 8002844:	000d883a 	mov	r6,zero
 8002848:	000f883a 	mov	r7,zero
 800284c:	e13f5b17 	ldw	r4,-660(fp)
 8002850:	e17f5c17 	ldw	r5,-656(fp)
 8002854:	800496c0 	call	800496c <__eqdf2>
 8002858:	1000161e 	bne	r2,zero,80028b4 <__kernel_rem_pio2+0xa80>
	    jz -= 1; q0 -= 24;
 800285c:	e0bf5217 	ldw	r2,-696(fp)
 8002860:	10bfffc4 	addi	r2,r2,-1
 8002864:	e0bf5215 	stw	r2,-696(fp)
 8002868:	e0bf5917 	ldw	r2,-668(fp)
 800286c:	10bffa04 	addi	r2,r2,-24
 8002870:	e0bf5915 	stw	r2,-668(fp)
	    while(iq[jz]==0) { jz--; q0-=24;}
 8002874:	00000606 	br	8002890 <__kernel_rem_pio2+0xa5c>
 8002878:	e0bf5217 	ldw	r2,-696(fp)
 800287c:	10bfffc4 	addi	r2,r2,-1
 8002880:	e0bf5215 	stw	r2,-696(fp)
 8002884:	e0bf5917 	ldw	r2,-668(fp)
 8002888:	10bffa04 	addi	r2,r2,-24
 800288c:	e0bf5915 	stw	r2,-668(fp)
 8002890:	e0bf5217 	ldw	r2,-696(fp)
 8002894:	1085883a 	add	r2,r2,r2
 8002898:	1085883a 	add	r2,r2,r2
 800289c:	e13f5204 	addi	r4,fp,-696
 80028a0:	2085883a 	add	r2,r4,r2
 80028a4:	10801104 	addi	r2,r2,68
 80028a8:	10800017 	ldw	r2,0(r2)
 80028ac:	103ff226 	beq	r2,zero,8002878 <__kernel_rem_pio2+0xa44>
 80028b0:	00006006 	br	8002a34 <__kernel_rem_pio2+0xc00>
	} else { /* break z into 24-bit if necessary */
	    z = scalbn(z,-(int)q0);
 80028b4:	e0bf5917 	ldw	r2,-668(fp)
 80028b8:	0085c83a 	sub	r2,zero,r2
 80028bc:	100d883a 	mov	r6,r2
 80028c0:	e13f5b17 	ldw	r4,-660(fp)
 80028c4:	e17f5c17 	ldw	r5,-656(fp)
 80028c8:	8003a3c0 	call	8003a3c <scalbn>
 80028cc:	e0bf5b15 	stw	r2,-660(fp)
 80028d0:	e0ff5c15 	stw	r3,-656(fp)
	    if(z>=two24) { 
 80028d4:	0005883a 	mov	r2,zero
 80028d8:	00d05c34 	movhi	r3,16752
 80028dc:	100d883a 	mov	r6,r2
 80028e0:	180f883a 	mov	r7,r3
 80028e4:	e13f5b17 	ldw	r4,-660(fp)
 80028e8:	e17f5c17 	ldw	r5,-656(fp)
 80028ec:	80049f40 	call	80049f4 <__gedf2>
 80028f0:	10004516 	blt	r2,zero,8002a08 <__kernel_rem_pio2+0xbd4>
		fw = (double)((__int32_t)(twon24*z));
 80028f4:	0005883a 	mov	r2,zero
 80028f8:	00cf9c34 	movhi	r3,15984
 80028fc:	e1bf5b17 	ldw	r6,-660(fp)
 8002900:	e1ff5c17 	ldw	r7,-656(fp)
 8002904:	1009883a 	mov	r4,r2
 8002908:	180b883a 	mov	r5,r3
 800290c:	8004ad00 	call	8004ad0 <__muldf3>
 8002910:	1009883a 	mov	r4,r2
 8002914:	180b883a 	mov	r5,r3
 8002918:	2005883a 	mov	r2,r4
 800291c:	2807883a 	mov	r3,r5
 8002920:	1009883a 	mov	r4,r2
 8002924:	180b883a 	mov	r5,r3
 8002928:	8005ae40 	call	8005ae4 <__fixdfsi>
 800292c:	1009883a 	mov	r4,r2
 8002930:	8005b640 	call	8005b64 <__floatsidf>
 8002934:	1009883a 	mov	r4,r2
 8002938:	180b883a 	mov	r5,r3
 800293c:	e13f5d15 	stw	r4,-652(fp)
 8002940:	e17f5e15 	stw	r5,-648(fp)
		iq[jz] = (__int32_t)(z-two24*fw);
 8002944:	0005883a 	mov	r2,zero
 8002948:	00d05c34 	movhi	r3,16752
 800294c:	e1bf5d17 	ldw	r6,-652(fp)
 8002950:	e1ff5e17 	ldw	r7,-648(fp)
 8002954:	1009883a 	mov	r4,r2
 8002958:	180b883a 	mov	r5,r3
 800295c:	8004ad00 	call	8004ad0 <__muldf3>
 8002960:	1009883a 	mov	r4,r2
 8002964:	180b883a 	mov	r5,r3
 8002968:	2005883a 	mov	r2,r4
 800296c:	2807883a 	mov	r3,r5
 8002970:	100d883a 	mov	r6,r2
 8002974:	180f883a 	mov	r7,r3
 8002978:	e13f5b17 	ldw	r4,-660(fp)
 800297c:	e17f5c17 	ldw	r5,-656(fp)
 8002980:	80051e80 	call	80051e8 <__subdf3>
 8002984:	1009883a 	mov	r4,r2
 8002988:	180b883a 	mov	r5,r3
 800298c:	2005883a 	mov	r2,r4
 8002990:	2807883a 	mov	r3,r5
 8002994:	1009883a 	mov	r4,r2
 8002998:	180b883a 	mov	r5,r3
 800299c:	8005ae40 	call	8005ae4 <__fixdfsi>
 80029a0:	1007883a 	mov	r3,r2
 80029a4:	e0bf5217 	ldw	r2,-696(fp)
 80029a8:	1085883a 	add	r2,r2,r2
 80029ac:	1085883a 	add	r2,r2,r2
 80029b0:	e17f5204 	addi	r5,fp,-696
 80029b4:	2885883a 	add	r2,r5,r2
 80029b8:	10801104 	addi	r2,r2,68
 80029bc:	10c00015 	stw	r3,0(r2)
		jz += 1; q0 += 24;
 80029c0:	e0bf5217 	ldw	r2,-696(fp)
 80029c4:	10800044 	addi	r2,r2,1
 80029c8:	e0bf5215 	stw	r2,-696(fp)
 80029cc:	e0bf5917 	ldw	r2,-668(fp)
 80029d0:	10800604 	addi	r2,r2,24
 80029d4:	e0bf5915 	stw	r2,-668(fp)
		iq[jz] = (__int32_t) fw;
 80029d8:	e13f5d17 	ldw	r4,-652(fp)
 80029dc:	e17f5e17 	ldw	r5,-648(fp)
 80029e0:	8005ae40 	call	8005ae4 <__fixdfsi>
 80029e4:	1007883a 	mov	r3,r2
 80029e8:	e0bf5217 	ldw	r2,-696(fp)
 80029ec:	1085883a 	add	r2,r2,r2
 80029f0:	1085883a 	add	r2,r2,r2
 80029f4:	e13f5204 	addi	r4,fp,-696
 80029f8:	2085883a 	add	r2,r4,r2
 80029fc:	10801104 	addi	r2,r2,68
 8002a00:	10c00015 	stw	r3,0(r2)
 8002a04:	00000b06 	br	8002a34 <__kernel_rem_pio2+0xc00>
	    } else iq[jz] = (__int32_t) z ;
 8002a08:	e13f5b17 	ldw	r4,-660(fp)
 8002a0c:	e17f5c17 	ldw	r5,-656(fp)
 8002a10:	8005ae40 	call	8005ae4 <__fixdfsi>
 8002a14:	1007883a 	mov	r3,r2
 8002a18:	e0bf5217 	ldw	r2,-696(fp)
 8002a1c:	1085883a 	add	r2,r2,r2
 8002a20:	1085883a 	add	r2,r2,r2
 8002a24:	e17f5204 	addi	r5,fp,-696
 8002a28:	2885883a 	add	r2,r5,r2
 8002a2c:	10801104 	addi	r2,r2,68
 8002a30:	10c00015 	stw	r3,0(r2)
	}

    /* convert integer "bit" chunk to floating-point value */
	fw = scalbn(one,(int)q0);
 8002a34:	0005883a 	mov	r2,zero
 8002a38:	00cffc34 	movhi	r3,16368
 8002a3c:	e1bf5917 	ldw	r6,-668(fp)
 8002a40:	1009883a 	mov	r4,r2
 8002a44:	180b883a 	mov	r5,r3
 8002a48:	8003a3c0 	call	8003a3c <scalbn>
 8002a4c:	e0bf5d15 	stw	r2,-652(fp)
 8002a50:	e0ff5e15 	stw	r3,-648(fp)
	for(i=jz;i>=0;i--) {
 8002a54:	e0bf5217 	ldw	r2,-696(fp)
 8002a58:	e0bf5615 	stw	r2,-680(fp)
 8002a5c:	00002906 	br	8002b04 <__kernel_rem_pio2+0xcd0>
	    q[i] = fw*(double)iq[i]; fw*=twon24;
 8002a60:	e0bf5617 	ldw	r2,-680(fp)
 8002a64:	1085883a 	add	r2,r2,r2
 8002a68:	1085883a 	add	r2,r2,r2
 8002a6c:	e0ff5204 	addi	r3,fp,-696
 8002a70:	1885883a 	add	r2,r3,r2
 8002a74:	10801104 	addi	r2,r2,68
 8002a78:	10800017 	ldw	r2,0(r2)
 8002a7c:	1009883a 	mov	r4,r2
 8002a80:	8005b640 	call	8005b64 <__floatsidf>
 8002a84:	1011883a 	mov	r8,r2
 8002a88:	1813883a 	mov	r9,r3
 8002a8c:	e1bf5d17 	ldw	r6,-652(fp)
 8002a90:	e1ff5e17 	ldw	r7,-648(fp)
 8002a94:	4009883a 	mov	r4,r8
 8002a98:	480b883a 	mov	r5,r9
 8002a9c:	8004ad00 	call	8004ad0 <__muldf3>
 8002aa0:	1009883a 	mov	r4,r2
 8002aa4:	180b883a 	mov	r5,r3
 8002aa8:	2005883a 	mov	r2,r4
 8002aac:	2807883a 	mov	r3,r5
 8002ab0:	e13f5617 	ldw	r4,-680(fp)
 8002ab4:	200890fa 	slli	r4,r4,3
 8002ab8:	e17f5204 	addi	r5,fp,-696
 8002abc:	2909883a 	add	r4,r5,r4
 8002ac0:	21007504 	addi	r4,r4,468
 8002ac4:	20800015 	stw	r2,0(r4)
 8002ac8:	20c00115 	stw	r3,4(r4)
 8002acc:	0005883a 	mov	r2,zero
 8002ad0:	00cf9c34 	movhi	r3,15984
 8002ad4:	100d883a 	mov	r6,r2
 8002ad8:	180f883a 	mov	r7,r3
 8002adc:	e13f5d17 	ldw	r4,-652(fp)
 8002ae0:	e17f5e17 	ldw	r5,-648(fp)
 8002ae4:	8004ad00 	call	8004ad0 <__muldf3>
 8002ae8:	1009883a 	mov	r4,r2
 8002aec:	180b883a 	mov	r5,r3
 8002af0:	e13f5d15 	stw	r4,-652(fp)
 8002af4:	e17f5e15 	stw	r5,-648(fp)
	    } else iq[jz] = (__int32_t) z ;
	}

    /* convert integer "bit" chunk to floating-point value */
	fw = scalbn(one,(int)q0);
	for(i=jz;i>=0;i--) {
 8002af8:	e0bf5617 	ldw	r2,-680(fp)
 8002afc:	10bfffc4 	addi	r2,r2,-1
 8002b00:	e0bf5615 	stw	r2,-680(fp)
 8002b04:	e0bf5617 	ldw	r2,-680(fp)
 8002b08:	103fd50e 	bge	r2,zero,8002a60 <__kernel_rem_pio2+0xc2c>
	    q[i] = fw*(double)iq[i]; fw*=twon24;
	}

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
	for(i=jz;i>=0;i--) {
 8002b0c:	e0bf5217 	ldw	r2,-696(fp)
 8002b10:	e0bf5615 	stw	r2,-680(fp)
 8002b14:	00003f06 	br	8002c14 <__kernel_rem_pio2+0xde0>
	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
 8002b18:	e03f5d15 	stw	zero,-652(fp)
 8002b1c:	e03f5e15 	stw	zero,-648(fp)
 8002b20:	e03f5815 	stw	zero,-672(fp)
 8002b24:	00002506 	br	8002bbc <__kernel_rem_pio2+0xd88>
 8002b28:	00820134 	movhi	r2,2052
 8002b2c:	10991904 	addi	r2,r2,25700
 8002b30:	e0ff5817 	ldw	r3,-672(fp)
 8002b34:	180690fa 	slli	r3,r3,3
 8002b38:	10c9883a 	add	r4,r2,r3
 8002b3c:	20800017 	ldw	r2,0(r4)
 8002b40:	20c00117 	ldw	r3,4(r4)
 8002b44:	e17f5617 	ldw	r5,-680(fp)
 8002b48:	e13f5817 	ldw	r4,-672(fp)
 8002b4c:	2909883a 	add	r4,r5,r4
 8002b50:	200890fa 	slli	r4,r4,3
 8002b54:	e17f5204 	addi	r5,fp,-696
 8002b58:	2909883a 	add	r4,r5,r4
 8002b5c:	21807504 	addi	r6,r4,468
 8002b60:	31000017 	ldw	r4,0(r6)
 8002b64:	31400117 	ldw	r5,4(r6)
 8002b68:	200d883a 	mov	r6,r4
 8002b6c:	280f883a 	mov	r7,r5
 8002b70:	1009883a 	mov	r4,r2
 8002b74:	180b883a 	mov	r5,r3
 8002b78:	8004ad00 	call	8004ad0 <__muldf3>
 8002b7c:	1009883a 	mov	r4,r2
 8002b80:	180b883a 	mov	r5,r3
 8002b84:	2005883a 	mov	r2,r4
 8002b88:	2807883a 	mov	r3,r5
 8002b8c:	100d883a 	mov	r6,r2
 8002b90:	180f883a 	mov	r7,r3
 8002b94:	e13f5d17 	ldw	r4,-652(fp)
 8002b98:	e17f5e17 	ldw	r5,-648(fp)
 8002b9c:	80040c00 	call	80040c0 <__adddf3>
 8002ba0:	1009883a 	mov	r4,r2
 8002ba4:	180b883a 	mov	r5,r3
 8002ba8:	e13f5d15 	stw	r4,-652(fp)
 8002bac:	e17f5e15 	stw	r5,-648(fp)
 8002bb0:	e0bf5817 	ldw	r2,-672(fp)
 8002bb4:	10800044 	addi	r2,r2,1
 8002bb8:	e0bf5815 	stw	r2,-672(fp)
 8002bbc:	e0bf5817 	ldw	r2,-672(fp)
 8002bc0:	e0ff6017 	ldw	r3,-640(fp)
 8002bc4:	18800516 	blt	r3,r2,8002bdc <__kernel_rem_pio2+0xda8>
 8002bc8:	e0ff5217 	ldw	r3,-696(fp)
 8002bcc:	e0bf5617 	ldw	r2,-680(fp)
 8002bd0:	1887c83a 	sub	r3,r3,r2
 8002bd4:	e0bf5817 	ldw	r2,-672(fp)
 8002bd8:	18bfd30e 	bge	r3,r2,8002b28 <__kernel_rem_pio2+0xcf4>
	    fq[jz-i] = fw;
 8002bdc:	e0ff5217 	ldw	r3,-696(fp)
 8002be0:	e0bf5617 	ldw	r2,-680(fp)
 8002be4:	1885c83a 	sub	r2,r3,r2
 8002be8:	100490fa 	slli	r2,r2,3
 8002bec:	e0ff5204 	addi	r3,fp,-696
 8002bf0:	1885883a 	add	r2,r3,r2
 8002bf4:	10804d04 	addi	r2,r2,308
 8002bf8:	e0ff5d17 	ldw	r3,-652(fp)
 8002bfc:	10c00015 	stw	r3,0(r2)
 8002c00:	e0ff5e17 	ldw	r3,-648(fp)
 8002c04:	10c00115 	stw	r3,4(r2)
	for(i=jz;i>=0;i--) {
	    q[i] = fw*(double)iq[i]; fw*=twon24;
	}

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
	for(i=jz;i>=0;i--) {
 8002c08:	e0bf5617 	ldw	r2,-680(fp)
 8002c0c:	10bfffc4 	addi	r2,r2,-1
 8002c10:	e0bf5615 	stw	r2,-680(fp)
 8002c14:	e0bf5617 	ldw	r2,-680(fp)
 8002c18:	103fbf0e 	bge	r2,zero,8002b18 <__kernel_rem_pio2+0xce4>
	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
	    fq[jz-i] = fw;
	}

    /* compress fq[] into y[] */
	switch(prec) {
 8002c1c:	e0800217 	ldw	r2,8(fp)
 8002c20:	10c000c8 	cmpgei	r3,r2,3
 8002c24:	1800031e 	bne	r3,zero,8002c34 <__kernel_rem_pio2+0xe00>
 8002c28:	00802b16 	blt	zero,r2,8002cd8 <__kernel_rem_pio2+0xea4>
 8002c2c:	10000426 	beq	r2,zero,8002c40 <__kernel_rem_pio2+0xe0c>
 8002c30:	00016f06 	br	80031f0 <__kernel_rem_pio2+0x13bc>
 8002c34:	108000e0 	cmpeqi	r2,r2,3
 8002c38:	10007d1e 	bne	r2,zero,8002e30 <__kernel_rem_pio2+0xffc>
 8002c3c:	00016c06 	br	80031f0 <__kernel_rem_pio2+0x13bc>
	    case 0:
		fw = 0.0;
 8002c40:	e03f5d15 	stw	zero,-652(fp)
 8002c44:	e03f5e15 	stw	zero,-648(fp)
		for (i=jz;i>=0;i--) fw += fq[i];
 8002c48:	e0bf5217 	ldw	r2,-696(fp)
 8002c4c:	e0bf5615 	stw	r2,-680(fp)
 8002c50:	00001306 	br	8002ca0 <__kernel_rem_pio2+0xe6c>
 8002c54:	e0bf5617 	ldw	r2,-680(fp)
 8002c58:	100490fa 	slli	r2,r2,3
 8002c5c:	e13f5204 	addi	r4,fp,-696
 8002c60:	2085883a 	add	r2,r4,r2
 8002c64:	11004d04 	addi	r4,r2,308
 8002c68:	20800017 	ldw	r2,0(r4)
 8002c6c:	20c00117 	ldw	r3,4(r4)
 8002c70:	100d883a 	mov	r6,r2
 8002c74:	180f883a 	mov	r7,r3
 8002c78:	e13f5d17 	ldw	r4,-652(fp)
 8002c7c:	e17f5e17 	ldw	r5,-648(fp)
 8002c80:	80040c00 	call	80040c0 <__adddf3>
 8002c84:	1009883a 	mov	r4,r2
 8002c88:	180b883a 	mov	r5,r3
 8002c8c:	e13f5d15 	stw	r4,-652(fp)
 8002c90:	e17f5e15 	stw	r5,-648(fp)
 8002c94:	e0bf5617 	ldw	r2,-680(fp)
 8002c98:	10bfffc4 	addi	r2,r2,-1
 8002c9c:	e0bf5615 	stw	r2,-680(fp)
 8002ca0:	e0bf5617 	ldw	r2,-680(fp)
 8002ca4:	103feb0e 	bge	r2,zero,8002c54 <__kernel_rem_pio2+0xe20>
		y[0] = (ih==0)? fw: -fw; 
 8002ca8:	e0bf5a17 	ldw	r2,-664(fp)
 8002cac:	10000426 	beq	r2,zero,8002cc0 <__kernel_rem_pio2+0xe8c>
 8002cb0:	e53f5d17 	ldw	r20,-652(fp)
 8002cb4:	e0bf5e17 	ldw	r2,-648(fp)
 8002cb8:	1560003c 	xorhi	r21,r2,32768
 8002cbc:	00000206 	br	8002cc8 <__kernel_rem_pio2+0xe94>
 8002cc0:	e53f5d17 	ldw	r20,-652(fp)
 8002cc4:	e57f5e17 	ldw	r21,-648(fp)
 8002cc8:	e0bff017 	ldw	r2,-64(fp)
 8002ccc:	15000015 	stw	r20,0(r2)
 8002cd0:	15400115 	stw	r21,4(r2)
		break;
 8002cd4:	00014606 	br	80031f0 <__kernel_rem_pio2+0x13bc>
	    case 1:
	    case 2:
		fw = 0.0;
 8002cd8:	e03f5d15 	stw	zero,-652(fp)
 8002cdc:	e03f5e15 	stw	zero,-648(fp)
		for (i=jz;i>=0;i--) fw += fq[i]; 
 8002ce0:	e0bf5217 	ldw	r2,-696(fp)
 8002ce4:	e0bf5615 	stw	r2,-680(fp)
 8002ce8:	00001306 	br	8002d38 <__kernel_rem_pio2+0xf04>
 8002cec:	e0bf5617 	ldw	r2,-680(fp)
 8002cf0:	100490fa 	slli	r2,r2,3
 8002cf4:	e17f5204 	addi	r5,fp,-696
 8002cf8:	2885883a 	add	r2,r5,r2
 8002cfc:	11004d04 	addi	r4,r2,308
 8002d00:	20800017 	ldw	r2,0(r4)
 8002d04:	20c00117 	ldw	r3,4(r4)
 8002d08:	100d883a 	mov	r6,r2
 8002d0c:	180f883a 	mov	r7,r3
 8002d10:	e13f5d17 	ldw	r4,-652(fp)
 8002d14:	e17f5e17 	ldw	r5,-648(fp)
 8002d18:	80040c00 	call	80040c0 <__adddf3>
 8002d1c:	1009883a 	mov	r4,r2
 8002d20:	180b883a 	mov	r5,r3
 8002d24:	e13f5d15 	stw	r4,-652(fp)
 8002d28:	e17f5e15 	stw	r5,-648(fp)
 8002d2c:	e0bf5617 	ldw	r2,-680(fp)
 8002d30:	10bfffc4 	addi	r2,r2,-1
 8002d34:	e0bf5615 	stw	r2,-680(fp)
 8002d38:	e0bf5617 	ldw	r2,-680(fp)
 8002d3c:	103feb0e 	bge	r2,zero,8002cec <__kernel_rem_pio2+0xeb8>
		y[0] = (ih==0)? fw: -fw; 
 8002d40:	e0bf5a17 	ldw	r2,-664(fp)
 8002d44:	10000426 	beq	r2,zero,8002d58 <__kernel_rem_pio2+0xf24>
 8002d48:	e4bf5d17 	ldw	r18,-652(fp)
 8002d4c:	e0bf5e17 	ldw	r2,-648(fp)
 8002d50:	14e0003c 	xorhi	r19,r2,32768
 8002d54:	00000206 	br	8002d60 <__kernel_rem_pio2+0xf2c>
 8002d58:	e4bf5d17 	ldw	r18,-652(fp)
 8002d5c:	e4ff5e17 	ldw	r19,-648(fp)
 8002d60:	e0bff017 	ldw	r2,-64(fp)
 8002d64:	14800015 	stw	r18,0(r2)
 8002d68:	14c00115 	stw	r19,4(r2)
		fw = fq[0]-fw;
 8002d6c:	e0bf9f17 	ldw	r2,-388(fp)
 8002d70:	e0ffa017 	ldw	r3,-384(fp)
 8002d74:	e1bf5d17 	ldw	r6,-652(fp)
 8002d78:	e1ff5e17 	ldw	r7,-648(fp)
 8002d7c:	1009883a 	mov	r4,r2
 8002d80:	180b883a 	mov	r5,r3
 8002d84:	80051e80 	call	80051e8 <__subdf3>
 8002d88:	1009883a 	mov	r4,r2
 8002d8c:	180b883a 	mov	r5,r3
 8002d90:	e13f5d15 	stw	r4,-652(fp)
 8002d94:	e17f5e15 	stw	r5,-648(fp)
		for (i=1;i<=jz;i++) fw += fq[i];
 8002d98:	00800044 	movi	r2,1
 8002d9c:	e0bf5615 	stw	r2,-680(fp)
 8002da0:	00001306 	br	8002df0 <__kernel_rem_pio2+0xfbc>
 8002da4:	e0bf5617 	ldw	r2,-680(fp)
 8002da8:	100490fa 	slli	r2,r2,3
 8002dac:	e0ff5204 	addi	r3,fp,-696
 8002db0:	1885883a 	add	r2,r3,r2
 8002db4:	11004d04 	addi	r4,r2,308
 8002db8:	20800017 	ldw	r2,0(r4)
 8002dbc:	20c00117 	ldw	r3,4(r4)
 8002dc0:	100d883a 	mov	r6,r2
 8002dc4:	180f883a 	mov	r7,r3
 8002dc8:	e13f5d17 	ldw	r4,-652(fp)
 8002dcc:	e17f5e17 	ldw	r5,-648(fp)
 8002dd0:	80040c00 	call	80040c0 <__adddf3>
 8002dd4:	1009883a 	mov	r4,r2
 8002dd8:	180b883a 	mov	r5,r3
 8002ddc:	e13f5d15 	stw	r4,-652(fp)
 8002de0:	e17f5e15 	stw	r5,-648(fp)
 8002de4:	e0bf5617 	ldw	r2,-680(fp)
 8002de8:	10800044 	addi	r2,r2,1
 8002dec:	e0bf5615 	stw	r2,-680(fp)
 8002df0:	e0bf5617 	ldw	r2,-680(fp)
 8002df4:	e0ff5217 	ldw	r3,-696(fp)
 8002df8:	18bfea0e 	bge	r3,r2,8002da4 <__kernel_rem_pio2+0xf70>
		y[1] = (ih==0)? fw: -fw; 
 8002dfc:	e0bff017 	ldw	r2,-64(fp)
 8002e00:	10800204 	addi	r2,r2,8
 8002e04:	e0ff5a17 	ldw	r3,-664(fp)
 8002e08:	18000426 	beq	r3,zero,8002e1c <__kernel_rem_pio2+0xfe8>
 8002e0c:	e43f5d17 	ldw	r16,-652(fp)
 8002e10:	e0ff5e17 	ldw	r3,-648(fp)
 8002e14:	1c60003c 	xorhi	r17,r3,32768
 8002e18:	00000206 	br	8002e24 <__kernel_rem_pio2+0xff0>
 8002e1c:	e43f5d17 	ldw	r16,-652(fp)
 8002e20:	e47f5e17 	ldw	r17,-648(fp)
 8002e24:	14000015 	stw	r16,0(r2)
 8002e28:	14400115 	stw	r17,4(r2)
		break;
 8002e2c:	0000f006 	br	80031f0 <__kernel_rem_pio2+0x13bc>
	    case 3:	/* painful */
		for (i=jz;i>0;i--) {
 8002e30:	e0bf5217 	ldw	r2,-696(fp)
 8002e34:	e0bf5615 	stw	r2,-680(fp)
 8002e38:	00004d06 	br	8002f70 <__kernel_rem_pio2+0x113c>
		    fw      = fq[i-1]+fq[i]; 
 8002e3c:	e0bf5617 	ldw	r2,-680(fp)
 8002e40:	10bfffc4 	addi	r2,r2,-1
 8002e44:	100490fa 	slli	r2,r2,3
 8002e48:	e13f5204 	addi	r4,fp,-696
 8002e4c:	2085883a 	add	r2,r4,r2
 8002e50:	11004d04 	addi	r4,r2,308
 8002e54:	20800017 	ldw	r2,0(r4)
 8002e58:	20c00117 	ldw	r3,4(r4)
 8002e5c:	e13f5617 	ldw	r4,-680(fp)
 8002e60:	200890fa 	slli	r4,r4,3
 8002e64:	e17f5204 	addi	r5,fp,-696
 8002e68:	2909883a 	add	r4,r5,r4
 8002e6c:	21804d04 	addi	r6,r4,308
 8002e70:	31000017 	ldw	r4,0(r6)
 8002e74:	31400117 	ldw	r5,4(r6)
 8002e78:	200d883a 	mov	r6,r4
 8002e7c:	280f883a 	mov	r7,r5
 8002e80:	1009883a 	mov	r4,r2
 8002e84:	180b883a 	mov	r5,r3
 8002e88:	80040c00 	call	80040c0 <__adddf3>
 8002e8c:	1009883a 	mov	r4,r2
 8002e90:	180b883a 	mov	r5,r3
 8002e94:	e13f5d15 	stw	r4,-652(fp)
 8002e98:	e17f5e15 	stw	r5,-648(fp)
		    fq[i]  += fq[i-1]-fw;
 8002e9c:	e0bf5617 	ldw	r2,-680(fp)
 8002ea0:	100490fa 	slli	r2,r2,3
 8002ea4:	e0ff5204 	addi	r3,fp,-696
 8002ea8:	1885883a 	add	r2,r3,r2
 8002eac:	10804d04 	addi	r2,r2,308
 8002eb0:	14000017 	ldw	r16,0(r2)
 8002eb4:	14400117 	ldw	r17,4(r2)
 8002eb8:	e0bf5617 	ldw	r2,-680(fp)
 8002ebc:	10bfffc4 	addi	r2,r2,-1
 8002ec0:	100490fa 	slli	r2,r2,3
 8002ec4:	e13f5204 	addi	r4,fp,-696
 8002ec8:	2085883a 	add	r2,r4,r2
 8002ecc:	11004d04 	addi	r4,r2,308
 8002ed0:	20800017 	ldw	r2,0(r4)
 8002ed4:	20c00117 	ldw	r3,4(r4)
 8002ed8:	e1bf5d17 	ldw	r6,-652(fp)
 8002edc:	e1ff5e17 	ldw	r7,-648(fp)
 8002ee0:	1009883a 	mov	r4,r2
 8002ee4:	180b883a 	mov	r5,r3
 8002ee8:	80051e80 	call	80051e8 <__subdf3>
 8002eec:	1009883a 	mov	r4,r2
 8002ef0:	180b883a 	mov	r5,r3
 8002ef4:	2005883a 	mov	r2,r4
 8002ef8:	2807883a 	mov	r3,r5
 8002efc:	100d883a 	mov	r6,r2
 8002f00:	180f883a 	mov	r7,r3
 8002f04:	8009883a 	mov	r4,r16
 8002f08:	880b883a 	mov	r5,r17
 8002f0c:	80040c00 	call	80040c0 <__adddf3>
 8002f10:	1009883a 	mov	r4,r2
 8002f14:	180b883a 	mov	r5,r3
 8002f18:	2005883a 	mov	r2,r4
 8002f1c:	2807883a 	mov	r3,r5
 8002f20:	e13f5617 	ldw	r4,-680(fp)
 8002f24:	200890fa 	slli	r4,r4,3
 8002f28:	e17f5204 	addi	r5,fp,-696
 8002f2c:	2909883a 	add	r4,r5,r4
 8002f30:	21004d04 	addi	r4,r4,308
 8002f34:	20800015 	stw	r2,0(r4)
 8002f38:	20c00115 	stw	r3,4(r4)
		    fq[i-1] = fw;
 8002f3c:	e0bf5617 	ldw	r2,-680(fp)
 8002f40:	10bfffc4 	addi	r2,r2,-1
 8002f44:	100490fa 	slli	r2,r2,3
 8002f48:	e0ff5204 	addi	r3,fp,-696
 8002f4c:	1885883a 	add	r2,r3,r2
 8002f50:	10804d04 	addi	r2,r2,308
 8002f54:	e0ff5d17 	ldw	r3,-652(fp)
 8002f58:	10c00015 	stw	r3,0(r2)
 8002f5c:	e0ff5e17 	ldw	r3,-648(fp)
 8002f60:	10c00115 	stw	r3,4(r2)
		fw = fq[0]-fw;
		for (i=1;i<=jz;i++) fw += fq[i];
		y[1] = (ih==0)? fw: -fw; 
		break;
	    case 3:	/* painful */
		for (i=jz;i>0;i--) {
 8002f64:	e0bf5617 	ldw	r2,-680(fp)
 8002f68:	10bfffc4 	addi	r2,r2,-1
 8002f6c:	e0bf5615 	stw	r2,-680(fp)
 8002f70:	e0bf5617 	ldw	r2,-680(fp)
 8002f74:	00bfb116 	blt	zero,r2,8002e3c <__kernel_rem_pio2+0x1008>
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (i=jz;i>1;i--) {
 8002f78:	e0bf5217 	ldw	r2,-696(fp)
 8002f7c:	e0bf5615 	stw	r2,-680(fp)
 8002f80:	00004d06 	br	80030b8 <__kernel_rem_pio2+0x1284>
		    fw      = fq[i-1]+fq[i]; 
 8002f84:	e0bf5617 	ldw	r2,-680(fp)
 8002f88:	10bfffc4 	addi	r2,r2,-1
 8002f8c:	100490fa 	slli	r2,r2,3
 8002f90:	e13f5204 	addi	r4,fp,-696
 8002f94:	2085883a 	add	r2,r4,r2
 8002f98:	11004d04 	addi	r4,r2,308
 8002f9c:	20800017 	ldw	r2,0(r4)
 8002fa0:	20c00117 	ldw	r3,4(r4)
 8002fa4:	e13f5617 	ldw	r4,-680(fp)
 8002fa8:	200890fa 	slli	r4,r4,3
 8002fac:	e17f5204 	addi	r5,fp,-696
 8002fb0:	2909883a 	add	r4,r5,r4
 8002fb4:	21804d04 	addi	r6,r4,308
 8002fb8:	31000017 	ldw	r4,0(r6)
 8002fbc:	31400117 	ldw	r5,4(r6)
 8002fc0:	200d883a 	mov	r6,r4
 8002fc4:	280f883a 	mov	r7,r5
 8002fc8:	1009883a 	mov	r4,r2
 8002fcc:	180b883a 	mov	r5,r3
 8002fd0:	80040c00 	call	80040c0 <__adddf3>
 8002fd4:	1009883a 	mov	r4,r2
 8002fd8:	180b883a 	mov	r5,r3
 8002fdc:	e13f5d15 	stw	r4,-652(fp)
 8002fe0:	e17f5e15 	stw	r5,-648(fp)
		    fq[i]  += fq[i-1]-fw;
 8002fe4:	e0bf5617 	ldw	r2,-680(fp)
 8002fe8:	100490fa 	slli	r2,r2,3
 8002fec:	e0ff5204 	addi	r3,fp,-696
 8002ff0:	1885883a 	add	r2,r3,r2
 8002ff4:	10804d04 	addi	r2,r2,308
 8002ff8:	14000017 	ldw	r16,0(r2)
 8002ffc:	14400117 	ldw	r17,4(r2)
 8003000:	e0bf5617 	ldw	r2,-680(fp)
 8003004:	10bfffc4 	addi	r2,r2,-1
 8003008:	100490fa 	slli	r2,r2,3
 800300c:	e13f5204 	addi	r4,fp,-696
 8003010:	2085883a 	add	r2,r4,r2
 8003014:	11004d04 	addi	r4,r2,308
 8003018:	20800017 	ldw	r2,0(r4)
 800301c:	20c00117 	ldw	r3,4(r4)
 8003020:	e1bf5d17 	ldw	r6,-652(fp)
 8003024:	e1ff5e17 	ldw	r7,-648(fp)
 8003028:	1009883a 	mov	r4,r2
 800302c:	180b883a 	mov	r5,r3
 8003030:	80051e80 	call	80051e8 <__subdf3>
 8003034:	1009883a 	mov	r4,r2
 8003038:	180b883a 	mov	r5,r3
 800303c:	2005883a 	mov	r2,r4
 8003040:	2807883a 	mov	r3,r5
 8003044:	100d883a 	mov	r6,r2
 8003048:	180f883a 	mov	r7,r3
 800304c:	8009883a 	mov	r4,r16
 8003050:	880b883a 	mov	r5,r17
 8003054:	80040c00 	call	80040c0 <__adddf3>
 8003058:	1009883a 	mov	r4,r2
 800305c:	180b883a 	mov	r5,r3
 8003060:	2005883a 	mov	r2,r4
 8003064:	2807883a 	mov	r3,r5
 8003068:	e13f5617 	ldw	r4,-680(fp)
 800306c:	200890fa 	slli	r4,r4,3
 8003070:	e17f5204 	addi	r5,fp,-696
 8003074:	2909883a 	add	r4,r5,r4
 8003078:	21004d04 	addi	r4,r4,308
 800307c:	20800015 	stw	r2,0(r4)
 8003080:	20c00115 	stw	r3,4(r4)
		    fq[i-1] = fw;
 8003084:	e0bf5617 	ldw	r2,-680(fp)
 8003088:	10bfffc4 	addi	r2,r2,-1
 800308c:	100490fa 	slli	r2,r2,3
 8003090:	e0ff5204 	addi	r3,fp,-696
 8003094:	1885883a 	add	r2,r3,r2
 8003098:	10804d04 	addi	r2,r2,308
 800309c:	e0ff5d17 	ldw	r3,-652(fp)
 80030a0:	10c00015 	stw	r3,0(r2)
 80030a4:	e0ff5e17 	ldw	r3,-648(fp)
 80030a8:	10c00115 	stw	r3,4(r2)
		for (i=jz;i>0;i--) {
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (i=jz;i>1;i--) {
 80030ac:	e0bf5617 	ldw	r2,-680(fp)
 80030b0:	10bfffc4 	addi	r2,r2,-1
 80030b4:	e0bf5615 	stw	r2,-680(fp)
 80030b8:	e0bf5617 	ldw	r2,-680(fp)
 80030bc:	10800088 	cmpgei	r2,r2,2
 80030c0:	103fb01e 	bne	r2,zero,8002f84 <__kernel_rem_pio2+0x1150>
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (fw=0.0,i=jz;i>=2;i--) fw += fq[i]; 
 80030c4:	e03f5d15 	stw	zero,-652(fp)
 80030c8:	e03f5e15 	stw	zero,-648(fp)
 80030cc:	e0bf5217 	ldw	r2,-696(fp)
 80030d0:	e0bf5615 	stw	r2,-680(fp)
 80030d4:	00001306 	br	8003124 <__kernel_rem_pio2+0x12f0>
 80030d8:	e0bf5617 	ldw	r2,-680(fp)
 80030dc:	100490fa 	slli	r2,r2,3
 80030e0:	e13f5204 	addi	r4,fp,-696
 80030e4:	2085883a 	add	r2,r4,r2
 80030e8:	11004d04 	addi	r4,r2,308
 80030ec:	20800017 	ldw	r2,0(r4)
 80030f0:	20c00117 	ldw	r3,4(r4)
 80030f4:	100d883a 	mov	r6,r2
 80030f8:	180f883a 	mov	r7,r3
 80030fc:	e13f5d17 	ldw	r4,-652(fp)
 8003100:	e17f5e17 	ldw	r5,-648(fp)
 8003104:	80040c00 	call	80040c0 <__adddf3>
 8003108:	1009883a 	mov	r4,r2
 800310c:	180b883a 	mov	r5,r3
 8003110:	e13f5d15 	stw	r4,-652(fp)
 8003114:	e17f5e15 	stw	r5,-648(fp)
 8003118:	e0bf5617 	ldw	r2,-680(fp)
 800311c:	10bfffc4 	addi	r2,r2,-1
 8003120:	e0bf5615 	stw	r2,-680(fp)
 8003124:	e0bf5617 	ldw	r2,-680(fp)
 8003128:	10800088 	cmpgei	r2,r2,2
 800312c:	103fea1e 	bne	r2,zero,80030d8 <__kernel_rem_pio2+0x12a4>
		if(ih==0) {
 8003130:	e0bf5a17 	ldw	r2,-664(fp)
 8003134:	1000121e 	bne	r2,zero,8003180 <__kernel_rem_pio2+0x134c>
		    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;
 8003138:	e0bf9f17 	ldw	r2,-388(fp)
 800313c:	e0ffa017 	ldw	r3,-384(fp)
 8003140:	e13ff017 	ldw	r4,-64(fp)
 8003144:	20800015 	stw	r2,0(r4)
 8003148:	20c00115 	stw	r3,4(r4)
 800314c:	e0bff017 	ldw	r2,-64(fp)
 8003150:	11000204 	addi	r4,r2,8
 8003154:	e0bfa117 	ldw	r2,-380(fp)
 8003158:	e0ffa217 	ldw	r3,-376(fp)
 800315c:	20800015 	stw	r2,0(r4)
 8003160:	20c00115 	stw	r3,4(r4)
 8003164:	e0bff017 	ldw	r2,-64(fp)
 8003168:	10800404 	addi	r2,r2,16
 800316c:	e0ff5d17 	ldw	r3,-652(fp)
 8003170:	10c00015 	stw	r3,0(r2)
 8003174:	e0ff5e17 	ldw	r3,-648(fp)
 8003178:	10c00115 	stw	r3,4(r2)
 800317c:	00001c06 	br	80031f0 <__kernel_rem_pio2+0x13bc>
		} else {
		    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
 8003180:	e0bf9f17 	ldw	r2,-388(fp)
 8003184:	e0ffa017 	ldw	r3,-384(fp)
 8003188:	e0bff415 	stw	r2,-48(fp)
 800318c:	1960003c 	xorhi	r5,r3,32768
 8003190:	e17ff515 	stw	r5,-44(fp)
 8003194:	e0bff017 	ldw	r2,-64(fp)
 8003198:	e0fff417 	ldw	r3,-48(fp)
 800319c:	10c00015 	stw	r3,0(r2)
 80031a0:	e13ff517 	ldw	r4,-44(fp)
 80031a4:	11000115 	stw	r4,4(r2)
 80031a8:	e0bff017 	ldw	r2,-64(fp)
 80031ac:	11000204 	addi	r4,r2,8
 80031b0:	e0bfa117 	ldw	r2,-380(fp)
 80031b4:	e0ffa217 	ldw	r3,-376(fp)
 80031b8:	e0bff615 	stw	r2,-40(fp)
 80031bc:	1960003c 	xorhi	r5,r3,32768
 80031c0:	e17ff715 	stw	r5,-36(fp)
 80031c4:	e0bff617 	ldw	r2,-40(fp)
 80031c8:	20800015 	stw	r2,0(r4)
 80031cc:	e0fff717 	ldw	r3,-36(fp)
 80031d0:	20c00115 	stw	r3,4(r4)
 80031d4:	e0bff017 	ldw	r2,-64(fp)
 80031d8:	10800404 	addi	r2,r2,16
 80031dc:	e5bf5d17 	ldw	r22,-652(fp)
 80031e0:	e0ff5e17 	ldw	r3,-648(fp)
 80031e4:	1de0003c 	xorhi	r23,r3,32768
 80031e8:	15800015 	stw	r22,0(r2)
 80031ec:	15c00115 	stw	r23,4(r2)
		}
	}
	return n&7;
 80031f0:	e0bf5517 	ldw	r2,-684(fp)
 80031f4:	108001cc 	andi	r2,r2,7
}
 80031f8:	e6fff804 	addi	sp,fp,-32
 80031fc:	dfc00917 	ldw	ra,36(sp)
 8003200:	df000817 	ldw	fp,32(sp)
 8003204:	ddc00717 	ldw	r23,28(sp)
 8003208:	dd800617 	ldw	r22,24(sp)
 800320c:	dd400517 	ldw	r21,20(sp)
 8003210:	dd000417 	ldw	r20,16(sp)
 8003214:	dcc00317 	ldw	r19,12(sp)
 8003218:	dc800217 	ldw	r18,8(sp)
 800321c:	dc400117 	ldw	r17,4(sp)
 8003220:	dc000017 	ldw	r16,0(sp)
 8003224:	dec00a04 	addi	sp,sp,40
 8003228:	f800283a 	ret

0800322c <__kernel_sin>:
	double __kernel_sin(double x, double y, int iy)
#else
	double __kernel_sin(x, y, iy)
	double x,y; int iy;		/* iy=0 if y is zero */
#endif
{
 800322c:	deffef04 	addi	sp,sp,-68
 8003230:	dfc01015 	stw	ra,64(sp)
 8003234:	df000f15 	stw	fp,60(sp)
 8003238:	dc400e15 	stw	r17,56(sp)
 800323c:	dc000d15 	stw	r16,52(sp)
 8003240:	df000f04 	addi	fp,sp,60
 8003244:	e13ffa15 	stw	r4,-24(fp)
 8003248:	e17ffb15 	stw	r5,-20(fp)
 800324c:	e1bffc15 	stw	r6,-16(fp)
 8003250:	e1fffd15 	stw	r7,-12(fp)
	double z,r,v;
	__int32_t ix;
	GET_HIGH_WORD(ix,x);
 8003254:	e0bffa17 	ldw	r2,-24(fp)
 8003258:	e0bff815 	stw	r2,-32(fp)
 800325c:	e0bffb17 	ldw	r2,-20(fp)
 8003260:	e0bff915 	stw	r2,-28(fp)
 8003264:	e0bff917 	ldw	r2,-28(fp)
 8003268:	e0bff115 	stw	r2,-60(fp)
	ix &= 0x7fffffff;			/* high word of x */
 800326c:	e0fff117 	ldw	r3,-60(fp)
 8003270:	00a00034 	movhi	r2,32768
 8003274:	10bfffc4 	addi	r2,r2,-1
 8003278:	1884703a 	and	r2,r3,r2
 800327c:	e0bff115 	stw	r2,-60(fp)
	if(ix<0x3e400000)			/* |x| < 2**-27 */
 8003280:	e0fff117 	ldw	r3,-60(fp)
 8003284:	008f9034 	movhi	r2,15936
 8003288:	1880070e 	bge	r3,r2,80032a8 <__kernel_sin+0x7c>
	   {if((int)x==0) return x;}		/* generate inexact */
 800328c:	e13ffa17 	ldw	r4,-24(fp)
 8003290:	e17ffb17 	ldw	r5,-20(fp)
 8003294:	8005ae40 	call	8005ae4 <__fixdfsi>
 8003298:	1000031e 	bne	r2,zero,80032a8 <__kernel_sin+0x7c>
 800329c:	e0bffa17 	ldw	r2,-24(fp)
 80032a0:	e0fffb17 	ldw	r3,-20(fp)
 80032a4:	0000e706 	br	8003644 <__kernel_sin+0x418>
	z	=  x*x;
 80032a8:	e1bffa17 	ldw	r6,-24(fp)
 80032ac:	e1fffb17 	ldw	r7,-20(fp)
 80032b0:	e13ffa17 	ldw	r4,-24(fp)
 80032b4:	e17ffb17 	ldw	r5,-20(fp)
 80032b8:	8004ad00 	call	8004ad0 <__muldf3>
 80032bc:	1009883a 	mov	r4,r2
 80032c0:	180b883a 	mov	r5,r3
 80032c4:	e13ff215 	stw	r4,-56(fp)
 80032c8:	e17ff315 	stw	r5,-52(fp)
	v	=  z*x;
 80032cc:	e1bffa17 	ldw	r6,-24(fp)
 80032d0:	e1fffb17 	ldw	r7,-20(fp)
 80032d4:	e13ff217 	ldw	r4,-56(fp)
 80032d8:	e17ff317 	ldw	r5,-52(fp)
 80032dc:	8004ad00 	call	8004ad0 <__muldf3>
 80032e0:	1009883a 	mov	r4,r2
 80032e4:	180b883a 	mov	r5,r3
 80032e8:	e13ff415 	stw	r4,-48(fp)
 80032ec:	e17ff515 	stw	r5,-44(fp)
	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
 80032f0:	0096b434 	movhi	r2,23248
 80032f4:	10b55f04 	addi	r2,r2,-10884
 80032f8:	00cf79b4 	movhi	r3,15846
 80032fc:	18f64e84 	addi	r3,r3,-9926
 8003300:	e1bff217 	ldw	r6,-56(fp)
 8003304:	e1fff317 	ldw	r7,-52(fp)
 8003308:	1009883a 	mov	r4,r2
 800330c:	180b883a 	mov	r5,r3
 8003310:	8004ad00 	call	8004ad0 <__muldf3>
 8003314:	1009883a 	mov	r4,r2
 8003318:	180b883a 	mov	r5,r3
 800331c:	2011883a 	mov	r8,r4
 8003320:	2813883a 	mov	r9,r5
 8003324:	00a28b34 	movhi	r2,35372
 8003328:	10a73ac4 	addi	r2,r2,-25365
 800332c:	00ef96f4 	movhi	r3,48731
 8003330:	18f97984 	addi	r3,r3,-6682
 8003334:	100d883a 	mov	r6,r2
 8003338:	180f883a 	mov	r7,r3
 800333c:	4009883a 	mov	r4,r8
 8003340:	480b883a 	mov	r5,r9
 8003344:	80040c00 	call	80040c0 <__adddf3>
 8003348:	1009883a 	mov	r4,r2
 800334c:	180b883a 	mov	r5,r3
 8003350:	2005883a 	mov	r2,r4
 8003354:	2807883a 	mov	r3,r5
 8003358:	e1bff217 	ldw	r6,-56(fp)
 800335c:	e1fff317 	ldw	r7,-52(fp)
 8003360:	1009883a 	mov	r4,r2
 8003364:	180b883a 	mov	r5,r3
 8003368:	8004ad00 	call	8004ad0 <__muldf3>
 800336c:	1009883a 	mov	r4,r2
 8003370:	180b883a 	mov	r5,r3
 8003374:	2011883a 	mov	r8,r4
 8003378:	2813883a 	mov	r9,r5
 800337c:	0095ecb4 	movhi	r2,22450
 8003380:	10bf9f44 	addi	r2,r2,-387
 8003384:	00cfb1f4 	movhi	r3,16071
 8003388:	18c778c4 	addi	r3,r3,7651
 800338c:	100d883a 	mov	r6,r2
 8003390:	180f883a 	mov	r7,r3
 8003394:	4009883a 	mov	r4,r8
 8003398:	480b883a 	mov	r5,r9
 800339c:	80040c00 	call	80040c0 <__adddf3>
 80033a0:	1009883a 	mov	r4,r2
 80033a4:	180b883a 	mov	r5,r3
 80033a8:	2005883a 	mov	r2,r4
 80033ac:	2807883a 	mov	r3,r5
 80033b0:	e1bff217 	ldw	r6,-56(fp)
 80033b4:	e1fff317 	ldw	r7,-52(fp)
 80033b8:	1009883a 	mov	r4,r2
 80033bc:	180b883a 	mov	r5,r3
 80033c0:	8004ad00 	call	8004ad0 <__muldf3>
 80033c4:	1009883a 	mov	r4,r2
 80033c8:	180b883a 	mov	r5,r3
 80033cc:	2011883a 	mov	r8,r4
 80033d0:	2813883a 	mov	r9,r5
 80033d4:	00867074 	movhi	r2,6593
 80033d8:	10987544 	addi	r2,r2,25045
 80033dc:	00efcab4 	movhi	r3,48938
 80033e0:	18c06804 	addi	r3,r3,416
 80033e4:	100d883a 	mov	r6,r2
 80033e8:	180f883a 	mov	r7,r3
 80033ec:	4009883a 	mov	r4,r8
 80033f0:	480b883a 	mov	r5,r9
 80033f4:	80040c00 	call	80040c0 <__adddf3>
 80033f8:	1009883a 	mov	r4,r2
 80033fc:	180b883a 	mov	r5,r3
 8003400:	2005883a 	mov	r2,r4
 8003404:	2807883a 	mov	r3,r5
 8003408:	e1bff217 	ldw	r6,-56(fp)
 800340c:	e1fff317 	ldw	r7,-52(fp)
 8003410:	1009883a 	mov	r4,r2
 8003414:	180b883a 	mov	r5,r3
 8003418:	8004ad00 	call	8004ad0 <__muldf3>
 800341c:	1009883a 	mov	r4,r2
 8003420:	180b883a 	mov	r5,r3
 8003424:	2011883a 	mov	r8,r4
 8003428:	2813883a 	mov	r9,r5
 800342c:	00844474 	movhi	r2,4369
 8003430:	10be2984 	addi	r2,r2,-1882
 8003434:	00cfe074 	movhi	r3,16257
 8003438:	18c44444 	addi	r3,r3,4369
 800343c:	100d883a 	mov	r6,r2
 8003440:	180f883a 	mov	r7,r3
 8003444:	4009883a 	mov	r4,r8
 8003448:	480b883a 	mov	r5,r9
 800344c:	80040c00 	call	80040c0 <__adddf3>
 8003450:	1009883a 	mov	r4,r2
 8003454:	180b883a 	mov	r5,r3
 8003458:	e13ff615 	stw	r4,-40(fp)
 800345c:	e17ff715 	stw	r5,-36(fp)
	if(iy==0) return x+v*(S1+z*r);
 8003460:	e0800217 	ldw	r2,8(fp)
 8003464:	1000291e 	bne	r2,zero,800350c <__kernel_sin+0x2e0>
 8003468:	e1bff617 	ldw	r6,-40(fp)
 800346c:	e1fff717 	ldw	r7,-36(fp)
 8003470:	e13ff217 	ldw	r4,-56(fp)
 8003474:	e17ff317 	ldw	r5,-52(fp)
 8003478:	8004ad00 	call	8004ad0 <__muldf3>
 800347c:	1009883a 	mov	r4,r2
 8003480:	180b883a 	mov	r5,r3
 8003484:	2011883a 	mov	r8,r4
 8003488:	2813883a 	mov	r9,r5
 800348c:	00955574 	movhi	r2,21845
 8003490:	10955244 	addi	r2,r2,21833
 8003494:	00eff174 	movhi	r3,49093
 8003498:	18d55544 	addi	r3,r3,21845
 800349c:	100d883a 	mov	r6,r2
 80034a0:	180f883a 	mov	r7,r3
 80034a4:	4009883a 	mov	r4,r8
 80034a8:	480b883a 	mov	r5,r9
 80034ac:	80040c00 	call	80040c0 <__adddf3>
 80034b0:	1009883a 	mov	r4,r2
 80034b4:	180b883a 	mov	r5,r3
 80034b8:	2005883a 	mov	r2,r4
 80034bc:	2807883a 	mov	r3,r5
 80034c0:	e1bff417 	ldw	r6,-48(fp)
 80034c4:	e1fff517 	ldw	r7,-44(fp)
 80034c8:	1009883a 	mov	r4,r2
 80034cc:	180b883a 	mov	r5,r3
 80034d0:	8004ad00 	call	8004ad0 <__muldf3>
 80034d4:	1009883a 	mov	r4,r2
 80034d8:	180b883a 	mov	r5,r3
 80034dc:	2005883a 	mov	r2,r4
 80034e0:	2807883a 	mov	r3,r5
 80034e4:	e1bffa17 	ldw	r6,-24(fp)
 80034e8:	e1fffb17 	ldw	r7,-20(fp)
 80034ec:	1009883a 	mov	r4,r2
 80034f0:	180b883a 	mov	r5,r3
 80034f4:	80040c00 	call	80040c0 <__adddf3>
 80034f8:	1009883a 	mov	r4,r2
 80034fc:	180b883a 	mov	r5,r3
 8003500:	2005883a 	mov	r2,r4
 8003504:	2807883a 	mov	r3,r5
 8003508:	00004e06 	br	8003644 <__kernel_sin+0x418>
	else      return x-((z*(half*y-v*r)-y)-v*S1);
 800350c:	0005883a 	mov	r2,zero
 8003510:	00cff834 	movhi	r3,16352
 8003514:	e1bffc17 	ldw	r6,-16(fp)
 8003518:	e1fffd17 	ldw	r7,-12(fp)
 800351c:	1009883a 	mov	r4,r2
 8003520:	180b883a 	mov	r5,r3
 8003524:	8004ad00 	call	8004ad0 <__muldf3>
 8003528:	1009883a 	mov	r4,r2
 800352c:	180b883a 	mov	r5,r3
 8003530:	2021883a 	mov	r16,r4
 8003534:	2823883a 	mov	r17,r5
 8003538:	e1bff617 	ldw	r6,-40(fp)
 800353c:	e1fff717 	ldw	r7,-36(fp)
 8003540:	e13ff417 	ldw	r4,-48(fp)
 8003544:	e17ff517 	ldw	r5,-44(fp)
 8003548:	8004ad00 	call	8004ad0 <__muldf3>
 800354c:	1009883a 	mov	r4,r2
 8003550:	180b883a 	mov	r5,r3
 8003554:	2005883a 	mov	r2,r4
 8003558:	2807883a 	mov	r3,r5
 800355c:	100d883a 	mov	r6,r2
 8003560:	180f883a 	mov	r7,r3
 8003564:	8009883a 	mov	r4,r16
 8003568:	880b883a 	mov	r5,r17
 800356c:	80051e80 	call	80051e8 <__subdf3>
 8003570:	1009883a 	mov	r4,r2
 8003574:	180b883a 	mov	r5,r3
 8003578:	2005883a 	mov	r2,r4
 800357c:	2807883a 	mov	r3,r5
 8003580:	e1bff217 	ldw	r6,-56(fp)
 8003584:	e1fff317 	ldw	r7,-52(fp)
 8003588:	1009883a 	mov	r4,r2
 800358c:	180b883a 	mov	r5,r3
 8003590:	8004ad00 	call	8004ad0 <__muldf3>
 8003594:	1009883a 	mov	r4,r2
 8003598:	180b883a 	mov	r5,r3
 800359c:	2005883a 	mov	r2,r4
 80035a0:	2807883a 	mov	r3,r5
 80035a4:	e1bffc17 	ldw	r6,-16(fp)
 80035a8:	e1fffd17 	ldw	r7,-12(fp)
 80035ac:	1009883a 	mov	r4,r2
 80035b0:	180b883a 	mov	r5,r3
 80035b4:	80051e80 	call	80051e8 <__subdf3>
 80035b8:	1009883a 	mov	r4,r2
 80035bc:	180b883a 	mov	r5,r3
 80035c0:	2021883a 	mov	r16,r4
 80035c4:	2823883a 	mov	r17,r5
 80035c8:	00955574 	movhi	r2,21845
 80035cc:	10955244 	addi	r2,r2,21833
 80035d0:	00eff174 	movhi	r3,49093
 80035d4:	18d55544 	addi	r3,r3,21845
 80035d8:	e1bff417 	ldw	r6,-48(fp)
 80035dc:	e1fff517 	ldw	r7,-44(fp)
 80035e0:	1009883a 	mov	r4,r2
 80035e4:	180b883a 	mov	r5,r3
 80035e8:	8004ad00 	call	8004ad0 <__muldf3>
 80035ec:	1009883a 	mov	r4,r2
 80035f0:	180b883a 	mov	r5,r3
 80035f4:	2005883a 	mov	r2,r4
 80035f8:	2807883a 	mov	r3,r5
 80035fc:	100d883a 	mov	r6,r2
 8003600:	180f883a 	mov	r7,r3
 8003604:	8009883a 	mov	r4,r16
 8003608:	880b883a 	mov	r5,r17
 800360c:	80051e80 	call	80051e8 <__subdf3>
 8003610:	1009883a 	mov	r4,r2
 8003614:	180b883a 	mov	r5,r3
 8003618:	2005883a 	mov	r2,r4
 800361c:	2807883a 	mov	r3,r5
 8003620:	100d883a 	mov	r6,r2
 8003624:	180f883a 	mov	r7,r3
 8003628:	e13ffa17 	ldw	r4,-24(fp)
 800362c:	e17ffb17 	ldw	r5,-20(fp)
 8003630:	80051e80 	call	80051e8 <__subdf3>
 8003634:	1009883a 	mov	r4,r2
 8003638:	180b883a 	mov	r5,r3
 800363c:	2005883a 	mov	r2,r4
 8003640:	2807883a 	mov	r3,r5
 8003644:	1009883a 	mov	r4,r2
 8003648:	180b883a 	mov	r5,r3
}
 800364c:	2005883a 	mov	r2,r4
 8003650:	2807883a 	mov	r3,r5
 8003654:	e6fffe04 	addi	sp,fp,-8
 8003658:	dfc00317 	ldw	ra,12(sp)
 800365c:	df000217 	ldw	fp,8(sp)
 8003660:	dc400117 	ldw	r17,4(sp)
 8003664:	dc000017 	ldw	r16,0(sp)
 8003668:	dec00404 	addi	sp,sp,16
 800366c:	f800283a 	ret

08003670 <fabs>:
	double fabs(double x)
#else
	double fabs(x)
	double x;
#endif
{
 8003670:	defff804 	addi	sp,sp,-32
 8003674:	df000715 	stw	fp,28(sp)
 8003678:	df000704 	addi	fp,sp,28
 800367c:	e13ffe15 	stw	r4,-8(fp)
 8003680:	e17fff15 	stw	r5,-4(fp)
	__uint32_t high;
	GET_HIGH_WORD(high,x);
 8003684:	e0bffe17 	ldw	r2,-8(fp)
 8003688:	e0bffa15 	stw	r2,-24(fp)
 800368c:	e0bfff17 	ldw	r2,-4(fp)
 8003690:	e0bffb15 	stw	r2,-20(fp)
 8003694:	e0bffb17 	ldw	r2,-20(fp)
 8003698:	e0bff915 	stw	r2,-28(fp)
	SET_HIGH_WORD(x,high&0x7fffffff);
 800369c:	e0bffe17 	ldw	r2,-8(fp)
 80036a0:	e0bffc15 	stw	r2,-16(fp)
 80036a4:	e0bfff17 	ldw	r2,-4(fp)
 80036a8:	e0bffd15 	stw	r2,-12(fp)
 80036ac:	e0fff917 	ldw	r3,-28(fp)
 80036b0:	00a00034 	movhi	r2,32768
 80036b4:	10bfffc4 	addi	r2,r2,-1
 80036b8:	1884703a 	and	r2,r3,r2
 80036bc:	e0bffd15 	stw	r2,-12(fp)
 80036c0:	e0bffc17 	ldw	r2,-16(fp)
 80036c4:	e0bffe15 	stw	r2,-8(fp)
 80036c8:	e0bffd17 	ldw	r2,-12(fp)
 80036cc:	e0bfff15 	stw	r2,-4(fp)
        return x;
 80036d0:	e0bffe17 	ldw	r2,-8(fp)
 80036d4:	e0ffff17 	ldw	r3,-4(fp)
 80036d8:	1009883a 	mov	r4,r2
 80036dc:	180b883a 	mov	r5,r3
}
 80036e0:	2005883a 	mov	r2,r4
 80036e4:	2807883a 	mov	r3,r5
 80036e8:	e037883a 	mov	sp,fp
 80036ec:	df000017 	ldw	fp,0(sp)
 80036f0:	dec00104 	addi	sp,sp,4
 80036f4:	f800283a 	ret

080036f8 <floor>:
	double floor(double x)
#else
	double floor(x)
	double x;
#endif
{
 80036f8:	defff304 	addi	sp,sp,-52
 80036fc:	dfc00c15 	stw	ra,48(sp)
 8003700:	df000b15 	stw	fp,44(sp)
 8003704:	df000b04 	addi	fp,sp,44
 8003708:	e13ffe15 	stw	r4,-8(fp)
 800370c:	e17fff15 	stw	r5,-4(fp)
	__int32_t i0,i1,j0;
	__uint32_t i,j;
	EXTRACT_WORDS(i0,i1,x);
 8003710:	e0bffe17 	ldw	r2,-8(fp)
 8003714:	e0bffa15 	stw	r2,-24(fp)
 8003718:	e0bfff17 	ldw	r2,-4(fp)
 800371c:	e0bffb15 	stw	r2,-20(fp)
 8003720:	e0bffb17 	ldw	r2,-20(fp)
 8003724:	e0bff515 	stw	r2,-44(fp)
 8003728:	e0bffa17 	ldw	r2,-24(fp)
 800372c:	e0bff615 	stw	r2,-40(fp)
	j0 = ((i0>>20)&0x7ff)-0x3ff;
 8003730:	e0bff517 	ldw	r2,-44(fp)
 8003734:	1005d53a 	srai	r2,r2,20
 8003738:	1081ffcc 	andi	r2,r2,2047
 800373c:	10bf0044 	addi	r2,r2,-1023
 8003740:	e0bff715 	stw	r2,-36(fp)
	if(j0<20) {
 8003744:	e0bff717 	ldw	r2,-36(fp)
 8003748:	10800508 	cmpgei	r2,r2,20
 800374c:	1000561e 	bne	r2,zero,80038a8 <floor+0x1b0>
	    if(j0<0) { 	/* raise inexact if x != 0 */
 8003750:	e0bff717 	ldw	r2,-36(fp)
 8003754:	1000240e 	bge	r2,zero,80037e8 <floor+0xf0>
		if(huge+x>0.0) {/* return 0*sign(x) if |x|<1 */
 8003758:	00a20034 	movhi	r2,34816
 800375c:	109d6704 	addi	r2,r2,30108
 8003760:	00df8e34 	movhi	r3,32312
 8003764:	18f90f04 	addi	r3,r3,-7108
 8003768:	e1bffe17 	ldw	r6,-8(fp)
 800376c:	e1ffff17 	ldw	r7,-4(fp)
 8003770:	1009883a 	mov	r4,r2
 8003774:	180b883a 	mov	r5,r3
 8003778:	80040c00 	call	80040c0 <__adddf3>
 800377c:	1009883a 	mov	r4,r2
 8003780:	180b883a 	mov	r5,r3
 8003784:	2005883a 	mov	r2,r4
 8003788:	2807883a 	mov	r3,r5
 800378c:	000d883a 	mov	r6,zero
 8003790:	000f883a 	mov	r7,zero
 8003794:	1009883a 	mov	r4,r2
 8003798:	180b883a 	mov	r5,r3
 800379c:	80049f40 	call	80049f4 <__gedf2>
 80037a0:	0080930e 	bge	zero,r2,80039f0 <floor+0x2f8>
		    if(i0>=0) {i0=i1=0;} 
 80037a4:	e0bff517 	ldw	r2,-44(fp)
 80037a8:	10000416 	blt	r2,zero,80037bc <floor+0xc4>
 80037ac:	e03ff615 	stw	zero,-40(fp)
 80037b0:	e0bff617 	ldw	r2,-40(fp)
 80037b4:	e0bff515 	stw	r2,-44(fp)
 80037b8:	00008d06 	br	80039f0 <floor+0x2f8>
		    else if(((i0&0x7fffffff)|i1)!=0)
 80037bc:	e0fff517 	ldw	r3,-44(fp)
 80037c0:	00a00034 	movhi	r2,32768
 80037c4:	10bfffc4 	addi	r2,r2,-1
 80037c8:	1886703a 	and	r3,r3,r2
 80037cc:	e0bff617 	ldw	r2,-40(fp)
 80037d0:	1884b03a 	or	r2,r3,r2
 80037d4:	10008626 	beq	r2,zero,80039f0 <floor+0x2f8>
			{ i0=0xbff00000;i1=0;}
 80037d8:	00affc34 	movhi	r2,49136
 80037dc:	e0bff515 	stw	r2,-44(fp)
 80037e0:	e03ff615 	stw	zero,-40(fp)
 80037e4:	00008206 	br	80039f0 <floor+0x2f8>
		}
	    } else {
		i = (0x000fffff)>>j0;
 80037e8:	00800434 	movhi	r2,16
 80037ec:	10bfffc4 	addi	r2,r2,-1
 80037f0:	e0fff717 	ldw	r3,-36(fp)
 80037f4:	10c5d83a 	sra	r2,r2,r3
 80037f8:	e0bff815 	stw	r2,-32(fp)
		if(((i0&i)|i1)==0) return x; /* x is integral */
 80037fc:	e0fff517 	ldw	r3,-44(fp)
 8003800:	e0bff817 	ldw	r2,-32(fp)
 8003804:	1886703a 	and	r3,r3,r2
 8003808:	e0bff617 	ldw	r2,-40(fp)
 800380c:	1884b03a 	or	r2,r3,r2
 8003810:	1000031e 	bne	r2,zero,8003820 <floor+0x128>
 8003814:	e0bffe17 	ldw	r2,-8(fp)
 8003818:	e0ffff17 	ldw	r3,-4(fp)
 800381c:	00007e06 	br	8003a18 <floor+0x320>
		if(huge+x>0.0) {	/* raise inexact flag */
 8003820:	00a20034 	movhi	r2,34816
 8003824:	109d6704 	addi	r2,r2,30108
 8003828:	00df8e34 	movhi	r3,32312
 800382c:	18f90f04 	addi	r3,r3,-7108
 8003830:	e1bffe17 	ldw	r6,-8(fp)
 8003834:	e1ffff17 	ldw	r7,-4(fp)
 8003838:	1009883a 	mov	r4,r2
 800383c:	180b883a 	mov	r5,r3
 8003840:	80040c00 	call	80040c0 <__adddf3>
 8003844:	1009883a 	mov	r4,r2
 8003848:	180b883a 	mov	r5,r3
 800384c:	2005883a 	mov	r2,r4
 8003850:	2807883a 	mov	r3,r5
 8003854:	000d883a 	mov	r6,zero
 8003858:	000f883a 	mov	r7,zero
 800385c:	1009883a 	mov	r4,r2
 8003860:	180b883a 	mov	r5,r3
 8003864:	80049f40 	call	80049f4 <__gedf2>
 8003868:	0080610e 	bge	zero,r2,80039f0 <floor+0x2f8>
		    if(i0<0) i0 += (0x00100000)>>j0;
 800386c:	e0bff517 	ldw	r2,-44(fp)
 8003870:	1000060e 	bge	r2,zero,800388c <floor+0x194>
 8003874:	00c00434 	movhi	r3,16
 8003878:	e0bff717 	ldw	r2,-36(fp)
 800387c:	1885d83a 	sra	r2,r3,r2
 8003880:	e0fff517 	ldw	r3,-44(fp)
 8003884:	1885883a 	add	r2,r3,r2
 8003888:	e0bff515 	stw	r2,-44(fp)
		    i0 &= (~i); i1=0;
 800388c:	e0bff817 	ldw	r2,-32(fp)
 8003890:	0086303a 	nor	r3,zero,r2
 8003894:	e0bff517 	ldw	r2,-44(fp)
 8003898:	1884703a 	and	r2,r3,r2
 800389c:	e0bff515 	stw	r2,-44(fp)
 80038a0:	e03ff615 	stw	zero,-40(fp)
 80038a4:	00005206 	br	80039f0 <floor+0x2f8>
		}
	    }
	} else if (j0>51) {
 80038a8:	e0bff717 	ldw	r2,-36(fp)
 80038ac:	10800d10 	cmplti	r2,r2,52
 80038b0:	1000121e 	bne	r2,zero,80038fc <floor+0x204>
	    if(j0==0x400) return x+x;	/* inf or NaN */
 80038b4:	e0bff717 	ldw	r2,-36(fp)
 80038b8:	10810018 	cmpnei	r2,r2,1024
 80038bc:	10000c1e 	bne	r2,zero,80038f0 <floor+0x1f8>
 80038c0:	e0bffe17 	ldw	r2,-8(fp)
 80038c4:	e0ffff17 	ldw	r3,-4(fp)
 80038c8:	100d883a 	mov	r6,r2
 80038cc:	180f883a 	mov	r7,r3
 80038d0:	1009883a 	mov	r4,r2
 80038d4:	180b883a 	mov	r5,r3
 80038d8:	80040c00 	call	80040c0 <__adddf3>
 80038dc:	1009883a 	mov	r4,r2
 80038e0:	180b883a 	mov	r5,r3
 80038e4:	2005883a 	mov	r2,r4
 80038e8:	2807883a 	mov	r3,r5
 80038ec:	00004a06 	br	8003a18 <floor+0x320>
	    else return x;		/* x is integral */
 80038f0:	e0bffe17 	ldw	r2,-8(fp)
 80038f4:	e0ffff17 	ldw	r3,-4(fp)
 80038f8:	00004706 	br	8003a18 <floor+0x320>
	} else {
	    i = ((__uint32_t)(0xffffffff))>>(j0-20);
 80038fc:	e0bff717 	ldw	r2,-36(fp)
 8003900:	10bffb04 	addi	r2,r2,-20
 8003904:	00ffffc4 	movi	r3,-1
 8003908:	1884d83a 	srl	r2,r3,r2
 800390c:	e0bff815 	stw	r2,-32(fp)
	    if((i1&i)==0) return x;	/* x is integral */
 8003910:	e0fff617 	ldw	r3,-40(fp)
 8003914:	e0bff817 	ldw	r2,-32(fp)
 8003918:	1884703a 	and	r2,r3,r2
 800391c:	1000031e 	bne	r2,zero,800392c <floor+0x234>
 8003920:	e0bffe17 	ldw	r2,-8(fp)
 8003924:	e0ffff17 	ldw	r3,-4(fp)
 8003928:	00003b06 	br	8003a18 <floor+0x320>
	    if(huge+x>0.0) { 		/* raise inexact flag */
 800392c:	00a20034 	movhi	r2,34816
 8003930:	109d6704 	addi	r2,r2,30108
 8003934:	00df8e34 	movhi	r3,32312
 8003938:	18f90f04 	addi	r3,r3,-7108
 800393c:	e1bffe17 	ldw	r6,-8(fp)
 8003940:	e1ffff17 	ldw	r7,-4(fp)
 8003944:	1009883a 	mov	r4,r2
 8003948:	180b883a 	mov	r5,r3
 800394c:	80040c00 	call	80040c0 <__adddf3>
 8003950:	1009883a 	mov	r4,r2
 8003954:	180b883a 	mov	r5,r3
 8003958:	2005883a 	mov	r2,r4
 800395c:	2807883a 	mov	r3,r5
 8003960:	000d883a 	mov	r6,zero
 8003964:	000f883a 	mov	r7,zero
 8003968:	1009883a 	mov	r4,r2
 800396c:	180b883a 	mov	r5,r3
 8003970:	80049f40 	call	80049f4 <__gedf2>
 8003974:	00801e0e 	bge	zero,r2,80039f0 <floor+0x2f8>
		if(i0<0) {
 8003978:	e0bff517 	ldw	r2,-44(fp)
 800397c:	1000170e 	bge	r2,zero,80039dc <floor+0x2e4>
		    if(j0==20) i0+=1; 
 8003980:	e0bff717 	ldw	r2,-36(fp)
 8003984:	10800518 	cmpnei	r2,r2,20
 8003988:	1000041e 	bne	r2,zero,800399c <floor+0x2a4>
 800398c:	e0bff517 	ldw	r2,-44(fp)
 8003990:	10800044 	addi	r2,r2,1
 8003994:	e0bff515 	stw	r2,-44(fp)
 8003998:	00001006 	br	80039dc <floor+0x2e4>
		    else {
			j = i1+(1<<(52-j0));
 800399c:	00c00d04 	movi	r3,52
 80039a0:	e0bff717 	ldw	r2,-36(fp)
 80039a4:	1885c83a 	sub	r2,r3,r2
 80039a8:	00c00044 	movi	r3,1
 80039ac:	1886983a 	sll	r3,r3,r2
 80039b0:	e0bff617 	ldw	r2,-40(fp)
 80039b4:	1885883a 	add	r2,r3,r2
 80039b8:	e0bff915 	stw	r2,-28(fp)
			if(j<i1) i0 +=1 ; 	/* got a carry */
 80039bc:	e0bff617 	ldw	r2,-40(fp)
 80039c0:	e0fff917 	ldw	r3,-28(fp)
 80039c4:	1880032e 	bgeu	r3,r2,80039d4 <floor+0x2dc>
 80039c8:	e0bff517 	ldw	r2,-44(fp)
 80039cc:	10800044 	addi	r2,r2,1
 80039d0:	e0bff515 	stw	r2,-44(fp)
			i1=j;
 80039d4:	e0bff917 	ldw	r2,-28(fp)
 80039d8:	e0bff615 	stw	r2,-40(fp)
		    }
		}
		i1 &= (~i);
 80039dc:	e0bff817 	ldw	r2,-32(fp)
 80039e0:	0086303a 	nor	r3,zero,r2
 80039e4:	e0bff617 	ldw	r2,-40(fp)
 80039e8:	1884703a 	and	r2,r3,r2
 80039ec:	e0bff615 	stw	r2,-40(fp)
	    }
	}
	INSERT_WORDS(x,i0,i1);
 80039f0:	e0bff517 	ldw	r2,-44(fp)
 80039f4:	e0bffd15 	stw	r2,-12(fp)
 80039f8:	e0bff617 	ldw	r2,-40(fp)
 80039fc:	e0bffc15 	stw	r2,-16(fp)
 8003a00:	e0bffc17 	ldw	r2,-16(fp)
 8003a04:	e0bffe15 	stw	r2,-8(fp)
 8003a08:	e0bffd17 	ldw	r2,-12(fp)
 8003a0c:	e0bfff15 	stw	r2,-4(fp)
	return x;
 8003a10:	e0bffe17 	ldw	r2,-8(fp)
 8003a14:	e0ffff17 	ldw	r3,-4(fp)
 8003a18:	1009883a 	mov	r4,r2
 8003a1c:	180b883a 	mov	r5,r3
}
 8003a20:	2005883a 	mov	r2,r4
 8003a24:	2807883a 	mov	r3,r5
 8003a28:	e037883a 	mov	sp,fp
 8003a2c:	dfc00117 	ldw	ra,4(sp)
 8003a30:	df000017 	ldw	fp,0(sp)
 8003a34:	dec00204 	addi	sp,sp,8
 8003a38:	f800283a 	ret

08003a3c <scalbn>:
	double scalbn (double x, int n)
#else
	double scalbn (x,n)
	double x; int n;
#endif
{
 8003a3c:	defff004 	addi	sp,sp,-64
 8003a40:	dfc00f15 	stw	ra,60(sp)
 8003a44:	df000e15 	stw	fp,56(sp)
 8003a48:	df000e04 	addi	fp,sp,56
 8003a4c:	e13ffd15 	stw	r4,-12(fp)
 8003a50:	e17ffe15 	stw	r5,-8(fp)
 8003a54:	e1bfff15 	stw	r6,-4(fp)
	__int32_t  k,hx,lx;
	EXTRACT_WORDS(hx,lx,x);
 8003a58:	e0bffd17 	ldw	r2,-12(fp)
 8003a5c:	e0bff515 	stw	r2,-44(fp)
 8003a60:	e0bffe17 	ldw	r2,-8(fp)
 8003a64:	e0bff615 	stw	r2,-40(fp)
 8003a68:	e0bff617 	ldw	r2,-40(fp)
 8003a6c:	e0bff315 	stw	r2,-52(fp)
 8003a70:	e0bff517 	ldw	r2,-44(fp)
 8003a74:	e0bff415 	stw	r2,-48(fp)
        k = (hx&0x7ff00000)>>20;		/* extract exponent */
 8003a78:	e0bff317 	ldw	r2,-52(fp)
 8003a7c:	109ffc2c 	andhi	r2,r2,32752
 8003a80:	1005d53a 	srai	r2,r2,20
 8003a84:	e0bff215 	stw	r2,-56(fp)
        if (k==0) {				/* 0 or subnormal x */
 8003a88:	e0bff217 	ldw	r2,-56(fp)
 8003a8c:	1000321e 	bne	r2,zero,8003b58 <scalbn+0x11c>
            if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */
 8003a90:	e0fff317 	ldw	r3,-52(fp)
 8003a94:	00a00034 	movhi	r2,32768
 8003a98:	10bfffc4 	addi	r2,r2,-1
 8003a9c:	1886703a 	and	r3,r3,r2
 8003aa0:	e0bff417 	ldw	r2,-48(fp)
 8003aa4:	1884b03a 	or	r2,r3,r2
 8003aa8:	1000031e 	bne	r2,zero,8003ab8 <scalbn+0x7c>
 8003aac:	e0bffd17 	ldw	r2,-12(fp)
 8003ab0:	e0fffe17 	ldw	r3,-8(fp)
 8003ab4:	0000c206 	br	8003dc0 <scalbn+0x384>
	    x *= two54; 
 8003ab8:	0005883a 	mov	r2,zero
 8003abc:	00d0d434 	movhi	r3,17232
 8003ac0:	100d883a 	mov	r6,r2
 8003ac4:	180f883a 	mov	r7,r3
 8003ac8:	e13ffd17 	ldw	r4,-12(fp)
 8003acc:	e17ffe17 	ldw	r5,-8(fp)
 8003ad0:	8004ad00 	call	8004ad0 <__muldf3>
 8003ad4:	1009883a 	mov	r4,r2
 8003ad8:	180b883a 	mov	r5,r3
 8003adc:	e13ffd15 	stw	r4,-12(fp)
 8003ae0:	e17ffe15 	stw	r5,-8(fp)
	    GET_HIGH_WORD(hx,x);
 8003ae4:	e0bffd17 	ldw	r2,-12(fp)
 8003ae8:	e0bff715 	stw	r2,-36(fp)
 8003aec:	e0bffe17 	ldw	r2,-8(fp)
 8003af0:	e0bff815 	stw	r2,-32(fp)
 8003af4:	e0bff817 	ldw	r2,-32(fp)
 8003af8:	e0bff315 	stw	r2,-52(fp)
	    k = ((hx&0x7ff00000)>>20) - 54; 
 8003afc:	e0bff317 	ldw	r2,-52(fp)
 8003b00:	109ffc2c 	andhi	r2,r2,32752
 8003b04:	1005d53a 	srai	r2,r2,20
 8003b08:	10bff284 	addi	r2,r2,-54
 8003b0c:	e0bff215 	stw	r2,-56(fp)
            if (n< -50000) return tiny*x; 	/*underflow*/
 8003b10:	e0ffff17 	ldw	r3,-4(fp)
 8003b14:	00bffff4 	movhi	r2,65535
 8003b18:	108f2c04 	addi	r2,r2,15536
 8003b1c:	18800e0e 	bge	r3,r2,8003b58 <scalbn+0x11c>
 8003b20:	00b0be74 	movhi	r2,49913
 8003b24:	10bcd644 	addi	r2,r2,-3239
 8003b28:	00c06974 	movhi	r3,421
 8003b2c:	18db87c4 	addi	r3,r3,28191
 8003b30:	e1bffd17 	ldw	r6,-12(fp)
 8003b34:	e1fffe17 	ldw	r7,-8(fp)
 8003b38:	1009883a 	mov	r4,r2
 8003b3c:	180b883a 	mov	r5,r3
 8003b40:	8004ad00 	call	8004ad0 <__muldf3>
 8003b44:	1009883a 	mov	r4,r2
 8003b48:	180b883a 	mov	r5,r3
 8003b4c:	2005883a 	mov	r2,r4
 8003b50:	2807883a 	mov	r3,r5
 8003b54:	00009a06 	br	8003dc0 <scalbn+0x384>
	    }
        if (k==0x7ff) return x+x;		/* NaN or Inf */
 8003b58:	e0bff217 	ldw	r2,-56(fp)
 8003b5c:	1081ffd8 	cmpnei	r2,r2,2047
 8003b60:	10000c1e 	bne	r2,zero,8003b94 <scalbn+0x158>
 8003b64:	e0bffd17 	ldw	r2,-12(fp)
 8003b68:	e0fffe17 	ldw	r3,-8(fp)
 8003b6c:	100d883a 	mov	r6,r2
 8003b70:	180f883a 	mov	r7,r3
 8003b74:	1009883a 	mov	r4,r2
 8003b78:	180b883a 	mov	r5,r3
 8003b7c:	80040c00 	call	80040c0 <__adddf3>
 8003b80:	1009883a 	mov	r4,r2
 8003b84:	180b883a 	mov	r5,r3
 8003b88:	2005883a 	mov	r2,r4
 8003b8c:	2807883a 	mov	r3,r5
 8003b90:	00008b06 	br	8003dc0 <scalbn+0x384>
        k = k+n; 
 8003b94:	e0fff217 	ldw	r3,-56(fp)
 8003b98:	e0bfff17 	ldw	r2,-4(fp)
 8003b9c:	1885883a 	add	r2,r3,r2
 8003ba0:	e0bff215 	stw	r2,-56(fp)
        if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */
 8003ba4:	e0bff217 	ldw	r2,-56(fp)
 8003ba8:	1081ffd0 	cmplti	r2,r2,2047
 8003bac:	1000191e 	bne	r2,zero,8003c14 <scalbn+0x1d8>
 8003bb0:	00a20034 	movhi	r2,34816
 8003bb4:	109d6704 	addi	r2,r2,30108
 8003bb8:	00df8e34 	movhi	r3,32312
 8003bbc:	18f90f04 	addi	r3,r3,-7108
 8003bc0:	e1bffd17 	ldw	r6,-12(fp)
 8003bc4:	e1fffe17 	ldw	r7,-8(fp)
 8003bc8:	1009883a 	mov	r4,r2
 8003bcc:	180b883a 	mov	r5,r3
 8003bd0:	8003de40 	call	8003de4 <copysign>
 8003bd4:	1011883a 	mov	r8,r2
 8003bd8:	1813883a 	mov	r9,r3
 8003bdc:	00a20034 	movhi	r2,34816
 8003be0:	109d6704 	addi	r2,r2,30108
 8003be4:	00df8e34 	movhi	r3,32312
 8003be8:	18f90f04 	addi	r3,r3,-7108
 8003bec:	100d883a 	mov	r6,r2
 8003bf0:	180f883a 	mov	r7,r3
 8003bf4:	4009883a 	mov	r4,r8
 8003bf8:	480b883a 	mov	r5,r9
 8003bfc:	8004ad00 	call	8004ad0 <__muldf3>
 8003c00:	1009883a 	mov	r4,r2
 8003c04:	180b883a 	mov	r5,r3
 8003c08:	2005883a 	mov	r2,r4
 8003c0c:	2807883a 	mov	r3,r5
 8003c10:	00006b06 	br	8003dc0 <scalbn+0x384>
        if (k > 0) 				/* normal result */
 8003c14:	e0bff217 	ldw	r2,-56(fp)
 8003c18:	0080130e 	bge	zero,r2,8003c68 <scalbn+0x22c>
	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}
 8003c1c:	e0bffd17 	ldw	r2,-12(fp)
 8003c20:	e0bff915 	stw	r2,-28(fp)
 8003c24:	e0bffe17 	ldw	r2,-8(fp)
 8003c28:	e0bffa15 	stw	r2,-24(fp)
 8003c2c:	e0fff317 	ldw	r3,-52(fp)
 8003c30:	00a00434 	movhi	r2,32784
 8003c34:	10bfffc4 	addi	r2,r2,-1
 8003c38:	1884703a 	and	r2,r3,r2
 8003c3c:	e0fff217 	ldw	r3,-56(fp)
 8003c40:	1806953a 	slli	r3,r3,20
 8003c44:	10c4b03a 	or	r2,r2,r3
 8003c48:	e0bffa15 	stw	r2,-24(fp)
 8003c4c:	e0bff917 	ldw	r2,-28(fp)
 8003c50:	e0bffd15 	stw	r2,-12(fp)
 8003c54:	e0bffa17 	ldw	r2,-24(fp)
 8003c58:	e0bffe15 	stw	r2,-8(fp)
 8003c5c:	e0bffd17 	ldw	r2,-12(fp)
 8003c60:	e0fffe17 	ldw	r3,-8(fp)
 8003c64:	00005606 	br	8003dc0 <scalbn+0x384>
        if (k <= -54) {
 8003c68:	e0bff217 	ldw	r2,-56(fp)
 8003c6c:	10bff2c8 	cmpgei	r2,r2,-53
 8003c70:	1000351e 	bne	r2,zero,8003d48 <scalbn+0x30c>
            if (n > 50000) 	/* in case integer overflow in n+k */
 8003c74:	e0bfff17 	ldw	r2,-4(fp)
 8003c78:	00f0d414 	movui	r3,50000
 8003c7c:	1880190e 	bge	r3,r2,8003ce4 <scalbn+0x2a8>
		return huge*copysign(huge,x);	/*overflow*/
 8003c80:	00a20034 	movhi	r2,34816
 8003c84:	109d6704 	addi	r2,r2,30108
 8003c88:	00df8e34 	movhi	r3,32312
 8003c8c:	18f90f04 	addi	r3,r3,-7108
 8003c90:	e1bffd17 	ldw	r6,-12(fp)
 8003c94:	e1fffe17 	ldw	r7,-8(fp)
 8003c98:	1009883a 	mov	r4,r2
 8003c9c:	180b883a 	mov	r5,r3
 8003ca0:	8003de40 	call	8003de4 <copysign>
 8003ca4:	1011883a 	mov	r8,r2
 8003ca8:	1813883a 	mov	r9,r3
 8003cac:	00a20034 	movhi	r2,34816
 8003cb0:	109d6704 	addi	r2,r2,30108
 8003cb4:	00df8e34 	movhi	r3,32312
 8003cb8:	18f90f04 	addi	r3,r3,-7108
 8003cbc:	100d883a 	mov	r6,r2
 8003cc0:	180f883a 	mov	r7,r3
 8003cc4:	4009883a 	mov	r4,r8
 8003cc8:	480b883a 	mov	r5,r9
 8003ccc:	8004ad00 	call	8004ad0 <__muldf3>
 8003cd0:	1009883a 	mov	r4,r2
 8003cd4:	180b883a 	mov	r5,r3
 8003cd8:	2005883a 	mov	r2,r4
 8003cdc:	2807883a 	mov	r3,r5
 8003ce0:	00003706 	br	8003dc0 <scalbn+0x384>
	    else return tiny*copysign(tiny,x); 	/*underflow*/
 8003ce4:	00b0be74 	movhi	r2,49913
 8003ce8:	10bcd644 	addi	r2,r2,-3239
 8003cec:	00c06974 	movhi	r3,421
 8003cf0:	18db87c4 	addi	r3,r3,28191
 8003cf4:	e1bffd17 	ldw	r6,-12(fp)
 8003cf8:	e1fffe17 	ldw	r7,-8(fp)
 8003cfc:	1009883a 	mov	r4,r2
 8003d00:	180b883a 	mov	r5,r3
 8003d04:	8003de40 	call	8003de4 <copysign>
 8003d08:	1011883a 	mov	r8,r2
 8003d0c:	1813883a 	mov	r9,r3
 8003d10:	00b0be74 	movhi	r2,49913
 8003d14:	10bcd644 	addi	r2,r2,-3239
 8003d18:	00c06974 	movhi	r3,421
 8003d1c:	18db87c4 	addi	r3,r3,28191
 8003d20:	100d883a 	mov	r6,r2
 8003d24:	180f883a 	mov	r7,r3
 8003d28:	4009883a 	mov	r4,r8
 8003d2c:	480b883a 	mov	r5,r9
 8003d30:	8004ad00 	call	8004ad0 <__muldf3>
 8003d34:	1009883a 	mov	r4,r2
 8003d38:	180b883a 	mov	r5,r3
 8003d3c:	2005883a 	mov	r2,r4
 8003d40:	2807883a 	mov	r3,r5
 8003d44:	00001e06 	br	8003dc0 <scalbn+0x384>
      }
        k += 54;				/* subnormal result */
 8003d48:	e0bff217 	ldw	r2,-56(fp)
 8003d4c:	10800d84 	addi	r2,r2,54
 8003d50:	e0bff215 	stw	r2,-56(fp)
	SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
 8003d54:	e0bffd17 	ldw	r2,-12(fp)
 8003d58:	e0bffb15 	stw	r2,-20(fp)
 8003d5c:	e0bffe17 	ldw	r2,-8(fp)
 8003d60:	e0bffc15 	stw	r2,-16(fp)
 8003d64:	e0fff317 	ldw	r3,-52(fp)
 8003d68:	00a00434 	movhi	r2,32784
 8003d6c:	10bfffc4 	addi	r2,r2,-1
 8003d70:	1884703a 	and	r2,r3,r2
 8003d74:	e0fff217 	ldw	r3,-56(fp)
 8003d78:	1806953a 	slli	r3,r3,20
 8003d7c:	10c4b03a 	or	r2,r2,r3
 8003d80:	e0bffc15 	stw	r2,-16(fp)
 8003d84:	e0bffb17 	ldw	r2,-20(fp)
 8003d88:	e0bffd15 	stw	r2,-12(fp)
 8003d8c:	e0bffc17 	ldw	r2,-16(fp)
 8003d90:	e0bffe15 	stw	r2,-8(fp)
        return x*twom54;
 8003d94:	0005883a 	mov	r2,zero
 8003d98:	00cf2434 	movhi	r3,15504
 8003d9c:	e1bffd17 	ldw	r6,-12(fp)
 8003da0:	e1fffe17 	ldw	r7,-8(fp)
 8003da4:	1009883a 	mov	r4,r2
 8003da8:	180b883a 	mov	r5,r3
 8003dac:	8004ad00 	call	8004ad0 <__muldf3>
 8003db0:	1009883a 	mov	r4,r2
 8003db4:	180b883a 	mov	r5,r3
 8003db8:	2005883a 	mov	r2,r4
 8003dbc:	2807883a 	mov	r3,r5
 8003dc0:	1009883a 	mov	r4,r2
 8003dc4:	180b883a 	mov	r5,r3
}
 8003dc8:	2005883a 	mov	r2,r4
 8003dcc:	2807883a 	mov	r3,r5
 8003dd0:	e037883a 	mov	sp,fp
 8003dd4:	dfc00117 	ldw	ra,4(sp)
 8003dd8:	df000017 	ldw	fp,0(sp)
 8003ddc:	dec00204 	addi	sp,sp,8
 8003de0:	f800283a 	ret

08003de4 <copysign>:
	double copysign(double x, double y)
#else
	double copysign(x,y)
	double x,y;
#endif
{
 8003de4:	defff304 	addi	sp,sp,-52
 8003de8:	df000c15 	stw	fp,48(sp)
 8003dec:	df000c04 	addi	fp,sp,48
 8003df0:	e13ffc15 	stw	r4,-16(fp)
 8003df4:	e17ffd15 	stw	r5,-12(fp)
 8003df8:	e1bffe15 	stw	r6,-8(fp)
 8003dfc:	e1ffff15 	stw	r7,-4(fp)
	__uint32_t hx,hy;
	GET_HIGH_WORD(hx,x);
 8003e00:	e0bffc17 	ldw	r2,-16(fp)
 8003e04:	e0bff615 	stw	r2,-40(fp)
 8003e08:	e0bffd17 	ldw	r2,-12(fp)
 8003e0c:	e0bff715 	stw	r2,-36(fp)
 8003e10:	e0bff717 	ldw	r2,-36(fp)
 8003e14:	e0bff415 	stw	r2,-48(fp)
	GET_HIGH_WORD(hy,y);
 8003e18:	e0bffe17 	ldw	r2,-8(fp)
 8003e1c:	e0bff815 	stw	r2,-32(fp)
 8003e20:	e0bfff17 	ldw	r2,-4(fp)
 8003e24:	e0bff915 	stw	r2,-28(fp)
 8003e28:	e0bff917 	ldw	r2,-28(fp)
 8003e2c:	e0bff515 	stw	r2,-44(fp)
	SET_HIGH_WORD(x,(hx&0x7fffffff)|(hy&0x80000000));
 8003e30:	e0bffc17 	ldw	r2,-16(fp)
 8003e34:	e0bffa15 	stw	r2,-24(fp)
 8003e38:	e0bffd17 	ldw	r2,-12(fp)
 8003e3c:	e0bffb15 	stw	r2,-20(fp)
 8003e40:	e0fff417 	ldw	r3,-48(fp)
 8003e44:	00a00034 	movhi	r2,32768
 8003e48:	10bfffc4 	addi	r2,r2,-1
 8003e4c:	1886703a 	and	r3,r3,r2
 8003e50:	e0bff517 	ldw	r2,-44(fp)
 8003e54:	10a0002c 	andhi	r2,r2,32768
 8003e58:	1884b03a 	or	r2,r3,r2
 8003e5c:	e0bffb15 	stw	r2,-20(fp)
 8003e60:	e0bffa17 	ldw	r2,-24(fp)
 8003e64:	e0bffc15 	stw	r2,-16(fp)
 8003e68:	e0bffb17 	ldw	r2,-20(fp)
 8003e6c:	e0bffd15 	stw	r2,-12(fp)
        return x;
 8003e70:	e0bffc17 	ldw	r2,-16(fp)
 8003e74:	e0fffd17 	ldw	r3,-12(fp)
 8003e78:	1009883a 	mov	r4,r2
 8003e7c:	180b883a 	mov	r5,r3
}
 8003e80:	2005883a 	mov	r2,r4
 8003e84:	2807883a 	mov	r3,r5
 8003e88:	e037883a 	mov	sp,fp
 8003e8c:	df000017 	ldw	fp,0(sp)
 8003e90:	dec00104 	addi	sp,sp,4
 8003e94:	f800283a 	ret

08003e98 <__fixunsdfsi>:
 8003e98:	defffd04 	addi	sp,sp,-12
 8003e9c:	000d883a 	mov	r6,zero
 8003ea0:	01d07834 	movhi	r7,16864
 8003ea4:	dc400115 	stw	r17,4(sp)
 8003ea8:	dc000015 	stw	r16,0(sp)
 8003eac:	dfc00215 	stw	ra,8(sp)
 8003eb0:	2023883a 	mov	r17,r4
 8003eb4:	2821883a 	mov	r16,r5
 8003eb8:	80049f40 	call	80049f4 <__gedf2>
 8003ebc:	1000080e 	bge	r2,zero,8003ee0 <__fixunsdfsi+0x48>
 8003ec0:	8809883a 	mov	r4,r17
 8003ec4:	800b883a 	mov	r5,r16
 8003ec8:	8005ae40 	call	8005ae4 <__fixdfsi>
 8003ecc:	dfc00217 	ldw	ra,8(sp)
 8003ed0:	dc400117 	ldw	r17,4(sp)
 8003ed4:	dc000017 	ldw	r16,0(sp)
 8003ed8:	dec00304 	addi	sp,sp,12
 8003edc:	f800283a 	ret
 8003ee0:	000d883a 	mov	r6,zero
 8003ee4:	01d07834 	movhi	r7,16864
 8003ee8:	8809883a 	mov	r4,r17
 8003eec:	800b883a 	mov	r5,r16
 8003ef0:	80051e80 	call	80051e8 <__subdf3>
 8003ef4:	180b883a 	mov	r5,r3
 8003ef8:	1009883a 	mov	r4,r2
 8003efc:	8005ae40 	call	8005ae4 <__fixdfsi>
 8003f00:	00e00034 	movhi	r3,32768
 8003f04:	10c5883a 	add	r2,r2,r3
 8003f08:	003ff006 	br	8003ecc <__fixunsdfsi+0x34>

08003f0c <__divsi3>:
 8003f0c:	20001b16 	blt	r4,zero,8003f7c <__divsi3+0x70>
 8003f10:	000f883a 	mov	r7,zero
 8003f14:	28001616 	blt	r5,zero,8003f70 <__divsi3+0x64>
 8003f18:	200d883a 	mov	r6,r4
 8003f1c:	29001a2e 	bgeu	r5,r4,8003f88 <__divsi3+0x7c>
 8003f20:	00800804 	movi	r2,32
 8003f24:	00c00044 	movi	r3,1
 8003f28:	00000106 	br	8003f30 <__divsi3+0x24>
 8003f2c:	10000d26 	beq	r2,zero,8003f64 <__divsi3+0x58>
 8003f30:	294b883a 	add	r5,r5,r5
 8003f34:	10bfffc4 	addi	r2,r2,-1
 8003f38:	18c7883a 	add	r3,r3,r3
 8003f3c:	293ffb36 	bltu	r5,r4,8003f2c <__divsi3+0x20>
 8003f40:	0005883a 	mov	r2,zero
 8003f44:	18000726 	beq	r3,zero,8003f64 <__divsi3+0x58>
 8003f48:	0005883a 	mov	r2,zero
 8003f4c:	31400236 	bltu	r6,r5,8003f58 <__divsi3+0x4c>
 8003f50:	314dc83a 	sub	r6,r6,r5
 8003f54:	10c4b03a 	or	r2,r2,r3
 8003f58:	1806d07a 	srli	r3,r3,1
 8003f5c:	280ad07a 	srli	r5,r5,1
 8003f60:	183ffa1e 	bne	r3,zero,8003f4c <__divsi3+0x40>
 8003f64:	38000126 	beq	r7,zero,8003f6c <__divsi3+0x60>
 8003f68:	0085c83a 	sub	r2,zero,r2
 8003f6c:	f800283a 	ret
 8003f70:	014bc83a 	sub	r5,zero,r5
 8003f74:	39c0005c 	xori	r7,r7,1
 8003f78:	003fe706 	br	8003f18 <__divsi3+0xc>
 8003f7c:	0109c83a 	sub	r4,zero,r4
 8003f80:	01c00044 	movi	r7,1
 8003f84:	003fe306 	br	8003f14 <__divsi3+0x8>
 8003f88:	00c00044 	movi	r3,1
 8003f8c:	003fee06 	br	8003f48 <__divsi3+0x3c>

08003f90 <__modsi3>:
 8003f90:	20001716 	blt	r4,zero,8003ff0 <__modsi3+0x60>
 8003f94:	000f883a 	mov	r7,zero
 8003f98:	2005883a 	mov	r2,r4
 8003f9c:	28001216 	blt	r5,zero,8003fe8 <__modsi3+0x58>
 8003fa0:	2900162e 	bgeu	r5,r4,8003ffc <__modsi3+0x6c>
 8003fa4:	01800804 	movi	r6,32
 8003fa8:	00c00044 	movi	r3,1
 8003fac:	00000106 	br	8003fb4 <__modsi3+0x24>
 8003fb0:	30000a26 	beq	r6,zero,8003fdc <__modsi3+0x4c>
 8003fb4:	294b883a 	add	r5,r5,r5
 8003fb8:	31bfffc4 	addi	r6,r6,-1
 8003fbc:	18c7883a 	add	r3,r3,r3
 8003fc0:	293ffb36 	bltu	r5,r4,8003fb0 <__modsi3+0x20>
 8003fc4:	18000526 	beq	r3,zero,8003fdc <__modsi3+0x4c>
 8003fc8:	1806d07a 	srli	r3,r3,1
 8003fcc:	11400136 	bltu	r2,r5,8003fd4 <__modsi3+0x44>
 8003fd0:	1145c83a 	sub	r2,r2,r5
 8003fd4:	280ad07a 	srli	r5,r5,1
 8003fd8:	183ffb1e 	bne	r3,zero,8003fc8 <__modsi3+0x38>
 8003fdc:	38000126 	beq	r7,zero,8003fe4 <__modsi3+0x54>
 8003fe0:	0085c83a 	sub	r2,zero,r2
 8003fe4:	f800283a 	ret
 8003fe8:	014bc83a 	sub	r5,zero,r5
 8003fec:	003fec06 	br	8003fa0 <__modsi3+0x10>
 8003ff0:	0109c83a 	sub	r4,zero,r4
 8003ff4:	01c00044 	movi	r7,1
 8003ff8:	003fe706 	br	8003f98 <__modsi3+0x8>
 8003ffc:	00c00044 	movi	r3,1
 8004000:	003ff106 	br	8003fc8 <__modsi3+0x38>

08004004 <__udivsi3>:
 8004004:	200d883a 	mov	r6,r4
 8004008:	2900152e 	bgeu	r5,r4,8004060 <__udivsi3+0x5c>
 800400c:	28001416 	blt	r5,zero,8004060 <__udivsi3+0x5c>
 8004010:	00800804 	movi	r2,32
 8004014:	00c00044 	movi	r3,1
 8004018:	00000206 	br	8004024 <__udivsi3+0x20>
 800401c:	10000e26 	beq	r2,zero,8004058 <__udivsi3+0x54>
 8004020:	28000516 	blt	r5,zero,8004038 <__udivsi3+0x34>
 8004024:	294b883a 	add	r5,r5,r5
 8004028:	10bfffc4 	addi	r2,r2,-1
 800402c:	18c7883a 	add	r3,r3,r3
 8004030:	293ffa36 	bltu	r5,r4,800401c <__udivsi3+0x18>
 8004034:	18000826 	beq	r3,zero,8004058 <__udivsi3+0x54>
 8004038:	0005883a 	mov	r2,zero
 800403c:	31400236 	bltu	r6,r5,8004048 <__udivsi3+0x44>
 8004040:	314dc83a 	sub	r6,r6,r5
 8004044:	10c4b03a 	or	r2,r2,r3
 8004048:	1806d07a 	srli	r3,r3,1
 800404c:	280ad07a 	srli	r5,r5,1
 8004050:	183ffa1e 	bne	r3,zero,800403c <__udivsi3+0x38>
 8004054:	f800283a 	ret
 8004058:	0005883a 	mov	r2,zero
 800405c:	f800283a 	ret
 8004060:	00c00044 	movi	r3,1
 8004064:	003ff406 	br	8004038 <__udivsi3+0x34>

08004068 <__umodsi3>:
 8004068:	2005883a 	mov	r2,r4
 800406c:	2900122e 	bgeu	r5,r4,80040b8 <__umodsi3+0x50>
 8004070:	28001116 	blt	r5,zero,80040b8 <__umodsi3+0x50>
 8004074:	01800804 	movi	r6,32
 8004078:	00c00044 	movi	r3,1
 800407c:	00000206 	br	8004088 <__umodsi3+0x20>
 8004080:	30000c26 	beq	r6,zero,80040b4 <__umodsi3+0x4c>
 8004084:	28000516 	blt	r5,zero,800409c <__umodsi3+0x34>
 8004088:	294b883a 	add	r5,r5,r5
 800408c:	31bfffc4 	addi	r6,r6,-1
 8004090:	18c7883a 	add	r3,r3,r3
 8004094:	293ffa36 	bltu	r5,r4,8004080 <__umodsi3+0x18>
 8004098:	18000626 	beq	r3,zero,80040b4 <__umodsi3+0x4c>
 800409c:	1806d07a 	srli	r3,r3,1
 80040a0:	11400136 	bltu	r2,r5,80040a8 <__umodsi3+0x40>
 80040a4:	1145c83a 	sub	r2,r2,r5
 80040a8:	280ad07a 	srli	r5,r5,1
 80040ac:	183ffb1e 	bne	r3,zero,800409c <__umodsi3+0x34>
 80040b0:	f800283a 	ret
 80040b4:	f800283a 	ret
 80040b8:	00c00044 	movi	r3,1
 80040bc:	003ff706 	br	800409c <__umodsi3+0x34>

080040c0 <__adddf3>:
 80040c0:	02c00434 	movhi	r11,16
 80040c4:	5affffc4 	addi	r11,r11,-1
 80040c8:	2806d7fa 	srli	r3,r5,31
 80040cc:	2ad4703a 	and	r10,r5,r11
 80040d0:	3ad2703a 	and	r9,r7,r11
 80040d4:	3804d53a 	srli	r2,r7,20
 80040d8:	3018d77a 	srli	r12,r6,29
 80040dc:	280ad53a 	srli	r5,r5,20
 80040e0:	501490fa 	slli	r10,r10,3
 80040e4:	2010d77a 	srli	r8,r4,29
 80040e8:	481290fa 	slli	r9,r9,3
 80040ec:	380ed7fa 	srli	r7,r7,31
 80040f0:	defffb04 	addi	sp,sp,-20
 80040f4:	dc800215 	stw	r18,8(sp)
 80040f8:	dc400115 	stw	r17,4(sp)
 80040fc:	dc000015 	stw	r16,0(sp)
 8004100:	dfc00415 	stw	ra,16(sp)
 8004104:	dcc00315 	stw	r19,12(sp)
 8004108:	1c803fcc 	andi	r18,r3,255
 800410c:	2c01ffcc 	andi	r16,r5,2047
 8004110:	5210b03a 	or	r8,r10,r8
 8004114:	202290fa 	slli	r17,r4,3
 8004118:	1081ffcc 	andi	r2,r2,2047
 800411c:	4b12b03a 	or	r9,r9,r12
 8004120:	300c90fa 	slli	r6,r6,3
 8004124:	91c07526 	beq	r18,r7,80042fc <__adddf3+0x23c>
 8004128:	8087c83a 	sub	r3,r16,r2
 800412c:	00c0ab0e 	bge	zero,r3,80043dc <__adddf3+0x31c>
 8004130:	10002a1e 	bne	r2,zero,80041dc <__adddf3+0x11c>
 8004134:	4984b03a 	or	r2,r9,r6
 8004138:	1000961e 	bne	r2,zero,8004394 <__adddf3+0x2d4>
 800413c:	888001cc 	andi	r2,r17,7
 8004140:	10000726 	beq	r2,zero,8004160 <__adddf3+0xa0>
 8004144:	888003cc 	andi	r2,r17,15
 8004148:	00c00104 	movi	r3,4
 800414c:	10c00426 	beq	r2,r3,8004160 <__adddf3+0xa0>
 8004150:	88c7883a 	add	r3,r17,r3
 8004154:	1c63803a 	cmpltu	r17,r3,r17
 8004158:	4451883a 	add	r8,r8,r17
 800415c:	1823883a 	mov	r17,r3
 8004160:	4080202c 	andhi	r2,r8,128
 8004164:	10005926 	beq	r2,zero,80042cc <__adddf3+0x20c>
 8004168:	84000044 	addi	r16,r16,1
 800416c:	0081ffc4 	movi	r2,2047
 8004170:	8080ba26 	beq	r16,r2,800445c <__adddf3+0x39c>
 8004174:	00bfe034 	movhi	r2,65408
 8004178:	10bfffc4 	addi	r2,r2,-1
 800417c:	4090703a 	and	r8,r8,r2
 8004180:	4004977a 	slli	r2,r8,29
 8004184:	4010927a 	slli	r8,r8,9
 8004188:	8822d0fa 	srli	r17,r17,3
 800418c:	8401ffcc 	andi	r16,r16,2047
 8004190:	4010d33a 	srli	r8,r8,12
 8004194:	9007883a 	mov	r3,r18
 8004198:	1444b03a 	or	r2,r2,r17
 800419c:	8401ffcc 	andi	r16,r16,2047
 80041a0:	8020953a 	slli	r16,r16,20
 80041a4:	18c03fcc 	andi	r3,r3,255
 80041a8:	01000434 	movhi	r4,16
 80041ac:	213fffc4 	addi	r4,r4,-1
 80041b0:	180697fa 	slli	r3,r3,31
 80041b4:	4110703a 	and	r8,r8,r4
 80041b8:	4410b03a 	or	r8,r8,r16
 80041bc:	40c6b03a 	or	r3,r8,r3
 80041c0:	dfc00417 	ldw	ra,16(sp)
 80041c4:	dcc00317 	ldw	r19,12(sp)
 80041c8:	dc800217 	ldw	r18,8(sp)
 80041cc:	dc400117 	ldw	r17,4(sp)
 80041d0:	dc000017 	ldw	r16,0(sp)
 80041d4:	dec00504 	addi	sp,sp,20
 80041d8:	f800283a 	ret
 80041dc:	0081ffc4 	movi	r2,2047
 80041e0:	80bfd626 	beq	r16,r2,800413c <__adddf3+0x7c>
 80041e4:	4a402034 	orhi	r9,r9,128
 80041e8:	00800e04 	movi	r2,56
 80041ec:	10c09f16 	blt	r2,r3,800446c <__adddf3+0x3ac>
 80041f0:	008007c4 	movi	r2,31
 80041f4:	10c0c216 	blt	r2,r3,8004500 <__adddf3+0x440>
 80041f8:	00800804 	movi	r2,32
 80041fc:	10c5c83a 	sub	r2,r2,r3
 8004200:	488a983a 	sll	r5,r9,r2
 8004204:	30c8d83a 	srl	r4,r6,r3
 8004208:	3084983a 	sll	r2,r6,r2
 800420c:	48c6d83a 	srl	r3,r9,r3
 8004210:	290cb03a 	or	r6,r5,r4
 8004214:	1004c03a 	cmpne	r2,r2,zero
 8004218:	308cb03a 	or	r6,r6,r2
 800421c:	898dc83a 	sub	r6,r17,r6
 8004220:	89a3803a 	cmpltu	r17,r17,r6
 8004224:	40d1c83a 	sub	r8,r8,r3
 8004228:	4451c83a 	sub	r8,r8,r17
 800422c:	3023883a 	mov	r17,r6
 8004230:	4080202c 	andhi	r2,r8,128
 8004234:	10002326 	beq	r2,zero,80042c4 <__adddf3+0x204>
 8004238:	04c02034 	movhi	r19,128
 800423c:	9cffffc4 	addi	r19,r19,-1
 8004240:	44e6703a 	and	r19,r8,r19
 8004244:	98007626 	beq	r19,zero,8004420 <__adddf3+0x360>
 8004248:	9809883a 	mov	r4,r19
 800424c:	8005d500 	call	8005d50 <__clzsi2>
 8004250:	10fffe04 	addi	r3,r2,-8
 8004254:	010007c4 	movi	r4,31
 8004258:	20c07716 	blt	r4,r3,8004438 <__adddf3+0x378>
 800425c:	00800804 	movi	r2,32
 8004260:	10c5c83a 	sub	r2,r2,r3
 8004264:	8884d83a 	srl	r2,r17,r2
 8004268:	98d0983a 	sll	r8,r19,r3
 800426c:	88e2983a 	sll	r17,r17,r3
 8004270:	1204b03a 	or	r2,r2,r8
 8004274:	1c007416 	blt	r3,r16,8004448 <__adddf3+0x388>
 8004278:	1c21c83a 	sub	r16,r3,r16
 800427c:	82000044 	addi	r8,r16,1
 8004280:	00c007c4 	movi	r3,31
 8004284:	1a009116 	blt	r3,r8,80044cc <__adddf3+0x40c>
 8004288:	00c00804 	movi	r3,32
 800428c:	1a07c83a 	sub	r3,r3,r8
 8004290:	8a08d83a 	srl	r4,r17,r8
 8004294:	88e2983a 	sll	r17,r17,r3
 8004298:	10c6983a 	sll	r3,r2,r3
 800429c:	1210d83a 	srl	r8,r2,r8
 80042a0:	8804c03a 	cmpne	r2,r17,zero
 80042a4:	1906b03a 	or	r3,r3,r4
 80042a8:	18a2b03a 	or	r17,r3,r2
 80042ac:	0021883a 	mov	r16,zero
 80042b0:	003fa206 	br	800413c <__adddf3+0x7c>
 80042b4:	1890b03a 	or	r8,r3,r2
 80042b8:	40017d26 	beq	r8,zero,80048b0 <__adddf3+0x7f0>
 80042bc:	1011883a 	mov	r8,r2
 80042c0:	1823883a 	mov	r17,r3
 80042c4:	888001cc 	andi	r2,r17,7
 80042c8:	103f9e1e 	bne	r2,zero,8004144 <__adddf3+0x84>
 80042cc:	4004977a 	slli	r2,r8,29
 80042d0:	8822d0fa 	srli	r17,r17,3
 80042d4:	4010d0fa 	srli	r8,r8,3
 80042d8:	9007883a 	mov	r3,r18
 80042dc:	1444b03a 	or	r2,r2,r17
 80042e0:	0101ffc4 	movi	r4,2047
 80042e4:	81002426 	beq	r16,r4,8004378 <__adddf3+0x2b8>
 80042e8:	8120703a 	and	r16,r16,r4
 80042ec:	01000434 	movhi	r4,16
 80042f0:	213fffc4 	addi	r4,r4,-1
 80042f4:	4110703a 	and	r8,r8,r4
 80042f8:	003fa806 	br	800419c <__adddf3+0xdc>
 80042fc:	8089c83a 	sub	r4,r16,r2
 8004300:	01005e0e 	bge	zero,r4,800447c <__adddf3+0x3bc>
 8004304:	10002b26 	beq	r2,zero,80043b4 <__adddf3+0x2f4>
 8004308:	0081ffc4 	movi	r2,2047
 800430c:	80bf8b26 	beq	r16,r2,800413c <__adddf3+0x7c>
 8004310:	4a402034 	orhi	r9,r9,128
 8004314:	00800e04 	movi	r2,56
 8004318:	1100a40e 	bge	r2,r4,80045ac <__adddf3+0x4ec>
 800431c:	498cb03a 	or	r6,r9,r6
 8004320:	300ac03a 	cmpne	r5,r6,zero
 8004324:	0013883a 	mov	r9,zero
 8004328:	2c4b883a 	add	r5,r5,r17
 800432c:	2c63803a 	cmpltu	r17,r5,r17
 8004330:	4a11883a 	add	r8,r9,r8
 8004334:	8a11883a 	add	r8,r17,r8
 8004338:	2823883a 	mov	r17,r5
 800433c:	4080202c 	andhi	r2,r8,128
 8004340:	103fe026 	beq	r2,zero,80042c4 <__adddf3+0x204>
 8004344:	84000044 	addi	r16,r16,1
 8004348:	0081ffc4 	movi	r2,2047
 800434c:	8080d226 	beq	r16,r2,8004698 <__adddf3+0x5d8>
 8004350:	00bfe034 	movhi	r2,65408
 8004354:	10bfffc4 	addi	r2,r2,-1
 8004358:	4090703a 	and	r8,r8,r2
 800435c:	880ad07a 	srli	r5,r17,1
 8004360:	400897fa 	slli	r4,r8,31
 8004364:	88c0004c 	andi	r3,r17,1
 8004368:	28e2b03a 	or	r17,r5,r3
 800436c:	4010d07a 	srli	r8,r8,1
 8004370:	2462b03a 	or	r17,r4,r17
 8004374:	003f7106 	br	800413c <__adddf3+0x7c>
 8004378:	4088b03a 	or	r4,r8,r2
 800437c:	20014526 	beq	r4,zero,8004894 <__adddf3+0x7d4>
 8004380:	01000434 	movhi	r4,16
 8004384:	42000234 	orhi	r8,r8,8
 8004388:	213fffc4 	addi	r4,r4,-1
 800438c:	4110703a 	and	r8,r8,r4
 8004390:	003f8206 	br	800419c <__adddf3+0xdc>
 8004394:	18ffffc4 	addi	r3,r3,-1
 8004398:	1800491e 	bne	r3,zero,80044c0 <__adddf3+0x400>
 800439c:	898bc83a 	sub	r5,r17,r6
 80043a0:	8963803a 	cmpltu	r17,r17,r5
 80043a4:	4251c83a 	sub	r8,r8,r9
 80043a8:	4451c83a 	sub	r8,r8,r17
 80043ac:	2823883a 	mov	r17,r5
 80043b0:	003f9f06 	br	8004230 <__adddf3+0x170>
 80043b4:	4984b03a 	or	r2,r9,r6
 80043b8:	103f6026 	beq	r2,zero,800413c <__adddf3+0x7c>
 80043bc:	213fffc4 	addi	r4,r4,-1
 80043c0:	2000931e 	bne	r4,zero,8004610 <__adddf3+0x550>
 80043c4:	898d883a 	add	r6,r17,r6
 80043c8:	3463803a 	cmpltu	r17,r6,r17
 80043cc:	4251883a 	add	r8,r8,r9
 80043d0:	8a11883a 	add	r8,r17,r8
 80043d4:	3023883a 	mov	r17,r6
 80043d8:	003fd806 	br	800433c <__adddf3+0x27c>
 80043dc:	1800541e 	bne	r3,zero,8004530 <__adddf3+0x470>
 80043e0:	80800044 	addi	r2,r16,1
 80043e4:	1081ffcc 	andi	r2,r2,2047
 80043e8:	00c00044 	movi	r3,1
 80043ec:	1880a00e 	bge	r3,r2,8004670 <__adddf3+0x5b0>
 80043f0:	8989c83a 	sub	r4,r17,r6
 80043f4:	8905803a 	cmpltu	r2,r17,r4
 80043f8:	4267c83a 	sub	r19,r8,r9
 80043fc:	98a7c83a 	sub	r19,r19,r2
 8004400:	9880202c 	andhi	r2,r19,128
 8004404:	10006326 	beq	r2,zero,8004594 <__adddf3+0x4d4>
 8004408:	3463c83a 	sub	r17,r6,r17
 800440c:	4a07c83a 	sub	r3,r9,r8
 8004410:	344d803a 	cmpltu	r6,r6,r17
 8004414:	19a7c83a 	sub	r19,r3,r6
 8004418:	3825883a 	mov	r18,r7
 800441c:	983f8a1e 	bne	r19,zero,8004248 <__adddf3+0x188>
 8004420:	8809883a 	mov	r4,r17
 8004424:	8005d500 	call	8005d50 <__clzsi2>
 8004428:	10800804 	addi	r2,r2,32
 800442c:	10fffe04 	addi	r3,r2,-8
 8004430:	010007c4 	movi	r4,31
 8004434:	20ff890e 	bge	r4,r3,800425c <__adddf3+0x19c>
 8004438:	10bff604 	addi	r2,r2,-40
 800443c:	8884983a 	sll	r2,r17,r2
 8004440:	0023883a 	mov	r17,zero
 8004444:	1c3f8c0e 	bge	r3,r16,8004278 <__adddf3+0x1b8>
 8004448:	023fe034 	movhi	r8,65408
 800444c:	423fffc4 	addi	r8,r8,-1
 8004450:	80e1c83a 	sub	r16,r16,r3
 8004454:	1210703a 	and	r8,r2,r8
 8004458:	003f3806 	br	800413c <__adddf3+0x7c>
 800445c:	9007883a 	mov	r3,r18
 8004460:	0011883a 	mov	r8,zero
 8004464:	0005883a 	mov	r2,zero
 8004468:	003f4c06 	br	800419c <__adddf3+0xdc>
 800446c:	498cb03a 	or	r6,r9,r6
 8004470:	300cc03a 	cmpne	r6,r6,zero
 8004474:	0007883a 	mov	r3,zero
 8004478:	003f6806 	br	800421c <__adddf3+0x15c>
 800447c:	20009c1e 	bne	r4,zero,80046f0 <__adddf3+0x630>
 8004480:	80800044 	addi	r2,r16,1
 8004484:	1141ffcc 	andi	r5,r2,2047
 8004488:	01000044 	movi	r4,1
 800448c:	2140670e 	bge	r4,r5,800462c <__adddf3+0x56c>
 8004490:	0101ffc4 	movi	r4,2047
 8004494:	11007f26 	beq	r2,r4,8004694 <__adddf3+0x5d4>
 8004498:	898d883a 	add	r6,r17,r6
 800449c:	4247883a 	add	r3,r8,r9
 80044a0:	3451803a 	cmpltu	r8,r6,r17
 80044a4:	40d1883a 	add	r8,r8,r3
 80044a8:	402297fa 	slli	r17,r8,31
 80044ac:	300cd07a 	srli	r6,r6,1
 80044b0:	4010d07a 	srli	r8,r8,1
 80044b4:	1021883a 	mov	r16,r2
 80044b8:	89a2b03a 	or	r17,r17,r6
 80044bc:	003f1f06 	br	800413c <__adddf3+0x7c>
 80044c0:	0081ffc4 	movi	r2,2047
 80044c4:	80bf481e 	bne	r16,r2,80041e8 <__adddf3+0x128>
 80044c8:	003f1c06 	br	800413c <__adddf3+0x7c>
 80044cc:	843ff844 	addi	r16,r16,-31
 80044d0:	01000804 	movi	r4,32
 80044d4:	1406d83a 	srl	r3,r2,r16
 80044d8:	41005026 	beq	r8,r4,800461c <__adddf3+0x55c>
 80044dc:	01001004 	movi	r4,64
 80044e0:	2211c83a 	sub	r8,r4,r8
 80044e4:	1204983a 	sll	r2,r2,r8
 80044e8:	88a2b03a 	or	r17,r17,r2
 80044ec:	8822c03a 	cmpne	r17,r17,zero
 80044f0:	1c62b03a 	or	r17,r3,r17
 80044f4:	0011883a 	mov	r8,zero
 80044f8:	0021883a 	mov	r16,zero
 80044fc:	003f7106 	br	80042c4 <__adddf3+0x204>
 8004500:	193ff804 	addi	r4,r3,-32
 8004504:	00800804 	movi	r2,32
 8004508:	4908d83a 	srl	r4,r9,r4
 800450c:	18804526 	beq	r3,r2,8004624 <__adddf3+0x564>
 8004510:	00801004 	movi	r2,64
 8004514:	10c5c83a 	sub	r2,r2,r3
 8004518:	4886983a 	sll	r3,r9,r2
 800451c:	198cb03a 	or	r6,r3,r6
 8004520:	300cc03a 	cmpne	r6,r6,zero
 8004524:	218cb03a 	or	r6,r4,r6
 8004528:	0007883a 	mov	r3,zero
 800452c:	003f3b06 	br	800421c <__adddf3+0x15c>
 8004530:	80002a26 	beq	r16,zero,80045dc <__adddf3+0x51c>
 8004534:	0101ffc4 	movi	r4,2047
 8004538:	11006826 	beq	r2,r4,80046dc <__adddf3+0x61c>
 800453c:	00c7c83a 	sub	r3,zero,r3
 8004540:	42002034 	orhi	r8,r8,128
 8004544:	01000e04 	movi	r4,56
 8004548:	20c07c16 	blt	r4,r3,800473c <__adddf3+0x67c>
 800454c:	010007c4 	movi	r4,31
 8004550:	20c0da16 	blt	r4,r3,80048bc <__adddf3+0x7fc>
 8004554:	01000804 	movi	r4,32
 8004558:	20c9c83a 	sub	r4,r4,r3
 800455c:	4114983a 	sll	r10,r8,r4
 8004560:	88cad83a 	srl	r5,r17,r3
 8004564:	8908983a 	sll	r4,r17,r4
 8004568:	40c6d83a 	srl	r3,r8,r3
 800456c:	5162b03a 	or	r17,r10,r5
 8004570:	2008c03a 	cmpne	r4,r4,zero
 8004574:	8922b03a 	or	r17,r17,r4
 8004578:	3463c83a 	sub	r17,r6,r17
 800457c:	48c7c83a 	sub	r3,r9,r3
 8004580:	344d803a 	cmpltu	r6,r6,r17
 8004584:	1991c83a 	sub	r8,r3,r6
 8004588:	1021883a 	mov	r16,r2
 800458c:	3825883a 	mov	r18,r7
 8004590:	003f2706 	br	8004230 <__adddf3+0x170>
 8004594:	24d0b03a 	or	r8,r4,r19
 8004598:	40001b1e 	bne	r8,zero,8004608 <__adddf3+0x548>
 800459c:	0005883a 	mov	r2,zero
 80045a0:	0007883a 	mov	r3,zero
 80045a4:	0021883a 	mov	r16,zero
 80045a8:	003f4d06 	br	80042e0 <__adddf3+0x220>
 80045ac:	008007c4 	movi	r2,31
 80045b0:	11003c16 	blt	r2,r4,80046a4 <__adddf3+0x5e4>
 80045b4:	00800804 	movi	r2,32
 80045b8:	1105c83a 	sub	r2,r2,r4
 80045bc:	488e983a 	sll	r7,r9,r2
 80045c0:	310ad83a 	srl	r5,r6,r4
 80045c4:	3084983a 	sll	r2,r6,r2
 80045c8:	4912d83a 	srl	r9,r9,r4
 80045cc:	394ab03a 	or	r5,r7,r5
 80045d0:	1004c03a 	cmpne	r2,r2,zero
 80045d4:	288ab03a 	or	r5,r5,r2
 80045d8:	003f5306 	br	8004328 <__adddf3+0x268>
 80045dc:	4448b03a 	or	r4,r8,r17
 80045e0:	20003e26 	beq	r4,zero,80046dc <__adddf3+0x61c>
 80045e4:	00c6303a 	nor	r3,zero,r3
 80045e8:	18003a1e 	bne	r3,zero,80046d4 <__adddf3+0x614>
 80045ec:	3463c83a 	sub	r17,r6,r17
 80045f0:	4a07c83a 	sub	r3,r9,r8
 80045f4:	344d803a 	cmpltu	r6,r6,r17
 80045f8:	1991c83a 	sub	r8,r3,r6
 80045fc:	1021883a 	mov	r16,r2
 8004600:	3825883a 	mov	r18,r7
 8004604:	003f0a06 	br	8004230 <__adddf3+0x170>
 8004608:	2023883a 	mov	r17,r4
 800460c:	003f0d06 	br	8004244 <__adddf3+0x184>
 8004610:	0081ffc4 	movi	r2,2047
 8004614:	80bf3f1e 	bne	r16,r2,8004314 <__adddf3+0x254>
 8004618:	003ec806 	br	800413c <__adddf3+0x7c>
 800461c:	0005883a 	mov	r2,zero
 8004620:	003fb106 	br	80044e8 <__adddf3+0x428>
 8004624:	0007883a 	mov	r3,zero
 8004628:	003fbc06 	br	800451c <__adddf3+0x45c>
 800462c:	4444b03a 	or	r2,r8,r17
 8004630:	8000871e 	bne	r16,zero,8004850 <__adddf3+0x790>
 8004634:	1000ba26 	beq	r2,zero,8004920 <__adddf3+0x860>
 8004638:	4984b03a 	or	r2,r9,r6
 800463c:	103ebf26 	beq	r2,zero,800413c <__adddf3+0x7c>
 8004640:	8985883a 	add	r2,r17,r6
 8004644:	4247883a 	add	r3,r8,r9
 8004648:	1451803a 	cmpltu	r8,r2,r17
 800464c:	40d1883a 	add	r8,r8,r3
 8004650:	40c0202c 	andhi	r3,r8,128
 8004654:	1023883a 	mov	r17,r2
 8004658:	183f1a26 	beq	r3,zero,80042c4 <__adddf3+0x204>
 800465c:	00bfe034 	movhi	r2,65408
 8004660:	10bfffc4 	addi	r2,r2,-1
 8004664:	2021883a 	mov	r16,r4
 8004668:	4090703a 	and	r8,r8,r2
 800466c:	003eb306 	br	800413c <__adddf3+0x7c>
 8004670:	4444b03a 	or	r2,r8,r17
 8004674:	8000291e 	bne	r16,zero,800471c <__adddf3+0x65c>
 8004678:	10004b1e 	bne	r2,zero,80047a8 <__adddf3+0x6e8>
 800467c:	4990b03a 	or	r8,r9,r6
 8004680:	40008b26 	beq	r8,zero,80048b0 <__adddf3+0x7f0>
 8004684:	4811883a 	mov	r8,r9
 8004688:	3023883a 	mov	r17,r6
 800468c:	3825883a 	mov	r18,r7
 8004690:	003eaa06 	br	800413c <__adddf3+0x7c>
 8004694:	1021883a 	mov	r16,r2
 8004698:	0011883a 	mov	r8,zero
 800469c:	0005883a 	mov	r2,zero
 80046a0:	003f0f06 	br	80042e0 <__adddf3+0x220>
 80046a4:	217ff804 	addi	r5,r4,-32
 80046a8:	00800804 	movi	r2,32
 80046ac:	494ad83a 	srl	r5,r9,r5
 80046b0:	20807d26 	beq	r4,r2,80048a8 <__adddf3+0x7e8>
 80046b4:	00801004 	movi	r2,64
 80046b8:	1109c83a 	sub	r4,r2,r4
 80046bc:	4912983a 	sll	r9,r9,r4
 80046c0:	498cb03a 	or	r6,r9,r6
 80046c4:	300cc03a 	cmpne	r6,r6,zero
 80046c8:	298ab03a 	or	r5,r5,r6
 80046cc:	0013883a 	mov	r9,zero
 80046d0:	003f1506 	br	8004328 <__adddf3+0x268>
 80046d4:	0101ffc4 	movi	r4,2047
 80046d8:	113f9a1e 	bne	r2,r4,8004544 <__adddf3+0x484>
 80046dc:	4811883a 	mov	r8,r9
 80046e0:	3023883a 	mov	r17,r6
 80046e4:	1021883a 	mov	r16,r2
 80046e8:	3825883a 	mov	r18,r7
 80046ec:	003e9306 	br	800413c <__adddf3+0x7c>
 80046f0:	8000161e 	bne	r16,zero,800474c <__adddf3+0x68c>
 80046f4:	444ab03a 	or	r5,r8,r17
 80046f8:	28005126 	beq	r5,zero,8004840 <__adddf3+0x780>
 80046fc:	0108303a 	nor	r4,zero,r4
 8004700:	20004d1e 	bne	r4,zero,8004838 <__adddf3+0x778>
 8004704:	89a3883a 	add	r17,r17,r6
 8004708:	4253883a 	add	r9,r8,r9
 800470c:	898d803a 	cmpltu	r6,r17,r6
 8004710:	3251883a 	add	r8,r6,r9
 8004714:	1021883a 	mov	r16,r2
 8004718:	003f0806 	br	800433c <__adddf3+0x27c>
 800471c:	1000301e 	bne	r2,zero,80047e0 <__adddf3+0x720>
 8004720:	4984b03a 	or	r2,r9,r6
 8004724:	10007126 	beq	r2,zero,80048ec <__adddf3+0x82c>
 8004728:	4811883a 	mov	r8,r9
 800472c:	3023883a 	mov	r17,r6
 8004730:	3825883a 	mov	r18,r7
 8004734:	0401ffc4 	movi	r16,2047
 8004738:	003e8006 	br	800413c <__adddf3+0x7c>
 800473c:	4462b03a 	or	r17,r8,r17
 8004740:	8822c03a 	cmpne	r17,r17,zero
 8004744:	0007883a 	mov	r3,zero
 8004748:	003f8b06 	br	8004578 <__adddf3+0x4b8>
 800474c:	0141ffc4 	movi	r5,2047
 8004750:	11403b26 	beq	r2,r5,8004840 <__adddf3+0x780>
 8004754:	0109c83a 	sub	r4,zero,r4
 8004758:	42002034 	orhi	r8,r8,128
 800475c:	01400e04 	movi	r5,56
 8004760:	29006716 	blt	r5,r4,8004900 <__adddf3+0x840>
 8004764:	014007c4 	movi	r5,31
 8004768:	29007016 	blt	r5,r4,800492c <__adddf3+0x86c>
 800476c:	01400804 	movi	r5,32
 8004770:	290bc83a 	sub	r5,r5,r4
 8004774:	4154983a 	sll	r10,r8,r5
 8004778:	890ed83a 	srl	r7,r17,r4
 800477c:	894a983a 	sll	r5,r17,r5
 8004780:	4108d83a 	srl	r4,r8,r4
 8004784:	51e2b03a 	or	r17,r10,r7
 8004788:	280ac03a 	cmpne	r5,r5,zero
 800478c:	8962b03a 	or	r17,r17,r5
 8004790:	89a3883a 	add	r17,r17,r6
 8004794:	2253883a 	add	r9,r4,r9
 8004798:	898d803a 	cmpltu	r6,r17,r6
 800479c:	3251883a 	add	r8,r6,r9
 80047a0:	1021883a 	mov	r16,r2
 80047a4:	003ee506 	br	800433c <__adddf3+0x27c>
 80047a8:	4984b03a 	or	r2,r9,r6
 80047ac:	103e6326 	beq	r2,zero,800413c <__adddf3+0x7c>
 80047b0:	8987c83a 	sub	r3,r17,r6
 80047b4:	88c9803a 	cmpltu	r4,r17,r3
 80047b8:	4245c83a 	sub	r2,r8,r9
 80047bc:	1105c83a 	sub	r2,r2,r4
 80047c0:	1100202c 	andhi	r4,r2,128
 80047c4:	203ebb26 	beq	r4,zero,80042b4 <__adddf3+0x1f4>
 80047c8:	3463c83a 	sub	r17,r6,r17
 80047cc:	4a07c83a 	sub	r3,r9,r8
 80047d0:	344d803a 	cmpltu	r6,r6,r17
 80047d4:	1991c83a 	sub	r8,r3,r6
 80047d8:	3825883a 	mov	r18,r7
 80047dc:	003e5706 	br	800413c <__adddf3+0x7c>
 80047e0:	4984b03a 	or	r2,r9,r6
 80047e4:	10002e26 	beq	r2,zero,80048a0 <__adddf3+0x7e0>
 80047e8:	4004d0fa 	srli	r2,r8,3
 80047ec:	8822d0fa 	srli	r17,r17,3
 80047f0:	4010977a 	slli	r8,r8,29
 80047f4:	10c0022c 	andhi	r3,r2,8
 80047f8:	4462b03a 	or	r17,r8,r17
 80047fc:	18000826 	beq	r3,zero,8004820 <__adddf3+0x760>
 8004800:	4808d0fa 	srli	r4,r9,3
 8004804:	20c0022c 	andhi	r3,r4,8
 8004808:	1800051e 	bne	r3,zero,8004820 <__adddf3+0x760>
 800480c:	300cd0fa 	srli	r6,r6,3
 8004810:	4806977a 	slli	r3,r9,29
 8004814:	2005883a 	mov	r2,r4
 8004818:	3825883a 	mov	r18,r7
 800481c:	19a2b03a 	or	r17,r3,r6
 8004820:	8810d77a 	srli	r8,r17,29
 8004824:	100490fa 	slli	r2,r2,3
 8004828:	882290fa 	slli	r17,r17,3
 800482c:	0401ffc4 	movi	r16,2047
 8004830:	4090b03a 	or	r8,r8,r2
 8004834:	003e4106 	br	800413c <__adddf3+0x7c>
 8004838:	0141ffc4 	movi	r5,2047
 800483c:	117fc71e 	bne	r2,r5,800475c <__adddf3+0x69c>
 8004840:	4811883a 	mov	r8,r9
 8004844:	3023883a 	mov	r17,r6
 8004848:	1021883a 	mov	r16,r2
 800484c:	003e3b06 	br	800413c <__adddf3+0x7c>
 8004850:	10002f26 	beq	r2,zero,8004910 <__adddf3+0x850>
 8004854:	4984b03a 	or	r2,r9,r6
 8004858:	10001126 	beq	r2,zero,80048a0 <__adddf3+0x7e0>
 800485c:	4004d0fa 	srli	r2,r8,3
 8004860:	8822d0fa 	srli	r17,r17,3
 8004864:	4010977a 	slli	r8,r8,29
 8004868:	10c0022c 	andhi	r3,r2,8
 800486c:	4462b03a 	or	r17,r8,r17
 8004870:	183feb26 	beq	r3,zero,8004820 <__adddf3+0x760>
 8004874:	4808d0fa 	srli	r4,r9,3
 8004878:	20c0022c 	andhi	r3,r4,8
 800487c:	183fe81e 	bne	r3,zero,8004820 <__adddf3+0x760>
 8004880:	300cd0fa 	srli	r6,r6,3
 8004884:	4806977a 	slli	r3,r9,29
 8004888:	2005883a 	mov	r2,r4
 800488c:	19a2b03a 	or	r17,r3,r6
 8004890:	003fe306 	br	8004820 <__adddf3+0x760>
 8004894:	0011883a 	mov	r8,zero
 8004898:	0005883a 	mov	r2,zero
 800489c:	003e3f06 	br	800419c <__adddf3+0xdc>
 80048a0:	0401ffc4 	movi	r16,2047
 80048a4:	003e2506 	br	800413c <__adddf3+0x7c>
 80048a8:	0013883a 	mov	r9,zero
 80048ac:	003f8406 	br	80046c0 <__adddf3+0x600>
 80048b0:	0005883a 	mov	r2,zero
 80048b4:	0007883a 	mov	r3,zero
 80048b8:	003e8906 	br	80042e0 <__adddf3+0x220>
 80048bc:	197ff804 	addi	r5,r3,-32
 80048c0:	01000804 	movi	r4,32
 80048c4:	414ad83a 	srl	r5,r8,r5
 80048c8:	19002426 	beq	r3,r4,800495c <__adddf3+0x89c>
 80048cc:	01001004 	movi	r4,64
 80048d0:	20c7c83a 	sub	r3,r4,r3
 80048d4:	40c6983a 	sll	r3,r8,r3
 80048d8:	1c46b03a 	or	r3,r3,r17
 80048dc:	1806c03a 	cmpne	r3,r3,zero
 80048e0:	28e2b03a 	or	r17,r5,r3
 80048e4:	0007883a 	mov	r3,zero
 80048e8:	003f2306 	br	8004578 <__adddf3+0x4b8>
 80048ec:	0007883a 	mov	r3,zero
 80048f0:	5811883a 	mov	r8,r11
 80048f4:	00bfffc4 	movi	r2,-1
 80048f8:	0401ffc4 	movi	r16,2047
 80048fc:	003e7806 	br	80042e0 <__adddf3+0x220>
 8004900:	4462b03a 	or	r17,r8,r17
 8004904:	8822c03a 	cmpne	r17,r17,zero
 8004908:	0009883a 	mov	r4,zero
 800490c:	003fa006 	br	8004790 <__adddf3+0x6d0>
 8004910:	4811883a 	mov	r8,r9
 8004914:	3023883a 	mov	r17,r6
 8004918:	0401ffc4 	movi	r16,2047
 800491c:	003e0706 	br	800413c <__adddf3+0x7c>
 8004920:	4811883a 	mov	r8,r9
 8004924:	3023883a 	mov	r17,r6
 8004928:	003e0406 	br	800413c <__adddf3+0x7c>
 800492c:	21fff804 	addi	r7,r4,-32
 8004930:	01400804 	movi	r5,32
 8004934:	41ced83a 	srl	r7,r8,r7
 8004938:	21400a26 	beq	r4,r5,8004964 <__adddf3+0x8a4>
 800493c:	01401004 	movi	r5,64
 8004940:	2909c83a 	sub	r4,r5,r4
 8004944:	4108983a 	sll	r4,r8,r4
 8004948:	2448b03a 	or	r4,r4,r17
 800494c:	2008c03a 	cmpne	r4,r4,zero
 8004950:	3922b03a 	or	r17,r7,r4
 8004954:	0009883a 	mov	r4,zero
 8004958:	003f8d06 	br	8004790 <__adddf3+0x6d0>
 800495c:	0007883a 	mov	r3,zero
 8004960:	003fdd06 	br	80048d8 <__adddf3+0x818>
 8004964:	0009883a 	mov	r4,zero
 8004968:	003ff706 	br	8004948 <__adddf3+0x888>

0800496c <__eqdf2>:
 800496c:	2804d53a 	srli	r2,r5,20
 8004970:	3806d53a 	srli	r3,r7,20
 8004974:	02000434 	movhi	r8,16
 8004978:	423fffc4 	addi	r8,r8,-1
 800497c:	1081ffcc 	andi	r2,r2,2047
 8004980:	0281ffc4 	movi	r10,2047
 8004984:	2a12703a 	and	r9,r5,r8
 8004988:	18c1ffcc 	andi	r3,r3,2047
 800498c:	3a10703a 	and	r8,r7,r8
 8004990:	280ad7fa 	srli	r5,r5,31
 8004994:	380ed7fa 	srli	r7,r7,31
 8004998:	12801026 	beq	r2,r10,80049dc <__eqdf2+0x70>
 800499c:	0281ffc4 	movi	r10,2047
 80049a0:	1a800a26 	beq	r3,r10,80049cc <__eqdf2+0x60>
 80049a4:	10c00226 	beq	r2,r3,80049b0 <__eqdf2+0x44>
 80049a8:	00800044 	movi	r2,1
 80049ac:	f800283a 	ret
 80049b0:	4a3ffd1e 	bne	r9,r8,80049a8 <__eqdf2+0x3c>
 80049b4:	21bffc1e 	bne	r4,r6,80049a8 <__eqdf2+0x3c>
 80049b8:	29c00c26 	beq	r5,r7,80049ec <__eqdf2+0x80>
 80049bc:	103ffa1e 	bne	r2,zero,80049a8 <__eqdf2+0x3c>
 80049c0:	2244b03a 	or	r2,r4,r9
 80049c4:	1004c03a 	cmpne	r2,r2,zero
 80049c8:	f800283a 	ret
 80049cc:	3214b03a 	or	r10,r6,r8
 80049d0:	503ff426 	beq	r10,zero,80049a4 <__eqdf2+0x38>
 80049d4:	00800044 	movi	r2,1
 80049d8:	f800283a 	ret
 80049dc:	2254b03a 	or	r10,r4,r9
 80049e0:	503fee26 	beq	r10,zero,800499c <__eqdf2+0x30>
 80049e4:	00800044 	movi	r2,1
 80049e8:	f800283a 	ret
 80049ec:	0005883a 	mov	r2,zero
 80049f0:	f800283a 	ret

080049f4 <__gedf2>:
 80049f4:	2804d53a 	srli	r2,r5,20
 80049f8:	3806d53a 	srli	r3,r7,20
 80049fc:	02000434 	movhi	r8,16
 8004a00:	423fffc4 	addi	r8,r8,-1
 8004a04:	1081ffcc 	andi	r2,r2,2047
 8004a08:	0241ffc4 	movi	r9,2047
 8004a0c:	2a14703a 	and	r10,r5,r8
 8004a10:	18c1ffcc 	andi	r3,r3,2047
 8004a14:	3a10703a 	and	r8,r7,r8
 8004a18:	280ad7fa 	srli	r5,r5,31
 8004a1c:	380ed7fa 	srli	r7,r7,31
 8004a20:	12401d26 	beq	r2,r9,8004a98 <__gedf2+0xa4>
 8004a24:	0241ffc4 	movi	r9,2047
 8004a28:	1a401226 	beq	r3,r9,8004a74 <__gedf2+0x80>
 8004a2c:	1000081e 	bne	r2,zero,8004a50 <__gedf2+0x5c>
 8004a30:	2296b03a 	or	r11,r4,r10
 8004a34:	5813003a 	cmpeq	r9,r11,zero
 8004a38:	1800091e 	bne	r3,zero,8004a60 <__gedf2+0x6c>
 8004a3c:	3218b03a 	or	r12,r6,r8
 8004a40:	6000071e 	bne	r12,zero,8004a60 <__gedf2+0x6c>
 8004a44:	0005883a 	mov	r2,zero
 8004a48:	5800101e 	bne	r11,zero,8004a8c <__gedf2+0x98>
 8004a4c:	f800283a 	ret
 8004a50:	18000c1e 	bne	r3,zero,8004a84 <__gedf2+0x90>
 8004a54:	3212b03a 	or	r9,r6,r8
 8004a58:	48000c26 	beq	r9,zero,8004a8c <__gedf2+0x98>
 8004a5c:	0013883a 	mov	r9,zero
 8004a60:	39c03fcc 	andi	r7,r7,255
 8004a64:	48000826 	beq	r9,zero,8004a88 <__gedf2+0x94>
 8004a68:	38000926 	beq	r7,zero,8004a90 <__gedf2+0x9c>
 8004a6c:	00800044 	movi	r2,1
 8004a70:	f800283a 	ret
 8004a74:	3212b03a 	or	r9,r6,r8
 8004a78:	483fec26 	beq	r9,zero,8004a2c <__gedf2+0x38>
 8004a7c:	00bfff84 	movi	r2,-2
 8004a80:	f800283a 	ret
 8004a84:	39c03fcc 	andi	r7,r7,255
 8004a88:	29c00626 	beq	r5,r7,8004aa4 <__gedf2+0xb0>
 8004a8c:	283ff726 	beq	r5,zero,8004a6c <__gedf2+0x78>
 8004a90:	00bfffc4 	movi	r2,-1
 8004a94:	f800283a 	ret
 8004a98:	2292b03a 	or	r9,r4,r10
 8004a9c:	483fe126 	beq	r9,zero,8004a24 <__gedf2+0x30>
 8004aa0:	003ff606 	br	8004a7c <__gedf2+0x88>
 8004aa4:	18bff916 	blt	r3,r2,8004a8c <__gedf2+0x98>
 8004aa8:	10c00316 	blt	r2,r3,8004ab8 <__gedf2+0xc4>
 8004aac:	42bff736 	bltu	r8,r10,8004a8c <__gedf2+0x98>
 8004ab0:	52000326 	beq	r10,r8,8004ac0 <__gedf2+0xcc>
 8004ab4:	5200042e 	bgeu	r10,r8,8004ac8 <__gedf2+0xd4>
 8004ab8:	283fec1e 	bne	r5,zero,8004a6c <__gedf2+0x78>
 8004abc:	003ff406 	br	8004a90 <__gedf2+0x9c>
 8004ac0:	313ff236 	bltu	r6,r4,8004a8c <__gedf2+0x98>
 8004ac4:	21bffc36 	bltu	r4,r6,8004ab8 <__gedf2+0xc4>
 8004ac8:	0005883a 	mov	r2,zero
 8004acc:	f800283a 	ret

08004ad0 <__muldf3>:
 8004ad0:	defff304 	addi	sp,sp,-52
 8004ad4:	2804d53a 	srli	r2,r5,20
 8004ad8:	dd800915 	stw	r22,36(sp)
 8004adc:	282cd7fa 	srli	r22,r5,31
 8004ae0:	dc000315 	stw	r16,12(sp)
 8004ae4:	04000434 	movhi	r16,16
 8004ae8:	dd400815 	stw	r21,32(sp)
 8004aec:	dc800515 	stw	r18,20(sp)
 8004af0:	843fffc4 	addi	r16,r16,-1
 8004af4:	dfc00c15 	stw	ra,48(sp)
 8004af8:	df000b15 	stw	fp,44(sp)
 8004afc:	ddc00a15 	stw	r23,40(sp)
 8004b00:	dd000715 	stw	r20,28(sp)
 8004b04:	dcc00615 	stw	r19,24(sp)
 8004b08:	dc400415 	stw	r17,16(sp)
 8004b0c:	1481ffcc 	andi	r18,r2,2047
 8004b10:	2c20703a 	and	r16,r5,r16
 8004b14:	b02b883a 	mov	r21,r22
 8004b18:	b2403fcc 	andi	r9,r22,255
 8004b1c:	90006026 	beq	r18,zero,8004ca0 <__muldf3+0x1d0>
 8004b20:	0081ffc4 	movi	r2,2047
 8004b24:	2029883a 	mov	r20,r4
 8004b28:	90803626 	beq	r18,r2,8004c04 <__muldf3+0x134>
 8004b2c:	80800434 	orhi	r2,r16,16
 8004b30:	100490fa 	slli	r2,r2,3
 8004b34:	2020d77a 	srli	r16,r4,29
 8004b38:	202890fa 	slli	r20,r4,3
 8004b3c:	94bf0044 	addi	r18,r18,-1023
 8004b40:	80a0b03a 	or	r16,r16,r2
 8004b44:	0027883a 	mov	r19,zero
 8004b48:	0039883a 	mov	fp,zero
 8004b4c:	3804d53a 	srli	r2,r7,20
 8004b50:	382ed7fa 	srli	r23,r7,31
 8004b54:	04400434 	movhi	r17,16
 8004b58:	8c7fffc4 	addi	r17,r17,-1
 8004b5c:	1081ffcc 	andi	r2,r2,2047
 8004b60:	3011883a 	mov	r8,r6
 8004b64:	3c62703a 	and	r17,r7,r17
 8004b68:	ba803fcc 	andi	r10,r23,255
 8004b6c:	10006d26 	beq	r2,zero,8004d24 <__muldf3+0x254>
 8004b70:	00c1ffc4 	movi	r3,2047
 8004b74:	10c06526 	beq	r2,r3,8004d0c <__muldf3+0x23c>
 8004b78:	88c00434 	orhi	r3,r17,16
 8004b7c:	180690fa 	slli	r3,r3,3
 8004b80:	3022d77a 	srli	r17,r6,29
 8004b84:	301090fa 	slli	r8,r6,3
 8004b88:	10bf0044 	addi	r2,r2,-1023
 8004b8c:	88e2b03a 	or	r17,r17,r3
 8004b90:	000b883a 	mov	r5,zero
 8004b94:	9085883a 	add	r2,r18,r2
 8004b98:	2cc8b03a 	or	r4,r5,r19
 8004b9c:	00c003c4 	movi	r3,15
 8004ba0:	bdacf03a 	xor	r22,r23,r22
 8004ba4:	12c00044 	addi	r11,r2,1
 8004ba8:	19009936 	bltu	r3,r4,8004e10 <__muldf3+0x340>
 8004bac:	200890ba 	slli	r4,r4,2
 8004bb0:	00c20034 	movhi	r3,2048
 8004bb4:	18d2f104 	addi	r3,r3,19396
 8004bb8:	20c9883a 	add	r4,r4,r3
 8004bbc:	20c00017 	ldw	r3,0(r4)
 8004bc0:	1800683a 	jmp	r3
 8004bc4:	08004e10 	cmplti	zero,at,312
 8004bc8:	08004c24 	muli	zero,at,304
 8004bcc:	08004c24 	muli	zero,at,304
 8004bd0:	08004c20 	cmpeqi	zero,at,304
 8004bd4:	08004dec 	andhi	zero,at,311
 8004bd8:	08004dec 	andhi	zero,at,311
 8004bdc:	08004dd4 	ori	zero,at,311
 8004be0:	08004c20 	cmpeqi	zero,at,304
 8004be4:	08004dec 	andhi	zero,at,311
 8004be8:	08004dd4 	ori	zero,at,311
 8004bec:	08004dec 	andhi	zero,at,311
 8004bf0:	08004c20 	cmpeqi	zero,at,304
 8004bf4:	08004dfc 	xorhi	zero,at,311
 8004bf8:	08004dfc 	xorhi	zero,at,311
 8004bfc:	08004dfc 	xorhi	zero,at,311
 8004c00:	08005018 	cmpnei	zero,at,320
 8004c04:	2404b03a 	or	r2,r4,r16
 8004c08:	10006f1e 	bne	r2,zero,8004dc8 <__muldf3+0x2f8>
 8004c0c:	04c00204 	movi	r19,8
 8004c10:	0021883a 	mov	r16,zero
 8004c14:	0029883a 	mov	r20,zero
 8004c18:	07000084 	movi	fp,2
 8004c1c:	003fcb06 	br	8004b4c <__muldf3+0x7c>
 8004c20:	502d883a 	mov	r22,r10
 8004c24:	00800084 	movi	r2,2
 8004c28:	28805726 	beq	r5,r2,8004d88 <__muldf3+0x2b8>
 8004c2c:	008000c4 	movi	r2,3
 8004c30:	28816626 	beq	r5,r2,80051cc <__muldf3+0x6fc>
 8004c34:	00800044 	movi	r2,1
 8004c38:	2881411e 	bne	r5,r2,8005140 <__muldf3+0x670>
 8004c3c:	b02b883a 	mov	r21,r22
 8004c40:	0005883a 	mov	r2,zero
 8004c44:	000b883a 	mov	r5,zero
 8004c48:	0029883a 	mov	r20,zero
 8004c4c:	1004953a 	slli	r2,r2,20
 8004c50:	a8c03fcc 	andi	r3,r21,255
 8004c54:	04400434 	movhi	r17,16
 8004c58:	8c7fffc4 	addi	r17,r17,-1
 8004c5c:	180697fa 	slli	r3,r3,31
 8004c60:	2c4a703a 	and	r5,r5,r17
 8004c64:	288ab03a 	or	r5,r5,r2
 8004c68:	28c6b03a 	or	r3,r5,r3
 8004c6c:	a005883a 	mov	r2,r20
 8004c70:	dfc00c17 	ldw	ra,48(sp)
 8004c74:	df000b17 	ldw	fp,44(sp)
 8004c78:	ddc00a17 	ldw	r23,40(sp)
 8004c7c:	dd800917 	ldw	r22,36(sp)
 8004c80:	dd400817 	ldw	r21,32(sp)
 8004c84:	dd000717 	ldw	r20,28(sp)
 8004c88:	dcc00617 	ldw	r19,24(sp)
 8004c8c:	dc800517 	ldw	r18,20(sp)
 8004c90:	dc400417 	ldw	r17,16(sp)
 8004c94:	dc000317 	ldw	r16,12(sp)
 8004c98:	dec00d04 	addi	sp,sp,52
 8004c9c:	f800283a 	ret
 8004ca0:	2404b03a 	or	r2,r4,r16
 8004ca4:	2027883a 	mov	r19,r4
 8004ca8:	10004226 	beq	r2,zero,8004db4 <__muldf3+0x2e4>
 8004cac:	8000fc26 	beq	r16,zero,80050a0 <__muldf3+0x5d0>
 8004cb0:	8009883a 	mov	r4,r16
 8004cb4:	d9800215 	stw	r6,8(sp)
 8004cb8:	d9c00015 	stw	r7,0(sp)
 8004cbc:	da400115 	stw	r9,4(sp)
 8004cc0:	8005d500 	call	8005d50 <__clzsi2>
 8004cc4:	d9800217 	ldw	r6,8(sp)
 8004cc8:	d9c00017 	ldw	r7,0(sp)
 8004ccc:	da400117 	ldw	r9,4(sp)
 8004cd0:	113ffd44 	addi	r4,r2,-11
 8004cd4:	00c00704 	movi	r3,28
 8004cd8:	1900ed16 	blt	r3,r4,8005090 <__muldf3+0x5c0>
 8004cdc:	00c00744 	movi	r3,29
 8004ce0:	147ffe04 	addi	r17,r2,-8
 8004ce4:	1907c83a 	sub	r3,r3,r4
 8004ce8:	8460983a 	sll	r16,r16,r17
 8004cec:	98c6d83a 	srl	r3,r19,r3
 8004cf0:	9c68983a 	sll	r20,r19,r17
 8004cf4:	1c20b03a 	or	r16,r3,r16
 8004cf8:	1080fcc4 	addi	r2,r2,1011
 8004cfc:	00a5c83a 	sub	r18,zero,r2
 8004d00:	0027883a 	mov	r19,zero
 8004d04:	0039883a 	mov	fp,zero
 8004d08:	003f9006 	br	8004b4c <__muldf3+0x7c>
 8004d0c:	3446b03a 	or	r3,r6,r17
 8004d10:	1800261e 	bne	r3,zero,8004dac <__muldf3+0x2dc>
 8004d14:	0023883a 	mov	r17,zero
 8004d18:	0011883a 	mov	r8,zero
 8004d1c:	01400084 	movi	r5,2
 8004d20:	003f9c06 	br	8004b94 <__muldf3+0xc4>
 8004d24:	3446b03a 	or	r3,r6,r17
 8004d28:	18001c26 	beq	r3,zero,8004d9c <__muldf3+0x2cc>
 8004d2c:	8800ce26 	beq	r17,zero,8005068 <__muldf3+0x598>
 8004d30:	8809883a 	mov	r4,r17
 8004d34:	d9800215 	stw	r6,8(sp)
 8004d38:	da400115 	stw	r9,4(sp)
 8004d3c:	da800015 	stw	r10,0(sp)
 8004d40:	8005d500 	call	8005d50 <__clzsi2>
 8004d44:	d9800217 	ldw	r6,8(sp)
 8004d48:	da400117 	ldw	r9,4(sp)
 8004d4c:	da800017 	ldw	r10,0(sp)
 8004d50:	113ffd44 	addi	r4,r2,-11
 8004d54:	00c00704 	movi	r3,28
 8004d58:	1900bf16 	blt	r3,r4,8005058 <__muldf3+0x588>
 8004d5c:	00c00744 	movi	r3,29
 8004d60:	123ffe04 	addi	r8,r2,-8
 8004d64:	1907c83a 	sub	r3,r3,r4
 8004d68:	8a22983a 	sll	r17,r17,r8
 8004d6c:	30c6d83a 	srl	r3,r6,r3
 8004d70:	3210983a 	sll	r8,r6,r8
 8004d74:	1c62b03a 	or	r17,r3,r17
 8004d78:	1080fcc4 	addi	r2,r2,1011
 8004d7c:	0085c83a 	sub	r2,zero,r2
 8004d80:	000b883a 	mov	r5,zero
 8004d84:	003f8306 	br	8004b94 <__muldf3+0xc4>
 8004d88:	b02b883a 	mov	r21,r22
 8004d8c:	0081ffc4 	movi	r2,2047
 8004d90:	000b883a 	mov	r5,zero
 8004d94:	0029883a 	mov	r20,zero
 8004d98:	003fac06 	br	8004c4c <__muldf3+0x17c>
 8004d9c:	0023883a 	mov	r17,zero
 8004da0:	0011883a 	mov	r8,zero
 8004da4:	01400044 	movi	r5,1
 8004da8:	003f7a06 	br	8004b94 <__muldf3+0xc4>
 8004dac:	014000c4 	movi	r5,3
 8004db0:	003f7806 	br	8004b94 <__muldf3+0xc4>
 8004db4:	04c00104 	movi	r19,4
 8004db8:	0021883a 	mov	r16,zero
 8004dbc:	0029883a 	mov	r20,zero
 8004dc0:	07000044 	movi	fp,1
 8004dc4:	003f6106 	br	8004b4c <__muldf3+0x7c>
 8004dc8:	04c00304 	movi	r19,12
 8004dcc:	070000c4 	movi	fp,3
 8004dd0:	003f5e06 	br	8004b4c <__muldf3+0x7c>
 8004dd4:	01400434 	movhi	r5,16
 8004dd8:	002b883a 	mov	r21,zero
 8004ddc:	297fffc4 	addi	r5,r5,-1
 8004de0:	053fffc4 	movi	r20,-1
 8004de4:	0081ffc4 	movi	r2,2047
 8004de8:	003f9806 	br	8004c4c <__muldf3+0x17c>
 8004dec:	8023883a 	mov	r17,r16
 8004df0:	a011883a 	mov	r8,r20
 8004df4:	e00b883a 	mov	r5,fp
 8004df8:	003f8a06 	br	8004c24 <__muldf3+0x154>
 8004dfc:	8023883a 	mov	r17,r16
 8004e00:	a011883a 	mov	r8,r20
 8004e04:	482d883a 	mov	r22,r9
 8004e08:	e00b883a 	mov	r5,fp
 8004e0c:	003f8506 	br	8004c24 <__muldf3+0x154>
 8004e10:	a00ad43a 	srli	r5,r20,16
 8004e14:	401ad43a 	srli	r13,r8,16
 8004e18:	a53fffcc 	andi	r20,r20,65535
 8004e1c:	423fffcc 	andi	r8,r8,65535
 8004e20:	4519383a 	mul	r12,r8,r20
 8004e24:	4147383a 	mul	r3,r8,r5
 8004e28:	6d09383a 	mul	r4,r13,r20
 8004e2c:	600cd43a 	srli	r6,r12,16
 8004e30:	2b5d383a 	mul	r14,r5,r13
 8004e34:	20c9883a 	add	r4,r4,r3
 8004e38:	310d883a 	add	r6,r6,r4
 8004e3c:	30c0022e 	bgeu	r6,r3,8004e48 <__muldf3+0x378>
 8004e40:	00c00074 	movhi	r3,1
 8004e44:	70dd883a 	add	r14,r14,r3
 8004e48:	8826d43a 	srli	r19,r17,16
 8004e4c:	8bffffcc 	andi	r15,r17,65535
 8004e50:	7d23383a 	mul	r17,r15,r20
 8004e54:	7949383a 	mul	r4,r15,r5
 8004e58:	9d29383a 	mul	r20,r19,r20
 8004e5c:	8814d43a 	srli	r10,r17,16
 8004e60:	3012943a 	slli	r9,r6,16
 8004e64:	a129883a 	add	r20,r20,r4
 8004e68:	633fffcc 	andi	r12,r12,65535
 8004e6c:	5515883a 	add	r10,r10,r20
 8004e70:	3006d43a 	srli	r3,r6,16
 8004e74:	4b13883a 	add	r9,r9,r12
 8004e78:	2ccb383a 	mul	r5,r5,r19
 8004e7c:	5100022e 	bgeu	r10,r4,8004e88 <__muldf3+0x3b8>
 8004e80:	01000074 	movhi	r4,1
 8004e84:	290b883a 	add	r5,r5,r4
 8004e88:	802ad43a 	srli	r21,r16,16
 8004e8c:	843fffcc 	andi	r16,r16,65535
 8004e90:	440d383a 	mul	r6,r8,r16
 8004e94:	4565383a 	mul	r18,r8,r21
 8004e98:	8349383a 	mul	r4,r16,r13
 8004e9c:	500e943a 	slli	r7,r10,16
 8004ea0:	3010d43a 	srli	r8,r6,16
 8004ea4:	5028d43a 	srli	r20,r10,16
 8004ea8:	2489883a 	add	r4,r4,r18
 8004eac:	8abfffcc 	andi	r10,r17,65535
 8004eb0:	3a95883a 	add	r10,r7,r10
 8004eb4:	4119883a 	add	r12,r8,r4
 8004eb8:	a169883a 	add	r20,r20,r5
 8004ebc:	1a87883a 	add	r3,r3,r10
 8004ec0:	6d5b383a 	mul	r13,r13,r21
 8004ec4:	6480022e 	bgeu	r12,r18,8004ed0 <__muldf3+0x400>
 8004ec8:	01000074 	movhi	r4,1
 8004ecc:	691b883a 	add	r13,r13,r4
 8004ed0:	7c25383a 	mul	r18,r15,r16
 8004ed4:	7d4b383a 	mul	r5,r15,r21
 8004ed8:	84cf383a 	mul	r7,r16,r19
 8004edc:	901ed43a 	srli	r15,r18,16
 8004ee0:	6008d43a 	srli	r4,r12,16
 8004ee4:	6010943a 	slli	r8,r12,16
 8004ee8:	394f883a 	add	r7,r7,r5
 8004eec:	333fffcc 	andi	r12,r6,65535
 8004ef0:	79df883a 	add	r15,r15,r7
 8004ef4:	235b883a 	add	r13,r4,r13
 8004ef8:	9d63383a 	mul	r17,r19,r21
 8004efc:	4309883a 	add	r4,r8,r12
 8004f00:	7940022e 	bgeu	r15,r5,8004f0c <__muldf3+0x43c>
 8004f04:	01400074 	movhi	r5,1
 8004f08:	8963883a 	add	r17,r17,r5
 8004f0c:	780a943a 	slli	r5,r15,16
 8004f10:	91bfffcc 	andi	r6,r18,65535
 8004f14:	70c7883a 	add	r3,r14,r3
 8004f18:	298d883a 	add	r6,r5,r6
 8004f1c:	1a8f803a 	cmpltu	r7,r3,r10
 8004f20:	350b883a 	add	r5,r6,r20
 8004f24:	20c7883a 	add	r3,r4,r3
 8004f28:	3955883a 	add	r10,r7,r5
 8004f2c:	1909803a 	cmpltu	r4,r3,r4
 8004f30:	6a91883a 	add	r8,r13,r10
 8004f34:	780cd43a 	srli	r6,r15,16
 8004f38:	2219883a 	add	r12,r4,r8
 8004f3c:	2d0b803a 	cmpltu	r5,r5,r20
 8004f40:	51cf803a 	cmpltu	r7,r10,r7
 8004f44:	29ceb03a 	or	r7,r5,r7
 8004f48:	4351803a 	cmpltu	r8,r8,r13
 8004f4c:	610b803a 	cmpltu	r5,r12,r4
 8004f50:	4148b03a 	or	r4,r8,r5
 8004f54:	398f883a 	add	r7,r7,r6
 8004f58:	3909883a 	add	r4,r7,r4
 8004f5c:	1810927a 	slli	r8,r3,9
 8004f60:	2449883a 	add	r4,r4,r17
 8004f64:	2008927a 	slli	r4,r4,9
 8004f68:	6022d5fa 	srli	r17,r12,23
 8004f6c:	1806d5fa 	srli	r3,r3,23
 8004f70:	4252b03a 	or	r9,r8,r9
 8004f74:	600a927a 	slli	r5,r12,9
 8004f78:	4810c03a 	cmpne	r8,r9,zero
 8004f7c:	2462b03a 	or	r17,r4,r17
 8004f80:	40c6b03a 	or	r3,r8,r3
 8004f84:	8900402c 	andhi	r4,r17,256
 8004f88:	1950b03a 	or	r8,r3,r5
 8004f8c:	20000726 	beq	r4,zero,8004fac <__muldf3+0x4dc>
 8004f90:	4006d07a 	srli	r3,r8,1
 8004f94:	880497fa 	slli	r2,r17,31
 8004f98:	4200004c 	andi	r8,r8,1
 8004f9c:	8822d07a 	srli	r17,r17,1
 8004fa0:	1a10b03a 	or	r8,r3,r8
 8004fa4:	1210b03a 	or	r8,r2,r8
 8004fa8:	5805883a 	mov	r2,r11
 8004fac:	1140ffc4 	addi	r5,r2,1023
 8004fb0:	0140440e 	bge	zero,r5,80050c4 <__muldf3+0x5f4>
 8004fb4:	40c001cc 	andi	r3,r8,7
 8004fb8:	18000726 	beq	r3,zero,8004fd8 <__muldf3+0x508>
 8004fbc:	40c003cc 	andi	r3,r8,15
 8004fc0:	01000104 	movi	r4,4
 8004fc4:	19000426 	beq	r3,r4,8004fd8 <__muldf3+0x508>
 8004fc8:	4107883a 	add	r3,r8,r4
 8004fcc:	1a11803a 	cmpltu	r8,r3,r8
 8004fd0:	8a23883a 	add	r17,r17,r8
 8004fd4:	1811883a 	mov	r8,r3
 8004fd8:	88c0402c 	andhi	r3,r17,256
 8004fdc:	18000426 	beq	r3,zero,8004ff0 <__muldf3+0x520>
 8004fe0:	11410004 	addi	r5,r2,1024
 8004fe4:	00bfc034 	movhi	r2,65280
 8004fe8:	10bfffc4 	addi	r2,r2,-1
 8004fec:	88a2703a 	and	r17,r17,r2
 8004ff0:	0081ff84 	movi	r2,2046
 8004ff4:	117f6416 	blt	r2,r5,8004d88 <__muldf3+0x2b8>
 8004ff8:	8828977a 	slli	r20,r17,29
 8004ffc:	4010d0fa 	srli	r8,r8,3
 8005000:	8822927a 	slli	r17,r17,9
 8005004:	2881ffcc 	andi	r2,r5,2047
 8005008:	a228b03a 	or	r20,r20,r8
 800500c:	880ad33a 	srli	r5,r17,12
 8005010:	b02b883a 	mov	r21,r22
 8005014:	003f0d06 	br	8004c4c <__muldf3+0x17c>
 8005018:	8080022c 	andhi	r2,r16,8
 800501c:	10000926 	beq	r2,zero,8005044 <__muldf3+0x574>
 8005020:	8880022c 	andhi	r2,r17,8
 8005024:	1000071e 	bne	r2,zero,8005044 <__muldf3+0x574>
 8005028:	00800434 	movhi	r2,16
 800502c:	89400234 	orhi	r5,r17,8
 8005030:	10bfffc4 	addi	r2,r2,-1
 8005034:	b82b883a 	mov	r21,r23
 8005038:	288a703a 	and	r5,r5,r2
 800503c:	4029883a 	mov	r20,r8
 8005040:	003f6806 	br	8004de4 <__muldf3+0x314>
 8005044:	00800434 	movhi	r2,16
 8005048:	81400234 	orhi	r5,r16,8
 800504c:	10bfffc4 	addi	r2,r2,-1
 8005050:	288a703a 	and	r5,r5,r2
 8005054:	003f6306 	br	8004de4 <__muldf3+0x314>
 8005058:	147ff604 	addi	r17,r2,-40
 800505c:	3462983a 	sll	r17,r6,r17
 8005060:	0011883a 	mov	r8,zero
 8005064:	003f4406 	br	8004d78 <__muldf3+0x2a8>
 8005068:	3009883a 	mov	r4,r6
 800506c:	d9800215 	stw	r6,8(sp)
 8005070:	da400115 	stw	r9,4(sp)
 8005074:	da800015 	stw	r10,0(sp)
 8005078:	8005d500 	call	8005d50 <__clzsi2>
 800507c:	10800804 	addi	r2,r2,32
 8005080:	da800017 	ldw	r10,0(sp)
 8005084:	da400117 	ldw	r9,4(sp)
 8005088:	d9800217 	ldw	r6,8(sp)
 800508c:	003f3006 	br	8004d50 <__muldf3+0x280>
 8005090:	143ff604 	addi	r16,r2,-40
 8005094:	9c20983a 	sll	r16,r19,r16
 8005098:	0029883a 	mov	r20,zero
 800509c:	003f1606 	br	8004cf8 <__muldf3+0x228>
 80050a0:	d9800215 	stw	r6,8(sp)
 80050a4:	d9c00015 	stw	r7,0(sp)
 80050a8:	da400115 	stw	r9,4(sp)
 80050ac:	8005d500 	call	8005d50 <__clzsi2>
 80050b0:	10800804 	addi	r2,r2,32
 80050b4:	da400117 	ldw	r9,4(sp)
 80050b8:	d9c00017 	ldw	r7,0(sp)
 80050bc:	d9800217 	ldw	r6,8(sp)
 80050c0:	003f0306 	br	8004cd0 <__muldf3+0x200>
 80050c4:	00c00044 	movi	r3,1
 80050c8:	1947c83a 	sub	r3,r3,r5
 80050cc:	00800e04 	movi	r2,56
 80050d0:	10feda16 	blt	r2,r3,8004c3c <__muldf3+0x16c>
 80050d4:	008007c4 	movi	r2,31
 80050d8:	10c01b16 	blt	r2,r3,8005148 <__muldf3+0x678>
 80050dc:	00800804 	movi	r2,32
 80050e0:	10c5c83a 	sub	r2,r2,r3
 80050e4:	888a983a 	sll	r5,r17,r2
 80050e8:	40c8d83a 	srl	r4,r8,r3
 80050ec:	4084983a 	sll	r2,r8,r2
 80050f0:	88e2d83a 	srl	r17,r17,r3
 80050f4:	2906b03a 	or	r3,r5,r4
 80050f8:	1004c03a 	cmpne	r2,r2,zero
 80050fc:	1886b03a 	or	r3,r3,r2
 8005100:	188001cc 	andi	r2,r3,7
 8005104:	10000726 	beq	r2,zero,8005124 <__muldf3+0x654>
 8005108:	188003cc 	andi	r2,r3,15
 800510c:	01000104 	movi	r4,4
 8005110:	11000426 	beq	r2,r4,8005124 <__muldf3+0x654>
 8005114:	1805883a 	mov	r2,r3
 8005118:	10c00104 	addi	r3,r2,4
 800511c:	1885803a 	cmpltu	r2,r3,r2
 8005120:	88a3883a 	add	r17,r17,r2
 8005124:	8880202c 	andhi	r2,r17,128
 8005128:	10001c26 	beq	r2,zero,800519c <__muldf3+0x6cc>
 800512c:	b02b883a 	mov	r21,r22
 8005130:	00800044 	movi	r2,1
 8005134:	000b883a 	mov	r5,zero
 8005138:	0029883a 	mov	r20,zero
 800513c:	003ec306 	br	8004c4c <__muldf3+0x17c>
 8005140:	5805883a 	mov	r2,r11
 8005144:	003f9906 	br	8004fac <__muldf3+0x4dc>
 8005148:	00bff844 	movi	r2,-31
 800514c:	1145c83a 	sub	r2,r2,r5
 8005150:	8888d83a 	srl	r4,r17,r2
 8005154:	00800804 	movi	r2,32
 8005158:	18801a26 	beq	r3,r2,80051c4 <__muldf3+0x6f4>
 800515c:	00801004 	movi	r2,64
 8005160:	10c5c83a 	sub	r2,r2,r3
 8005164:	8884983a 	sll	r2,r17,r2
 8005168:	1204b03a 	or	r2,r2,r8
 800516c:	1004c03a 	cmpne	r2,r2,zero
 8005170:	2084b03a 	or	r2,r4,r2
 8005174:	144001cc 	andi	r17,r2,7
 8005178:	88000d1e 	bne	r17,zero,80051b0 <__muldf3+0x6e0>
 800517c:	000b883a 	mov	r5,zero
 8005180:	1028d0fa 	srli	r20,r2,3
 8005184:	b02b883a 	mov	r21,r22
 8005188:	0005883a 	mov	r2,zero
 800518c:	a468b03a 	or	r20,r20,r17
 8005190:	003eae06 	br	8004c4c <__muldf3+0x17c>
 8005194:	1007883a 	mov	r3,r2
 8005198:	0023883a 	mov	r17,zero
 800519c:	880a927a 	slli	r5,r17,9
 80051a0:	1805883a 	mov	r2,r3
 80051a4:	8822977a 	slli	r17,r17,29
 80051a8:	280ad33a 	srli	r5,r5,12
 80051ac:	003ff406 	br	8005180 <__muldf3+0x6b0>
 80051b0:	10c003cc 	andi	r3,r2,15
 80051b4:	01000104 	movi	r4,4
 80051b8:	193ff626 	beq	r3,r4,8005194 <__muldf3+0x6c4>
 80051bc:	0023883a 	mov	r17,zero
 80051c0:	003fd506 	br	8005118 <__muldf3+0x648>
 80051c4:	0005883a 	mov	r2,zero
 80051c8:	003fe706 	br	8005168 <__muldf3+0x698>
 80051cc:	00800434 	movhi	r2,16
 80051d0:	89400234 	orhi	r5,r17,8
 80051d4:	10bfffc4 	addi	r2,r2,-1
 80051d8:	b02b883a 	mov	r21,r22
 80051dc:	288a703a 	and	r5,r5,r2
 80051e0:	4029883a 	mov	r20,r8
 80051e4:	003eff06 	br	8004de4 <__muldf3+0x314>

080051e8 <__subdf3>:
 80051e8:	02000434 	movhi	r8,16
 80051ec:	423fffc4 	addi	r8,r8,-1
 80051f0:	defffb04 	addi	sp,sp,-20
 80051f4:	2a14703a 	and	r10,r5,r8
 80051f8:	3812d53a 	srli	r9,r7,20
 80051fc:	3a10703a 	and	r8,r7,r8
 8005200:	2006d77a 	srli	r3,r4,29
 8005204:	3004d77a 	srli	r2,r6,29
 8005208:	dc000015 	stw	r16,0(sp)
 800520c:	501490fa 	slli	r10,r10,3
 8005210:	2820d53a 	srli	r16,r5,20
 8005214:	401090fa 	slli	r8,r8,3
 8005218:	dc800215 	stw	r18,8(sp)
 800521c:	dc400115 	stw	r17,4(sp)
 8005220:	dfc00415 	stw	ra,16(sp)
 8005224:	202290fa 	slli	r17,r4,3
 8005228:	dcc00315 	stw	r19,12(sp)
 800522c:	4a41ffcc 	andi	r9,r9,2047
 8005230:	0101ffc4 	movi	r4,2047
 8005234:	2824d7fa 	srli	r18,r5,31
 8005238:	8401ffcc 	andi	r16,r16,2047
 800523c:	50c6b03a 	or	r3,r10,r3
 8005240:	380ed7fa 	srli	r7,r7,31
 8005244:	408ab03a 	or	r5,r8,r2
 8005248:	300c90fa 	slli	r6,r6,3
 800524c:	49009626 	beq	r9,r4,80054a8 <__subdf3+0x2c0>
 8005250:	39c0005c 	xori	r7,r7,1
 8005254:	8245c83a 	sub	r2,r16,r9
 8005258:	3c807426 	beq	r7,r18,800542c <__subdf3+0x244>
 800525c:	0080af0e 	bge	zero,r2,800551c <__subdf3+0x334>
 8005260:	48002a1e 	bne	r9,zero,800530c <__subdf3+0x124>
 8005264:	2988b03a 	or	r4,r5,r6
 8005268:	20009a1e 	bne	r4,zero,80054d4 <__subdf3+0x2ec>
 800526c:	888001cc 	andi	r2,r17,7
 8005270:	10000726 	beq	r2,zero,8005290 <__subdf3+0xa8>
 8005274:	888003cc 	andi	r2,r17,15
 8005278:	01000104 	movi	r4,4
 800527c:	11000426 	beq	r2,r4,8005290 <__subdf3+0xa8>
 8005280:	890b883a 	add	r5,r17,r4
 8005284:	2c63803a 	cmpltu	r17,r5,r17
 8005288:	1c47883a 	add	r3,r3,r17
 800528c:	2823883a 	mov	r17,r5
 8005290:	1880202c 	andhi	r2,r3,128
 8005294:	10005926 	beq	r2,zero,80053fc <__subdf3+0x214>
 8005298:	84000044 	addi	r16,r16,1
 800529c:	0081ffc4 	movi	r2,2047
 80052a0:	8080be26 	beq	r16,r2,800559c <__subdf3+0x3b4>
 80052a4:	017fe034 	movhi	r5,65408
 80052a8:	297fffc4 	addi	r5,r5,-1
 80052ac:	1946703a 	and	r3,r3,r5
 80052b0:	1804977a 	slli	r2,r3,29
 80052b4:	1806927a 	slli	r3,r3,9
 80052b8:	8822d0fa 	srli	r17,r17,3
 80052bc:	8401ffcc 	andi	r16,r16,2047
 80052c0:	180ad33a 	srli	r5,r3,12
 80052c4:	9100004c 	andi	r4,r18,1
 80052c8:	1444b03a 	or	r2,r2,r17
 80052cc:	80c1ffcc 	andi	r3,r16,2047
 80052d0:	1820953a 	slli	r16,r3,20
 80052d4:	20c03fcc 	andi	r3,r4,255
 80052d8:	180897fa 	slli	r4,r3,31
 80052dc:	00c00434 	movhi	r3,16
 80052e0:	18ffffc4 	addi	r3,r3,-1
 80052e4:	28c6703a 	and	r3,r5,r3
 80052e8:	1c06b03a 	or	r3,r3,r16
 80052ec:	1906b03a 	or	r3,r3,r4
 80052f0:	dfc00417 	ldw	ra,16(sp)
 80052f4:	dcc00317 	ldw	r19,12(sp)
 80052f8:	dc800217 	ldw	r18,8(sp)
 80052fc:	dc400117 	ldw	r17,4(sp)
 8005300:	dc000017 	ldw	r16,0(sp)
 8005304:	dec00504 	addi	sp,sp,20
 8005308:	f800283a 	ret
 800530c:	0101ffc4 	movi	r4,2047
 8005310:	813fd626 	beq	r16,r4,800526c <__subdf3+0x84>
 8005314:	29402034 	orhi	r5,r5,128
 8005318:	01000e04 	movi	r4,56
 800531c:	2080a316 	blt	r4,r2,80055ac <__subdf3+0x3c4>
 8005320:	010007c4 	movi	r4,31
 8005324:	2080c616 	blt	r4,r2,8005640 <__subdf3+0x458>
 8005328:	01000804 	movi	r4,32
 800532c:	2089c83a 	sub	r4,r4,r2
 8005330:	2910983a 	sll	r8,r5,r4
 8005334:	308ed83a 	srl	r7,r6,r2
 8005338:	3108983a 	sll	r4,r6,r4
 800533c:	2884d83a 	srl	r2,r5,r2
 8005340:	41ccb03a 	or	r6,r8,r7
 8005344:	2008c03a 	cmpne	r4,r4,zero
 8005348:	310cb03a 	or	r6,r6,r4
 800534c:	898dc83a 	sub	r6,r17,r6
 8005350:	89a3803a 	cmpltu	r17,r17,r6
 8005354:	1887c83a 	sub	r3,r3,r2
 8005358:	1c47c83a 	sub	r3,r3,r17
 800535c:	3023883a 	mov	r17,r6
 8005360:	1880202c 	andhi	r2,r3,128
 8005364:	10002326 	beq	r2,zero,80053f4 <__subdf3+0x20c>
 8005368:	04c02034 	movhi	r19,128
 800536c:	9cffffc4 	addi	r19,r19,-1
 8005370:	1ce6703a 	and	r19,r3,r19
 8005374:	98007a26 	beq	r19,zero,8005560 <__subdf3+0x378>
 8005378:	9809883a 	mov	r4,r19
 800537c:	8005d500 	call	8005d50 <__clzsi2>
 8005380:	113ffe04 	addi	r4,r2,-8
 8005384:	00c007c4 	movi	r3,31
 8005388:	19007b16 	blt	r3,r4,8005578 <__subdf3+0x390>
 800538c:	00800804 	movi	r2,32
 8005390:	1105c83a 	sub	r2,r2,r4
 8005394:	8884d83a 	srl	r2,r17,r2
 8005398:	9906983a 	sll	r3,r19,r4
 800539c:	8922983a 	sll	r17,r17,r4
 80053a0:	10c4b03a 	or	r2,r2,r3
 80053a4:	24007816 	blt	r4,r16,8005588 <__subdf3+0x3a0>
 80053a8:	2421c83a 	sub	r16,r4,r16
 80053ac:	80c00044 	addi	r3,r16,1
 80053b0:	010007c4 	movi	r4,31
 80053b4:	20c09516 	blt	r4,r3,800560c <__subdf3+0x424>
 80053b8:	01400804 	movi	r5,32
 80053bc:	28cbc83a 	sub	r5,r5,r3
 80053c0:	88c8d83a 	srl	r4,r17,r3
 80053c4:	8962983a 	sll	r17,r17,r5
 80053c8:	114a983a 	sll	r5,r2,r5
 80053cc:	10c6d83a 	srl	r3,r2,r3
 80053d0:	8804c03a 	cmpne	r2,r17,zero
 80053d4:	290ab03a 	or	r5,r5,r4
 80053d8:	28a2b03a 	or	r17,r5,r2
 80053dc:	0021883a 	mov	r16,zero
 80053e0:	003fa206 	br	800526c <__subdf3+0x84>
 80053e4:	2090b03a 	or	r8,r4,r2
 80053e8:	40018e26 	beq	r8,zero,8005a24 <__subdf3+0x83c>
 80053ec:	1007883a 	mov	r3,r2
 80053f0:	2023883a 	mov	r17,r4
 80053f4:	888001cc 	andi	r2,r17,7
 80053f8:	103f9e1e 	bne	r2,zero,8005274 <__subdf3+0x8c>
 80053fc:	1804977a 	slli	r2,r3,29
 8005400:	8822d0fa 	srli	r17,r17,3
 8005404:	1810d0fa 	srli	r8,r3,3
 8005408:	9100004c 	andi	r4,r18,1
 800540c:	1444b03a 	or	r2,r2,r17
 8005410:	00c1ffc4 	movi	r3,2047
 8005414:	80c02826 	beq	r16,r3,80054b8 <__subdf3+0x2d0>
 8005418:	01400434 	movhi	r5,16
 800541c:	297fffc4 	addi	r5,r5,-1
 8005420:	80e0703a 	and	r16,r16,r3
 8005424:	414a703a 	and	r5,r8,r5
 8005428:	003fa806 	br	80052cc <__subdf3+0xe4>
 800542c:	0080630e 	bge	zero,r2,80055bc <__subdf3+0x3d4>
 8005430:	48003026 	beq	r9,zero,80054f4 <__subdf3+0x30c>
 8005434:	0101ffc4 	movi	r4,2047
 8005438:	813f8c26 	beq	r16,r4,800526c <__subdf3+0x84>
 800543c:	29402034 	orhi	r5,r5,128
 8005440:	01000e04 	movi	r4,56
 8005444:	2080a90e 	bge	r4,r2,80056ec <__subdf3+0x504>
 8005448:	298cb03a 	or	r6,r5,r6
 800544c:	3012c03a 	cmpne	r9,r6,zero
 8005450:	0005883a 	mov	r2,zero
 8005454:	4c53883a 	add	r9,r9,r17
 8005458:	4c63803a 	cmpltu	r17,r9,r17
 800545c:	10c7883a 	add	r3,r2,r3
 8005460:	88c7883a 	add	r3,r17,r3
 8005464:	4823883a 	mov	r17,r9
 8005468:	1880202c 	andhi	r2,r3,128
 800546c:	1000d026 	beq	r2,zero,80057b0 <__subdf3+0x5c8>
 8005470:	84000044 	addi	r16,r16,1
 8005474:	0081ffc4 	movi	r2,2047
 8005478:	8080fe26 	beq	r16,r2,8005874 <__subdf3+0x68c>
 800547c:	00bfe034 	movhi	r2,65408
 8005480:	10bfffc4 	addi	r2,r2,-1
 8005484:	1886703a 	and	r3,r3,r2
 8005488:	880ad07a 	srli	r5,r17,1
 800548c:	180497fa 	slli	r2,r3,31
 8005490:	8900004c 	andi	r4,r17,1
 8005494:	2922b03a 	or	r17,r5,r4
 8005498:	1806d07a 	srli	r3,r3,1
 800549c:	1462b03a 	or	r17,r2,r17
 80054a0:	3825883a 	mov	r18,r7
 80054a4:	003f7106 	br	800526c <__subdf3+0x84>
 80054a8:	2984b03a 	or	r2,r5,r6
 80054ac:	103f6826 	beq	r2,zero,8005250 <__subdf3+0x68>
 80054b0:	39c03fcc 	andi	r7,r7,255
 80054b4:	003f6706 	br	8005254 <__subdf3+0x6c>
 80054b8:	4086b03a 	or	r3,r8,r2
 80054bc:	18015226 	beq	r3,zero,8005a08 <__subdf3+0x820>
 80054c0:	00c00434 	movhi	r3,16
 80054c4:	41400234 	orhi	r5,r8,8
 80054c8:	18ffffc4 	addi	r3,r3,-1
 80054cc:	28ca703a 	and	r5,r5,r3
 80054d0:	003f7e06 	br	80052cc <__subdf3+0xe4>
 80054d4:	10bfffc4 	addi	r2,r2,-1
 80054d8:	1000491e 	bne	r2,zero,8005600 <__subdf3+0x418>
 80054dc:	898fc83a 	sub	r7,r17,r6
 80054e0:	89e3803a 	cmpltu	r17,r17,r7
 80054e4:	1947c83a 	sub	r3,r3,r5
 80054e8:	1c47c83a 	sub	r3,r3,r17
 80054ec:	3823883a 	mov	r17,r7
 80054f0:	003f9b06 	br	8005360 <__subdf3+0x178>
 80054f4:	2988b03a 	or	r4,r5,r6
 80054f8:	203f5c26 	beq	r4,zero,800526c <__subdf3+0x84>
 80054fc:	10bfffc4 	addi	r2,r2,-1
 8005500:	1000931e 	bne	r2,zero,8005750 <__subdf3+0x568>
 8005504:	898d883a 	add	r6,r17,r6
 8005508:	3463803a 	cmpltu	r17,r6,r17
 800550c:	1947883a 	add	r3,r3,r5
 8005510:	88c7883a 	add	r3,r17,r3
 8005514:	3023883a 	mov	r17,r6
 8005518:	003fd306 	br	8005468 <__subdf3+0x280>
 800551c:	1000541e 	bne	r2,zero,8005670 <__subdf3+0x488>
 8005520:	80800044 	addi	r2,r16,1
 8005524:	1081ffcc 	andi	r2,r2,2047
 8005528:	01000044 	movi	r4,1
 800552c:	2080a20e 	bge	r4,r2,80057b8 <__subdf3+0x5d0>
 8005530:	8989c83a 	sub	r4,r17,r6
 8005534:	8905803a 	cmpltu	r2,r17,r4
 8005538:	1967c83a 	sub	r19,r3,r5
 800553c:	98a7c83a 	sub	r19,r19,r2
 8005540:	9880202c 	andhi	r2,r19,128
 8005544:	10006326 	beq	r2,zero,80056d4 <__subdf3+0x4ec>
 8005548:	3463c83a 	sub	r17,r6,r17
 800554c:	28c7c83a 	sub	r3,r5,r3
 8005550:	344d803a 	cmpltu	r6,r6,r17
 8005554:	19a7c83a 	sub	r19,r3,r6
 8005558:	3825883a 	mov	r18,r7
 800555c:	983f861e 	bne	r19,zero,8005378 <__subdf3+0x190>
 8005560:	8809883a 	mov	r4,r17
 8005564:	8005d500 	call	8005d50 <__clzsi2>
 8005568:	10800804 	addi	r2,r2,32
 800556c:	113ffe04 	addi	r4,r2,-8
 8005570:	00c007c4 	movi	r3,31
 8005574:	193f850e 	bge	r3,r4,800538c <__subdf3+0x1a4>
 8005578:	10bff604 	addi	r2,r2,-40
 800557c:	8884983a 	sll	r2,r17,r2
 8005580:	0023883a 	mov	r17,zero
 8005584:	243f880e 	bge	r4,r16,80053a8 <__subdf3+0x1c0>
 8005588:	00ffe034 	movhi	r3,65408
 800558c:	18ffffc4 	addi	r3,r3,-1
 8005590:	8121c83a 	sub	r16,r16,r4
 8005594:	10c6703a 	and	r3,r2,r3
 8005598:	003f3406 	br	800526c <__subdf3+0x84>
 800559c:	9100004c 	andi	r4,r18,1
 80055a0:	000b883a 	mov	r5,zero
 80055a4:	0005883a 	mov	r2,zero
 80055a8:	003f4806 	br	80052cc <__subdf3+0xe4>
 80055ac:	298cb03a 	or	r6,r5,r6
 80055b0:	300cc03a 	cmpne	r6,r6,zero
 80055b4:	0005883a 	mov	r2,zero
 80055b8:	003f6406 	br	800534c <__subdf3+0x164>
 80055bc:	10009a1e 	bne	r2,zero,8005828 <__subdf3+0x640>
 80055c0:	82400044 	addi	r9,r16,1
 80055c4:	4881ffcc 	andi	r2,r9,2047
 80055c8:	02800044 	movi	r10,1
 80055cc:	5080670e 	bge	r10,r2,800576c <__subdf3+0x584>
 80055d0:	0081ffc4 	movi	r2,2047
 80055d4:	4880af26 	beq	r9,r2,8005894 <__subdf3+0x6ac>
 80055d8:	898d883a 	add	r6,r17,r6
 80055dc:	1945883a 	add	r2,r3,r5
 80055e0:	3447803a 	cmpltu	r3,r6,r17
 80055e4:	1887883a 	add	r3,r3,r2
 80055e8:	182297fa 	slli	r17,r3,31
 80055ec:	300cd07a 	srli	r6,r6,1
 80055f0:	1806d07a 	srli	r3,r3,1
 80055f4:	4821883a 	mov	r16,r9
 80055f8:	89a2b03a 	or	r17,r17,r6
 80055fc:	003f1b06 	br	800526c <__subdf3+0x84>
 8005600:	0101ffc4 	movi	r4,2047
 8005604:	813f441e 	bne	r16,r4,8005318 <__subdf3+0x130>
 8005608:	003f1806 	br	800526c <__subdf3+0x84>
 800560c:	843ff844 	addi	r16,r16,-31
 8005610:	01400804 	movi	r5,32
 8005614:	1408d83a 	srl	r4,r2,r16
 8005618:	19405026 	beq	r3,r5,800575c <__subdf3+0x574>
 800561c:	01401004 	movi	r5,64
 8005620:	28c7c83a 	sub	r3,r5,r3
 8005624:	10c4983a 	sll	r2,r2,r3
 8005628:	88a2b03a 	or	r17,r17,r2
 800562c:	8822c03a 	cmpne	r17,r17,zero
 8005630:	2462b03a 	or	r17,r4,r17
 8005634:	0007883a 	mov	r3,zero
 8005638:	0021883a 	mov	r16,zero
 800563c:	003f6d06 	br	80053f4 <__subdf3+0x20c>
 8005640:	11fff804 	addi	r7,r2,-32
 8005644:	01000804 	movi	r4,32
 8005648:	29ced83a 	srl	r7,r5,r7
 800564c:	11004526 	beq	r2,r4,8005764 <__subdf3+0x57c>
 8005650:	01001004 	movi	r4,64
 8005654:	2089c83a 	sub	r4,r4,r2
 8005658:	2904983a 	sll	r2,r5,r4
 800565c:	118cb03a 	or	r6,r2,r6
 8005660:	300cc03a 	cmpne	r6,r6,zero
 8005664:	398cb03a 	or	r6,r7,r6
 8005668:	0005883a 	mov	r2,zero
 800566c:	003f3706 	br	800534c <__subdf3+0x164>
 8005670:	80002a26 	beq	r16,zero,800571c <__subdf3+0x534>
 8005674:	0101ffc4 	movi	r4,2047
 8005678:	49006626 	beq	r9,r4,8005814 <__subdf3+0x62c>
 800567c:	0085c83a 	sub	r2,zero,r2
 8005680:	18c02034 	orhi	r3,r3,128
 8005684:	01000e04 	movi	r4,56
 8005688:	20807e16 	blt	r4,r2,8005884 <__subdf3+0x69c>
 800568c:	010007c4 	movi	r4,31
 8005690:	2080e716 	blt	r4,r2,8005a30 <__subdf3+0x848>
 8005694:	01000804 	movi	r4,32
 8005698:	2089c83a 	sub	r4,r4,r2
 800569c:	1914983a 	sll	r10,r3,r4
 80056a0:	8890d83a 	srl	r8,r17,r2
 80056a4:	8908983a 	sll	r4,r17,r4
 80056a8:	1884d83a 	srl	r2,r3,r2
 80056ac:	5222b03a 	or	r17,r10,r8
 80056b0:	2006c03a 	cmpne	r3,r4,zero
 80056b4:	88e2b03a 	or	r17,r17,r3
 80056b8:	3463c83a 	sub	r17,r6,r17
 80056bc:	2885c83a 	sub	r2,r5,r2
 80056c0:	344d803a 	cmpltu	r6,r6,r17
 80056c4:	1187c83a 	sub	r3,r2,r6
 80056c8:	4821883a 	mov	r16,r9
 80056cc:	3825883a 	mov	r18,r7
 80056d0:	003f2306 	br	8005360 <__subdf3+0x178>
 80056d4:	24d0b03a 	or	r8,r4,r19
 80056d8:	40001b1e 	bne	r8,zero,8005748 <__subdf3+0x560>
 80056dc:	0005883a 	mov	r2,zero
 80056e0:	0009883a 	mov	r4,zero
 80056e4:	0021883a 	mov	r16,zero
 80056e8:	003f4906 	br	8005410 <__subdf3+0x228>
 80056ec:	010007c4 	movi	r4,31
 80056f0:	20803a16 	blt	r4,r2,80057dc <__subdf3+0x5f4>
 80056f4:	01000804 	movi	r4,32
 80056f8:	2089c83a 	sub	r4,r4,r2
 80056fc:	2912983a 	sll	r9,r5,r4
 8005700:	3090d83a 	srl	r8,r6,r2
 8005704:	3108983a 	sll	r4,r6,r4
 8005708:	2884d83a 	srl	r2,r5,r2
 800570c:	4a12b03a 	or	r9,r9,r8
 8005710:	2008c03a 	cmpne	r4,r4,zero
 8005714:	4912b03a 	or	r9,r9,r4
 8005718:	003f4e06 	br	8005454 <__subdf3+0x26c>
 800571c:	1c48b03a 	or	r4,r3,r17
 8005720:	20003c26 	beq	r4,zero,8005814 <__subdf3+0x62c>
 8005724:	0084303a 	nor	r2,zero,r2
 8005728:	1000381e 	bne	r2,zero,800580c <__subdf3+0x624>
 800572c:	3463c83a 	sub	r17,r6,r17
 8005730:	28c5c83a 	sub	r2,r5,r3
 8005734:	344d803a 	cmpltu	r6,r6,r17
 8005738:	1187c83a 	sub	r3,r2,r6
 800573c:	4821883a 	mov	r16,r9
 8005740:	3825883a 	mov	r18,r7
 8005744:	003f0606 	br	8005360 <__subdf3+0x178>
 8005748:	2023883a 	mov	r17,r4
 800574c:	003f0906 	br	8005374 <__subdf3+0x18c>
 8005750:	0101ffc4 	movi	r4,2047
 8005754:	813f3a1e 	bne	r16,r4,8005440 <__subdf3+0x258>
 8005758:	003ec406 	br	800526c <__subdf3+0x84>
 800575c:	0005883a 	mov	r2,zero
 8005760:	003fb106 	br	8005628 <__subdf3+0x440>
 8005764:	0005883a 	mov	r2,zero
 8005768:	003fbc06 	br	800565c <__subdf3+0x474>
 800576c:	1c44b03a 	or	r2,r3,r17
 8005770:	80008e1e 	bne	r16,zero,80059ac <__subdf3+0x7c4>
 8005774:	1000c826 	beq	r2,zero,8005a98 <__subdf3+0x8b0>
 8005778:	2984b03a 	or	r2,r5,r6
 800577c:	103ebb26 	beq	r2,zero,800526c <__subdf3+0x84>
 8005780:	8989883a 	add	r4,r17,r6
 8005784:	1945883a 	add	r2,r3,r5
 8005788:	2447803a 	cmpltu	r3,r4,r17
 800578c:	1887883a 	add	r3,r3,r2
 8005790:	1880202c 	andhi	r2,r3,128
 8005794:	2023883a 	mov	r17,r4
 8005798:	103f1626 	beq	r2,zero,80053f4 <__subdf3+0x20c>
 800579c:	00bfe034 	movhi	r2,65408
 80057a0:	10bfffc4 	addi	r2,r2,-1
 80057a4:	5021883a 	mov	r16,r10
 80057a8:	1886703a 	and	r3,r3,r2
 80057ac:	003eaf06 	br	800526c <__subdf3+0x84>
 80057b0:	3825883a 	mov	r18,r7
 80057b4:	003f0f06 	br	80053f4 <__subdf3+0x20c>
 80057b8:	1c44b03a 	or	r2,r3,r17
 80057bc:	8000251e 	bne	r16,zero,8005854 <__subdf3+0x66c>
 80057c0:	1000661e 	bne	r2,zero,800595c <__subdf3+0x774>
 80057c4:	2990b03a 	or	r8,r5,r6
 80057c8:	40009626 	beq	r8,zero,8005a24 <__subdf3+0x83c>
 80057cc:	2807883a 	mov	r3,r5
 80057d0:	3023883a 	mov	r17,r6
 80057d4:	3825883a 	mov	r18,r7
 80057d8:	003ea406 	br	800526c <__subdf3+0x84>
 80057dc:	127ff804 	addi	r9,r2,-32
 80057e0:	01000804 	movi	r4,32
 80057e4:	2a52d83a 	srl	r9,r5,r9
 80057e8:	11008c26 	beq	r2,r4,8005a1c <__subdf3+0x834>
 80057ec:	01001004 	movi	r4,64
 80057f0:	2085c83a 	sub	r2,r4,r2
 80057f4:	2884983a 	sll	r2,r5,r2
 80057f8:	118cb03a 	or	r6,r2,r6
 80057fc:	300cc03a 	cmpne	r6,r6,zero
 8005800:	4992b03a 	or	r9,r9,r6
 8005804:	0005883a 	mov	r2,zero
 8005808:	003f1206 	br	8005454 <__subdf3+0x26c>
 800580c:	0101ffc4 	movi	r4,2047
 8005810:	493f9c1e 	bne	r9,r4,8005684 <__subdf3+0x49c>
 8005814:	2807883a 	mov	r3,r5
 8005818:	3023883a 	mov	r17,r6
 800581c:	4821883a 	mov	r16,r9
 8005820:	3825883a 	mov	r18,r7
 8005824:	003e9106 	br	800526c <__subdf3+0x84>
 8005828:	80001f1e 	bne	r16,zero,80058a8 <__subdf3+0x6c0>
 800582c:	1c48b03a 	or	r4,r3,r17
 8005830:	20005a26 	beq	r4,zero,800599c <__subdf3+0x7b4>
 8005834:	0084303a 	nor	r2,zero,r2
 8005838:	1000561e 	bne	r2,zero,8005994 <__subdf3+0x7ac>
 800583c:	89a3883a 	add	r17,r17,r6
 8005840:	1945883a 	add	r2,r3,r5
 8005844:	898d803a 	cmpltu	r6,r17,r6
 8005848:	3087883a 	add	r3,r6,r2
 800584c:	4821883a 	mov	r16,r9
 8005850:	003f0506 	br	8005468 <__subdf3+0x280>
 8005854:	10002b1e 	bne	r2,zero,8005904 <__subdf3+0x71c>
 8005858:	2984b03a 	or	r2,r5,r6
 800585c:	10008026 	beq	r2,zero,8005a60 <__subdf3+0x878>
 8005860:	2807883a 	mov	r3,r5
 8005864:	3023883a 	mov	r17,r6
 8005868:	3825883a 	mov	r18,r7
 800586c:	0401ffc4 	movi	r16,2047
 8005870:	003e7e06 	br	800526c <__subdf3+0x84>
 8005874:	3809883a 	mov	r4,r7
 8005878:	0011883a 	mov	r8,zero
 800587c:	0005883a 	mov	r2,zero
 8005880:	003ee306 	br	8005410 <__subdf3+0x228>
 8005884:	1c62b03a 	or	r17,r3,r17
 8005888:	8822c03a 	cmpne	r17,r17,zero
 800588c:	0005883a 	mov	r2,zero
 8005890:	003f8906 	br	80056b8 <__subdf3+0x4d0>
 8005894:	3809883a 	mov	r4,r7
 8005898:	4821883a 	mov	r16,r9
 800589c:	0011883a 	mov	r8,zero
 80058a0:	0005883a 	mov	r2,zero
 80058a4:	003eda06 	br	8005410 <__subdf3+0x228>
 80058a8:	0101ffc4 	movi	r4,2047
 80058ac:	49003b26 	beq	r9,r4,800599c <__subdf3+0x7b4>
 80058b0:	0085c83a 	sub	r2,zero,r2
 80058b4:	18c02034 	orhi	r3,r3,128
 80058b8:	01000e04 	movi	r4,56
 80058bc:	20806e16 	blt	r4,r2,8005a78 <__subdf3+0x890>
 80058c0:	010007c4 	movi	r4,31
 80058c4:	20807716 	blt	r4,r2,8005aa4 <__subdf3+0x8bc>
 80058c8:	01000804 	movi	r4,32
 80058cc:	2089c83a 	sub	r4,r4,r2
 80058d0:	1914983a 	sll	r10,r3,r4
 80058d4:	8890d83a 	srl	r8,r17,r2
 80058d8:	8908983a 	sll	r4,r17,r4
 80058dc:	1884d83a 	srl	r2,r3,r2
 80058e0:	5222b03a 	or	r17,r10,r8
 80058e4:	2006c03a 	cmpne	r3,r4,zero
 80058e8:	88e2b03a 	or	r17,r17,r3
 80058ec:	89a3883a 	add	r17,r17,r6
 80058f0:	1145883a 	add	r2,r2,r5
 80058f4:	898d803a 	cmpltu	r6,r17,r6
 80058f8:	3087883a 	add	r3,r6,r2
 80058fc:	4821883a 	mov	r16,r9
 8005900:	003ed906 	br	8005468 <__subdf3+0x280>
 8005904:	2984b03a 	or	r2,r5,r6
 8005908:	10004226 	beq	r2,zero,8005a14 <__subdf3+0x82c>
 800590c:	1808d0fa 	srli	r4,r3,3
 8005910:	8822d0fa 	srli	r17,r17,3
 8005914:	1806977a 	slli	r3,r3,29
 8005918:	2080022c 	andhi	r2,r4,8
 800591c:	1c62b03a 	or	r17,r3,r17
 8005920:	10000826 	beq	r2,zero,8005944 <__subdf3+0x75c>
 8005924:	2812d0fa 	srli	r9,r5,3
 8005928:	4880022c 	andhi	r2,r9,8
 800592c:	1000051e 	bne	r2,zero,8005944 <__subdf3+0x75c>
 8005930:	300cd0fa 	srli	r6,r6,3
 8005934:	2804977a 	slli	r2,r5,29
 8005938:	4809883a 	mov	r4,r9
 800593c:	3825883a 	mov	r18,r7
 8005940:	11a2b03a 	or	r17,r2,r6
 8005944:	8806d77a 	srli	r3,r17,29
 8005948:	200890fa 	slli	r4,r4,3
 800594c:	882290fa 	slli	r17,r17,3
 8005950:	0401ffc4 	movi	r16,2047
 8005954:	1906b03a 	or	r3,r3,r4
 8005958:	003e4406 	br	800526c <__subdf3+0x84>
 800595c:	2984b03a 	or	r2,r5,r6
 8005960:	103e4226 	beq	r2,zero,800526c <__subdf3+0x84>
 8005964:	8989c83a 	sub	r4,r17,r6
 8005968:	8911803a 	cmpltu	r8,r17,r4
 800596c:	1945c83a 	sub	r2,r3,r5
 8005970:	1205c83a 	sub	r2,r2,r8
 8005974:	1200202c 	andhi	r8,r2,128
 8005978:	403e9a26 	beq	r8,zero,80053e4 <__subdf3+0x1fc>
 800597c:	3463c83a 	sub	r17,r6,r17
 8005980:	28c5c83a 	sub	r2,r5,r3
 8005984:	344d803a 	cmpltu	r6,r6,r17
 8005988:	1187c83a 	sub	r3,r2,r6
 800598c:	3825883a 	mov	r18,r7
 8005990:	003e3606 	br	800526c <__subdf3+0x84>
 8005994:	0101ffc4 	movi	r4,2047
 8005998:	493fc71e 	bne	r9,r4,80058b8 <__subdf3+0x6d0>
 800599c:	2807883a 	mov	r3,r5
 80059a0:	3023883a 	mov	r17,r6
 80059a4:	4821883a 	mov	r16,r9
 80059a8:	003e3006 	br	800526c <__subdf3+0x84>
 80059ac:	10003626 	beq	r2,zero,8005a88 <__subdf3+0x8a0>
 80059b0:	2984b03a 	or	r2,r5,r6
 80059b4:	10001726 	beq	r2,zero,8005a14 <__subdf3+0x82c>
 80059b8:	1808d0fa 	srli	r4,r3,3
 80059bc:	8822d0fa 	srli	r17,r17,3
 80059c0:	1806977a 	slli	r3,r3,29
 80059c4:	2080022c 	andhi	r2,r4,8
 80059c8:	1c62b03a 	or	r17,r3,r17
 80059cc:	10000726 	beq	r2,zero,80059ec <__subdf3+0x804>
 80059d0:	2812d0fa 	srli	r9,r5,3
 80059d4:	4880022c 	andhi	r2,r9,8
 80059d8:	1000041e 	bne	r2,zero,80059ec <__subdf3+0x804>
 80059dc:	300cd0fa 	srli	r6,r6,3
 80059e0:	2804977a 	slli	r2,r5,29
 80059e4:	4809883a 	mov	r4,r9
 80059e8:	11a2b03a 	or	r17,r2,r6
 80059ec:	8806d77a 	srli	r3,r17,29
 80059f0:	200890fa 	slli	r4,r4,3
 80059f4:	882290fa 	slli	r17,r17,3
 80059f8:	3825883a 	mov	r18,r7
 80059fc:	1906b03a 	or	r3,r3,r4
 8005a00:	0401ffc4 	movi	r16,2047
 8005a04:	003e1906 	br	800526c <__subdf3+0x84>
 8005a08:	000b883a 	mov	r5,zero
 8005a0c:	0005883a 	mov	r2,zero
 8005a10:	003e2e06 	br	80052cc <__subdf3+0xe4>
 8005a14:	0401ffc4 	movi	r16,2047
 8005a18:	003e1406 	br	800526c <__subdf3+0x84>
 8005a1c:	0005883a 	mov	r2,zero
 8005a20:	003f7506 	br	80057f8 <__subdf3+0x610>
 8005a24:	0005883a 	mov	r2,zero
 8005a28:	0009883a 	mov	r4,zero
 8005a2c:	003e7806 	br	8005410 <__subdf3+0x228>
 8005a30:	123ff804 	addi	r8,r2,-32
 8005a34:	01000804 	movi	r4,32
 8005a38:	1a10d83a 	srl	r8,r3,r8
 8005a3c:	11002526 	beq	r2,r4,8005ad4 <__subdf3+0x8ec>
 8005a40:	01001004 	movi	r4,64
 8005a44:	2085c83a 	sub	r2,r4,r2
 8005a48:	1884983a 	sll	r2,r3,r2
 8005a4c:	1444b03a 	or	r2,r2,r17
 8005a50:	1004c03a 	cmpne	r2,r2,zero
 8005a54:	40a2b03a 	or	r17,r8,r2
 8005a58:	0005883a 	mov	r2,zero
 8005a5c:	003f1606 	br	80056b8 <__subdf3+0x4d0>
 8005a60:	02000434 	movhi	r8,16
 8005a64:	0009883a 	mov	r4,zero
 8005a68:	423fffc4 	addi	r8,r8,-1
 8005a6c:	00bfffc4 	movi	r2,-1
 8005a70:	0401ffc4 	movi	r16,2047
 8005a74:	003e6606 	br	8005410 <__subdf3+0x228>
 8005a78:	1c62b03a 	or	r17,r3,r17
 8005a7c:	8822c03a 	cmpne	r17,r17,zero
 8005a80:	0005883a 	mov	r2,zero
 8005a84:	003f9906 	br	80058ec <__subdf3+0x704>
 8005a88:	2807883a 	mov	r3,r5
 8005a8c:	3023883a 	mov	r17,r6
 8005a90:	0401ffc4 	movi	r16,2047
 8005a94:	003df506 	br	800526c <__subdf3+0x84>
 8005a98:	2807883a 	mov	r3,r5
 8005a9c:	3023883a 	mov	r17,r6
 8005aa0:	003df206 	br	800526c <__subdf3+0x84>
 8005aa4:	123ff804 	addi	r8,r2,-32
 8005aa8:	01000804 	movi	r4,32
 8005aac:	1a10d83a 	srl	r8,r3,r8
 8005ab0:	11000a26 	beq	r2,r4,8005adc <__subdf3+0x8f4>
 8005ab4:	01001004 	movi	r4,64
 8005ab8:	2085c83a 	sub	r2,r4,r2
 8005abc:	1884983a 	sll	r2,r3,r2
 8005ac0:	1444b03a 	or	r2,r2,r17
 8005ac4:	1004c03a 	cmpne	r2,r2,zero
 8005ac8:	40a2b03a 	or	r17,r8,r2
 8005acc:	0005883a 	mov	r2,zero
 8005ad0:	003f8606 	br	80058ec <__subdf3+0x704>
 8005ad4:	0005883a 	mov	r2,zero
 8005ad8:	003fdc06 	br	8005a4c <__subdf3+0x864>
 8005adc:	0005883a 	mov	r2,zero
 8005ae0:	003ff706 	br	8005ac0 <__subdf3+0x8d8>

08005ae4 <__fixdfsi>:
 8005ae4:	280cd53a 	srli	r6,r5,20
 8005ae8:	00c00434 	movhi	r3,16
 8005aec:	18ffffc4 	addi	r3,r3,-1
 8005af0:	3181ffcc 	andi	r6,r6,2047
 8005af4:	01c0ff84 	movi	r7,1022
 8005af8:	28c6703a 	and	r3,r5,r3
 8005afc:	280ad7fa 	srli	r5,r5,31
 8005b00:	3980120e 	bge	r7,r6,8005b4c <__fixdfsi+0x68>
 8005b04:	00810744 	movi	r2,1053
 8005b08:	11800c16 	blt	r2,r6,8005b3c <__fixdfsi+0x58>
 8005b0c:	00810cc4 	movi	r2,1075
 8005b10:	1185c83a 	sub	r2,r2,r6
 8005b14:	01c007c4 	movi	r7,31
 8005b18:	18c00434 	orhi	r3,r3,16
 8005b1c:	38800d16 	blt	r7,r2,8005b54 <__fixdfsi+0x70>
 8005b20:	31befb44 	addi	r6,r6,-1043
 8005b24:	2084d83a 	srl	r2,r4,r2
 8005b28:	1986983a 	sll	r3,r3,r6
 8005b2c:	1884b03a 	or	r2,r3,r2
 8005b30:	28000726 	beq	r5,zero,8005b50 <__fixdfsi+0x6c>
 8005b34:	0085c83a 	sub	r2,zero,r2
 8005b38:	f800283a 	ret
 8005b3c:	00a00034 	movhi	r2,32768
 8005b40:	10bfffc4 	addi	r2,r2,-1
 8005b44:	2885883a 	add	r2,r5,r2
 8005b48:	f800283a 	ret
 8005b4c:	0005883a 	mov	r2,zero
 8005b50:	f800283a 	ret
 8005b54:	008104c4 	movi	r2,1043
 8005b58:	1185c83a 	sub	r2,r2,r6
 8005b5c:	1884d83a 	srl	r2,r3,r2
 8005b60:	003ff306 	br	8005b30 <__fixdfsi+0x4c>

08005b64 <__floatsidf>:
 8005b64:	defffd04 	addi	sp,sp,-12
 8005b68:	dfc00215 	stw	ra,8(sp)
 8005b6c:	dc400115 	stw	r17,4(sp)
 8005b70:	dc000015 	stw	r16,0(sp)
 8005b74:	20002b26 	beq	r4,zero,8005c24 <__floatsidf+0xc0>
 8005b78:	2023883a 	mov	r17,r4
 8005b7c:	2020d7fa 	srli	r16,r4,31
 8005b80:	20002d16 	blt	r4,zero,8005c38 <__floatsidf+0xd4>
 8005b84:	8809883a 	mov	r4,r17
 8005b88:	8005d500 	call	8005d50 <__clzsi2>
 8005b8c:	01410784 	movi	r5,1054
 8005b90:	288bc83a 	sub	r5,r5,r2
 8005b94:	01010cc4 	movi	r4,1075
 8005b98:	2149c83a 	sub	r4,r4,r5
 8005b9c:	00c007c4 	movi	r3,31
 8005ba0:	1900160e 	bge	r3,r4,8005bfc <__floatsidf+0x98>
 8005ba4:	00c104c4 	movi	r3,1043
 8005ba8:	1947c83a 	sub	r3,r3,r5
 8005bac:	88c6983a 	sll	r3,r17,r3
 8005bb0:	00800434 	movhi	r2,16
 8005bb4:	10bfffc4 	addi	r2,r2,-1
 8005bb8:	1886703a 	and	r3,r3,r2
 8005bbc:	2941ffcc 	andi	r5,r5,2047
 8005bc0:	800d883a 	mov	r6,r16
 8005bc4:	0005883a 	mov	r2,zero
 8005bc8:	280a953a 	slli	r5,r5,20
 8005bcc:	31803fcc 	andi	r6,r6,255
 8005bd0:	01000434 	movhi	r4,16
 8005bd4:	300c97fa 	slli	r6,r6,31
 8005bd8:	213fffc4 	addi	r4,r4,-1
 8005bdc:	1906703a 	and	r3,r3,r4
 8005be0:	1946b03a 	or	r3,r3,r5
 8005be4:	1986b03a 	or	r3,r3,r6
 8005be8:	dfc00217 	ldw	ra,8(sp)
 8005bec:	dc400117 	ldw	r17,4(sp)
 8005bf0:	dc000017 	ldw	r16,0(sp)
 8005bf4:	dec00304 	addi	sp,sp,12
 8005bf8:	f800283a 	ret
 8005bfc:	00c002c4 	movi	r3,11
 8005c00:	1887c83a 	sub	r3,r3,r2
 8005c04:	88c6d83a 	srl	r3,r17,r3
 8005c08:	8904983a 	sll	r2,r17,r4
 8005c0c:	01000434 	movhi	r4,16
 8005c10:	213fffc4 	addi	r4,r4,-1
 8005c14:	2941ffcc 	andi	r5,r5,2047
 8005c18:	1906703a 	and	r3,r3,r4
 8005c1c:	800d883a 	mov	r6,r16
 8005c20:	003fe906 	br	8005bc8 <__floatsidf+0x64>
 8005c24:	000d883a 	mov	r6,zero
 8005c28:	000b883a 	mov	r5,zero
 8005c2c:	0007883a 	mov	r3,zero
 8005c30:	0005883a 	mov	r2,zero
 8005c34:	003fe406 	br	8005bc8 <__floatsidf+0x64>
 8005c38:	0123c83a 	sub	r17,zero,r4
 8005c3c:	003fd106 	br	8005b84 <__floatsidf+0x20>

08005c40 <__extendsfdf2>:
 8005c40:	200ad5fa 	srli	r5,r4,23
 8005c44:	defffd04 	addi	sp,sp,-12
 8005c48:	dc400115 	stw	r17,4(sp)
 8005c4c:	29403fcc 	andi	r5,r5,255
 8005c50:	29800044 	addi	r6,r5,1
 8005c54:	04402034 	movhi	r17,128
 8005c58:	dc000015 	stw	r16,0(sp)
 8005c5c:	8c7fffc4 	addi	r17,r17,-1
 8005c60:	dfc00215 	stw	ra,8(sp)
 8005c64:	31803fcc 	andi	r6,r6,255
 8005c68:	00800044 	movi	r2,1
 8005c6c:	8922703a 	and	r17,r17,r4
 8005c70:	2020d7fa 	srli	r16,r4,31
 8005c74:	1180110e 	bge	r2,r6,8005cbc <__extendsfdf2+0x7c>
 8005c78:	880cd0fa 	srli	r6,r17,3
 8005c7c:	8822977a 	slli	r17,r17,29
 8005c80:	2940e004 	addi	r5,r5,896
 8005c84:	2941ffcc 	andi	r5,r5,2047
 8005c88:	2804953a 	slli	r2,r5,20
 8005c8c:	01400434 	movhi	r5,16
 8005c90:	800697fa 	slli	r3,r16,31
 8005c94:	297fffc4 	addi	r5,r5,-1
 8005c98:	314a703a 	and	r5,r6,r5
 8005c9c:	288ab03a 	or	r5,r5,r2
 8005ca0:	28c6b03a 	or	r3,r5,r3
 8005ca4:	8805883a 	mov	r2,r17
 8005ca8:	dfc00217 	ldw	ra,8(sp)
 8005cac:	dc400117 	ldw	r17,4(sp)
 8005cb0:	dc000017 	ldw	r16,0(sp)
 8005cb4:	dec00304 	addi	sp,sp,12
 8005cb8:	f800283a 	ret
 8005cbc:	2800111e 	bne	r5,zero,8005d04 <__extendsfdf2+0xc4>
 8005cc0:	88001c26 	beq	r17,zero,8005d34 <__extendsfdf2+0xf4>
 8005cc4:	8809883a 	mov	r4,r17
 8005cc8:	8005d500 	call	8005d50 <__clzsi2>
 8005ccc:	00c00284 	movi	r3,10
 8005cd0:	18801b16 	blt	r3,r2,8005d40 <__extendsfdf2+0x100>
 8005cd4:	018002c4 	movi	r6,11
 8005cd8:	308dc83a 	sub	r6,r6,r2
 8005cdc:	11000544 	addi	r4,r2,21
 8005ce0:	8986d83a 	srl	r3,r17,r6
 8005ce4:	8922983a 	sll	r17,r17,r4
 8005ce8:	0180e244 	movi	r6,905
 8005cec:	01400434 	movhi	r5,16
 8005cf0:	3085c83a 	sub	r2,r6,r2
 8005cf4:	297fffc4 	addi	r5,r5,-1
 8005cf8:	194c703a 	and	r6,r3,r5
 8005cfc:	1141ffcc 	andi	r5,r2,2047
 8005d00:	003fe006 	br	8005c84 <__extendsfdf2+0x44>
 8005d04:	88000826 	beq	r17,zero,8005d28 <__extendsfdf2+0xe8>
 8005d08:	880cd0fa 	srli	r6,r17,3
 8005d0c:	00800434 	movhi	r2,16
 8005d10:	10bfffc4 	addi	r2,r2,-1
 8005d14:	31800234 	orhi	r6,r6,8
 8005d18:	8822977a 	slli	r17,r17,29
 8005d1c:	308c703a 	and	r6,r6,r2
 8005d20:	0141ffc4 	movi	r5,2047
 8005d24:	003fd706 	br	8005c84 <__extendsfdf2+0x44>
 8005d28:	0141ffc4 	movi	r5,2047
 8005d2c:	000d883a 	mov	r6,zero
 8005d30:	003fd406 	br	8005c84 <__extendsfdf2+0x44>
 8005d34:	000b883a 	mov	r5,zero
 8005d38:	000d883a 	mov	r6,zero
 8005d3c:	003fd106 	br	8005c84 <__extendsfdf2+0x44>
 8005d40:	11bffd44 	addi	r6,r2,-11
 8005d44:	8986983a 	sll	r3,r17,r6
 8005d48:	0023883a 	mov	r17,zero
 8005d4c:	003fe606 	br	8005ce8 <__extendsfdf2+0xa8>

08005d50 <__clzsi2>:
 8005d50:	00bfffd4 	movui	r2,65535
 8005d54:	11000536 	bltu	r2,r4,8005d6c <__clzsi2+0x1c>
 8005d58:	00803fc4 	movi	r2,255
 8005d5c:	11000f36 	bltu	r2,r4,8005d9c <__clzsi2+0x4c>
 8005d60:	00800804 	movi	r2,32
 8005d64:	0007883a 	mov	r3,zero
 8005d68:	00000506 	br	8005d80 <__clzsi2+0x30>
 8005d6c:	00804034 	movhi	r2,256
 8005d70:	10bfffc4 	addi	r2,r2,-1
 8005d74:	11000c2e 	bgeu	r2,r4,8005da8 <__clzsi2+0x58>
 8005d78:	00800204 	movi	r2,8
 8005d7c:	00c00604 	movi	r3,24
 8005d80:	20c8d83a 	srl	r4,r4,r3
 8005d84:	00c20134 	movhi	r3,2052
 8005d88:	18d92904 	addi	r3,r3,25764
 8005d8c:	1909883a 	add	r4,r3,r4
 8005d90:	20c00003 	ldbu	r3,0(r4)
 8005d94:	10c5c83a 	sub	r2,r2,r3
 8005d98:	f800283a 	ret
 8005d9c:	00800604 	movi	r2,24
 8005da0:	00c00204 	movi	r3,8
 8005da4:	003ff606 	br	8005d80 <__clzsi2+0x30>
 8005da8:	00800404 	movi	r2,16
 8005dac:	1007883a 	mov	r3,r2
 8005db0:	003ff306 	br	8005d80 <__clzsi2+0x30>

08005db4 <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
 8005db4:	defff104 	addi	sp,sp,-60
 8005db8:	dfc00e15 	stw	ra,56(sp)
 8005dbc:	df000d15 	stw	fp,52(sp)
 8005dc0:	df000d04 	addi	fp,sp,52
 8005dc4:	e13ffe15 	stw	r4,-8(fp)
 8005dc8:	e17fff15 	stw	r5,-4(fp)
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
 8005dcc:	e13fff17 	ldw	r4,-4(fp)
 8005dd0:	8005f040 	call	8005f04 <strlen>
 8005dd4:	e0bff315 	stw	r2,-52(fp)
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
 8005dd8:	e0bfff17 	ldw	r2,-4(fp)
 8005ddc:	e0bffa15 	stw	r2,-24(fp)
  iov[0].iov_len = c;
 8005de0:	e0bff317 	ldw	r2,-52(fp)
 8005de4:	e0bffb15 	stw	r2,-20(fp)
  iov[1].iov_base = "\n";
 8005de8:	00820134 	movhi	r2,2052
 8005dec:	10996904 	addi	r2,r2,26020
 8005df0:	e0bffc15 	stw	r2,-16(fp)
  iov[1].iov_len = 1;
 8005df4:	00800044 	movi	r2,1
 8005df8:	e0bffd15 	stw	r2,-12(fp)
  uio.uio_resid = c + 1;
 8005dfc:	e0bff317 	ldw	r2,-52(fp)
 8005e00:	10800044 	addi	r2,r2,1
 8005e04:	e0bff915 	stw	r2,-28(fp)
  uio.uio_iov = &iov[0];
 8005e08:	e0bffa04 	addi	r2,fp,-24
 8005e0c:	e0bff715 	stw	r2,-36(fp)
  uio.uio_iovcnt = 2;
 8005e10:	00800084 	movi	r2,2
 8005e14:	e0bff815 	stw	r2,-32(fp)

  CHECK_STD_INIT (ptr);
 8005e18:	e0bffe17 	ldw	r2,-8(fp)
 8005e1c:	e0bff415 	stw	r2,-48(fp)
 8005e20:	e0bff417 	ldw	r2,-48(fp)
 8005e24:	10000526 	beq	r2,zero,8005e3c <_puts_r+0x88>
 8005e28:	e0bff417 	ldw	r2,-48(fp)
 8005e2c:	10800e17 	ldw	r2,56(r2)
 8005e30:	1000021e 	bne	r2,zero,8005e3c <_puts_r+0x88>
 8005e34:	e13ff417 	ldw	r4,-48(fp)
 8005e38:	800639c0 	call	800639c <__sinit>
  fp = _stdout_r (ptr);
 8005e3c:	e0bffe17 	ldw	r2,-8(fp)
 8005e40:	10800217 	ldw	r2,8(r2)
 8005e44:	e0bff515 	stw	r2,-44(fp)
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
 8005e48:	e0bff517 	ldw	r2,-44(fp)
 8005e4c:	1080030b 	ldhu	r2,12(r2)
 8005e50:	10bfffcc 	andi	r2,r2,65535
 8005e54:	1088000c 	andi	r2,r2,8192
 8005e58:	10000c1e 	bne	r2,zero,8005e8c <_puts_r+0xd8>
 8005e5c:	e0bff517 	ldw	r2,-44(fp)
 8005e60:	1080030b 	ldhu	r2,12(r2)
 8005e64:	10880014 	ori	r2,r2,8192
 8005e68:	1007883a 	mov	r3,r2
 8005e6c:	e0bff517 	ldw	r2,-44(fp)
 8005e70:	10c0030d 	sth	r3,12(r2)
 8005e74:	e0bff517 	ldw	r2,-44(fp)
 8005e78:	10c01917 	ldw	r3,100(r2)
 8005e7c:	00b7ffc4 	movi	r2,-8193
 8005e80:	1886703a 	and	r3,r3,r2
 8005e84:	e0bff517 	ldw	r2,-44(fp)
 8005e88:	10c01915 	stw	r3,100(r2)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
 8005e8c:	e0bff704 	addi	r2,fp,-36
 8005e90:	100d883a 	mov	r6,r2
 8005e94:	e17ff517 	ldw	r5,-44(fp)
 8005e98:	e13ffe17 	ldw	r4,-8(fp)
 8005e9c:	80065bc0 	call	80065bc <__sfvwrite_r>
 8005ea0:	10000226 	beq	r2,zero,8005eac <_puts_r+0xf8>
 8005ea4:	00bfffc4 	movi	r2,-1
 8005ea8:	00000106 	br	8005eb0 <_puts_r+0xfc>
 8005eac:	00800284 	movi	r2,10
 8005eb0:	e0bff615 	stw	r2,-40(fp)
  _newlib_flockfile_end (fp);
  return result;
 8005eb4:	e0bff617 	ldw	r2,-40(fp)

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
 8005eb8:	e037883a 	mov	sp,fp
 8005ebc:	dfc00117 	ldw	ra,4(sp)
 8005ec0:	df000017 	ldw	fp,0(sp)
 8005ec4:	dec00204 	addi	sp,sp,8
 8005ec8:	f800283a 	ret

08005ecc <puts>:
#ifndef _REENT_ONLY

int
_DEFUN(puts, (s),
       char _CONST * s)
{
 8005ecc:	defffd04 	addi	sp,sp,-12
 8005ed0:	dfc00215 	stw	ra,8(sp)
 8005ed4:	df000115 	stw	fp,4(sp)
 8005ed8:	df000104 	addi	fp,sp,4
 8005edc:	e13fff15 	stw	r4,-4(fp)
  return _puts_r (_REENT, s);
 8005ee0:	d0a04217 	ldw	r2,-32504(gp)
 8005ee4:	e17fff17 	ldw	r5,-4(fp)
 8005ee8:	1009883a 	mov	r4,r2
 8005eec:	8005db40 	call	8005db4 <_puts_r>
}
 8005ef0:	e037883a 	mov	sp,fp
 8005ef4:	dfc00117 	ldw	ra,4(sp)
 8005ef8:	df000017 	ldw	fp,0(sp)
 8005efc:	dec00204 	addi	sp,sp,8
 8005f00:	f800283a 	ret

08005f04 <strlen>:
#endif

size_t
_DEFUN (strlen, (str),
	_CONST char *str)
{
 8005f04:	defffc04 	addi	sp,sp,-16
 8005f08:	df000315 	stw	fp,12(sp)
 8005f0c:	df000304 	addi	fp,sp,12
 8005f10:	e13fff15 	stw	r4,-4(fp)
  _CONST char *start = str;
 8005f14:	e0bfff17 	ldw	r2,-4(fp)
 8005f18:	e0bffe15 	stw	r2,-8(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 8005f1c:	00000d06 	br	8005f54 <strlen+0x50>
    {
      if (!*str)
 8005f20:	e0bfff17 	ldw	r2,-4(fp)
 8005f24:	10800003 	ldbu	r2,0(r2)
 8005f28:	10803fcc 	andi	r2,r2,255
 8005f2c:	1080201c 	xori	r2,r2,128
 8005f30:	10bfe004 	addi	r2,r2,-128
 8005f34:	1000041e 	bne	r2,zero,8005f48 <strlen+0x44>
	return str - start;
 8005f38:	e0ffff17 	ldw	r3,-4(fp)
 8005f3c:	e0bffe17 	ldw	r2,-8(fp)
 8005f40:	1885c83a 	sub	r2,r3,r2
 8005f44:	00002806 	br	8005fe8 <strlen+0xe4>
      str++;
 8005f48:	e0bfff17 	ldw	r2,-4(fp)
 8005f4c:	10800044 	addi	r2,r2,1
 8005f50:	e0bfff15 	stw	r2,-4(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 8005f54:	e0bfff17 	ldw	r2,-4(fp)
 8005f58:	108000cc 	andi	r2,r2,3
 8005f5c:	103ff01e 	bne	r2,zero,8005f20 <strlen+0x1c>
      str++;
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
 8005f60:	e0bfff17 	ldw	r2,-4(fp)
 8005f64:	e0bffd15 	stw	r2,-12(fp)
  while (!DETECTNULL (*aligned_addr))
 8005f68:	00000306 	br	8005f78 <strlen+0x74>
    aligned_addr++;
 8005f6c:	e0bffd17 	ldw	r2,-12(fp)
 8005f70:	10800104 	addi	r2,r2,4
 8005f74:	e0bffd15 	stw	r2,-12(fp)
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
  while (!DETECTNULL (*aligned_addr))
 8005f78:	e0bffd17 	ldw	r2,-12(fp)
 8005f7c:	10c00017 	ldw	r3,0(r2)
 8005f80:	00bfbff4 	movhi	r2,65279
 8005f84:	10bfbfc4 	addi	r2,r2,-257
 8005f88:	1887883a 	add	r3,r3,r2
 8005f8c:	e0bffd17 	ldw	r2,-12(fp)
 8005f90:	10800017 	ldw	r2,0(r2)
 8005f94:	0084303a 	nor	r2,zero,r2
 8005f98:	1886703a 	and	r3,r3,r2
 8005f9c:	00a02074 	movhi	r2,32897
 8005fa0:	10a02004 	addi	r2,r2,-32640
 8005fa4:	1884703a 	and	r2,r3,r2
 8005fa8:	103ff026 	beq	r2,zero,8005f6c <strlen+0x68>
    aligned_addr++;

  /* Once a null is detected, we check each byte in that block for a
     precise position of the null.  */
  str = (char *) aligned_addr;
 8005fac:	e0bffd17 	ldw	r2,-12(fp)
 8005fb0:	e0bfff15 	stw	r2,-4(fp)

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 8005fb4:	00000306 	br	8005fc4 <strlen+0xc0>
    str++;
 8005fb8:	e0bfff17 	ldw	r2,-4(fp)
 8005fbc:	10800044 	addi	r2,r2,1
 8005fc0:	e0bfff15 	stw	r2,-4(fp)
     precise position of the null.  */
  str = (char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 8005fc4:	e0bfff17 	ldw	r2,-4(fp)
 8005fc8:	10800003 	ldbu	r2,0(r2)
 8005fcc:	10803fcc 	andi	r2,r2,255
 8005fd0:	1080201c 	xori	r2,r2,128
 8005fd4:	10bfe004 	addi	r2,r2,-128
 8005fd8:	103ff71e 	bne	r2,zero,8005fb8 <strlen+0xb4>
    str++;
  return str - start;
 8005fdc:	e0ffff17 	ldw	r3,-4(fp)
 8005fe0:	e0bffe17 	ldw	r2,-8(fp)
 8005fe4:	1885c83a 	sub	r2,r3,r2
}
 8005fe8:	e037883a 	mov	sp,fp
 8005fec:	df000017 	ldw	fp,0(sp)
 8005ff0:	dec00104 	addi	sp,sp,4
 8005ff4:	f800283a 	ret

08005ff8 <std>:
_DEFUN(std, (ptr, flags, file, data),
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
 8005ff8:	defffa04 	addi	sp,sp,-24
 8005ffc:	dfc00515 	stw	ra,20(sp)
 8006000:	df000415 	stw	fp,16(sp)
 8006004:	df000404 	addi	fp,sp,16
 8006008:	e13ffc15 	stw	r4,-16(fp)
 800600c:	e17ffd15 	stw	r5,-12(fp)
 8006010:	e1bffe15 	stw	r6,-8(fp)
 8006014:	e1ffff15 	stw	r7,-4(fp)
  ptr->_p = 0;
 8006018:	e0bffc17 	ldw	r2,-16(fp)
 800601c:	10000015 	stw	zero,0(r2)
  ptr->_r = 0;
 8006020:	e0bffc17 	ldw	r2,-16(fp)
 8006024:	10000115 	stw	zero,4(r2)
  ptr->_w = 0;
 8006028:	e0bffc17 	ldw	r2,-16(fp)
 800602c:	10000215 	stw	zero,8(r2)
  ptr->_flags = flags;
 8006030:	e0bffd17 	ldw	r2,-12(fp)
 8006034:	1007883a 	mov	r3,r2
 8006038:	e0bffc17 	ldw	r2,-16(fp)
 800603c:	10c0030d 	sth	r3,12(r2)
  ptr->_flags2 = 0;
 8006040:	e0bffc17 	ldw	r2,-16(fp)
 8006044:	10001915 	stw	zero,100(r2)
  ptr->_file = file;
 8006048:	e0bffe17 	ldw	r2,-8(fp)
 800604c:	1007883a 	mov	r3,r2
 8006050:	e0bffc17 	ldw	r2,-16(fp)
 8006054:	10c0038d 	sth	r3,14(r2)
  ptr->_bf._base = 0;
 8006058:	e0bffc17 	ldw	r2,-16(fp)
 800605c:	10000415 	stw	zero,16(r2)
  ptr->_bf._size = 0;
 8006060:	e0bffc17 	ldw	r2,-16(fp)
 8006064:	10000515 	stw	zero,20(r2)
  ptr->_lbfsize = 0;
 8006068:	e0bffc17 	ldw	r2,-16(fp)
 800606c:	10000615 	stw	zero,24(r2)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
 8006070:	e0bffc17 	ldw	r2,-16(fp)
 8006074:	10801704 	addi	r2,r2,92
 8006078:	01800204 	movi	r6,8
 800607c:	000b883a 	mov	r5,zero
 8006080:	1009883a 	mov	r4,r2
 8006084:	80081c80 	call	80081c8 <memset>
  ptr->_cookie = ptr;
 8006088:	e0bffc17 	ldw	r2,-16(fp)
 800608c:	e0fffc17 	ldw	r3,-16(fp)
 8006090:	10c00715 	stw	r3,28(r2)
  ptr->_read = __sread;
 8006094:	e0fffc17 	ldw	r3,-16(fp)
 8006098:	00820074 	movhi	r2,2049
 800609c:	10a3f704 	addi	r2,r2,-28708
 80060a0:	18800815 	stw	r2,32(r3)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
 80060a4:	e0fffc17 	ldw	r3,-16(fp)
 80060a8:	00820074 	movhi	r2,2049
 80060ac:	10a42a04 	addi	r2,r2,-28504
 80060b0:	18800915 	stw	r2,36(r3)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
 80060b4:	e0fffc17 	ldw	r3,-16(fp)
 80060b8:	00820074 	movhi	r2,2049
 80060bc:	10a45704 	addi	r2,r2,-28324
 80060c0:	18800a15 	stw	r2,40(r3)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
 80060c4:	e0fffc17 	ldw	r3,-16(fp)
 80060c8:	00820074 	movhi	r2,2049
 80060cc:	10a47f04 	addi	r2,r2,-28164
 80060d0:	18800b15 	stw	r2,44(r3)

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
 80060d4:	0001883a 	nop
 80060d8:	e037883a 	mov	sp,fp
 80060dc:	dfc00117 	ldw	ra,4(sp)
 80060e0:	df000017 	ldw	fp,0(sp)
 80060e4:	dec00204 	addi	sp,sp,8
 80060e8:	f800283a 	ret

080060ec <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
 80060ec:	defffb04 	addi	sp,sp,-20
 80060f0:	dfc00415 	stw	ra,16(sp)
 80060f4:	df000315 	stw	fp,12(sp)
 80060f8:	dc000215 	stw	r16,8(sp)
 80060fc:	df000304 	addi	fp,sp,12
 8006100:	e13ffe15 	stw	r4,-8(fp)
 8006104:	2821883a 	mov	r16,r5
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
 8006108:	80bfffc4 	addi	r2,r16,-1
 800610c:	10801a24 	muli	r2,r2,104
 8006110:	10801d04 	addi	r2,r2,116
       struct _reent *d _AND
       register int n)
{
  struct glue_with_file *g;

  g = (struct glue_with_file *)
 8006114:	100b883a 	mov	r5,r2
 8006118:	e13ffe17 	ldw	r4,-8(fp)
 800611c:	80071000 	call	8007100 <_malloc_r>
 8006120:	e0bffd15 	stw	r2,-12(fp)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
 8006124:	e0bffd17 	ldw	r2,-12(fp)
 8006128:	1000021e 	bne	r2,zero,8006134 <__sfmoreglue+0x48>
    return NULL;
 800612c:	0005883a 	mov	r2,zero
 8006130:	00001106 	br	8006178 <__sfmoreglue+0x8c>
  g->glue._next = NULL;
 8006134:	e0bffd17 	ldw	r2,-12(fp)
 8006138:	10000015 	stw	zero,0(r2)
  g->glue._niobs = n;
 800613c:	e0bffd17 	ldw	r2,-12(fp)
 8006140:	14000115 	stw	r16,4(r2)
  g->glue._iobs = &g->file;
 8006144:	e0bffd17 	ldw	r2,-12(fp)
 8006148:	10c00304 	addi	r3,r2,12
 800614c:	e0bffd17 	ldw	r2,-12(fp)
 8006150:	10c00215 	stw	r3,8(r2)
  memset (&g->file, 0, n * sizeof (FILE));
 8006154:	e0bffd17 	ldw	r2,-12(fp)
 8006158:	10800304 	addi	r2,r2,12
 800615c:	8007883a 	mov	r3,r16
 8006160:	18c01a24 	muli	r3,r3,104
 8006164:	180d883a 	mov	r6,r3
 8006168:	000b883a 	mov	r5,zero
 800616c:	1009883a 	mov	r4,r2
 8006170:	80081c80 	call	80081c8 <memset>
  return &g->glue;
 8006174:	e0bffd17 	ldw	r2,-12(fp)
}
 8006178:	e6ffff04 	addi	sp,fp,-4
 800617c:	dfc00217 	ldw	ra,8(sp)
 8006180:	df000117 	ldw	fp,4(sp)
 8006184:	dc000017 	ldw	r16,0(sp)
 8006188:	dec00304 	addi	sp,sp,12
 800618c:	f800283a 	ret

08006190 <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
 8006190:	defffa04 	addi	sp,sp,-24
 8006194:	dfc00515 	stw	ra,20(sp)
 8006198:	df000415 	stw	fp,16(sp)
 800619c:	df000404 	addi	fp,sp,16
 80061a0:	e13fff15 	stw	r4,-4(fp)
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
 80061a4:	80064740 	call	8006474 <__sfp_lock_acquire>

  if (!_GLOBAL_REENT->__sdidinit)
 80061a8:	d0a04317 	ldw	r2,-32500(gp)
 80061ac:	10800e17 	ldw	r2,56(r2)
 80061b0:	1000031e 	bne	r2,zero,80061c0 <__sfp+0x30>
    __sinit (_GLOBAL_REENT);
 80061b4:	d0a04317 	ldw	r2,-32500(gp)
 80061b8:	1009883a 	mov	r4,r2
 80061bc:	800639c0 	call	800639c <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 80061c0:	d0a04317 	ldw	r2,-32500(gp)
 80061c4:	1080b804 	addi	r2,r2,736
 80061c8:	e0bffe15 	stw	r2,-8(fp)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 80061cc:	e0bffe17 	ldw	r2,-8(fp)
 80061d0:	10800217 	ldw	r2,8(r2)
 80061d4:	e0bffc15 	stw	r2,-16(fp)
 80061d8:	e0bffe17 	ldw	r2,-8(fp)
 80061dc:	10800117 	ldw	r2,4(r2)
 80061e0:	e0bffd15 	stw	r2,-12(fp)
 80061e4:	00000906 	br	800620c <__sfp+0x7c>
	if (fp->_flags == 0)
 80061e8:	e0bffc17 	ldw	r2,-16(fp)
 80061ec:	1080030b 	ldhu	r2,12(r2)
 80061f0:	10bfffcc 	andi	r2,r2,65535
 80061f4:	10a0001c 	xori	r2,r2,32768
 80061f8:	10a00004 	addi	r2,r2,-32768
 80061fc:	10001f26 	beq	r2,zero,800627c <__sfp+0xec>

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006200:	e0bffc17 	ldw	r2,-16(fp)
 8006204:	10801a04 	addi	r2,r2,104
 8006208:	e0bffc15 	stw	r2,-16(fp)
 800620c:	e0bffd17 	ldw	r2,-12(fp)
 8006210:	10bfffc4 	addi	r2,r2,-1
 8006214:	e0bffd15 	stw	r2,-12(fp)
 8006218:	e0bffd17 	ldw	r2,-12(fp)
 800621c:	103ff20e 	bge	r2,zero,80061e8 <__sfp+0x58>
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
 8006220:	e0bffe17 	ldw	r2,-8(fp)
 8006224:	10800017 	ldw	r2,0(r2)
 8006228:	1000091e 	bne	r2,zero,8006250 <__sfp+0xc0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
 800622c:	01400104 	movi	r5,4
 8006230:	e13fff17 	ldw	r4,-4(fp)
 8006234:	80060ec0 	call	80060ec <__sfmoreglue>
 8006238:	1007883a 	mov	r3,r2
 800623c:	e0bffe17 	ldw	r2,-8(fp)
 8006240:	10c00015 	stw	r3,0(r2)
 8006244:	e0bffe17 	ldw	r2,-8(fp)
 8006248:	10800017 	ldw	r2,0(r2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
 800624c:	10000426 	beq	r2,zero,8006260 <__sfp+0xd0>

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 8006250:	e0bffe17 	ldw	r2,-8(fp)
 8006254:	10800017 	ldw	r2,0(r2)
 8006258:	e0bffe15 	stw	r2,-8(fp)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
 800625c:	003fdb06 	br	80061cc <__sfp+0x3c>
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
 8006260:	0001883a 	nop
    }
  _newlib_sfp_lock_exit ();
 8006264:	80064940 	call	8006494 <__sfp_lock_release>
  d->_errno = ENOMEM;
 8006268:	e0bfff17 	ldw	r2,-4(fp)
 800626c:	00c00304 	movi	r3,12
 8006270:	10c00015 	stw	r3,0(r2)
  return NULL;
 8006274:	0005883a 	mov	r2,zero
 8006278:	00002506 	br	8006310 <__sfp+0x180>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
 800627c:	0001883a 	nop
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
 8006280:	e0bffc17 	ldw	r2,-16(fp)
 8006284:	00ffffc4 	movi	r3,-1
 8006288:	10c0038d 	sth	r3,14(r2)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
 800628c:	e0bffc17 	ldw	r2,-16(fp)
 8006290:	00c00044 	movi	r3,1
 8006294:	10c0030d 	sth	r3,12(r2)
  fp->_flags2 = 0;
 8006298:	e0bffc17 	ldw	r2,-16(fp)
 800629c:	10001915 	stw	zero,100(r2)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();
 80062a0:	80064940 	call	8006494 <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
 80062a4:	e0bffc17 	ldw	r2,-16(fp)
 80062a8:	10000015 	stw	zero,0(r2)
  fp->_w = 0;			/* nothing to read or write */
 80062ac:	e0bffc17 	ldw	r2,-16(fp)
 80062b0:	10000215 	stw	zero,8(r2)
  fp->_r = 0;
 80062b4:	e0bffc17 	ldw	r2,-16(fp)
 80062b8:	10000115 	stw	zero,4(r2)
  fp->_bf._base = NULL;		/* no buffer */
 80062bc:	e0bffc17 	ldw	r2,-16(fp)
 80062c0:	10000415 	stw	zero,16(r2)
  fp->_bf._size = 0;
 80062c4:	e0bffc17 	ldw	r2,-16(fp)
 80062c8:	10000515 	stw	zero,20(r2)
  fp->_lbfsize = 0;		/* not line buffered */
 80062cc:	e0bffc17 	ldw	r2,-16(fp)
 80062d0:	10000615 	stw	zero,24(r2)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
 80062d4:	e0bffc17 	ldw	r2,-16(fp)
 80062d8:	10801704 	addi	r2,r2,92
 80062dc:	01800204 	movi	r6,8
 80062e0:	000b883a 	mov	r5,zero
 80062e4:	1009883a 	mov	r4,r2
 80062e8:	80081c80 	call	80081c8 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
 80062ec:	e0bffc17 	ldw	r2,-16(fp)
 80062f0:	10000c15 	stw	zero,48(r2)
  fp->_ub._size = 0;
 80062f4:	e0bffc17 	ldw	r2,-16(fp)
 80062f8:	10000d15 	stw	zero,52(r2)
  fp->_lb._base = NULL;		/* no line buffer */
 80062fc:	e0bffc17 	ldw	r2,-16(fp)
 8006300:	10001115 	stw	zero,68(r2)
  fp->_lb._size = 0;
 8006304:	e0bffc17 	ldw	r2,-16(fp)
 8006308:	10001215 	stw	zero,72(r2)

  return fp;
 800630c:	e0bffc17 	ldw	r2,-16(fp)
}
 8006310:	e037883a 	mov	sp,fp
 8006314:	dfc00117 	ldw	ra,4(sp)
 8006318:	df000017 	ldw	fp,0(sp)
 800631c:	dec00204 	addi	sp,sp,8
 8006320:	f800283a 	ret

08006324 <_cleanup_r>:
 */

_VOID
_DEFUN(_cleanup_r, (ptr),
       struct _reent *ptr)
{
 8006324:	defffc04 	addi	sp,sp,-16
 8006328:	dfc00315 	stw	ra,12(sp)
 800632c:	df000215 	stw	fp,8(sp)
 8006330:	df000204 	addi	fp,sp,8
 8006334:	e13fff15 	stw	r4,-4(fp)
  /* Otherwise close files and flush read streams, too.
     Note we call flush directly if "--enable-lite-exit" is in effect.  */
#ifdef _LITE_EXIT
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
 8006338:	00820074 	movhi	r2,2049
 800633c:	10a53004 	addi	r2,r2,-27456
 8006340:	e0bffe15 	stw	r2,-8(fp)
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
 8006344:	e17ffe17 	ldw	r5,-8(fp)
 8006348:	e13fff17 	ldw	r4,-4(fp)
 800634c:	8006c700 	call	8006c70 <_fwalk_reent>
}
 8006350:	0001883a 	nop
 8006354:	e037883a 	mov	sp,fp
 8006358:	dfc00117 	ldw	ra,4(sp)
 800635c:	df000017 	ldw	fp,0(sp)
 8006360:	dec00204 	addi	sp,sp,8
 8006364:	f800283a 	ret

08006368 <_cleanup>:

#ifndef _REENT_ONLY
_VOID
_DEFUN_VOID(_cleanup)
{
 8006368:	defffe04 	addi	sp,sp,-8
 800636c:	dfc00115 	stw	ra,4(sp)
 8006370:	df000015 	stw	fp,0(sp)
 8006374:	d839883a 	mov	fp,sp
  _cleanup_r (_GLOBAL_REENT);
 8006378:	d0a04317 	ldw	r2,-32500(gp)
 800637c:	1009883a 	mov	r4,r2
 8006380:	80063240 	call	8006324 <_cleanup_r>
}
 8006384:	0001883a 	nop
 8006388:	e037883a 	mov	sp,fp
 800638c:	dfc00117 	ldw	ra,4(sp)
 8006390:	df000017 	ldw	fp,0(sp)
 8006394:	dec00204 	addi	sp,sp,8
 8006398:	f800283a 	ret

0800639c <__sinit>:
 */

_VOID
_DEFUN(__sinit, (s),
       struct _reent *s)
{
 800639c:	defffd04 	addi	sp,sp,-12
 80063a0:	dfc00215 	stw	ra,8(sp)
 80063a4:	df000115 	stw	fp,4(sp)
 80063a8:	df000104 	addi	fp,sp,4
 80063ac:	e13fff15 	stw	r4,-4(fp)
  __sinit_lock_acquire ();
 80063b0:	80064b40 	call	80064b4 <__sinit_lock_acquire>

  if (s->__sdidinit)
 80063b4:	e0bfff17 	ldw	r2,-4(fp)
 80063b8:	10800e17 	ldw	r2,56(r2)
 80063bc:	10000226 	beq	r2,zero,80063c8 <__sinit+0x2c>
    {
      __sinit_lock_release ();
 80063c0:	80064d40 	call	80064d4 <__sinit_lock_release>
      return;
 80063c4:	00002606 	br	8006460 <__sinit+0xc4>
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
 80063c8:	e0ffff17 	ldw	r3,-4(fp)
 80063cc:	00820034 	movhi	r2,2048
 80063d0:	1098c904 	addi	r2,r2,25380
 80063d4:	18800f15 	stw	r2,60(r3)

  s->__sglue._next = NULL;
 80063d8:	e0bfff17 	ldw	r2,-4(fp)
 80063dc:	1000b815 	stw	zero,736(r2)
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
 80063e0:	e0bfff17 	ldw	r2,-4(fp)
 80063e4:	00c000c4 	movi	r3,3
 80063e8:	10c0b915 	stw	r3,740(r2)
  s->__sglue._iobs = &s->__sf[0];
 80063ec:	e0bfff17 	ldw	r2,-4(fp)
 80063f0:	10c0bb04 	addi	r3,r2,748
 80063f4:	e0bfff17 	ldw	r2,-4(fp)
 80063f8:	10c0ba15 	stw	r3,744(r2)
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
 80063fc:	e0bfff17 	ldw	r2,-4(fp)
 8006400:	10800117 	ldw	r2,4(r2)
 8006404:	e1ffff17 	ldw	r7,-4(fp)
 8006408:	000d883a 	mov	r6,zero
 800640c:	01400104 	movi	r5,4
 8006410:	1009883a 	mov	r4,r2
 8006414:	8005ff80 	call	8005ff8 <std>
#ifdef HAVE_FCNTL
/*std (s->_stdout, __SWR, 1, s); */
  std (s->_stdout, __SWR | __SNBF, 1, s);	/* AlteraSpecific: Change to have no buffering on stdout. */
#else
/*std (s->_stdout, __SWR | __SLBF, 1, s); */
  std (s->_stdout, __SWR | __SNBF, 1, s);	/* AlteraSpecific: Change to have no buffering on stdout. */
 8006418:	e0bfff17 	ldw	r2,-4(fp)
 800641c:	10800217 	ldw	r2,8(r2)
 8006420:	e1ffff17 	ldw	r7,-4(fp)
 8006424:	01800044 	movi	r6,1
 8006428:	01400284 	movi	r5,10
 800642c:	1009883a 	mov	r4,r2
 8006430:	8005ff80 	call	8005ff8 <std>
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
 8006434:	e0bfff17 	ldw	r2,-4(fp)
 8006438:	10800317 	ldw	r2,12(r2)
 800643c:	e1ffff17 	ldw	r7,-4(fp)
 8006440:	01800084 	movi	r6,2
 8006444:	01400484 	movi	r5,18
 8006448:	1009883a 	mov	r4,r2
 800644c:	8005ff80 	call	8005ff8 <std>

  s->__sdidinit = 1;
 8006450:	e0bfff17 	ldw	r2,-4(fp)
 8006454:	00c00044 	movi	r3,1
 8006458:	10c00e15 	stw	r3,56(r2)

  __sinit_lock_release ();
 800645c:	80064d40 	call	80064d4 <__sinit_lock_release>
}
 8006460:	e037883a 	mov	sp,fp
 8006464:	dfc00117 	ldw	ra,4(sp)
 8006468:	df000017 	ldw	fp,0(sp)
 800646c:	dec00204 	addi	sp,sp,8
 8006470:	f800283a 	ret

08006474 <__sfp_lock_acquire>:
__LOCK_INIT_RECURSIVE(static, __sfp_lock);
__LOCK_INIT_RECURSIVE(static, __sinit_lock);

_VOID
_DEFUN_VOID(__sfp_lock_acquire)
{
 8006474:	deffff04 	addi	sp,sp,-4
 8006478:	df000015 	stw	fp,0(sp)
 800647c:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sfp_lock);
}
 8006480:	0001883a 	nop
 8006484:	e037883a 	mov	sp,fp
 8006488:	df000017 	ldw	fp,0(sp)
 800648c:	dec00104 	addi	sp,sp,4
 8006490:	f800283a 	ret

08006494 <__sfp_lock_release>:

_VOID
_DEFUN_VOID(__sfp_lock_release)
{
 8006494:	deffff04 	addi	sp,sp,-4
 8006498:	df000015 	stw	fp,0(sp)
 800649c:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sfp_lock);
}
 80064a0:	0001883a 	nop
 80064a4:	e037883a 	mov	sp,fp
 80064a8:	df000017 	ldw	fp,0(sp)
 80064ac:	dec00104 	addi	sp,sp,4
 80064b0:	f800283a 	ret

080064b4 <__sinit_lock_acquire>:

_VOID
_DEFUN_VOID(__sinit_lock_acquire)
{
 80064b4:	deffff04 	addi	sp,sp,-4
 80064b8:	df000015 	stw	fp,0(sp)
 80064bc:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sinit_lock);
}
 80064c0:	0001883a 	nop
 80064c4:	e037883a 	mov	sp,fp
 80064c8:	df000017 	ldw	fp,0(sp)
 80064cc:	dec00104 	addi	sp,sp,4
 80064d0:	f800283a 	ret

080064d4 <__sinit_lock_release>:

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
 80064d4:	deffff04 	addi	sp,sp,-4
 80064d8:	df000015 	stw	fp,0(sp)
 80064dc:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sinit_lock);
}
 80064e0:	0001883a 	nop
 80064e4:	e037883a 	mov	sp,fp
 80064e8:	df000017 	ldw	fp,0(sp)
 80064ec:	dec00104 	addi	sp,sp,4
 80064f0:	f800283a 	ret

080064f4 <__fp_lock>:

/* Walkable file locking routine.  */
static int
_DEFUN(__fp_lock, (ptr),
       FILE * ptr)
{
 80064f4:	defffe04 	addi	sp,sp,-8
 80064f8:	df000115 	stw	fp,4(sp)
 80064fc:	df000104 	addi	fp,sp,4
 8006500:	e13fff15 	stw	r4,-4(fp)
  _flockfile (ptr);

  return 0;
 8006504:	0005883a 	mov	r2,zero
}
 8006508:	e037883a 	mov	sp,fp
 800650c:	df000017 	ldw	fp,0(sp)
 8006510:	dec00104 	addi	sp,sp,4
 8006514:	f800283a 	ret

08006518 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
_DEFUN(__fp_unlock, (ptr),
       FILE * ptr)
{
 8006518:	defffe04 	addi	sp,sp,-8
 800651c:	df000115 	stw	fp,4(sp)
 8006520:	df000104 	addi	fp,sp,4
 8006524:	e13fff15 	stw	r4,-4(fp)
  _funlockfile (ptr);

  return 0;
 8006528:	0005883a 	mov	r2,zero
}
 800652c:	e037883a 	mov	sp,fp
 8006530:	df000017 	ldw	fp,0(sp)
 8006534:	dec00104 	addi	sp,sp,4
 8006538:	f800283a 	ret

0800653c <__fp_lock_all>:

_VOID
_DEFUN_VOID(__fp_lock_all)
{
 800653c:	defffe04 	addi	sp,sp,-8
 8006540:	dfc00115 	stw	ra,4(sp)
 8006544:	df000015 	stw	fp,0(sp)
 8006548:	d839883a 	mov	fp,sp
  __sfp_lock_acquire ();
 800654c:	80064740 	call	8006474 <__sfp_lock_acquire>

  _CAST_VOID _fwalk (_REENT, __fp_lock);
 8006550:	d0a04217 	ldw	r2,-32504(gp)
 8006554:	01420034 	movhi	r5,2048
 8006558:	29593d04 	addi	r5,r5,25844
 800655c:	1009883a 	mov	r4,r2
 8006560:	8006b980 	call	8006b98 <_fwalk>
}
 8006564:	0001883a 	nop
 8006568:	e037883a 	mov	sp,fp
 800656c:	dfc00117 	ldw	ra,4(sp)
 8006570:	df000017 	ldw	fp,0(sp)
 8006574:	dec00204 	addi	sp,sp,8
 8006578:	f800283a 	ret

0800657c <__fp_unlock_all>:

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
 800657c:	defffe04 	addi	sp,sp,-8
 8006580:	dfc00115 	stw	ra,4(sp)
 8006584:	df000015 	stw	fp,0(sp)
 8006588:	d839883a 	mov	fp,sp
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
 800658c:	d0a04217 	ldw	r2,-32504(gp)
 8006590:	01420034 	movhi	r5,2048
 8006594:	29594604 	addi	r5,r5,25880
 8006598:	1009883a 	mov	r4,r2
 800659c:	8006b980 	call	8006b98 <_fwalk>

  __sfp_lock_release ();
 80065a0:	80064940 	call	8006494 <__sfp_lock_release>
}
 80065a4:	0001883a 	nop
 80065a8:	e037883a 	mov	sp,fp
 80065ac:	dfc00117 	ldw	ra,4(sp)
 80065b0:	df000017 	ldw	fp,0(sp)
 80065b4:	dec00204 	addi	sp,sp,8
 80065b8:	f800283a 	ret

080065bc <__sfvwrite_r>:
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
 80065bc:	defff004 	addi	sp,sp,-64
 80065c0:	dfc00f15 	stw	ra,60(sp)
 80065c4:	df000e15 	stw	fp,56(sp)
 80065c8:	dd800d15 	stw	r22,52(sp)
 80065cc:	dd400c15 	stw	r21,48(sp)
 80065d0:	dd000b15 	stw	r20,44(sp)
 80065d4:	dcc00a15 	stw	r19,40(sp)
 80065d8:	dc800915 	stw	r18,36(sp)
 80065dc:	dc400815 	stw	r17,32(sp)
 80065e0:	dc000715 	stw	r16,28(sp)
 80065e4:	df000e04 	addi	fp,sp,56
 80065e8:	e13ff815 	stw	r4,-32(fp)
 80065ec:	2821883a 	mov	r16,r5
 80065f0:	302b883a 	mov	r21,r6
  register size_t len;
  register _CONST char *p = NULL;
 80065f4:	0027883a 	mov	r19,zero
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
 80065f8:	ac800217 	ldw	r18,8(r21)
 80065fc:	9000021e 	bne	r18,zero,8006608 <__sfvwrite_r+0x4c>
    return 0;
 8006600:	0005883a 	mov	r2,zero
 8006604:	00015806 	br	8006b68 <__sfvwrite_r+0x5ac>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
 8006608:	8080030b 	ldhu	r2,12(r16)
 800660c:	10bfffcc 	andi	r2,r2,65535
 8006610:	1080020c 	andi	r2,r2,8
 8006614:	10000226 	beq	r2,zero,8006620 <__sfvwrite_r+0x64>
 8006618:	80800417 	ldw	r2,16(r16)
 800661c:	1000061e 	bne	r2,zero,8006638 <__sfvwrite_r+0x7c>
 8006620:	800b883a 	mov	r5,r16
 8006624:	e13ff817 	ldw	r4,-32(fp)
 8006628:	80092c00 	call	80092c0 <__swsetup_r>
 800662c:	10000226 	beq	r2,zero,8006638 <__sfvwrite_r+0x7c>
    return EOF;
 8006630:	00bfffc4 	movi	r2,-1
 8006634:	00014c06 	br	8006b68 <__sfvwrite_r+0x5ac>

  iov = uio->uio_iov;
 8006638:	ad000017 	ldw	r20,0(r21)
  len = 0;
 800663c:	0025883a 	mov	r18,zero
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
 8006640:	8080030b 	ldhu	r2,12(r16)
 8006644:	10bfffcc 	andi	r2,r2,65535
 8006648:	1080008c 	andi	r2,r2,2
 800664c:	10001f26 	beq	r2,zero,80066cc <__sfvwrite_r+0x110>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
 8006650:	00000306 	br	8006660 <__sfvwrite_r+0xa4>
 8006654:	a4c00017 	ldw	r19,0(r20)
 8006658:	a4800117 	ldw	r18,4(r20)
 800665c:	a5000204 	addi	r20,r20,8
 8006660:	903ffc26 	beq	r18,zero,8006654 <__sfvwrite_r+0x98>
	  w = fp->_write (ptr, fp->_cookie, p,
 8006664:	82000917 	ldw	r8,36(r16)
 8006668:	81000717 	ldw	r4,28(r16)
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
 800666c:	9005883a 	mov	r2,r18
 8006670:	00e00034 	movhi	r3,32768
 8006674:	18ff0004 	addi	r3,r3,-1024
 8006678:	1880022e 	bgeu	r3,r2,8006684 <__sfvwrite_r+0xc8>
 800667c:	00a00034 	movhi	r2,32768
 8006680:	10bf0004 	addi	r2,r2,-1024
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
 8006684:	100f883a 	mov	r7,r2
 8006688:	980d883a 	mov	r6,r19
 800668c:	200b883a 	mov	r5,r4
 8006690:	e13ff817 	ldw	r4,-32(fp)
 8006694:	403ee83a 	callr	r8
 8006698:	1023883a 	mov	r17,r2
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
 800669c:	0441290e 	bge	zero,r17,8006b44 <__sfvwrite_r+0x588>
	    goto err;
	  p += w;
 80066a0:	8805883a 	mov	r2,r17
 80066a4:	98a7883a 	add	r19,r19,r2
	  len -= w;
 80066a8:	8805883a 	mov	r2,r17
 80066ac:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 80066b0:	a8800217 	ldw	r2,8(r21)
 80066b4:	8807883a 	mov	r3,r17
 80066b8:	10c5c83a 	sub	r2,r2,r3
 80066bc:	a8800215 	stw	r2,8(r21)
 80066c0:	a8800217 	ldw	r2,8(r21)
 80066c4:	103fe61e 	bne	r2,zero,8006660 <__sfvwrite_r+0xa4>
 80066c8:	00011c06 	br	8006b3c <__sfvwrite_r+0x580>
    }
  else if ((fp->_flags & __SLBF) == 0)
 80066cc:	8080030b 	ldhu	r2,12(r16)
 80066d0:	10bfffcc 	andi	r2,r2,65535
 80066d4:	1080004c 	andi	r2,r2,1
 80066d8:	1000b51e 	bne	r2,zero,80069b0 <__sfvwrite_r+0x3f4>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
 80066dc:	00000306 	br	80066ec <__sfvwrite_r+0x130>
 80066e0:	a4c00017 	ldw	r19,0(r20)
 80066e4:	a4800117 	ldw	r18,4(r20)
 80066e8:	a5000204 	addi	r20,r20,8
 80066ec:	903ffc26 	beq	r18,zero,80066e0 <__sfvwrite_r+0x124>
	  w = fp->_w;
 80066f0:	84400217 	ldw	r17,8(r16)
	  if (fp->_flags & __SSTR)
 80066f4:	8080030b 	ldhu	r2,12(r16)
 80066f8:	10bfffcc 	andi	r2,r2,65535
 80066fc:	1080800c 	andi	r2,r2,512
 8006700:	10006b26 	beq	r2,zero,80068b0 <__sfvwrite_r+0x2f4>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
 8006704:	8805883a 	mov	r2,r17
 8006708:	90805736 	bltu	r18,r2,8006868 <__sfvwrite_r+0x2ac>
 800670c:	8080030b 	ldhu	r2,12(r16)
 8006710:	10bfffcc 	andi	r2,r2,65535
 8006714:	1081200c 	andi	r2,r2,1152
 8006718:	10005326 	beq	r2,zero,8006868 <__sfvwrite_r+0x2ac>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
 800671c:	80800017 	ldw	r2,0(r16)
 8006720:	1007883a 	mov	r3,r2
 8006724:	80800417 	ldw	r2,16(r16)
 8006728:	1885c83a 	sub	r2,r3,r2
 800672c:	e0bff615 	stw	r2,-40(fp)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
 8006730:	80c00517 	ldw	r3,20(r16)
 8006734:	1805883a 	mov	r2,r3
 8006738:	1085883a 	add	r2,r2,r2
 800673c:	10c5883a 	add	r2,r2,r3
 8006740:	1006d7fa 	srli	r3,r2,31
 8006744:	1885883a 	add	r2,r3,r2
 8006748:	1005d07a 	srai	r2,r2,1
 800674c:	e0bff515 	stw	r2,-44(fp)
		  if (newsize < curpos + len + 1)
 8006750:	e0bff617 	ldw	r2,-40(fp)
 8006754:	1485883a 	add	r2,r2,r18
 8006758:	10800044 	addi	r2,r2,1
 800675c:	e0fff517 	ldw	r3,-44(fp)
 8006760:	1880042e 	bgeu	r3,r2,8006774 <__sfvwrite_r+0x1b8>
		    newsize = curpos + len + 1;
 8006764:	e0bff617 	ldw	r2,-40(fp)
 8006768:	1485883a 	add	r2,r2,r18
 800676c:	10800044 	addi	r2,r2,1
 8006770:	e0bff515 	stw	r2,-44(fp)
		  if (fp->_flags & __SOPT)
 8006774:	8080030b 	ldhu	r2,12(r16)
 8006778:	10bfffcc 	andi	r2,r2,65535
 800677c:	1081000c 	andi	r2,r2,1024
 8006780:	10001726 	beq	r2,zero,80067e0 <__sfvwrite_r+0x224>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
 8006784:	e0bff517 	ldw	r2,-44(fp)
 8006788:	100b883a 	mov	r5,r2
 800678c:	e13ff817 	ldw	r4,-32(fp)
 8006790:	80071000 	call	8007100 <_malloc_r>
 8006794:	e0bff415 	stw	r2,-48(fp)
		      if (!str)
 8006798:	e0bff417 	ldw	r2,-48(fp)
 800679c:	1000041e 	bne	r2,zero,80067b0 <__sfvwrite_r+0x1f4>
			{
			  ptr->_errno = ENOMEM;
 80067a0:	e0bff817 	ldw	r2,-32(fp)
 80067a4:	00c00304 	movi	r3,12
 80067a8:	10c00015 	stw	r3,0(r2)
			  goto err;
 80067ac:	0000ea06 	br	8006b58 <__sfvwrite_r+0x59c>
			}
		      memcpy (str, fp->_bf._base, curpos);
 80067b0:	80800417 	ldw	r2,16(r16)
 80067b4:	e0fff617 	ldw	r3,-40(fp)
 80067b8:	180d883a 	mov	r6,r3
 80067bc:	100b883a 	mov	r5,r2
 80067c0:	e13ff417 	ldw	r4,-48(fp)
 80067c4:	8007e380 	call	8007e38 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
 80067c8:	80c0030b 	ldhu	r3,12(r16)
 80067cc:	00bedfc4 	movi	r2,-1153
 80067d0:	1884703a 	and	r2,r3,r2
 80067d4:	10802014 	ori	r2,r2,128
 80067d8:	8080030d 	sth	r2,12(r16)
 80067dc:	00001506 	br	8006834 <__sfvwrite_r+0x278>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
 80067e0:	80800417 	ldw	r2,16(r16)
 80067e4:	e0fff517 	ldw	r3,-44(fp)
 80067e8:	180d883a 	mov	r6,r3
 80067ec:	100b883a 	mov	r5,r2
 80067f0:	e13ff817 	ldw	r4,-32(fp)
 80067f4:	800838c0 	call	800838c <_realloc_r>
 80067f8:	e0bff415 	stw	r2,-48(fp)
							 newsize);
		      if (!str)
 80067fc:	e0bff417 	ldw	r2,-48(fp)
 8006800:	10000c1e 	bne	r2,zero,8006834 <__sfvwrite_r+0x278>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
 8006804:	80800417 	ldw	r2,16(r16)
 8006808:	100b883a 	mov	r5,r2
 800680c:	e13ff817 	ldw	r4,-32(fp)
 8006810:	8009a040 	call	8009a04 <_free_r>
			  fp->_flags &=  ~__SMBF;
 8006814:	80c0030b 	ldhu	r3,12(r16)
 8006818:	00bfdfc4 	movi	r2,-129
 800681c:	1884703a 	and	r2,r3,r2
 8006820:	8080030d 	sth	r2,12(r16)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
 8006824:	e0bff817 	ldw	r2,-32(fp)
 8006828:	00c00304 	movi	r3,12
 800682c:	10c00015 	stw	r3,0(r2)
			  goto err;
 8006830:	0000c906 	br	8006b58 <__sfvwrite_r+0x59c>
			}
		    }
		  fp->_bf._base = str;
 8006834:	e0bff417 	ldw	r2,-48(fp)
 8006838:	80800415 	stw	r2,16(r16)
		  fp->_p = str + curpos;
 800683c:	e0bff617 	ldw	r2,-40(fp)
 8006840:	e0fff417 	ldw	r3,-48(fp)
 8006844:	1885883a 	add	r2,r3,r2
 8006848:	80800015 	stw	r2,0(r16)
		  fp->_bf._size = newsize;
 800684c:	e0bff517 	ldw	r2,-44(fp)
 8006850:	80800515 	stw	r2,20(r16)
		  w = len;
 8006854:	9023883a 	mov	r17,r18
		  fp->_w = newsize - curpos;
 8006858:	e0fff517 	ldw	r3,-44(fp)
 800685c:	e0bff617 	ldw	r2,-40(fp)
 8006860:	1885c83a 	sub	r2,r3,r2
 8006864:	80800215 	stw	r2,8(r16)
		}
	      if (len < w)
 8006868:	8805883a 	mov	r2,r17
 800686c:	9080012e 	bgeu	r18,r2,8006874 <__sfvwrite_r+0x2b8>
		w = len;
 8006870:	9023883a 	mov	r17,r18
	      COPY (w);		/* copy MIN(fp->_w,len), */
 8006874:	80800017 	ldw	r2,0(r16)
 8006878:	8807883a 	mov	r3,r17
 800687c:	180d883a 	mov	r6,r3
 8006880:	980b883a 	mov	r5,r19
 8006884:	1009883a 	mov	r4,r2
 8006888:	8007fc00 	call	8007fc0 <memmove>
	      fp->_w -= w;
 800688c:	80800217 	ldw	r2,8(r16)
 8006890:	1445c83a 	sub	r2,r2,r17
 8006894:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 8006898:	80800017 	ldw	r2,0(r16)
 800689c:	8807883a 	mov	r3,r17
 80068a0:	10c5883a 	add	r2,r2,r3
 80068a4:	80800015 	stw	r2,0(r16)
	      w = len;		/* but pretend copied all */
 80068a8:	9023883a 	mov	r17,r18
 80068ac:	00003506 	br	8006984 <__sfvwrite_r+0x3c8>
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
 80068b0:	80800017 	ldw	r2,0(r16)
 80068b4:	80c00417 	ldw	r3,16(r16)
 80068b8:	18800236 	bltu	r3,r2,80068c4 <__sfvwrite_r+0x308>
 80068bc:	80800517 	ldw	r2,20(r16)
 80068c0:	9080182e 	bgeu	r18,r2,8006924 <__sfvwrite_r+0x368>
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
 80068c4:	8805883a 	mov	r2,r17
 80068c8:	9080012e 	bgeu	r18,r2,80068d0 <__sfvwrite_r+0x314>
 80068cc:	9005883a 	mov	r2,r18
 80068d0:	1023883a 	mov	r17,r2
	      COPY (w);
 80068d4:	80800017 	ldw	r2,0(r16)
 80068d8:	8807883a 	mov	r3,r17
 80068dc:	180d883a 	mov	r6,r3
 80068e0:	980b883a 	mov	r5,r19
 80068e4:	1009883a 	mov	r4,r2
 80068e8:	8007fc00 	call	8007fc0 <memmove>
	      fp->_w -= w;
 80068ec:	80800217 	ldw	r2,8(r16)
 80068f0:	1445c83a 	sub	r2,r2,r17
 80068f4:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 80068f8:	80800017 	ldw	r2,0(r16)
 80068fc:	8807883a 	mov	r3,r17
 8006900:	10c5883a 	add	r2,r2,r3
 8006904:	80800015 	stw	r2,0(r16)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 8006908:	80800217 	ldw	r2,8(r16)
 800690c:	10001c1e 	bne	r2,zero,8006980 <__sfvwrite_r+0x3c4>
 8006910:	800b883a 	mov	r5,r16
 8006914:	e13ff817 	ldw	r4,-32(fp)
 8006918:	80099280 	call	8009928 <_fflush_r>
 800691c:	10001826 	beq	r2,zero,8006980 <__sfvwrite_r+0x3c4>
		goto err;
 8006920:	00008d06 	br	8006b58 <__sfvwrite_r+0x59c>
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
 8006924:	9005883a 	mov	r2,r18
 8006928:	00e00034 	movhi	r3,32768
 800692c:	10c00236 	bltu	r2,r3,8006938 <__sfvwrite_r+0x37c>
 8006930:	00a00034 	movhi	r2,32768
 8006934:	10bfffc4 	addi	r2,r2,-1
 8006938:	1007883a 	mov	r3,r2
 800693c:	80800517 	ldw	r2,20(r16)
 8006940:	100b883a 	mov	r5,r2
 8006944:	1809883a 	mov	r4,r3
 8006948:	8003f0c0 	call	8003f0c <__divsi3>
 800694c:	1007883a 	mov	r3,r2
 8006950:	80800517 	ldw	r2,20(r16)
 8006954:	18a3383a 	mul	r17,r3,r2
	      w = fp->_write (ptr, fp->_cookie, p, w);
 8006958:	80800917 	ldw	r2,36(r16)
 800695c:	80c00717 	ldw	r3,28(r16)
 8006960:	880f883a 	mov	r7,r17
 8006964:	980d883a 	mov	r6,r19
 8006968:	180b883a 	mov	r5,r3
 800696c:	e13ff817 	ldw	r4,-32(fp)
 8006970:	103ee83a 	callr	r2
 8006974:	1023883a 	mov	r17,r2
	      if (w <= 0)
 8006978:	0440740e 	bge	zero,r17,8006b4c <__sfvwrite_r+0x590>
 800697c:	00000106 	br	8006984 <__sfvwrite_r+0x3c8>
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 8006980:	0001883a 	nop
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
 8006984:	8805883a 	mov	r2,r17
 8006988:	98a7883a 	add	r19,r19,r2
	  len -= w;
 800698c:	8805883a 	mov	r2,r17
 8006990:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 8006994:	a8800217 	ldw	r2,8(r21)
 8006998:	8807883a 	mov	r3,r17
 800699c:	10c5c83a 	sub	r2,r2,r3
 80069a0:	a8800215 	stw	r2,8(r21)
 80069a4:	a8800217 	ldw	r2,8(r21)
 80069a8:	103f501e 	bne	r2,zero,80066ec <__sfvwrite_r+0x130>
 80069ac:	00006306 	br	8006b3c <__sfvwrite_r+0x580>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
 80069b0:	e03ff215 	stw	zero,-56(fp)
      nldist = 0;
 80069b4:	e03ff315 	stw	zero,-52(fp)
      do
	{
	  GETIOV (nlknown = 0);
 80069b8:	00000406 	br	80069cc <__sfvwrite_r+0x410>
 80069bc:	e03ff215 	stw	zero,-56(fp)
 80069c0:	a4c00017 	ldw	r19,0(r20)
 80069c4:	a4800117 	ldw	r18,4(r20)
 80069c8:	a5000204 	addi	r20,r20,8
 80069cc:	903ffb26 	beq	r18,zero,80069bc <__sfvwrite_r+0x400>
	  if (!nlknown)
 80069d0:	e0bff217 	ldw	r2,-56(fp)
 80069d4:	1000111e 	bne	r2,zero,8006a1c <__sfvwrite_r+0x460>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
 80069d8:	900d883a 	mov	r6,r18
 80069dc:	01400284 	movi	r5,10
 80069e0:	9809883a 	mov	r4,r19
 80069e4:	8007c7c0 	call	8007c7c <memchr>
 80069e8:	e0bff715 	stw	r2,-36(fp)
	      nldist = nl ? nl + 1 - p : len + 1;
 80069ec:	e0bff717 	ldw	r2,-36(fp)
 80069f0:	10000626 	beq	r2,zero,8006a0c <__sfvwrite_r+0x450>
 80069f4:	e0bff717 	ldw	r2,-36(fp)
 80069f8:	10800044 	addi	r2,r2,1
 80069fc:	1007883a 	mov	r3,r2
 8006a00:	9805883a 	mov	r2,r19
 8006a04:	1885c83a 	sub	r2,r3,r2
 8006a08:	00000106 	br	8006a10 <__sfvwrite_r+0x454>
 8006a0c:	90800044 	addi	r2,r18,1
 8006a10:	e0bff315 	stw	r2,-52(fp)
	      nlknown = 1;
 8006a14:	00800044 	movi	r2,1
 8006a18:	e0bff215 	stw	r2,-56(fp)
	    }
	  s = MIN (len, nldist);
 8006a1c:	e0bff317 	ldw	r2,-52(fp)
 8006a20:	9080012e 	bgeu	r18,r2,8006a28 <__sfvwrite_r+0x46c>
 8006a24:	9005883a 	mov	r2,r18
 8006a28:	102d883a 	mov	r22,r2
	  w = fp->_w + fp->_bf._size;
 8006a2c:	80c00217 	ldw	r3,8(r16)
 8006a30:	80800517 	ldw	r2,20(r16)
 8006a34:	18a3883a 	add	r17,r3,r2
	  if (fp->_p > fp->_bf._base && s > w)
 8006a38:	80800017 	ldw	r2,0(r16)
 8006a3c:	80c00417 	ldw	r3,16(r16)
 8006a40:	1880102e 	bgeu	r3,r2,8006a84 <__sfvwrite_r+0x4c8>
 8006a44:	8d800f0e 	bge	r17,r22,8006a84 <__sfvwrite_r+0x4c8>
	    {
	      COPY (w);
 8006a48:	80800017 	ldw	r2,0(r16)
 8006a4c:	8807883a 	mov	r3,r17
 8006a50:	180d883a 	mov	r6,r3
 8006a54:	980b883a 	mov	r5,r19
 8006a58:	1009883a 	mov	r4,r2
 8006a5c:	8007fc00 	call	8007fc0 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
 8006a60:	80800017 	ldw	r2,0(r16)
 8006a64:	8807883a 	mov	r3,r17
 8006a68:	10c5883a 	add	r2,r2,r3
 8006a6c:	80800015 	stw	r2,0(r16)
	      if (_fflush_r (ptr, fp))
 8006a70:	800b883a 	mov	r5,r16
 8006a74:	e13ff817 	ldw	r4,-32(fp)
 8006a78:	80099280 	call	8009928 <_fflush_r>
 8006a7c:	10001b26 	beq	r2,zero,8006aec <__sfvwrite_r+0x530>
		goto err;
 8006a80:	00003506 	br	8006b58 <__sfvwrite_r+0x59c>
	    }
	  else if (s >= (w = fp->_bf._size))
 8006a84:	84400517 	ldw	r17,20(r16)
 8006a88:	b4400a16 	blt	r22,r17,8006ab4 <__sfvwrite_r+0x4f8>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
 8006a8c:	80800917 	ldw	r2,36(r16)
 8006a90:	80c00717 	ldw	r3,28(r16)
 8006a94:	880f883a 	mov	r7,r17
 8006a98:	980d883a 	mov	r6,r19
 8006a9c:	180b883a 	mov	r5,r3
 8006aa0:	e13ff817 	ldw	r4,-32(fp)
 8006aa4:	103ee83a 	callr	r2
 8006aa8:	1023883a 	mov	r17,r2
	      if (w <= 0)
 8006aac:	04400f16 	blt	zero,r17,8006aec <__sfvwrite_r+0x530>
		goto err;
 8006ab0:	00002906 	br	8006b58 <__sfvwrite_r+0x59c>
	    }
	  else
	    {
	      w = s;
 8006ab4:	b023883a 	mov	r17,r22
	      COPY (w);
 8006ab8:	80800017 	ldw	r2,0(r16)
 8006abc:	8807883a 	mov	r3,r17
 8006ac0:	180d883a 	mov	r6,r3
 8006ac4:	980b883a 	mov	r5,r19
 8006ac8:	1009883a 	mov	r4,r2
 8006acc:	8007fc00 	call	8007fc0 <memmove>
	      fp->_w -= w;
 8006ad0:	80800217 	ldw	r2,8(r16)
 8006ad4:	1445c83a 	sub	r2,r2,r17
 8006ad8:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 8006adc:	80800017 	ldw	r2,0(r16)
 8006ae0:	8807883a 	mov	r3,r17
 8006ae4:	10c5883a 	add	r2,r2,r3
 8006ae8:	80800015 	stw	r2,0(r16)
	    }
	  if ((nldist -= w) == 0)
 8006aec:	e0bff317 	ldw	r2,-52(fp)
 8006af0:	1445c83a 	sub	r2,r2,r17
 8006af4:	e0bff315 	stw	r2,-52(fp)
 8006af8:	e0bff317 	ldw	r2,-52(fp)
 8006afc:	1000051e 	bne	r2,zero,8006b14 <__sfvwrite_r+0x558>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
 8006b00:	800b883a 	mov	r5,r16
 8006b04:	e13ff817 	ldw	r4,-32(fp)
 8006b08:	80099280 	call	8009928 <_fflush_r>
 8006b0c:	1000111e 	bne	r2,zero,8006b54 <__sfvwrite_r+0x598>
		goto err;
	      nlknown = 0;
 8006b10:	e03ff215 	stw	zero,-56(fp)
	    }
	  p += w;
 8006b14:	8805883a 	mov	r2,r17
 8006b18:	98a7883a 	add	r19,r19,r2
	  len -= w;
 8006b1c:	8805883a 	mov	r2,r17
 8006b20:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 8006b24:	a8800217 	ldw	r2,8(r21)
 8006b28:	8807883a 	mov	r3,r17
 8006b2c:	10c5c83a 	sub	r2,r2,r3
 8006b30:	a8800215 	stw	r2,8(r21)
 8006b34:	a8800217 	ldw	r2,8(r21)
 8006b38:	103fa41e 	bne	r2,zero,80069cc <__sfvwrite_r+0x410>
    }
  return 0;
 8006b3c:	0005883a 	mov	r2,zero
 8006b40:	00000906 	br	8006b68 <__sfvwrite_r+0x5ac>
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
 8006b44:	0001883a 	nop
 8006b48:	00000306 	br	8006b58 <__sfvwrite_r+0x59c>
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
 8006b4c:	0001883a 	nop
 8006b50:	00000106 	br	8006b58 <__sfvwrite_r+0x59c>
	    }
	  if ((nldist -= w) == 0)
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
 8006b54:	0001883a 	nop
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
 8006b58:	8080030b 	ldhu	r2,12(r16)
 8006b5c:	10801014 	ori	r2,r2,64
 8006b60:	8080030d 	sth	r2,12(r16)
  return EOF;
 8006b64:	00bfffc4 	movi	r2,-1
}
 8006b68:	e6fff904 	addi	sp,fp,-28
 8006b6c:	dfc00817 	ldw	ra,32(sp)
 8006b70:	df000717 	ldw	fp,28(sp)
 8006b74:	dd800617 	ldw	r22,24(sp)
 8006b78:	dd400517 	ldw	r21,20(sp)
 8006b7c:	dd000417 	ldw	r20,16(sp)
 8006b80:	dcc00317 	ldw	r19,12(sp)
 8006b84:	dc800217 	ldw	r18,8(sp)
 8006b88:	dc400117 	ldw	r17,4(sp)
 8006b8c:	dc000017 	ldw	r16,0(sp)
 8006b90:	dec00904 	addi	sp,sp,36
 8006b94:	f800283a 	ret

08006b98 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
 8006b98:	defff804 	addi	sp,sp,-32
 8006b9c:	dfc00715 	stw	ra,28(sp)
 8006ba0:	df000615 	stw	fp,24(sp)
 8006ba4:	dd000515 	stw	r20,20(sp)
 8006ba8:	dcc00415 	stw	r19,16(sp)
 8006bac:	dc800315 	stw	r18,12(sp)
 8006bb0:	dc400215 	stw	r17,8(sp)
 8006bb4:	dc000115 	stw	r16,4(sp)
 8006bb8:	df000604 	addi	fp,sp,24
 8006bbc:	e13ffa15 	stw	r4,-24(fp)
 8006bc0:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 8006bc4:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8006bc8:	e0bffa17 	ldw	r2,-24(fp)
 8006bcc:	1440b804 	addi	r17,r2,736
 8006bd0:	00001b06 	br	8006c40 <_fwalk+0xa8>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006bd4:	8c000217 	ldw	r16,8(r17)
 8006bd8:	8c800117 	ldw	r18,4(r17)
 8006bdc:	00001506 	br	8006c34 <_fwalk+0x9c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 8006be0:	8080030b 	ldhu	r2,12(r16)
 8006be4:	10bfffcc 	andi	r2,r2,65535
 8006be8:	10a0001c 	xori	r2,r2,32768
 8006bec:	10a00004 	addi	r2,r2,-32768
 8006bf0:	10000f26 	beq	r2,zero,8006c30 <_fwalk+0x98>
 8006bf4:	8080030b 	ldhu	r2,12(r16)
 8006bf8:	10bfffcc 	andi	r2,r2,65535
 8006bfc:	10a0001c 	xori	r2,r2,32768
 8006c00:	10a00004 	addi	r2,r2,-32768
 8006c04:	10800060 	cmpeqi	r2,r2,1
 8006c08:	1000091e 	bne	r2,zero,8006c30 <_fwalk+0x98>
 8006c0c:	8080038b 	ldhu	r2,14(r16)
 8006c10:	10bfffcc 	andi	r2,r2,65535
 8006c14:	10a0001c 	xori	r2,r2,32768
 8006c18:	10a00004 	addi	r2,r2,-32768
 8006c1c:	10bfffe0 	cmpeqi	r2,r2,-1
 8006c20:	1000031e 	bne	r2,zero,8006c30 <_fwalk+0x98>
	ret |= (*function) (fp);
 8006c24:	8009883a 	mov	r4,r16
 8006c28:	a03ee83a 	callr	r20
 8006c2c:	98a6b03a 	or	r19,r19,r2
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006c30:	84001a04 	addi	r16,r16,104
 8006c34:	94bfffc4 	addi	r18,r18,-1
 8006c38:	903fe90e 	bge	r18,zero,8006be0 <_fwalk+0x48>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8006c3c:	8c400017 	ldw	r17,0(r17)
 8006c40:	883fe41e 	bne	r17,zero,8006bd4 <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
 8006c44:	9805883a 	mov	r2,r19
}
 8006c48:	e6fffb04 	addi	sp,fp,-20
 8006c4c:	dfc00617 	ldw	ra,24(sp)
 8006c50:	df000517 	ldw	fp,20(sp)
 8006c54:	dd000417 	ldw	r20,16(sp)
 8006c58:	dcc00317 	ldw	r19,12(sp)
 8006c5c:	dc800217 	ldw	r18,8(sp)
 8006c60:	dc400117 	ldw	r17,4(sp)
 8006c64:	dc000017 	ldw	r16,0(sp)
 8006c68:	dec00704 	addi	sp,sp,28
 8006c6c:	f800283a 	ret

08006c70 <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
 8006c70:	defff804 	addi	sp,sp,-32
 8006c74:	dfc00715 	stw	ra,28(sp)
 8006c78:	df000615 	stw	fp,24(sp)
 8006c7c:	dd000515 	stw	r20,20(sp)
 8006c80:	dcc00415 	stw	r19,16(sp)
 8006c84:	dc800315 	stw	r18,12(sp)
 8006c88:	dc400215 	stw	r17,8(sp)
 8006c8c:	dc000115 	stw	r16,4(sp)
 8006c90:	df000604 	addi	fp,sp,24
 8006c94:	e13ffa15 	stw	r4,-24(fp)
 8006c98:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 8006c9c:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8006ca0:	e0bffa17 	ldw	r2,-24(fp)
 8006ca4:	1440b804 	addi	r17,r2,736
 8006ca8:	00001c06 	br	8006d1c <_fwalk_reent+0xac>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006cac:	8c000217 	ldw	r16,8(r17)
 8006cb0:	8c800117 	ldw	r18,4(r17)
 8006cb4:	00001606 	br	8006d10 <_fwalk_reent+0xa0>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 8006cb8:	8080030b 	ldhu	r2,12(r16)
 8006cbc:	10bfffcc 	andi	r2,r2,65535
 8006cc0:	10a0001c 	xori	r2,r2,32768
 8006cc4:	10a00004 	addi	r2,r2,-32768
 8006cc8:	10001026 	beq	r2,zero,8006d0c <_fwalk_reent+0x9c>
 8006ccc:	8080030b 	ldhu	r2,12(r16)
 8006cd0:	10bfffcc 	andi	r2,r2,65535
 8006cd4:	10a0001c 	xori	r2,r2,32768
 8006cd8:	10a00004 	addi	r2,r2,-32768
 8006cdc:	10800060 	cmpeqi	r2,r2,1
 8006ce0:	10000a1e 	bne	r2,zero,8006d0c <_fwalk_reent+0x9c>
 8006ce4:	8080038b 	ldhu	r2,14(r16)
 8006ce8:	10bfffcc 	andi	r2,r2,65535
 8006cec:	10a0001c 	xori	r2,r2,32768
 8006cf0:	10a00004 	addi	r2,r2,-32768
 8006cf4:	10bfffe0 	cmpeqi	r2,r2,-1
 8006cf8:	1000041e 	bne	r2,zero,8006d0c <_fwalk_reent+0x9c>
	ret |= (*reent_function) (ptr, fp);
 8006cfc:	800b883a 	mov	r5,r16
 8006d00:	e13ffa17 	ldw	r4,-24(fp)
 8006d04:	a03ee83a 	callr	r20
 8006d08:	98a6b03a 	or	r19,r19,r2
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006d0c:	84001a04 	addi	r16,r16,104
 8006d10:	94bfffc4 	addi	r18,r18,-1
 8006d14:	903fe80e 	bge	r18,zero,8006cb8 <_fwalk_reent+0x48>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8006d18:	8c400017 	ldw	r17,0(r17)
 8006d1c:	883fe31e 	bne	r17,zero,8006cac <_fwalk_reent+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
 8006d20:	9805883a 	mov	r2,r19
}
 8006d24:	e6fffb04 	addi	sp,fp,-20
 8006d28:	dfc00617 	ldw	ra,24(sp)
 8006d2c:	df000517 	ldw	fp,20(sp)
 8006d30:	dd000417 	ldw	r20,16(sp)
 8006d34:	dcc00317 	ldw	r19,12(sp)
 8006d38:	dc800217 	ldw	r18,8(sp)
 8006d3c:	dc400117 	ldw	r17,4(sp)
 8006d40:	dc000017 	ldw	r16,0(sp)
 8006d44:	dec00704 	addi	sp,sp,28
 8006d48:	f800283a 	ret

08006d4c <malloc_extend_top>:
#if __STD_C
static void malloc_extend_top(RARG INTERNAL_SIZE_T nb)
#else
static void malloc_extend_top(RARG nb) RDECL INTERNAL_SIZE_T nb;
#endif
{
 8006d4c:	defff104 	addi	sp,sp,-60
 8006d50:	dfc00e15 	stw	ra,56(sp)
 8006d54:	df000d15 	stw	fp,52(sp)
 8006d58:	df000d04 	addi	fp,sp,52
 8006d5c:	e13ffe15 	stw	r4,-8(fp)
 8006d60:	e17fff15 	stw	r5,-4(fp)
  char*     brk;                  /* return value from sbrk */
  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of sbrked space */
  INTERNAL_SIZE_T correction;     /* bytes for 2nd sbrk call */
  int correction_failed = 0;      /* whether we should relax the assertion */
 8006d64:	e03ff715 	stw	zero,-36(fp)
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
 8006d68:	00820134 	movhi	r2,2052
 8006d6c:	109aa204 	addi	r2,r2,27272
 8006d70:	10800217 	ldw	r2,8(r2)
 8006d74:	e0bff815 	stw	r2,-32(fp)
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
 8006d78:	e0bff817 	ldw	r2,-32(fp)
 8006d7c:	10c00117 	ldw	r3,4(r2)
 8006d80:	00bfff04 	movi	r2,-4
 8006d84:	1884703a 	and	r2,r3,r2
 8006d88:	e0bff915 	stw	r2,-28(fp)
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
 8006d8c:	e0fff817 	ldw	r3,-32(fp)
 8006d90:	e0bff917 	ldw	r2,-28(fp)
 8006d94:	1885883a 	add	r2,r3,r2
 8006d98:	e0bffa15 	stw	r2,-24(fp)

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
 8006d9c:	d0e76717 	ldw	r3,-25188(gp)
 8006da0:	e0bfff17 	ldw	r2,-4(fp)
 8006da4:	1885883a 	add	r2,r3,r2
 8006da8:	10800404 	addi	r2,r2,16
 8006dac:	e0bff615 	stw	r2,-40(fp)
  unsigned long pagesz    = malloc_getpagesize;
 8006db0:	00840004 	movi	r2,4096
 8006db4:	e0bffb15 	stw	r2,-20(fp)

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
 8006db8:	d0a04517 	ldw	r2,-32492(gp)
 8006dbc:	10bfffe0 	cmpeqi	r2,r2,-1
 8006dc0:	1000081e 	bne	r2,zero,8006de4 <malloc_extend_top+0x98>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
 8006dc4:	e0fffb17 	ldw	r3,-20(fp)
 8006dc8:	e0bff617 	ldw	r2,-40(fp)
 8006dcc:	1885883a 	add	r2,r3,r2
 8006dd0:	10ffffc4 	addi	r3,r2,-1
 8006dd4:	e0bffb17 	ldw	r2,-20(fp)
 8006dd8:	0085c83a 	sub	r2,zero,r2
 8006ddc:	1884703a 	and	r2,r3,r2
 8006de0:	e0bff615 	stw	r2,-40(fp)

  brk = (char*)(MORECORE (sbrk_size));
 8006de4:	e0bff617 	ldw	r2,-40(fp)
 8006de8:	100b883a 	mov	r5,r2
 8006dec:	e13ffe17 	ldw	r4,-8(fp)
 8006df0:	8008f7c0 	call	8008f7c <_sbrk_r>
 8006df4:	e0bff315 	stw	r2,-52(fp)

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
 8006df8:	e0bff317 	ldw	r2,-52(fp)
 8006dfc:	10bfffe0 	cmpeqi	r2,r2,-1
 8006e00:	1000b91e 	bne	r2,zero,80070e8 <malloc_extend_top+0x39c>
 8006e04:	e0fff317 	ldw	r3,-52(fp)
 8006e08:	e0bffa17 	ldw	r2,-24(fp)
 8006e0c:	1880042e 	bgeu	r3,r2,8006e20 <malloc_extend_top+0xd4>
      (brk < old_end && old_top != initial_top))
 8006e10:	00820134 	movhi	r2,2052
 8006e14:	109aa204 	addi	r2,r2,27272
 8006e18:	e0fff817 	ldw	r3,-32(fp)
 8006e1c:	1880b21e 	bne	r3,r2,80070e8 <malloc_extend_top+0x39c>
    return;

  sbrked_mem += sbrk_size;
 8006e20:	00820174 	movhi	r2,2053
 8006e24:	10a7d104 	addi	r2,r2,-24764
 8006e28:	10800017 	ldw	r2,0(r2)
 8006e2c:	1007883a 	mov	r3,r2
 8006e30:	e0bff617 	ldw	r2,-40(fp)
 8006e34:	1885883a 	add	r2,r3,r2
 8006e38:	1007883a 	mov	r3,r2
 8006e3c:	00820174 	movhi	r2,2053
 8006e40:	10a7d104 	addi	r2,r2,-24764
 8006e44:	10c00015 	stw	r3,0(r2)

  if (brk == old_end /* can just add bytes to current top, unless
 8006e48:	e0fff317 	ldw	r3,-52(fp)
 8006e4c:	e0bffa17 	ldw	r2,-24(fp)
 8006e50:	1880101e 	bne	r3,r2,8006e94 <malloc_extend_top+0x148>
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
 8006e54:	e0bffb17 	ldw	r2,-20(fp)
 8006e58:	10ffffc4 	addi	r3,r2,-1
 8006e5c:	e0bffa17 	ldw	r2,-24(fp)
 8006e60:	1884703a 	and	r2,r3,r2
 8006e64:	10000b1e 	bne	r2,zero,8006e94 <malloc_extend_top+0x148>
  {
    top_size = sbrk_size + old_top_size;
 8006e68:	e0fff617 	ldw	r3,-40(fp)
 8006e6c:	e0bff917 	ldw	r2,-28(fp)
 8006e70:	1885883a 	add	r2,r3,r2
 8006e74:	e0bffc15 	stw	r2,-16(fp)
    set_head(top, top_size | PREV_INUSE);
 8006e78:	00820134 	movhi	r2,2052
 8006e7c:	109aa204 	addi	r2,r2,27272
 8006e80:	10800217 	ldw	r2,8(r2)
 8006e84:	e0fffc17 	ldw	r3,-16(fp)
 8006e88:	18c00054 	ori	r3,r3,1
 8006e8c:	10c00115 	stw	r3,4(r2)
 8006e90:	00008006 	br	8007094 <malloc_extend_top+0x348>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
 8006e94:	d0a04517 	ldw	r2,-32492(gp)
 8006e98:	10bfffd8 	cmpnei	r2,r2,-1
 8006e9c:	1000031e 	bne	r2,zero,8006eac <malloc_extend_top+0x160>
      sbrk_base = brk;
 8006ea0:	e0bff317 	ldw	r2,-52(fp)
 8006ea4:	d0a04515 	stw	r2,-32492(gp)
 8006ea8:	00000a06 	br	8006ed4 <malloc_extend_top+0x188>
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
 8006eac:	00820174 	movhi	r2,2053
 8006eb0:	10a7d104 	addi	r2,r2,-24764
 8006eb4:	10c00017 	ldw	r3,0(r2)
 8006eb8:	e13ff317 	ldw	r4,-52(fp)
 8006ebc:	e0bffa17 	ldw	r2,-24(fp)
 8006ec0:	2085c83a 	sub	r2,r4,r2
 8006ec4:	1887883a 	add	r3,r3,r2
 8006ec8:	00820174 	movhi	r2,2053
 8006ecc:	10a7d104 	addi	r2,r2,-24764
 8006ed0:	10c00015 	stw	r3,0(r2)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
 8006ed4:	e0bff317 	ldw	r2,-52(fp)
 8006ed8:	10800204 	addi	r2,r2,8
 8006edc:	108001cc 	andi	r2,r2,7
 8006ee0:	e0bffd15 	stw	r2,-12(fp)
    if (front_misalign > 0) 
 8006ee4:	e0bffd17 	ldw	r2,-12(fp)
 8006ee8:	10000926 	beq	r2,zero,8006f10 <malloc_extend_top+0x1c4>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
 8006eec:	00c00204 	movi	r3,8
 8006ef0:	e0bffd17 	ldw	r2,-12(fp)
 8006ef4:	1885c83a 	sub	r2,r3,r2
 8006ef8:	e0bff415 	stw	r2,-48(fp)
      brk += correction;
 8006efc:	e0fff317 	ldw	r3,-52(fp)
 8006f00:	e0bff417 	ldw	r2,-48(fp)
 8006f04:	1885883a 	add	r2,r3,r2
 8006f08:	e0bff315 	stw	r2,-52(fp)
 8006f0c:	00000106 	br	8006f14 <malloc_extend_top+0x1c8>
    }
    else
      correction = 0;
 8006f10:	e03ff415 	stw	zero,-48(fp)

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
 8006f14:	e0fff317 	ldw	r3,-52(fp)
 8006f18:	e0bff617 	ldw	r2,-40(fp)
 8006f1c:	1885883a 	add	r2,r3,r2
 8006f20:	1007883a 	mov	r3,r2
 8006f24:	e0bffb17 	ldw	r2,-20(fp)
 8006f28:	10bfffc4 	addi	r2,r2,-1
 8006f2c:	1884703a 	and	r2,r3,r2
 8006f30:	e0fffb17 	ldw	r3,-20(fp)
 8006f34:	1885c83a 	sub	r2,r3,r2
 8006f38:	e0fff417 	ldw	r3,-48(fp)
 8006f3c:	1885883a 	add	r2,r3,r2
 8006f40:	e0bff415 	stw	r2,-48(fp)

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
 8006f44:	e0bff417 	ldw	r2,-48(fp)
 8006f48:	100b883a 	mov	r5,r2
 8006f4c:	e13ffe17 	ldw	r4,-8(fp)
 8006f50:	8008f7c0 	call	8008f7c <_sbrk_r>
 8006f54:	e0bff515 	stw	r2,-44(fp)
    if (new_brk == (char*)(MORECORE_FAILURE))
 8006f58:	e0bff517 	ldw	r2,-44(fp)
 8006f5c:	10bfffd8 	cmpnei	r2,r2,-1
 8006f60:	1000051e 	bne	r2,zero,8006f78 <malloc_extend_top+0x22c>
      {
	correction = 0;
 8006f64:	e03ff415 	stw	zero,-48(fp)
	correction_failed = 1;
 8006f68:	00800044 	movi	r2,1
 8006f6c:	e0bff715 	stw	r2,-36(fp)
	new_brk = brk;
 8006f70:	e0bff317 	ldw	r2,-52(fp)
 8006f74:	e0bff515 	stw	r2,-44(fp)
      }

    sbrked_mem += correction;
 8006f78:	00820174 	movhi	r2,2053
 8006f7c:	10a7d104 	addi	r2,r2,-24764
 8006f80:	10800017 	ldw	r2,0(r2)
 8006f84:	1007883a 	mov	r3,r2
 8006f88:	e0bff417 	ldw	r2,-48(fp)
 8006f8c:	1885883a 	add	r2,r3,r2
 8006f90:	1007883a 	mov	r3,r2
 8006f94:	00820174 	movhi	r2,2053
 8006f98:	10a7d104 	addi	r2,r2,-24764
 8006f9c:	10c00015 	stw	r3,0(r2)

    top = (mchunkptr)brk;
 8006fa0:	00820134 	movhi	r2,2052
 8006fa4:	109aa204 	addi	r2,r2,27272
 8006fa8:	e0fff317 	ldw	r3,-52(fp)
 8006fac:	10c00215 	stw	r3,8(r2)
    top_size = new_brk - brk + correction;
 8006fb0:	e0fff517 	ldw	r3,-44(fp)
 8006fb4:	e0bff317 	ldw	r2,-52(fp)
 8006fb8:	1885c83a 	sub	r2,r3,r2
 8006fbc:	1007883a 	mov	r3,r2
 8006fc0:	e0bff417 	ldw	r2,-48(fp)
 8006fc4:	1885883a 	add	r2,r3,r2
 8006fc8:	e0bffc15 	stw	r2,-16(fp)
    set_head(top, top_size | PREV_INUSE);
 8006fcc:	00820134 	movhi	r2,2052
 8006fd0:	109aa204 	addi	r2,r2,27272
 8006fd4:	10800217 	ldw	r2,8(r2)
 8006fd8:	e0fffc17 	ldw	r3,-16(fp)
 8006fdc:	18c00054 	ori	r3,r3,1
 8006fe0:	10c00115 	stw	r3,4(r2)

    if (old_top != initial_top)
 8006fe4:	00820134 	movhi	r2,2052
 8006fe8:	109aa204 	addi	r2,r2,27272
 8006fec:	e0fff817 	ldw	r3,-32(fp)
 8006ff0:	18802826 	beq	r3,r2,8007094 <malloc_extend_top+0x348>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
 8006ff4:	e0bff917 	ldw	r2,-28(fp)
 8006ff8:	10800428 	cmpgeui	r2,r2,16
 8006ffc:	1000061e 	bne	r2,zero,8007018 <malloc_extend_top+0x2cc>
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
 8007000:	00820134 	movhi	r2,2052
 8007004:	109aa204 	addi	r2,r2,27272
 8007008:	10800217 	ldw	r2,8(r2)
 800700c:	00c00044 	movi	r3,1
 8007010:	10c00115 	stw	r3,4(r2)
        return;
 8007014:	00003506 	br	80070ec <malloc_extend_top+0x3a0>
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
 8007018:	e0bff917 	ldw	r2,-28(fp)
 800701c:	10fffd04 	addi	r3,r2,-12
 8007020:	00bffe04 	movi	r2,-8
 8007024:	1884703a 	and	r2,r3,r2
 8007028:	e0bff915 	stw	r2,-28(fp)
      set_head_size(old_top, old_top_size);
 800702c:	e0bff817 	ldw	r2,-32(fp)
 8007030:	10800117 	ldw	r2,4(r2)
 8007034:	10c0004c 	andi	r3,r2,1
 8007038:	e0bff917 	ldw	r2,-28(fp)
 800703c:	1886b03a 	or	r3,r3,r2
 8007040:	e0bff817 	ldw	r2,-32(fp)
 8007044:	10c00115 	stw	r3,4(r2)
      chunk_at_offset(old_top, old_top_size          )->size =
 8007048:	e0fff817 	ldw	r3,-32(fp)
 800704c:	e0bff917 	ldw	r2,-28(fp)
 8007050:	1885883a 	add	r2,r3,r2
 8007054:	00c00144 	movi	r3,5
 8007058:	10c00115 	stw	r3,4(r2)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
 800705c:	e0bff917 	ldw	r2,-28(fp)
 8007060:	10800104 	addi	r2,r2,4
 8007064:	e0fff817 	ldw	r3,-32(fp)
 8007068:	1885883a 	add	r2,r3,r2
 800706c:	00c00144 	movi	r3,5
 8007070:	10c00115 	stw	r3,4(r2)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
 8007074:	e0bff917 	ldw	r2,-28(fp)
 8007078:	10800430 	cmpltui	r2,r2,16
 800707c:	1000051e 	bne	r2,zero,8007094 <malloc_extend_top+0x348>
        fREe(RCALL chunk2mem(old_top));
 8007080:	e0bff817 	ldw	r2,-32(fp)
 8007084:	10800204 	addi	r2,r2,8
 8007088:	100b883a 	mov	r5,r2
 800708c:	e13ffe17 	ldw	r4,-8(fp)
 8007090:	8009a040 	call	8009a04 <_free_r>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
 8007094:	00820174 	movhi	r2,2053
 8007098:	10a7d104 	addi	r2,r2,-24764
 800709c:	10800017 	ldw	r2,0(r2)
 80070a0:	1007883a 	mov	r3,r2
 80070a4:	d0a76817 	ldw	r2,-25184(gp)
 80070a8:	10c0042e 	bgeu	r2,r3,80070bc <malloc_extend_top+0x370>
    max_sbrked_mem = sbrked_mem;
 80070ac:	00820174 	movhi	r2,2053
 80070b0:	10a7d104 	addi	r2,r2,-24764
 80070b4:	10800017 	ldw	r2,0(r2)
 80070b8:	d0a76815 	stw	r2,-25184(gp)
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
 80070bc:	00820174 	movhi	r2,2053
 80070c0:	10a7d104 	addi	r2,r2,-24764
 80070c4:	10800017 	ldw	r2,0(r2)
 80070c8:	1007883a 	mov	r3,r2
 80070cc:	d0a76917 	ldw	r2,-25180(gp)
 80070d0:	10c0062e 	bgeu	r2,r3,80070ec <malloc_extend_top+0x3a0>
    max_total_mem = sbrked_mem;
 80070d4:	00820174 	movhi	r2,2053
 80070d8:	10a7d104 	addi	r2,r2,-24764
 80070dc:	10800017 	ldw	r2,0(r2)
 80070e0:	d0a76915 	stw	r2,-25180(gp)
 80070e4:	00000106 	br	80070ec <malloc_extend_top+0x3a0>
  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
    return;
 80070e8:	0001883a 	nop
#endif

  /* We always land on a page boundary */
  assert(((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0
	 || correction_failed);
}
 80070ec:	e037883a 	mov	sp,fp
 80070f0:	dfc00117 	ldw	ra,4(sp)
 80070f4:	df000017 	ldw	fp,0(sp)
 80070f8:	dec00204 	addi	sp,sp,8
 80070fc:	f800283a 	ret

08007100 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
 8007100:	deffef04 	addi	sp,sp,-68
 8007104:	dfc01015 	stw	ra,64(sp)
 8007108:	df000f15 	stw	fp,60(sp)
 800710c:	df000f04 	addi	fp,sp,60
 8007110:	e13ffe15 	stw	r4,-8(fp)
 8007114:	e17fff15 	stw	r5,-4(fp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
 8007118:	e0bfff17 	ldw	r2,-4(fp)
 800711c:	108002c4 	addi	r2,r2,11
 8007120:	108005f0 	cmpltui	r2,r2,23
 8007124:	1000051e 	bne	r2,zero,800713c <_malloc_r+0x3c>
 8007128:	e0bfff17 	ldw	r2,-4(fp)
 800712c:	10c002c4 	addi	r3,r2,11
 8007130:	00bffe04 	movi	r2,-8
 8007134:	1884703a 	and	r2,r3,r2
 8007138:	00000106 	br	8007140 <_malloc_r+0x40>
 800713c:	00800404 	movi	r2,16
 8007140:	e0bffa15 	stw	r2,-24(fp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
 8007144:	e0bffa17 	ldw	r2,-24(fp)
 8007148:	10000316 	blt	r2,zero,8007158 <_malloc_r+0x58>
 800714c:	e0fffa17 	ldw	r3,-24(fp)
 8007150:	e0bfff17 	ldw	r2,-4(fp)
 8007154:	1880052e 	bgeu	r3,r2,800716c <_malloc_r+0x6c>
  {
    RERRNO = ENOMEM;
 8007158:	e0bffe17 	ldw	r2,-8(fp)
 800715c:	00c00304 	movi	r3,12
 8007160:	10c00015 	stw	r3,0(r2)
    return 0;
 8007164:	0005883a 	mov	r2,zero
 8007168:	0002bf06 	br	8007c68 <_malloc_r+0xb68>
  }

  MALLOC_LOCK;
 800716c:	e13ffe17 	ldw	r4,-8(fp)
 8007170:	800aa640 	call	800aa64 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
 8007174:	e0bffa17 	ldw	r2,-24(fp)
 8007178:	10807e28 	cmpgeui	r2,r2,504
 800717c:	10003f1e 	bne	r2,zero,800727c <_malloc_r+0x17c>
  {
    idx = smallbin_index(nb); 
 8007180:	e0bffa17 	ldw	r2,-24(fp)
 8007184:	1004d0fa 	srli	r2,r2,3
 8007188:	e0bff215 	stw	r2,-56(fp)

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
 800718c:	e0bff217 	ldw	r2,-56(fp)
 8007190:	10800044 	addi	r2,r2,1
 8007194:	1085883a 	add	r2,r2,r2
 8007198:	1085883a 	add	r2,r2,r2
 800719c:	1087883a 	add	r3,r2,r2
 80071a0:	00820134 	movhi	r2,2052
 80071a4:	109aa204 	addi	r2,r2,27272
 80071a8:	1885883a 	add	r2,r3,r2
 80071ac:	10bffe04 	addi	r2,r2,-8
 80071b0:	e0bff915 	stw	r2,-28(fp)
    victim = last(q);
 80071b4:	e0bff917 	ldw	r2,-28(fp)
 80071b8:	10800317 	ldw	r2,12(r2)
 80071bc:	e0bff115 	stw	r2,-60(fp)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
 80071c0:	e0fff117 	ldw	r3,-60(fp)
 80071c4:	e0bff917 	ldw	r2,-28(fp)
 80071c8:	1880061e 	bne	r3,r2,80071e4 <_malloc_r+0xe4>
    {
      q = next_bin(q);
 80071cc:	e0bff917 	ldw	r2,-28(fp)
 80071d0:	10800204 	addi	r2,r2,8
 80071d4:	e0bff915 	stw	r2,-28(fp)
      victim = last(q);
 80071d8:	e0bff917 	ldw	r2,-28(fp)
 80071dc:	10800317 	ldw	r2,12(r2)
 80071e0:	e0bff115 	stw	r2,-60(fp)
    }
#endif
    if (victim != q)
 80071e4:	e0fff117 	ldw	r3,-60(fp)
 80071e8:	e0bff917 	ldw	r2,-28(fp)
 80071ec:	18801f26 	beq	r3,r2,800726c <_malloc_r+0x16c>
    {
      victim_size = chunksize(victim);
 80071f0:	e0bff117 	ldw	r2,-60(fp)
 80071f4:	10c00117 	ldw	r3,4(r2)
 80071f8:	00bfff04 	movi	r2,-4
 80071fc:	1884703a 	and	r2,r3,r2
 8007200:	e0bffb15 	stw	r2,-20(fp)
      unlink(victim, bck, fwd);
 8007204:	e0bff117 	ldw	r2,-60(fp)
 8007208:	10800317 	ldw	r2,12(r2)
 800720c:	e0bff815 	stw	r2,-32(fp)
 8007210:	e0bff117 	ldw	r2,-60(fp)
 8007214:	10800217 	ldw	r2,8(r2)
 8007218:	e0bff715 	stw	r2,-36(fp)
 800721c:	e0bff717 	ldw	r2,-36(fp)
 8007220:	e0fff817 	ldw	r3,-32(fp)
 8007224:	10c00315 	stw	r3,12(r2)
 8007228:	e0bff817 	ldw	r2,-32(fp)
 800722c:	e0fff717 	ldw	r3,-36(fp)
 8007230:	10c00215 	stw	r3,8(r2)
      set_inuse_bit_at_offset(victim, victim_size);
 8007234:	e0fff117 	ldw	r3,-60(fp)
 8007238:	e0bffb17 	ldw	r2,-20(fp)
 800723c:	1885883a 	add	r2,r3,r2
 8007240:	e13ff117 	ldw	r4,-60(fp)
 8007244:	e0fffb17 	ldw	r3,-20(fp)
 8007248:	20c7883a 	add	r3,r4,r3
 800724c:	18c00117 	ldw	r3,4(r3)
 8007250:	18c00054 	ori	r3,r3,1
 8007254:	10c00115 	stw	r3,4(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 8007258:	e13ffe17 	ldw	r4,-8(fp)
 800725c:	800aa880 	call	800aa88 <__malloc_unlock>
      return chunk2mem(victim);
 8007260:	e0bff117 	ldw	r2,-60(fp)
 8007264:	10800204 	addi	r2,r2,8
 8007268:	00027f06 	br	8007c68 <_malloc_r+0xb68>
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
 800726c:	e0bff217 	ldw	r2,-56(fp)
 8007270:	10800084 	addi	r2,r2,2
 8007274:	e0bff215 	stw	r2,-56(fp)
 8007278:	00007306 	br	8007448 <_malloc_r+0x348>

  }
  else
  {
    idx = bin_index(nb);
 800727c:	e0bffa17 	ldw	r2,-24(fp)
 8007280:	1004d27a 	srli	r2,r2,9
 8007284:	1000031e 	bne	r2,zero,8007294 <_malloc_r+0x194>
 8007288:	e0bffa17 	ldw	r2,-24(fp)
 800728c:	1004d0fa 	srli	r2,r2,3
 8007290:	00002906 	br	8007338 <_malloc_r+0x238>
 8007294:	e0bffa17 	ldw	r2,-24(fp)
 8007298:	1004d27a 	srli	r2,r2,9
 800729c:	10800168 	cmpgeui	r2,r2,5
 80072a0:	1000041e 	bne	r2,zero,80072b4 <_malloc_r+0x1b4>
 80072a4:	e0bffa17 	ldw	r2,-24(fp)
 80072a8:	1004d1ba 	srli	r2,r2,6
 80072ac:	10800e04 	addi	r2,r2,56
 80072b0:	00002106 	br	8007338 <_malloc_r+0x238>
 80072b4:	e0bffa17 	ldw	r2,-24(fp)
 80072b8:	1004d27a 	srli	r2,r2,9
 80072bc:	10800568 	cmpgeui	r2,r2,21
 80072c0:	1000041e 	bne	r2,zero,80072d4 <_malloc_r+0x1d4>
 80072c4:	e0bffa17 	ldw	r2,-24(fp)
 80072c8:	1004d27a 	srli	r2,r2,9
 80072cc:	108016c4 	addi	r2,r2,91
 80072d0:	00001906 	br	8007338 <_malloc_r+0x238>
 80072d4:	e0bffa17 	ldw	r2,-24(fp)
 80072d8:	1004d27a 	srli	r2,r2,9
 80072dc:	10801568 	cmpgeui	r2,r2,85
 80072e0:	1000041e 	bne	r2,zero,80072f4 <_malloc_r+0x1f4>
 80072e4:	e0bffa17 	ldw	r2,-24(fp)
 80072e8:	1004d33a 	srli	r2,r2,12
 80072ec:	10801b84 	addi	r2,r2,110
 80072f0:	00001106 	br	8007338 <_malloc_r+0x238>
 80072f4:	e0bffa17 	ldw	r2,-24(fp)
 80072f8:	1004d27a 	srli	r2,r2,9
 80072fc:	10805568 	cmpgeui	r2,r2,341
 8007300:	1000041e 	bne	r2,zero,8007314 <_malloc_r+0x214>
 8007304:	e0bffa17 	ldw	r2,-24(fp)
 8007308:	1004d3fa 	srli	r2,r2,15
 800730c:	10801dc4 	addi	r2,r2,119
 8007310:	00000906 	br	8007338 <_malloc_r+0x238>
 8007314:	e0bffa17 	ldw	r2,-24(fp)
 8007318:	1004d27a 	srli	r2,r2,9
 800731c:	10815568 	cmpgeui	r2,r2,1365
 8007320:	1000041e 	bne	r2,zero,8007334 <_malloc_r+0x234>
 8007324:	e0bffa17 	ldw	r2,-24(fp)
 8007328:	1004d4ba 	srli	r2,r2,18
 800732c:	10801f04 	addi	r2,r2,124
 8007330:	00000106 	br	8007338 <_malloc_r+0x238>
 8007334:	00801f84 	movi	r2,126
 8007338:	e0bff215 	stw	r2,-56(fp)
    bin = bin_at(idx);
 800733c:	e0bff217 	ldw	r2,-56(fp)
 8007340:	10800044 	addi	r2,r2,1
 8007344:	1085883a 	add	r2,r2,r2
 8007348:	1085883a 	add	r2,r2,r2
 800734c:	1087883a 	add	r3,r2,r2
 8007350:	00820134 	movhi	r2,2052
 8007354:	109aa204 	addi	r2,r2,27272
 8007358:	1885883a 	add	r2,r3,r2
 800735c:	10bffe04 	addi	r2,r2,-8
 8007360:	e0bff315 	stw	r2,-52(fp)

    for (victim = last(bin); victim != bin; victim = victim->bk)
 8007364:	e0bff317 	ldw	r2,-52(fp)
 8007368:	10800317 	ldw	r2,12(r2)
 800736c:	e0bff115 	stw	r2,-60(fp)
 8007370:	00002f06 	br	8007430 <_malloc_r+0x330>
    {
      victim_size = chunksize(victim);
 8007374:	e0bff117 	ldw	r2,-60(fp)
 8007378:	10c00117 	ldw	r3,4(r2)
 800737c:	00bfff04 	movi	r2,-4
 8007380:	1884703a 	and	r2,r3,r2
 8007384:	e0bffb15 	stw	r2,-20(fp)
      remainder_size = long_sub_size_t(victim_size, nb);
 8007388:	e0fffb17 	ldw	r3,-20(fp)
 800738c:	e0bffa17 	ldw	r2,-24(fp)
 8007390:	1885c83a 	sub	r2,r3,r2
 8007394:	e0bff415 	stw	r2,-48(fp)
      
      if (remainder_size >= (long)MINSIZE) /* too big */
 8007398:	e0bff417 	ldw	r2,-48(fp)
 800739c:	10800410 	cmplti	r2,r2,16
 80073a0:	1000041e 	bne	r2,zero,80073b4 <_malloc_r+0x2b4>
      {
        --idx; /* adjust to rescan below after checking last remainder */
 80073a4:	e0bff217 	ldw	r2,-56(fp)
 80073a8:	10bfffc4 	addi	r2,r2,-1
 80073ac:	e0bff215 	stw	r2,-56(fp)
        break;   
 80073b0:	00002206 	br	800743c <_malloc_r+0x33c>
      }

      else if (remainder_size >= 0) /* exact fit */
 80073b4:	e0bff417 	ldw	r2,-48(fp)
 80073b8:	10001a16 	blt	r2,zero,8007424 <_malloc_r+0x324>
      {
        unlink(victim, bck, fwd);
 80073bc:	e0bff117 	ldw	r2,-60(fp)
 80073c0:	10800317 	ldw	r2,12(r2)
 80073c4:	e0bff815 	stw	r2,-32(fp)
 80073c8:	e0bff117 	ldw	r2,-60(fp)
 80073cc:	10800217 	ldw	r2,8(r2)
 80073d0:	e0bff715 	stw	r2,-36(fp)
 80073d4:	e0bff717 	ldw	r2,-36(fp)
 80073d8:	e0fff817 	ldw	r3,-32(fp)
 80073dc:	10c00315 	stw	r3,12(r2)
 80073e0:	e0bff817 	ldw	r2,-32(fp)
 80073e4:	e0fff717 	ldw	r3,-36(fp)
 80073e8:	10c00215 	stw	r3,8(r2)
        set_inuse_bit_at_offset(victim, victim_size);
 80073ec:	e0fff117 	ldw	r3,-60(fp)
 80073f0:	e0bffb17 	ldw	r2,-20(fp)
 80073f4:	1885883a 	add	r2,r3,r2
 80073f8:	e13ff117 	ldw	r4,-60(fp)
 80073fc:	e0fffb17 	ldw	r3,-20(fp)
 8007400:	20c7883a 	add	r3,r4,r3
 8007404:	18c00117 	ldw	r3,4(r3)
 8007408:	18c00054 	ori	r3,r3,1
 800740c:	10c00115 	stw	r3,4(r2)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
 8007410:	e13ffe17 	ldw	r4,-8(fp)
 8007414:	800aa880 	call	800aa88 <__malloc_unlock>
        return chunk2mem(victim);
 8007418:	e0bff117 	ldw	r2,-60(fp)
 800741c:	10800204 	addi	r2,r2,8
 8007420:	00021106 	br	8007c68 <_malloc_r+0xb68>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
 8007424:	e0bff117 	ldw	r2,-60(fp)
 8007428:	10800317 	ldw	r2,12(r2)
 800742c:	e0bff115 	stw	r2,-60(fp)
 8007430:	e0fff117 	ldw	r3,-60(fp)
 8007434:	e0bff317 	ldw	r2,-52(fp)
 8007438:	18bfce1e 	bne	r3,r2,8007374 <_malloc_r+0x274>
	MALLOC_UNLOCK;
        return chunk2mem(victim);
      }
    }

    ++idx; 
 800743c:	e0bff217 	ldw	r2,-56(fp)
 8007440:	10800044 	addi	r2,r2,1
 8007444:	e0bff215 	stw	r2,-56(fp)

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
 8007448:	00820134 	movhi	r2,2052
 800744c:	109aa404 	addi	r2,r2,27280
 8007450:	10800217 	ldw	r2,8(r2)
 8007454:	e0bff115 	stw	r2,-60(fp)
 8007458:	00820134 	movhi	r2,2052
 800745c:	109aa404 	addi	r2,r2,27280
 8007460:	e0fff117 	ldw	r3,-60(fp)
 8007464:	1880e626 	beq	r3,r2,8007800 <_malloc_r+0x700>
  {
    victim_size = chunksize(victim);
 8007468:	e0bff117 	ldw	r2,-60(fp)
 800746c:	10c00117 	ldw	r3,4(r2)
 8007470:	00bfff04 	movi	r2,-4
 8007474:	1884703a 	and	r2,r3,r2
 8007478:	e0bffb15 	stw	r2,-20(fp)
    remainder_size = long_sub_size_t(victim_size, nb);
 800747c:	e0fffb17 	ldw	r3,-20(fp)
 8007480:	e0bffa17 	ldw	r2,-24(fp)
 8007484:	1885c83a 	sub	r2,r3,r2
 8007488:	e0bff415 	stw	r2,-48(fp)

    if (remainder_size >= (long)MINSIZE) /* re-split */
 800748c:	e0bff417 	ldw	r2,-48(fp)
 8007490:	10800410 	cmplti	r2,r2,16
 8007494:	1000271e 	bne	r2,zero,8007534 <_malloc_r+0x434>
    {
      remainder = chunk_at_offset(victim, nb);
 8007498:	e0fff117 	ldw	r3,-60(fp)
 800749c:	e0bffa17 	ldw	r2,-24(fp)
 80074a0:	1885883a 	add	r2,r3,r2
 80074a4:	e0bffc15 	stw	r2,-16(fp)
      set_head(victim, nb | PREV_INUSE);
 80074a8:	e0bffa17 	ldw	r2,-24(fp)
 80074ac:	10c00054 	ori	r3,r2,1
 80074b0:	e0bff117 	ldw	r2,-60(fp)
 80074b4:	10c00115 	stw	r3,4(r2)
      link_last_remainder(remainder);
 80074b8:	00c20134 	movhi	r3,2052
 80074bc:	18daa404 	addi	r3,r3,27280
 80074c0:	00820134 	movhi	r2,2052
 80074c4:	109aa404 	addi	r2,r2,27280
 80074c8:	e13ffc17 	ldw	r4,-16(fp)
 80074cc:	11000315 	stw	r4,12(r2)
 80074d0:	10800317 	ldw	r2,12(r2)
 80074d4:	18800215 	stw	r2,8(r3)
 80074d8:	00820134 	movhi	r2,2052
 80074dc:	109aa404 	addi	r2,r2,27280
 80074e0:	e0fffc17 	ldw	r3,-16(fp)
 80074e4:	18800315 	stw	r2,12(r3)
 80074e8:	e0bffc17 	ldw	r2,-16(fp)
 80074ec:	10c00317 	ldw	r3,12(r2)
 80074f0:	e0bffc17 	ldw	r2,-16(fp)
 80074f4:	10c00215 	stw	r3,8(r2)
      set_head(remainder, remainder_size | PREV_INUSE);
 80074f8:	e0bff417 	ldw	r2,-48(fp)
 80074fc:	10800054 	ori	r2,r2,1
 8007500:	1007883a 	mov	r3,r2
 8007504:	e0bffc17 	ldw	r2,-16(fp)
 8007508:	10c00115 	stw	r3,4(r2)
      set_foot(remainder, remainder_size);
 800750c:	e0bff417 	ldw	r2,-48(fp)
 8007510:	e0fffc17 	ldw	r3,-16(fp)
 8007514:	1885883a 	add	r2,r3,r2
 8007518:	e0fff417 	ldw	r3,-48(fp)
 800751c:	10c00015 	stw	r3,0(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 8007520:	e13ffe17 	ldw	r4,-8(fp)
 8007524:	800aa880 	call	800aa88 <__malloc_unlock>
      return chunk2mem(victim);
 8007528:	e0bff117 	ldw	r2,-60(fp)
 800752c:	10800204 	addi	r2,r2,8
 8007530:	0001cd06 	br	8007c68 <_malloc_r+0xb68>
    }

    clear_last_remainder;
 8007534:	00c20134 	movhi	r3,2052
 8007538:	18daa404 	addi	r3,r3,27280
 800753c:	00820134 	movhi	r2,2052
 8007540:	109aa404 	addi	r2,r2,27280
 8007544:	01020134 	movhi	r4,2052
 8007548:	211aa404 	addi	r4,r4,27280
 800754c:	11000315 	stw	r4,12(r2)
 8007550:	10800317 	ldw	r2,12(r2)
 8007554:	18800215 	stw	r2,8(r3)

    if (remainder_size >= 0)  /* exhaust */
 8007558:	e0bff417 	ldw	r2,-48(fp)
 800755c:	10000e16 	blt	r2,zero,8007598 <_malloc_r+0x498>
    {
      set_inuse_bit_at_offset(victim, victim_size);
 8007560:	e0fff117 	ldw	r3,-60(fp)
 8007564:	e0bffb17 	ldw	r2,-20(fp)
 8007568:	1885883a 	add	r2,r3,r2
 800756c:	e13ff117 	ldw	r4,-60(fp)
 8007570:	e0fffb17 	ldw	r3,-20(fp)
 8007574:	20c7883a 	add	r3,r4,r3
 8007578:	18c00117 	ldw	r3,4(r3)
 800757c:	18c00054 	ori	r3,r3,1
 8007580:	10c00115 	stw	r3,4(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 8007584:	e13ffe17 	ldw	r4,-8(fp)
 8007588:	800aa880 	call	800aa88 <__malloc_unlock>
      return chunk2mem(victim);
 800758c:	e0bff117 	ldw	r2,-60(fp)
 8007590:	10800204 	addi	r2,r2,8
 8007594:	0001b406 	br	8007c68 <_malloc_r+0xb68>
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
 8007598:	e0bffb17 	ldw	r2,-20(fp)
 800759c:	10808028 	cmpgeui	r2,r2,512
 80075a0:	10002c1e 	bne	r2,zero,8007654 <_malloc_r+0x554>
 80075a4:	e0bffb17 	ldw	r2,-20(fp)
 80075a8:	1004d0fa 	srli	r2,r2,3
 80075ac:	e0bffd15 	stw	r2,-12(fp)
 80075b0:	00c20134 	movhi	r3,2052
 80075b4:	18daa204 	addi	r3,r3,27272
 80075b8:	00820134 	movhi	r2,2052
 80075bc:	109aa204 	addi	r2,r2,27272
 80075c0:	11000117 	ldw	r4,4(r2)
 80075c4:	e0bffd17 	ldw	r2,-12(fp)
 80075c8:	1000010e 	bge	r2,zero,80075d0 <_malloc_r+0x4d0>
 80075cc:	108000c4 	addi	r2,r2,3
 80075d0:	1005d0ba 	srai	r2,r2,2
 80075d4:	100b883a 	mov	r5,r2
 80075d8:	00800044 	movi	r2,1
 80075dc:	1144983a 	sll	r2,r2,r5
 80075e0:	2084b03a 	or	r2,r4,r2
 80075e4:	18800115 	stw	r2,4(r3)
 80075e8:	e0bffd17 	ldw	r2,-12(fp)
 80075ec:	10800044 	addi	r2,r2,1
 80075f0:	1085883a 	add	r2,r2,r2
 80075f4:	1085883a 	add	r2,r2,r2
 80075f8:	1087883a 	add	r3,r2,r2
 80075fc:	00820134 	movhi	r2,2052
 8007600:	109aa204 	addi	r2,r2,27272
 8007604:	1885883a 	add	r2,r3,r2
 8007608:	10bffe04 	addi	r2,r2,-8
 800760c:	e0bff815 	stw	r2,-32(fp)
 8007610:	e0bff817 	ldw	r2,-32(fp)
 8007614:	10800217 	ldw	r2,8(r2)
 8007618:	e0bff715 	stw	r2,-36(fp)
 800761c:	e0bff117 	ldw	r2,-60(fp)
 8007620:	e0fff817 	ldw	r3,-32(fp)
 8007624:	10c00315 	stw	r3,12(r2)
 8007628:	e0bff117 	ldw	r2,-60(fp)
 800762c:	e0fff717 	ldw	r3,-36(fp)
 8007630:	10c00215 	stw	r3,8(r2)
 8007634:	e0bff817 	ldw	r2,-32(fp)
 8007638:	e0fff117 	ldw	r3,-60(fp)
 800763c:	10c00215 	stw	r3,8(r2)
 8007640:	e0bff817 	ldw	r2,-32(fp)
 8007644:	10c00217 	ldw	r3,8(r2)
 8007648:	e0bff717 	ldw	r2,-36(fp)
 800764c:	10c00315 	stw	r3,12(r2)
 8007650:	00006b06 	br	8007800 <_malloc_r+0x700>
 8007654:	e0bffb17 	ldw	r2,-20(fp)
 8007658:	1004d27a 	srli	r2,r2,9
 800765c:	1000031e 	bne	r2,zero,800766c <_malloc_r+0x56c>
 8007660:	e0bffb17 	ldw	r2,-20(fp)
 8007664:	1004d0fa 	srli	r2,r2,3
 8007668:	00002906 	br	8007710 <_malloc_r+0x610>
 800766c:	e0bffb17 	ldw	r2,-20(fp)
 8007670:	1004d27a 	srli	r2,r2,9
 8007674:	10800168 	cmpgeui	r2,r2,5
 8007678:	1000041e 	bne	r2,zero,800768c <_malloc_r+0x58c>
 800767c:	e0bffb17 	ldw	r2,-20(fp)
 8007680:	1004d1ba 	srli	r2,r2,6
 8007684:	10800e04 	addi	r2,r2,56
 8007688:	00002106 	br	8007710 <_malloc_r+0x610>
 800768c:	e0bffb17 	ldw	r2,-20(fp)
 8007690:	1004d27a 	srli	r2,r2,9
 8007694:	10800568 	cmpgeui	r2,r2,21
 8007698:	1000041e 	bne	r2,zero,80076ac <_malloc_r+0x5ac>
 800769c:	e0bffb17 	ldw	r2,-20(fp)
 80076a0:	1004d27a 	srli	r2,r2,9
 80076a4:	108016c4 	addi	r2,r2,91
 80076a8:	00001906 	br	8007710 <_malloc_r+0x610>
 80076ac:	e0bffb17 	ldw	r2,-20(fp)
 80076b0:	1004d27a 	srli	r2,r2,9
 80076b4:	10801568 	cmpgeui	r2,r2,85
 80076b8:	1000041e 	bne	r2,zero,80076cc <_malloc_r+0x5cc>
 80076bc:	e0bffb17 	ldw	r2,-20(fp)
 80076c0:	1004d33a 	srli	r2,r2,12
 80076c4:	10801b84 	addi	r2,r2,110
 80076c8:	00001106 	br	8007710 <_malloc_r+0x610>
 80076cc:	e0bffb17 	ldw	r2,-20(fp)
 80076d0:	1004d27a 	srli	r2,r2,9
 80076d4:	10805568 	cmpgeui	r2,r2,341
 80076d8:	1000041e 	bne	r2,zero,80076ec <_malloc_r+0x5ec>
 80076dc:	e0bffb17 	ldw	r2,-20(fp)
 80076e0:	1004d3fa 	srli	r2,r2,15
 80076e4:	10801dc4 	addi	r2,r2,119
 80076e8:	00000906 	br	8007710 <_malloc_r+0x610>
 80076ec:	e0bffb17 	ldw	r2,-20(fp)
 80076f0:	1004d27a 	srli	r2,r2,9
 80076f4:	10815568 	cmpgeui	r2,r2,1365
 80076f8:	1000041e 	bne	r2,zero,800770c <_malloc_r+0x60c>
 80076fc:	e0bffb17 	ldw	r2,-20(fp)
 8007700:	1004d4ba 	srli	r2,r2,18
 8007704:	10801f04 	addi	r2,r2,124
 8007708:	00000106 	br	8007710 <_malloc_r+0x610>
 800770c:	00801f84 	movi	r2,126
 8007710:	e0bffd15 	stw	r2,-12(fp)
 8007714:	e0bffd17 	ldw	r2,-12(fp)
 8007718:	10800044 	addi	r2,r2,1
 800771c:	1085883a 	add	r2,r2,r2
 8007720:	1085883a 	add	r2,r2,r2
 8007724:	1087883a 	add	r3,r2,r2
 8007728:	00820134 	movhi	r2,2052
 800772c:	109aa204 	addi	r2,r2,27272
 8007730:	1885883a 	add	r2,r3,r2
 8007734:	10bffe04 	addi	r2,r2,-8
 8007738:	e0bff815 	stw	r2,-32(fp)
 800773c:	e0bff817 	ldw	r2,-32(fp)
 8007740:	10800217 	ldw	r2,8(r2)
 8007744:	e0bff715 	stw	r2,-36(fp)
 8007748:	e0fff717 	ldw	r3,-36(fp)
 800774c:	e0bff817 	ldw	r2,-32(fp)
 8007750:	1880121e 	bne	r3,r2,800779c <_malloc_r+0x69c>
 8007754:	00c20134 	movhi	r3,2052
 8007758:	18daa204 	addi	r3,r3,27272
 800775c:	00820134 	movhi	r2,2052
 8007760:	109aa204 	addi	r2,r2,27272
 8007764:	11000117 	ldw	r4,4(r2)
 8007768:	e0bffd17 	ldw	r2,-12(fp)
 800776c:	1000010e 	bge	r2,zero,8007774 <_malloc_r+0x674>
 8007770:	108000c4 	addi	r2,r2,3
 8007774:	1005d0ba 	srai	r2,r2,2
 8007778:	100b883a 	mov	r5,r2
 800777c:	00800044 	movi	r2,1
 8007780:	1144983a 	sll	r2,r2,r5
 8007784:	2084b03a 	or	r2,r4,r2
 8007788:	18800115 	stw	r2,4(r3)
 800778c:	00000f06 	br	80077cc <_malloc_r+0x6cc>
 8007790:	e0bff717 	ldw	r2,-36(fp)
 8007794:	10800217 	ldw	r2,8(r2)
 8007798:	e0bff715 	stw	r2,-36(fp)
 800779c:	e0fff717 	ldw	r3,-36(fp)
 80077a0:	e0bff817 	ldw	r2,-32(fp)
 80077a4:	18800626 	beq	r3,r2,80077c0 <_malloc_r+0x6c0>
 80077a8:	e0bff717 	ldw	r2,-36(fp)
 80077ac:	10c00117 	ldw	r3,4(r2)
 80077b0:	00bfff04 	movi	r2,-4
 80077b4:	1884703a 	and	r2,r3,r2
 80077b8:	e0fffb17 	ldw	r3,-20(fp)
 80077bc:	18bff436 	bltu	r3,r2,8007790 <_malloc_r+0x690>
 80077c0:	e0bff717 	ldw	r2,-36(fp)
 80077c4:	10800317 	ldw	r2,12(r2)
 80077c8:	e0bff815 	stw	r2,-32(fp)
 80077cc:	e0bff117 	ldw	r2,-60(fp)
 80077d0:	e0fff817 	ldw	r3,-32(fp)
 80077d4:	10c00315 	stw	r3,12(r2)
 80077d8:	e0bff117 	ldw	r2,-60(fp)
 80077dc:	e0fff717 	ldw	r3,-36(fp)
 80077e0:	10c00215 	stw	r3,8(r2)
 80077e4:	e0bff817 	ldw	r2,-32(fp)
 80077e8:	e0fff117 	ldw	r3,-60(fp)
 80077ec:	10c00215 	stw	r3,8(r2)
 80077f0:	e0bff817 	ldw	r2,-32(fp)
 80077f4:	10c00217 	ldw	r3,8(r2)
 80077f8:	e0bff717 	ldw	r2,-36(fp)
 80077fc:	10c00315 	stw	r3,12(r2)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
 8007800:	e0bff217 	ldw	r2,-56(fp)
 8007804:	1000010e 	bge	r2,zero,800780c <_malloc_r+0x70c>
 8007808:	108000c4 	addi	r2,r2,3
 800780c:	1005d0ba 	srai	r2,r2,2
 8007810:	1007883a 	mov	r3,r2
 8007814:	00800044 	movi	r2,1
 8007818:	10c4983a 	sll	r2,r2,r3
 800781c:	e0bff515 	stw	r2,-44(fp)
 8007820:	00820134 	movhi	r2,2052
 8007824:	109aa204 	addi	r2,r2,27272
 8007828:	10c00117 	ldw	r3,4(r2)
 800782c:	e0bff517 	ldw	r2,-44(fp)
 8007830:	1880c636 	bltu	r3,r2,8007b4c <_malloc_r+0xa4c>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
 8007834:	00820134 	movhi	r2,2052
 8007838:	109aa204 	addi	r2,r2,27272
 800783c:	10c00117 	ldw	r3,4(r2)
 8007840:	e0bff517 	ldw	r2,-44(fp)
 8007844:	1884703a 	and	r2,r3,r2
 8007848:	1000151e 	bne	r2,zero,80078a0 <_malloc_r+0x7a0>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
 800784c:	e0fff217 	ldw	r3,-56(fp)
 8007850:	00bfff04 	movi	r2,-4
 8007854:	1884703a 	and	r2,r3,r2
 8007858:	10800104 	addi	r2,r2,4
 800785c:	e0bff215 	stw	r2,-56(fp)
      block <<= 1;
 8007860:	e0bff517 	ldw	r2,-44(fp)
 8007864:	1085883a 	add	r2,r2,r2
 8007868:	e0bff515 	stw	r2,-44(fp)
      while ((block & binblocks) == 0)
 800786c:	00000606 	br	8007888 <_malloc_r+0x788>
      {
        idx += BINBLOCKWIDTH;
 8007870:	e0bff217 	ldw	r2,-56(fp)
 8007874:	10800104 	addi	r2,r2,4
 8007878:	e0bff215 	stw	r2,-56(fp)
        block <<= 1;
 800787c:	e0bff517 	ldw	r2,-44(fp)
 8007880:	1085883a 	add	r2,r2,r2
 8007884:	e0bff515 	stw	r2,-44(fp)
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
 8007888:	00820134 	movhi	r2,2052
 800788c:	109aa204 	addi	r2,r2,27272
 8007890:	10c00117 	ldw	r3,4(r2)
 8007894:	e0bff517 	ldw	r2,-44(fp)
 8007898:	1884703a 	and	r2,r3,r2
 800789c:	103ff426 	beq	r2,zero,8007870 <_malloc_r+0x770>
    }
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
 80078a0:	e0bff217 	ldw	r2,-56(fp)
 80078a4:	e0bff615 	stw	r2,-40(fp)
      q = bin = bin_at(idx);
 80078a8:	e0bff217 	ldw	r2,-56(fp)
 80078ac:	10800044 	addi	r2,r2,1
 80078b0:	1085883a 	add	r2,r2,r2
 80078b4:	1085883a 	add	r2,r2,r2
 80078b8:	1087883a 	add	r3,r2,r2
 80078bc:	00820134 	movhi	r2,2052
 80078c0:	109aa204 	addi	r2,r2,27272
 80078c4:	1885883a 	add	r2,r3,r2
 80078c8:	10bffe04 	addi	r2,r2,-8
 80078cc:	e0bff315 	stw	r2,-52(fp)
 80078d0:	e0bff317 	ldw	r2,-52(fp)
 80078d4:	e0bff915 	stw	r2,-28(fp)
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
 80078d8:	e0bff317 	ldw	r2,-52(fp)
 80078dc:	10800317 	ldw	r2,12(r2)
 80078e0:	e0bff115 	stw	r2,-60(fp)
 80078e4:	00005e06 	br	8007a60 <_malloc_r+0x960>
        {
          victim_size = chunksize(victim);
 80078e8:	e0bff117 	ldw	r2,-60(fp)
 80078ec:	10c00117 	ldw	r3,4(r2)
 80078f0:	00bfff04 	movi	r2,-4
 80078f4:	1884703a 	and	r2,r3,r2
 80078f8:	e0bffb15 	stw	r2,-20(fp)
          remainder_size = long_sub_size_t(victim_size, nb);
 80078fc:	e0fffb17 	ldw	r3,-20(fp)
 8007900:	e0bffa17 	ldw	r2,-24(fp)
 8007904:	1885c83a 	sub	r2,r3,r2
 8007908:	e0bff415 	stw	r2,-48(fp)

          if (remainder_size >= (long)MINSIZE) /* split */
 800790c:	e0bff417 	ldw	r2,-48(fp)
 8007910:	10800410 	cmplti	r2,r2,16
 8007914:	1000331e 	bne	r2,zero,80079e4 <_malloc_r+0x8e4>
          {
            remainder = chunk_at_offset(victim, nb);
 8007918:	e0fff117 	ldw	r3,-60(fp)
 800791c:	e0bffa17 	ldw	r2,-24(fp)
 8007920:	1885883a 	add	r2,r3,r2
 8007924:	e0bffc15 	stw	r2,-16(fp)
            set_head(victim, nb | PREV_INUSE);
 8007928:	e0bffa17 	ldw	r2,-24(fp)
 800792c:	10c00054 	ori	r3,r2,1
 8007930:	e0bff117 	ldw	r2,-60(fp)
 8007934:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 8007938:	e0bff117 	ldw	r2,-60(fp)
 800793c:	10800317 	ldw	r2,12(r2)
 8007940:	e0bff815 	stw	r2,-32(fp)
 8007944:	e0bff117 	ldw	r2,-60(fp)
 8007948:	10800217 	ldw	r2,8(r2)
 800794c:	e0bff715 	stw	r2,-36(fp)
 8007950:	e0bff717 	ldw	r2,-36(fp)
 8007954:	e0fff817 	ldw	r3,-32(fp)
 8007958:	10c00315 	stw	r3,12(r2)
 800795c:	e0bff817 	ldw	r2,-32(fp)
 8007960:	e0fff717 	ldw	r3,-36(fp)
 8007964:	10c00215 	stw	r3,8(r2)
            link_last_remainder(remainder);
 8007968:	00c20134 	movhi	r3,2052
 800796c:	18daa404 	addi	r3,r3,27280
 8007970:	00820134 	movhi	r2,2052
 8007974:	109aa404 	addi	r2,r2,27280
 8007978:	e13ffc17 	ldw	r4,-16(fp)
 800797c:	11000315 	stw	r4,12(r2)
 8007980:	10800317 	ldw	r2,12(r2)
 8007984:	18800215 	stw	r2,8(r3)
 8007988:	00820134 	movhi	r2,2052
 800798c:	109aa404 	addi	r2,r2,27280
 8007990:	e0fffc17 	ldw	r3,-16(fp)
 8007994:	18800315 	stw	r2,12(r3)
 8007998:	e0bffc17 	ldw	r2,-16(fp)
 800799c:	10c00317 	ldw	r3,12(r2)
 80079a0:	e0bffc17 	ldw	r2,-16(fp)
 80079a4:	10c00215 	stw	r3,8(r2)
            set_head(remainder, remainder_size | PREV_INUSE);
 80079a8:	e0bff417 	ldw	r2,-48(fp)
 80079ac:	10800054 	ori	r2,r2,1
 80079b0:	1007883a 	mov	r3,r2
 80079b4:	e0bffc17 	ldw	r2,-16(fp)
 80079b8:	10c00115 	stw	r3,4(r2)
            set_foot(remainder, remainder_size);
 80079bc:	e0bff417 	ldw	r2,-48(fp)
 80079c0:	e0fffc17 	ldw	r3,-16(fp)
 80079c4:	1885883a 	add	r2,r3,r2
 80079c8:	e0fff417 	ldw	r3,-48(fp)
 80079cc:	10c00015 	stw	r3,0(r2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
 80079d0:	e13ffe17 	ldw	r4,-8(fp)
 80079d4:	800aa880 	call	800aa88 <__malloc_unlock>
            return chunk2mem(victim);
 80079d8:	e0bff117 	ldw	r2,-60(fp)
 80079dc:	10800204 	addi	r2,r2,8
 80079e0:	0000a106 	br	8007c68 <_malloc_r+0xb68>
          }

          else if (remainder_size >= 0)  /* take */
 80079e4:	e0bff417 	ldw	r2,-48(fp)
 80079e8:	10001a16 	blt	r2,zero,8007a54 <_malloc_r+0x954>
          {
            set_inuse_bit_at_offset(victim, victim_size);
 80079ec:	e0fff117 	ldw	r3,-60(fp)
 80079f0:	e0bffb17 	ldw	r2,-20(fp)
 80079f4:	1885883a 	add	r2,r3,r2
 80079f8:	e13ff117 	ldw	r4,-60(fp)
 80079fc:	e0fffb17 	ldw	r3,-20(fp)
 8007a00:	20c7883a 	add	r3,r4,r3
 8007a04:	18c00117 	ldw	r3,4(r3)
 8007a08:	18c00054 	ori	r3,r3,1
 8007a0c:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 8007a10:	e0bff117 	ldw	r2,-60(fp)
 8007a14:	10800317 	ldw	r2,12(r2)
 8007a18:	e0bff815 	stw	r2,-32(fp)
 8007a1c:	e0bff117 	ldw	r2,-60(fp)
 8007a20:	10800217 	ldw	r2,8(r2)
 8007a24:	e0bff715 	stw	r2,-36(fp)
 8007a28:	e0bff717 	ldw	r2,-36(fp)
 8007a2c:	e0fff817 	ldw	r3,-32(fp)
 8007a30:	10c00315 	stw	r3,12(r2)
 8007a34:	e0bff817 	ldw	r2,-32(fp)
 8007a38:	e0fff717 	ldw	r3,-36(fp)
 8007a3c:	10c00215 	stw	r3,8(r2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
 8007a40:	e13ffe17 	ldw	r4,-8(fp)
 8007a44:	800aa880 	call	800aa88 <__malloc_unlock>
            return chunk2mem(victim);
 8007a48:	e0bff117 	ldw	r2,-60(fp)
 8007a4c:	10800204 	addi	r2,r2,8
 8007a50:	00008506 	br	8007c68 <_malloc_r+0xb68>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
 8007a54:	e0bff117 	ldw	r2,-60(fp)
 8007a58:	10800317 	ldw	r2,12(r2)
 8007a5c:	e0bff115 	stw	r2,-60(fp)
 8007a60:	e0fff117 	ldw	r3,-60(fp)
 8007a64:	e0bff317 	ldw	r2,-52(fp)
 8007a68:	18bf9f1e 	bne	r3,r2,80078e8 <_malloc_r+0x7e8>
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
 8007a6c:	e0bff317 	ldw	r2,-52(fp)
 8007a70:	10800204 	addi	r2,r2,8
 8007a74:	e0bff315 	stw	r2,-52(fp)
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
 8007a78:	e0bff217 	ldw	r2,-56(fp)
 8007a7c:	10800044 	addi	r2,r2,1
 8007a80:	e0bff215 	stw	r2,-56(fp)
 8007a84:	e0bff217 	ldw	r2,-56(fp)
 8007a88:	108000cc 	andi	r2,r2,3
 8007a8c:	103f921e 	bne	r2,zero,80078d8 <_malloc_r+0x7d8>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
 8007a90:	e0bff617 	ldw	r2,-40(fp)
 8007a94:	108000cc 	andi	r2,r2,3
 8007a98:	10000a1e 	bne	r2,zero,8007ac4 <_malloc_r+0x9c4>
        {
          binblocks &= ~block;
 8007a9c:	00820134 	movhi	r2,2052
 8007aa0:	109aa204 	addi	r2,r2,27272
 8007aa4:	00c20134 	movhi	r3,2052
 8007aa8:	18daa204 	addi	r3,r3,27272
 8007aac:	19000117 	ldw	r4,4(r3)
 8007ab0:	e0fff517 	ldw	r3,-44(fp)
 8007ab4:	00c6303a 	nor	r3,zero,r3
 8007ab8:	20c6703a 	and	r3,r4,r3
 8007abc:	10c00115 	stw	r3,4(r2)
          break;
 8007ac0:	00000a06 	br	8007aec <_malloc_r+0x9ec>
        }
        --startidx;
 8007ac4:	e0bff617 	ldw	r2,-40(fp)
 8007ac8:	10bfffc4 	addi	r2,r2,-1
 8007acc:	e0bff615 	stw	r2,-40(fp)
       q = prev_bin(q);
 8007ad0:	e0bff917 	ldw	r2,-28(fp)
 8007ad4:	10bffe04 	addi	r2,r2,-8
 8007ad8:	e0bff915 	stw	r2,-28(fp)
      } while (first(q) == q);
 8007adc:	e0bff917 	ldw	r2,-28(fp)
 8007ae0:	10c00217 	ldw	r3,8(r2)
 8007ae4:	e0bff917 	ldw	r2,-28(fp)
 8007ae8:	18bfe926 	beq	r3,r2,8007a90 <_malloc_r+0x990>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
 8007aec:	e0bff517 	ldw	r2,-44(fp)
 8007af0:	1085883a 	add	r2,r2,r2
 8007af4:	e0bff515 	stw	r2,-44(fp)
 8007af8:	00820134 	movhi	r2,2052
 8007afc:	109aa204 	addi	r2,r2,27272
 8007b00:	10c00117 	ldw	r3,4(r2)
 8007b04:	e0bff517 	ldw	r2,-44(fp)
 8007b08:	18801036 	bltu	r3,r2,8007b4c <_malloc_r+0xa4c>
 8007b0c:	e0bff517 	ldw	r2,-44(fp)
 8007b10:	10000e26 	beq	r2,zero,8007b4c <_malloc_r+0xa4c>
      {
        while ((block & binblocks) == 0)
 8007b14:	00000606 	br	8007b30 <_malloc_r+0xa30>
        {
          idx += BINBLOCKWIDTH;
 8007b18:	e0bff217 	ldw	r2,-56(fp)
 8007b1c:	10800104 	addi	r2,r2,4
 8007b20:	e0bff215 	stw	r2,-56(fp)
          block <<= 1;
 8007b24:	e0bff517 	ldw	r2,-44(fp)
 8007b28:	1085883a 	add	r2,r2,r2
 8007b2c:	e0bff515 	stw	r2,-44(fp)

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
 8007b30:	00820134 	movhi	r2,2052
 8007b34:	109aa204 	addi	r2,r2,27272
 8007b38:	10c00117 	ldw	r3,4(r2)
 8007b3c:	e0bff517 	ldw	r2,-44(fp)
 8007b40:	1884703a 	and	r2,r3,r2
 8007b44:	103ff426 	beq	r2,zero,8007b18 <_malloc_r+0xa18>
          block <<= 1;
        }
      }
      else
        break;
    }
 8007b48:	003f5506 	br	80078a0 <_malloc_r+0x7a0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
 8007b4c:	00820134 	movhi	r2,2052
 8007b50:	109aa204 	addi	r2,r2,27272
 8007b54:	10800217 	ldw	r2,8(r2)
 8007b58:	10c00117 	ldw	r3,4(r2)
 8007b5c:	00bfff04 	movi	r2,-4
 8007b60:	1886703a 	and	r3,r3,r2
 8007b64:	e0bffa17 	ldw	r2,-24(fp)
 8007b68:	1885c83a 	sub	r2,r3,r2
 8007b6c:	e0bff415 	stw	r2,-48(fp)
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 8007b70:	00820134 	movhi	r2,2052
 8007b74:	109aa204 	addi	r2,r2,27272
 8007b78:	10800217 	ldw	r2,8(r2)
 8007b7c:	10c00117 	ldw	r3,4(r2)
 8007b80:	00bfff04 	movi	r2,-4
 8007b84:	1886703a 	and	r3,r3,r2
 8007b88:	e0bffa17 	ldw	r2,-24(fp)
 8007b8c:	18800336 	bltu	r3,r2,8007b9c <_malloc_r+0xa9c>
 8007b90:	e0bff417 	ldw	r2,-48(fp)
 8007b94:	10800408 	cmpgei	r2,r2,16
 8007b98:	10001b1e 	bne	r2,zero,8007c08 <_malloc_r+0xb08>
      return chunk2mem(victim);
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
 8007b9c:	e17ffa17 	ldw	r5,-24(fp)
 8007ba0:	e13ffe17 	ldw	r4,-8(fp)
 8007ba4:	8006d4c0 	call	8006d4c <malloc_extend_top>
    remainder_size = long_sub_size_t(chunksize(top), nb);
 8007ba8:	00820134 	movhi	r2,2052
 8007bac:	109aa204 	addi	r2,r2,27272
 8007bb0:	10800217 	ldw	r2,8(r2)
 8007bb4:	10c00117 	ldw	r3,4(r2)
 8007bb8:	00bfff04 	movi	r2,-4
 8007bbc:	1886703a 	and	r3,r3,r2
 8007bc0:	e0bffa17 	ldw	r2,-24(fp)
 8007bc4:	1885c83a 	sub	r2,r3,r2
 8007bc8:	e0bff415 	stw	r2,-48(fp)
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 8007bcc:	00820134 	movhi	r2,2052
 8007bd0:	109aa204 	addi	r2,r2,27272
 8007bd4:	10800217 	ldw	r2,8(r2)
 8007bd8:	10c00117 	ldw	r3,4(r2)
 8007bdc:	00bfff04 	movi	r2,-4
 8007be0:	1886703a 	and	r3,r3,r2
 8007be4:	e0bffa17 	ldw	r2,-24(fp)
 8007be8:	18800336 	bltu	r3,r2,8007bf8 <_malloc_r+0xaf8>
 8007bec:	e0bff417 	ldw	r2,-48(fp)
 8007bf0:	10800408 	cmpgei	r2,r2,16
 8007bf4:	1000041e 	bne	r2,zero,8007c08 <_malloc_r+0xb08>
    {
      MALLOC_UNLOCK;
 8007bf8:	e13ffe17 	ldw	r4,-8(fp)
 8007bfc:	800aa880 	call	800aa88 <__malloc_unlock>
      return 0; /* propagate failure */
 8007c00:	0005883a 	mov	r2,zero
 8007c04:	00001806 	br	8007c68 <_malloc_r+0xb68>
    }
  }

  victim = top;
 8007c08:	00820134 	movhi	r2,2052
 8007c0c:	109aa204 	addi	r2,r2,27272
 8007c10:	10800217 	ldw	r2,8(r2)
 8007c14:	e0bff115 	stw	r2,-60(fp)
  set_head(victim, nb | PREV_INUSE);
 8007c18:	e0bffa17 	ldw	r2,-24(fp)
 8007c1c:	10c00054 	ori	r3,r2,1
 8007c20:	e0bff117 	ldw	r2,-60(fp)
 8007c24:	10c00115 	stw	r3,4(r2)
  top = chunk_at_offset(victim, nb);
 8007c28:	00820134 	movhi	r2,2052
 8007c2c:	109aa204 	addi	r2,r2,27272
 8007c30:	e13ff117 	ldw	r4,-60(fp)
 8007c34:	e0fffa17 	ldw	r3,-24(fp)
 8007c38:	20c7883a 	add	r3,r4,r3
 8007c3c:	10c00215 	stw	r3,8(r2)
  set_head(top, remainder_size | PREV_INUSE);
 8007c40:	00820134 	movhi	r2,2052
 8007c44:	109aa204 	addi	r2,r2,27272
 8007c48:	10800217 	ldw	r2,8(r2)
 8007c4c:	e0fff417 	ldw	r3,-48(fp)
 8007c50:	18c00054 	ori	r3,r3,1
 8007c54:	10c00115 	stw	r3,4(r2)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
 8007c58:	e13ffe17 	ldw	r4,-8(fp)
 8007c5c:	800aa880 	call	800aa88 <__malloc_unlock>
  return chunk2mem(victim);
 8007c60:	e0bff117 	ldw	r2,-60(fp)
 8007c64:	10800204 	addi	r2,r2,8

#endif /* MALLOC_PROVIDED */
}
 8007c68:	e037883a 	mov	sp,fp
 8007c6c:	dfc00117 	ldw	ra,4(sp)
 8007c70:	df000017 	ldw	fp,0(sp)
 8007c74:	dec00204 	addi	sp,sp,8
 8007c78:	f800283a 	ret

08007c7c <memchr>:
_PTR
_DEFUN (memchr, (src_void, c, length),
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
 8007c7c:	defff704 	addi	sp,sp,-36
 8007c80:	df000815 	stw	fp,32(sp)
 8007c84:	df000804 	addi	fp,sp,32
 8007c88:	e13ffd15 	stw	r4,-12(fp)
 8007c8c:	e17ffe15 	stw	r5,-8(fp)
 8007c90:	e1bfff15 	stw	r6,-4(fp)
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
 8007c94:	e0bffd17 	ldw	r2,-12(fp)
 8007c98:	e0bff815 	stw	r2,-32(fp)
  unsigned char d = c;
 8007c9c:	e0bffe17 	ldw	r2,-8(fp)
 8007ca0:	e0bffc05 	stb	r2,-16(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 8007ca4:	00001006 	br	8007ce8 <memchr+0x6c>
    {
      if (!length--)
 8007ca8:	e0bfff17 	ldw	r2,-4(fp)
 8007cac:	10ffffc4 	addi	r3,r2,-1
 8007cb0:	e0ffff15 	stw	r3,-4(fp)
 8007cb4:	1000021e 	bne	r2,zero,8007cc0 <memchr+0x44>
        return NULL;
 8007cb8:	0005883a 	mov	r2,zero
 8007cbc:	00005a06 	br	8007e28 <memchr+0x1ac>
      if (*src == d)
 8007cc0:	e0bff817 	ldw	r2,-32(fp)
 8007cc4:	10800003 	ldbu	r2,0(r2)
 8007cc8:	10c03fcc 	andi	r3,r2,255
 8007ccc:	e0bffc03 	ldbu	r2,-16(fp)
 8007cd0:	1880021e 	bne	r3,r2,8007cdc <memchr+0x60>
        return (void *) src;
 8007cd4:	e0bff817 	ldw	r2,-32(fp)
 8007cd8:	00005306 	br	8007e28 <memchr+0x1ac>
      src++;
 8007cdc:	e0bff817 	ldw	r2,-32(fp)
 8007ce0:	10800044 	addi	r2,r2,1
 8007ce4:	e0bff815 	stw	r2,-32(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 8007ce8:	e0bff817 	ldw	r2,-32(fp)
 8007cec:	108000cc 	andi	r2,r2,3
 8007cf0:	103fed1e 	bne	r2,zero,8007ca8 <memchr+0x2c>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
 8007cf4:	e0bfff17 	ldw	r2,-4(fp)
 8007cf8:	10800130 	cmpltui	r2,r2,4
 8007cfc:	1000451e 	bne	r2,zero,8007e14 <memchr+0x198>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
 8007d00:	e0bff817 	ldw	r2,-32(fp)
 8007d04:	e0bff915 	stw	r2,-28(fp)
      mask = d << 8 | d;
 8007d08:	e0bffc03 	ldbu	r2,-16(fp)
 8007d0c:	1006923a 	slli	r3,r2,8
 8007d10:	e0bffc03 	ldbu	r2,-16(fp)
 8007d14:	1884b03a 	or	r2,r3,r2
 8007d18:	e0bffa15 	stw	r2,-24(fp)
      mask = mask << 16 | mask;
 8007d1c:	e0bffa17 	ldw	r2,-24(fp)
 8007d20:	1004943a 	slli	r2,r2,16
 8007d24:	e0fffa17 	ldw	r3,-24(fp)
 8007d28:	1884b03a 	or	r2,r3,r2
 8007d2c:	e0bffa15 	stw	r2,-24(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 8007d30:	00800804 	movi	r2,32
 8007d34:	e0bffb15 	stw	r2,-20(fp)
 8007d38:	00000906 	br	8007d60 <memchr+0xe4>
        mask = (mask << i) | mask;
 8007d3c:	e0fffa17 	ldw	r3,-24(fp)
 8007d40:	e0bffb17 	ldw	r2,-20(fp)
 8007d44:	1884983a 	sll	r2,r3,r2
 8007d48:	e0fffa17 	ldw	r3,-24(fp)
 8007d4c:	1884b03a 	or	r2,r3,r2
 8007d50:	e0bffa15 	stw	r2,-24(fp)
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 8007d54:	e0bffb17 	ldw	r2,-20(fp)
 8007d58:	1085883a 	add	r2,r2,r2
 8007d5c:	e0bffb15 	stw	r2,-20(fp)
 8007d60:	e0bffb17 	ldw	r2,-20(fp)
 8007d64:	10800830 	cmpltui	r2,r2,32
 8007d68:	103ff41e 	bne	r2,zero,8007d3c <memchr+0xc0>
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
 8007d6c:	00001706 	br	8007dcc <memchr+0x150>
        {
          if (DETECTCHAR (*asrc, mask))
 8007d70:	e0bff917 	ldw	r2,-28(fp)
 8007d74:	10c00017 	ldw	r3,0(r2)
 8007d78:	e0bffa17 	ldw	r2,-24(fp)
 8007d7c:	1886f03a 	xor	r3,r3,r2
 8007d80:	00bfbff4 	movhi	r2,65279
 8007d84:	10bfbfc4 	addi	r2,r2,-257
 8007d88:	1887883a 	add	r3,r3,r2
 8007d8c:	e0bff917 	ldw	r2,-28(fp)
 8007d90:	11000017 	ldw	r4,0(r2)
 8007d94:	e0bffa17 	ldw	r2,-24(fp)
 8007d98:	2084f03a 	xor	r2,r4,r2
 8007d9c:	0084303a 	nor	r2,zero,r2
 8007da0:	1886703a 	and	r3,r3,r2
 8007da4:	00a02074 	movhi	r2,32897
 8007da8:	10a02004 	addi	r2,r2,-32640
 8007dac:	1884703a 	and	r2,r3,r2
 8007db0:	10000a1e 	bne	r2,zero,8007ddc <memchr+0x160>
            break;
          length -= LBLOCKSIZE;
 8007db4:	e0bfff17 	ldw	r2,-4(fp)
 8007db8:	10bfff04 	addi	r2,r2,-4
 8007dbc:	e0bfff15 	stw	r2,-4(fp)
          asrc++;
 8007dc0:	e0bff917 	ldw	r2,-28(fp)
 8007dc4:	10800104 	addi	r2,r2,4
 8007dc8:	e0bff915 	stw	r2,-28(fp)
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
 8007dcc:	e0bfff17 	ldw	r2,-4(fp)
 8007dd0:	10800128 	cmpgeui	r2,r2,4
 8007dd4:	103fe61e 	bne	r2,zero,8007d70 <memchr+0xf4>
 8007dd8:	00000106 	br	8007de0 <memchr+0x164>
        {
          if (DETECTCHAR (*asrc, mask))
            break;
 8007ddc:	0001883a 	nop
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
 8007de0:	e0bff917 	ldw	r2,-28(fp)
 8007de4:	e0bff815 	stw	r2,-32(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 8007de8:	00000a06 	br	8007e14 <memchr+0x198>
    {
      if (*src == d)
 8007dec:	e0bff817 	ldw	r2,-32(fp)
 8007df0:	10800003 	ldbu	r2,0(r2)
 8007df4:	10c03fcc 	andi	r3,r2,255
 8007df8:	e0bffc03 	ldbu	r2,-16(fp)
 8007dfc:	1880021e 	bne	r3,r2,8007e08 <memchr+0x18c>
        return (void *) src;
 8007e00:	e0bff817 	ldw	r2,-32(fp)
 8007e04:	00000806 	br	8007e28 <memchr+0x1ac>
      src++;
 8007e08:	e0bff817 	ldw	r2,-32(fp)
 8007e0c:	10800044 	addi	r2,r2,1
 8007e10:	e0bff815 	stw	r2,-32(fp)
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 8007e14:	e0bfff17 	ldw	r2,-4(fp)
 8007e18:	10ffffc4 	addi	r3,r2,-1
 8007e1c:	e0ffff15 	stw	r3,-4(fp)
 8007e20:	103ff21e 	bne	r2,zero,8007dec <memchr+0x170>
      if (*src == d)
        return (void *) src;
      src++;
    }

  return NULL;
 8007e24:	0005883a 	mov	r2,zero
}
 8007e28:	e037883a 	mov	sp,fp
 8007e2c:	df000017 	ldw	fp,0(sp)
 8007e30:	dec00104 	addi	sp,sp,4
 8007e34:	f800283a 	ret

08007e38 <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR __restrict dst0 _AND
	_CONST _PTR __restrict src0 _AND
	size_t len0)
{
 8007e38:	defff804 	addi	sp,sp,-32
 8007e3c:	df000715 	stw	fp,28(sp)
 8007e40:	df000704 	addi	fp,sp,28
 8007e44:	e13ffd15 	stw	r4,-12(fp)
 8007e48:	e17ffe15 	stw	r5,-8(fp)
 8007e4c:	e1bfff15 	stw	r6,-4(fp)
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
 8007e50:	e0bffd17 	ldw	r2,-12(fp)
 8007e54:	e0bff915 	stw	r2,-28(fp)
  _CONST char *src = src0;
 8007e58:	e0bffe17 	ldw	r2,-8(fp)
 8007e5c:	e0bffa15 	stw	r2,-24(fp)
  long *aligned_dst;
  _CONST long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
 8007e60:	e0bfff17 	ldw	r2,-4(fp)
 8007e64:	10800430 	cmpltui	r2,r2,16
 8007e68:	10004c1e 	bne	r2,zero,8007f9c <memcpy+0x164>
 8007e6c:	e0fffa17 	ldw	r3,-24(fp)
 8007e70:	e0bff917 	ldw	r2,-28(fp)
 8007e74:	1884b03a 	or	r2,r3,r2
 8007e78:	108000cc 	andi	r2,r2,3
 8007e7c:	1000471e 	bne	r2,zero,8007f9c <memcpy+0x164>
    {
      aligned_dst = (long*)dst;
 8007e80:	e0bff917 	ldw	r2,-28(fp)
 8007e84:	e0bffb15 	stw	r2,-20(fp)
      aligned_src = (long*)src;
 8007e88:	e0bffa17 	ldw	r2,-24(fp)
 8007e8c:	e0bffc15 	stw	r2,-16(fp)

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 8007e90:	00002306 	br	8007f20 <memcpy+0xe8>
        {
          *aligned_dst++ = *aligned_src++;
 8007e94:	e0bffb17 	ldw	r2,-20(fp)
 8007e98:	10c00104 	addi	r3,r2,4
 8007e9c:	e0fffb15 	stw	r3,-20(fp)
 8007ea0:	e0fffc17 	ldw	r3,-16(fp)
 8007ea4:	19000104 	addi	r4,r3,4
 8007ea8:	e13ffc15 	stw	r4,-16(fp)
 8007eac:	18c00017 	ldw	r3,0(r3)
 8007eb0:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 8007eb4:	e0bffb17 	ldw	r2,-20(fp)
 8007eb8:	10c00104 	addi	r3,r2,4
 8007ebc:	e0fffb15 	stw	r3,-20(fp)
 8007ec0:	e0fffc17 	ldw	r3,-16(fp)
 8007ec4:	19000104 	addi	r4,r3,4
 8007ec8:	e13ffc15 	stw	r4,-16(fp)
 8007ecc:	18c00017 	ldw	r3,0(r3)
 8007ed0:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 8007ed4:	e0bffb17 	ldw	r2,-20(fp)
 8007ed8:	10c00104 	addi	r3,r2,4
 8007edc:	e0fffb15 	stw	r3,-20(fp)
 8007ee0:	e0fffc17 	ldw	r3,-16(fp)
 8007ee4:	19000104 	addi	r4,r3,4
 8007ee8:	e13ffc15 	stw	r4,-16(fp)
 8007eec:	18c00017 	ldw	r3,0(r3)
 8007ef0:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 8007ef4:	e0bffb17 	ldw	r2,-20(fp)
 8007ef8:	10c00104 	addi	r3,r2,4
 8007efc:	e0fffb15 	stw	r3,-20(fp)
 8007f00:	e0fffc17 	ldw	r3,-16(fp)
 8007f04:	19000104 	addi	r4,r3,4
 8007f08:	e13ffc15 	stw	r4,-16(fp)
 8007f0c:	18c00017 	ldw	r3,0(r3)
 8007f10:	10c00015 	stw	r3,0(r2)
          len0 -= BIGBLOCKSIZE;
 8007f14:	e0bfff17 	ldw	r2,-4(fp)
 8007f18:	10bffc04 	addi	r2,r2,-16
 8007f1c:	e0bfff15 	stw	r2,-4(fp)
    {
      aligned_dst = (long*)dst;
      aligned_src = (long*)src;

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 8007f20:	e0bfff17 	ldw	r2,-4(fp)
 8007f24:	10800428 	cmpgeui	r2,r2,16
 8007f28:	103fda1e 	bne	r2,zero,8007e94 <memcpy+0x5c>
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 8007f2c:	00000b06 	br	8007f5c <memcpy+0x124>
        {
          *aligned_dst++ = *aligned_src++;
 8007f30:	e0bffb17 	ldw	r2,-20(fp)
 8007f34:	10c00104 	addi	r3,r2,4
 8007f38:	e0fffb15 	stw	r3,-20(fp)
 8007f3c:	e0fffc17 	ldw	r3,-16(fp)
 8007f40:	19000104 	addi	r4,r3,4
 8007f44:	e13ffc15 	stw	r4,-16(fp)
 8007f48:	18c00017 	ldw	r3,0(r3)
 8007f4c:	10c00015 	stw	r3,0(r2)
          len0 -= LITTLEBLOCKSIZE;
 8007f50:	e0bfff17 	ldw	r2,-4(fp)
 8007f54:	10bfff04 	addi	r2,r2,-4
 8007f58:	e0bfff15 	stw	r2,-4(fp)
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 8007f5c:	e0bfff17 	ldw	r2,-4(fp)
 8007f60:	10800128 	cmpgeui	r2,r2,4
 8007f64:	103ff21e 	bne	r2,zero,8007f30 <memcpy+0xf8>
          *aligned_dst++ = *aligned_src++;
          len0 -= LITTLEBLOCKSIZE;
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
 8007f68:	e0bffb17 	ldw	r2,-20(fp)
 8007f6c:	e0bff915 	stw	r2,-28(fp)
      src = (char*)aligned_src;
 8007f70:	e0bffc17 	ldw	r2,-16(fp)
 8007f74:	e0bffa15 	stw	r2,-24(fp)
    }

  while (len0--)
 8007f78:	00000806 	br	8007f9c <memcpy+0x164>
    *dst++ = *src++;
 8007f7c:	e0bff917 	ldw	r2,-28(fp)
 8007f80:	10c00044 	addi	r3,r2,1
 8007f84:	e0fff915 	stw	r3,-28(fp)
 8007f88:	e0fffa17 	ldw	r3,-24(fp)
 8007f8c:	19000044 	addi	r4,r3,1
 8007f90:	e13ffa15 	stw	r4,-24(fp)
 8007f94:	18c00003 	ldbu	r3,0(r3)
 8007f98:	10c00005 	stb	r3,0(r2)
       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }

  while (len0--)
 8007f9c:	e0bfff17 	ldw	r2,-4(fp)
 8007fa0:	10ffffc4 	addi	r3,r2,-1
 8007fa4:	e0ffff15 	stw	r3,-4(fp)
 8007fa8:	103ff41e 	bne	r2,zero,8007f7c <memcpy+0x144>
    *dst++ = *src++;

  return dst0;
 8007fac:	e0bffd17 	ldw	r2,-12(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 8007fb0:	e037883a 	mov	sp,fp
 8007fb4:	df000017 	ldw	fp,0(sp)
 8007fb8:	dec00104 	addi	sp,sp,4
 8007fbc:	f800283a 	ret

08007fc0 <memmove>:
__inhibit_loop_to_libcall
_DEFUN (memmove, (dst_void, src_void, length),
	_PTR dst_void _AND
	_CONST _PTR src_void _AND
	size_t length)
{
 8007fc0:	defff804 	addi	sp,sp,-32
 8007fc4:	df000715 	stw	fp,28(sp)
 8007fc8:	df000704 	addi	fp,sp,28
 8007fcc:	e13ffd15 	stw	r4,-12(fp)
 8007fd0:	e17ffe15 	stw	r5,-8(fp)
 8007fd4:	e1bfff15 	stw	r6,-4(fp)
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
 8007fd8:	e0bffd17 	ldw	r2,-12(fp)
 8007fdc:	e0bff915 	stw	r2,-28(fp)
  _CONST char *src = src_void;
 8007fe0:	e0bffe17 	ldw	r2,-8(fp)
 8007fe4:	e0bffa15 	stw	r2,-24(fp)
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
 8007fe8:	e0fffa17 	ldw	r3,-24(fp)
 8007fec:	e0bff917 	ldw	r2,-28(fp)
 8007ff0:	18801d2e 	bgeu	r3,r2,8008068 <memmove+0xa8>
 8007ff4:	e0fffa17 	ldw	r3,-24(fp)
 8007ff8:	e0bfff17 	ldw	r2,-4(fp)
 8007ffc:	1885883a 	add	r2,r3,r2
 8008000:	e0fff917 	ldw	r3,-28(fp)
 8008004:	1880182e 	bgeu	r3,r2,8008068 <memmove+0xa8>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
 8008008:	e0fffa17 	ldw	r3,-24(fp)
 800800c:	e0bfff17 	ldw	r2,-4(fp)
 8008010:	1885883a 	add	r2,r3,r2
 8008014:	e0bffa15 	stw	r2,-24(fp)
      dst += length;
 8008018:	e0fff917 	ldw	r3,-28(fp)
 800801c:	e0bfff17 	ldw	r2,-4(fp)
 8008020:	1885883a 	add	r2,r3,r2
 8008024:	e0bff915 	stw	r2,-28(fp)
      while (length--)
 8008028:	00000a06 	br	8008054 <memmove+0x94>
	{
	  *--dst = *--src;
 800802c:	e0bff917 	ldw	r2,-28(fp)
 8008030:	10bfffc4 	addi	r2,r2,-1
 8008034:	e0bff915 	stw	r2,-28(fp)
 8008038:	e0bffa17 	ldw	r2,-24(fp)
 800803c:	10bfffc4 	addi	r2,r2,-1
 8008040:	e0bffa15 	stw	r2,-24(fp)
 8008044:	e0bffa17 	ldw	r2,-24(fp)
 8008048:	10c00003 	ldbu	r3,0(r2)
 800804c:	e0bff917 	ldw	r2,-28(fp)
 8008050:	10c00005 	stb	r3,0(r2)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
 8008054:	e0bfff17 	ldw	r2,-4(fp)
 8008058:	10ffffc4 	addi	r3,r2,-1
 800805c:	e0ffff15 	stw	r3,-4(fp)
 8008060:	103ff21e 	bne	r2,zero,800802c <memmove+0x6c>
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
 8008064:	00005306 	br	80081b4 <memmove+0x1f4>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
 8008068:	e0bfff17 	ldw	r2,-4(fp)
 800806c:	10800430 	cmpltui	r2,r2,16
 8008070:	10004c1e 	bne	r2,zero,80081a4 <memmove+0x1e4>
 8008074:	e0fffa17 	ldw	r3,-24(fp)
 8008078:	e0bff917 	ldw	r2,-28(fp)
 800807c:	1884b03a 	or	r2,r3,r2
 8008080:	108000cc 	andi	r2,r2,3
 8008084:	1000471e 	bne	r2,zero,80081a4 <memmove+0x1e4>
        {
          aligned_dst = (long*)dst;
 8008088:	e0bff917 	ldw	r2,-28(fp)
 800808c:	e0bffb15 	stw	r2,-20(fp)
          aligned_src = (long*)src;
 8008090:	e0bffa17 	ldw	r2,-24(fp)
 8008094:	e0bffc15 	stw	r2,-16(fp)

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 8008098:	00002306 	br	8008128 <memmove+0x168>
            {
              *aligned_dst++ = *aligned_src++;
 800809c:	e0bffb17 	ldw	r2,-20(fp)
 80080a0:	10c00104 	addi	r3,r2,4
 80080a4:	e0fffb15 	stw	r3,-20(fp)
 80080a8:	e0fffc17 	ldw	r3,-16(fp)
 80080ac:	19000104 	addi	r4,r3,4
 80080b0:	e13ffc15 	stw	r4,-16(fp)
 80080b4:	18c00017 	ldw	r3,0(r3)
 80080b8:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 80080bc:	e0bffb17 	ldw	r2,-20(fp)
 80080c0:	10c00104 	addi	r3,r2,4
 80080c4:	e0fffb15 	stw	r3,-20(fp)
 80080c8:	e0fffc17 	ldw	r3,-16(fp)
 80080cc:	19000104 	addi	r4,r3,4
 80080d0:	e13ffc15 	stw	r4,-16(fp)
 80080d4:	18c00017 	ldw	r3,0(r3)
 80080d8:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 80080dc:	e0bffb17 	ldw	r2,-20(fp)
 80080e0:	10c00104 	addi	r3,r2,4
 80080e4:	e0fffb15 	stw	r3,-20(fp)
 80080e8:	e0fffc17 	ldw	r3,-16(fp)
 80080ec:	19000104 	addi	r4,r3,4
 80080f0:	e13ffc15 	stw	r4,-16(fp)
 80080f4:	18c00017 	ldw	r3,0(r3)
 80080f8:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 80080fc:	e0bffb17 	ldw	r2,-20(fp)
 8008100:	10c00104 	addi	r3,r2,4
 8008104:	e0fffb15 	stw	r3,-20(fp)
 8008108:	e0fffc17 	ldw	r3,-16(fp)
 800810c:	19000104 	addi	r4,r3,4
 8008110:	e13ffc15 	stw	r4,-16(fp)
 8008114:	18c00017 	ldw	r3,0(r3)
 8008118:	10c00015 	stw	r3,0(r2)
              length -= BIGBLOCKSIZE;
 800811c:	e0bfff17 	ldw	r2,-4(fp)
 8008120:	10bffc04 	addi	r2,r2,-16
 8008124:	e0bfff15 	stw	r2,-4(fp)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 8008128:	e0bfff17 	ldw	r2,-4(fp)
 800812c:	10800428 	cmpgeui	r2,r2,16
 8008130:	103fda1e 	bne	r2,zero,800809c <memmove+0xdc>
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 8008134:	00000b06 	br	8008164 <memmove+0x1a4>
            {
              *aligned_dst++ = *aligned_src++;
 8008138:	e0bffb17 	ldw	r2,-20(fp)
 800813c:	10c00104 	addi	r3,r2,4
 8008140:	e0fffb15 	stw	r3,-20(fp)
 8008144:	e0fffc17 	ldw	r3,-16(fp)
 8008148:	19000104 	addi	r4,r3,4
 800814c:	e13ffc15 	stw	r4,-16(fp)
 8008150:	18c00017 	ldw	r3,0(r3)
 8008154:	10c00015 	stw	r3,0(r2)
              length -= LITTLEBLOCKSIZE;
 8008158:	e0bfff17 	ldw	r2,-4(fp)
 800815c:	10bfff04 	addi	r2,r2,-4
 8008160:	e0bfff15 	stw	r2,-4(fp)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 8008164:	e0bfff17 	ldw	r2,-4(fp)
 8008168:	10800128 	cmpgeui	r2,r2,4
 800816c:	103ff21e 	bne	r2,zero,8008138 <memmove+0x178>
              *aligned_dst++ = *aligned_src++;
              length -= LITTLEBLOCKSIZE;
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
 8008170:	e0bffb17 	ldw	r2,-20(fp)
 8008174:	e0bff915 	stw	r2,-28(fp)
          src = (char*)aligned_src;
 8008178:	e0bffc17 	ldw	r2,-16(fp)
 800817c:	e0bffa15 	stw	r2,-24(fp)
        }

      while (length--)
 8008180:	00000806 	br	80081a4 <memmove+0x1e4>
        {
          *dst++ = *src++;
 8008184:	e0bff917 	ldw	r2,-28(fp)
 8008188:	10c00044 	addi	r3,r2,1
 800818c:	e0fff915 	stw	r3,-28(fp)
 8008190:	e0fffa17 	ldw	r3,-24(fp)
 8008194:	19000044 	addi	r4,r3,1
 8008198:	e13ffa15 	stw	r4,-24(fp)
 800819c:	18c00003 	ldbu	r3,0(r3)
 80081a0:	10c00005 	stb	r3,0(r2)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
 80081a4:	e0bfff17 	ldw	r2,-4(fp)
 80081a8:	10ffffc4 	addi	r3,r2,-1
 80081ac:	e0ffff15 	stw	r3,-4(fp)
 80081b0:	103ff41e 	bne	r2,zero,8008184 <memmove+0x1c4>
        {
          *dst++ = *src++;
        }
    }

  return dst_void;
 80081b4:	e0bffd17 	ldw	r2,-12(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 80081b8:	e037883a 	mov	sp,fp
 80081bc:	df000017 	ldw	fp,0(sp)
 80081c0:	dec00104 	addi	sp,sp,4
 80081c4:	f800283a 	ret

080081c8 <memset>:
__inhibit_loop_to_libcall
_DEFUN (memset, (m, c, n),
	_PTR m _AND
	int c _AND
	size_t n)
{
 80081c8:	defff704 	addi	sp,sp,-36
 80081cc:	df000815 	stw	fp,32(sp)
 80081d0:	df000804 	addi	fp,sp,32
 80081d4:	e13ffd15 	stw	r4,-12(fp)
 80081d8:	e17ffe15 	stw	r5,-8(fp)
 80081dc:	e1bfff15 	stw	r6,-4(fp)
  char *s = (char *) m;
 80081e0:	e0bffd17 	ldw	r2,-12(fp)
 80081e4:	e0bff815 	stw	r2,-32(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
 80081e8:	e0bffe17 	ldw	r2,-8(fp)
 80081ec:	10803fcc 	andi	r2,r2,255
 80081f0:	e0bffc15 	stw	r2,-16(fp)
				   unsigned variable.  */

  while (UNALIGNED (s))
 80081f4:	00000c06 	br	8008228 <memset+0x60>
    {
      if (n--)
 80081f8:	e0bfff17 	ldw	r2,-4(fp)
 80081fc:	10ffffc4 	addi	r3,r2,-1
 8008200:	e0ffff15 	stw	r3,-4(fp)
 8008204:	10000626 	beq	r2,zero,8008220 <memset+0x58>
        *s++ = (char) c;
 8008208:	e0bff817 	ldw	r2,-32(fp)
 800820c:	10c00044 	addi	r3,r2,1
 8008210:	e0fff815 	stw	r3,-32(fp)
 8008214:	e0fffe17 	ldw	r3,-8(fp)
 8008218:	10c00005 	stb	r3,0(r2)
 800821c:	00000206 	br	8008228 <memset+0x60>
      else
        return m;
 8008220:	e0bffd17 	ldw	r2,-12(fp)
 8008224:	00005506 	br	800837c <memset+0x1b4>
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
				   unsigned variable.  */

  while (UNALIGNED (s))
 8008228:	e0bff817 	ldw	r2,-32(fp)
 800822c:	108000cc 	andi	r2,r2,3
 8008230:	103ff11e 	bne	r2,zero,80081f8 <memset+0x30>
        *s++ = (char) c;
      else
        return m;
    }

  if (!TOO_SMALL (n))
 8008234:	e0bfff17 	ldw	r2,-4(fp)
 8008238:	10800130 	cmpltui	r2,r2,4
 800823c:	10004a1e 	bne	r2,zero,8008368 <memset+0x1a0>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
 8008240:	e0bff817 	ldw	r2,-32(fp)
 8008244:	e0bffb15 	stw	r2,-20(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
 8008248:	e0bffc17 	ldw	r2,-16(fp)
 800824c:	1006923a 	slli	r3,r2,8
 8008250:	e0bffc17 	ldw	r2,-16(fp)
 8008254:	1884b03a 	or	r2,r3,r2
 8008258:	e0bffa15 	stw	r2,-24(fp)
      buffer |= (buffer << 16);
 800825c:	e0bffa17 	ldw	r2,-24(fp)
 8008260:	1004943a 	slli	r2,r2,16
 8008264:	e0fffa17 	ldw	r3,-24(fp)
 8008268:	1884b03a 	or	r2,r3,r2
 800826c:	e0bffa15 	stw	r2,-24(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 8008270:	00800804 	movi	r2,32
 8008274:	e0bff915 	stw	r2,-28(fp)
 8008278:	00000906 	br	80082a0 <memset+0xd8>
        buffer = (buffer << i) | buffer;
 800827c:	e0fffa17 	ldw	r3,-24(fp)
 8008280:	e0bff917 	ldw	r2,-28(fp)
 8008284:	1884983a 	sll	r2,r3,r2
 8008288:	e0fffa17 	ldw	r3,-24(fp)
 800828c:	1884b03a 	or	r2,r3,r2
 8008290:	e0bffa15 	stw	r2,-24(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 8008294:	e0bff917 	ldw	r2,-28(fp)
 8008298:	1085883a 	add	r2,r2,r2
 800829c:	e0bff915 	stw	r2,-28(fp)
 80082a0:	e0bff917 	ldw	r2,-28(fp)
 80082a4:	10800830 	cmpltui	r2,r2,32
 80082a8:	103ff41e 	bne	r2,zero,800827c <memset+0xb4>
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 80082ac:	00001706 	br	800830c <memset+0x144>
        {
          *aligned_addr++ = buffer;
 80082b0:	e0bffb17 	ldw	r2,-20(fp)
 80082b4:	10c00104 	addi	r3,r2,4
 80082b8:	e0fffb15 	stw	r3,-20(fp)
 80082bc:	e0fffa17 	ldw	r3,-24(fp)
 80082c0:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 80082c4:	e0bffb17 	ldw	r2,-20(fp)
 80082c8:	10c00104 	addi	r3,r2,4
 80082cc:	e0fffb15 	stw	r3,-20(fp)
 80082d0:	e0fffa17 	ldw	r3,-24(fp)
 80082d4:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 80082d8:	e0bffb17 	ldw	r2,-20(fp)
 80082dc:	10c00104 	addi	r3,r2,4
 80082e0:	e0fffb15 	stw	r3,-20(fp)
 80082e4:	e0fffa17 	ldw	r3,-24(fp)
 80082e8:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 80082ec:	e0bffb17 	ldw	r2,-20(fp)
 80082f0:	10c00104 	addi	r3,r2,4
 80082f4:	e0fffb15 	stw	r3,-20(fp)
 80082f8:	e0fffa17 	ldw	r3,-24(fp)
 80082fc:	10c00015 	stw	r3,0(r2)
          n -= 4*LBLOCKSIZE;
 8008300:	e0bfff17 	ldw	r2,-4(fp)
 8008304:	10bffc04 	addi	r2,r2,-16
 8008308:	e0bfff15 	stw	r2,-4(fp)
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 800830c:	e0bfff17 	ldw	r2,-4(fp)
 8008310:	10800428 	cmpgeui	r2,r2,16
 8008314:	103fe61e 	bne	r2,zero,80082b0 <memset+0xe8>
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
 8008318:	00000806 	br	800833c <memset+0x174>
        {
          *aligned_addr++ = buffer;
 800831c:	e0bffb17 	ldw	r2,-20(fp)
 8008320:	10c00104 	addi	r3,r2,4
 8008324:	e0fffb15 	stw	r3,-20(fp)
 8008328:	e0fffa17 	ldw	r3,-24(fp)
 800832c:	10c00015 	stw	r3,0(r2)
          n -= LBLOCKSIZE;
 8008330:	e0bfff17 	ldw	r2,-4(fp)
 8008334:	10bfff04 	addi	r2,r2,-4
 8008338:	e0bfff15 	stw	r2,-4(fp)
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
 800833c:	e0bfff17 	ldw	r2,-4(fp)
 8008340:	10800128 	cmpgeui	r2,r2,4
 8008344:	103ff51e 	bne	r2,zero,800831c <memset+0x154>
        {
          *aligned_addr++ = buffer;
          n -= LBLOCKSIZE;
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
 8008348:	e0bffb17 	ldw	r2,-20(fp)
 800834c:	e0bff815 	stw	r2,-32(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 8008350:	00000506 	br	8008368 <memset+0x1a0>
    *s++ = (char) c;
 8008354:	e0bff817 	ldw	r2,-32(fp)
 8008358:	10c00044 	addi	r3,r2,1
 800835c:	e0fff815 	stw	r3,-32(fp)
 8008360:	e0fffe17 	ldw	r3,-8(fp)
 8008364:	10c00005 	stb	r3,0(r2)
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 8008368:	e0bfff17 	ldw	r2,-4(fp)
 800836c:	10ffffc4 	addi	r3,r2,-1
 8008370:	e0ffff15 	stw	r3,-4(fp)
 8008374:	103ff71e 	bne	r2,zero,8008354 <memset+0x18c>
    *s++ = (char) c;

  return m;
 8008378:	e0bffd17 	ldw	r2,-12(fp)
}
 800837c:	e037883a 	mov	sp,fp
 8008380:	df000017 	ldw	fp,0(sp)
 8008384:	dec00104 	addi	sp,sp,4
 8008388:	f800283a 	ret

0800838c <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
 800838c:	deffe104 	addi	sp,sp,-124
 8008390:	dfc01e15 	stw	ra,120(sp)
 8008394:	df001d15 	stw	fp,116(sp)
 8008398:	df001d04 	addi	fp,sp,116
 800839c:	e13ffd15 	stw	r4,-12(fp)
 80083a0:	e17ffe15 	stw	r5,-8(fp)
 80083a4:	e1bfff15 	stw	r6,-4(fp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
 80083a8:	e0bffe17 	ldw	r2,-8(fp)
 80083ac:	1000041e 	bne	r2,zero,80083c0 <_realloc_r+0x34>
 80083b0:	e17fff17 	ldw	r5,-4(fp)
 80083b4:	e13ffd17 	ldw	r4,-12(fp)
 80083b8:	80071000 	call	8007100 <_malloc_r>
 80083bc:	0002ea06 	br	8008f68 <_realloc_r+0xbdc>

  MALLOC_LOCK;
 80083c0:	e13ffd17 	ldw	r4,-12(fp)
 80083c4:	800aa640 	call	800aa64 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
 80083c8:	e0bffe17 	ldw	r2,-8(fp)
 80083cc:	10bffe04 	addi	r2,r2,-8
 80083d0:	e0bfef15 	stw	r2,-68(fp)
 80083d4:	e0bfef17 	ldw	r2,-68(fp)
 80083d8:	e0bfe315 	stw	r2,-116(fp)
  newsize = oldsize = chunksize(oldp);
 80083dc:	e0bfef17 	ldw	r2,-68(fp)
 80083e0:	10c00117 	ldw	r3,4(r2)
 80083e4:	00bfff04 	movi	r2,-4
 80083e8:	1884703a 	and	r2,r3,r2
 80083ec:	e0bff015 	stw	r2,-64(fp)
 80083f0:	e0bff017 	ldw	r2,-64(fp)
 80083f4:	e0bfe415 	stw	r2,-112(fp)


  nb = request2size(bytes);
 80083f8:	e0bfff17 	ldw	r2,-4(fp)
 80083fc:	108002c4 	addi	r2,r2,11
 8008400:	108005f0 	cmpltui	r2,r2,23
 8008404:	1000051e 	bne	r2,zero,800841c <_realloc_r+0x90>
 8008408:	e0bfff17 	ldw	r2,-4(fp)
 800840c:	10c002c4 	addi	r3,r2,11
 8008410:	00bffe04 	movi	r2,-8
 8008414:	1884703a 	and	r2,r3,r2
 8008418:	00000106 	br	8008420 <_realloc_r+0x94>
 800841c:	00800404 	movi	r2,16
 8008420:	e0bff115 	stw	r2,-60(fp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
 8008424:	e0bff117 	ldw	r2,-60(fp)
 8008428:	10000316 	blt	r2,zero,8008438 <_realloc_r+0xac>
 800842c:	e0fff117 	ldw	r3,-60(fp)
 8008430:	e0bfff17 	ldw	r2,-4(fp)
 8008434:	1880052e 	bgeu	r3,r2,800844c <_realloc_r+0xc0>
  {
    RERRNO = ENOMEM;
 8008438:	e0bffd17 	ldw	r2,-12(fp)
 800843c:	00c00304 	movi	r3,12
 8008440:	10c00015 	stw	r3,0(r2)
    return 0;
 8008444:	0005883a 	mov	r2,zero
 8008448:	0002c706 	br	8008f68 <_realloc_r+0xbdc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
 800844c:	e0fff017 	ldw	r3,-64(fp)
 8008450:	e0bff117 	ldw	r2,-60(fp)
 8008454:	18828b0e 	bge	r3,r2,8008e84 <_realloc_r+0xaf8>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
 8008458:	e0ffef17 	ldw	r3,-68(fp)
 800845c:	e0bff017 	ldw	r2,-64(fp)
 8008460:	1885883a 	add	r2,r3,r2
 8008464:	e0bfe515 	stw	r2,-108(fp)
    if (next == top || !inuse(next)) 
 8008468:	00820134 	movhi	r2,2052
 800846c:	109aa204 	addi	r2,r2,27272
 8008470:	10c00217 	ldw	r3,8(r2)
 8008474:	e0bfe517 	ldw	r2,-108(fp)
 8008478:	18800926 	beq	r3,r2,80084a0 <_realloc_r+0x114>
 800847c:	e0bfe517 	ldw	r2,-108(fp)
 8008480:	10c00117 	ldw	r3,4(r2)
 8008484:	00bfff84 	movi	r2,-2
 8008488:	1884703a 	and	r2,r3,r2
 800848c:	e0ffe517 	ldw	r3,-108(fp)
 8008490:	1885883a 	add	r2,r3,r2
 8008494:	10800117 	ldw	r2,4(r2)
 8008498:	1080004c 	andi	r2,r2,1
 800849c:	1000461e 	bne	r2,zero,80085b8 <_realloc_r+0x22c>
    {
      nextsize = chunksize(next);
 80084a0:	e0bfe517 	ldw	r2,-108(fp)
 80084a4:	10c00117 	ldw	r3,4(r2)
 80084a8:	00bfff04 	movi	r2,-4
 80084ac:	1884703a 	and	r2,r3,r2
 80084b0:	e0bfe615 	stw	r2,-104(fp)

      /* Forward into top only if a remainder */
      if (next == top)
 80084b4:	00820134 	movhi	r2,2052
 80084b8:	109aa204 	addi	r2,r2,27272
 80084bc:	10c00217 	ldw	r3,8(r2)
 80084c0:	e0bfe517 	ldw	r2,-108(fp)
 80084c4:	1880251e 	bne	r3,r2,800855c <_realloc_r+0x1d0>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
 80084c8:	e0ffe617 	ldw	r3,-104(fp)
 80084cc:	e0bfe417 	ldw	r2,-112(fp)
 80084d0:	1885883a 	add	r2,r3,r2
 80084d4:	1007883a 	mov	r3,r2
 80084d8:	e0bff117 	ldw	r2,-60(fp)
 80084dc:	10800404 	addi	r2,r2,16
 80084e0:	18803816 	blt	r3,r2,80085c4 <_realloc_r+0x238>
        {
          newsize += nextsize;
 80084e4:	e0ffe417 	ldw	r3,-112(fp)
 80084e8:	e0bfe617 	ldw	r2,-104(fp)
 80084ec:	1885883a 	add	r2,r3,r2
 80084f0:	e0bfe415 	stw	r2,-112(fp)
          top = chunk_at_offset(oldp, nb);
 80084f4:	00820134 	movhi	r2,2052
 80084f8:	109aa204 	addi	r2,r2,27272
 80084fc:	e13fef17 	ldw	r4,-68(fp)
 8008500:	e0fff117 	ldw	r3,-60(fp)
 8008504:	20c7883a 	add	r3,r4,r3
 8008508:	10c00215 	stw	r3,8(r2)
          set_head(top, (newsize - nb) | PREV_INUSE);
 800850c:	00820134 	movhi	r2,2052
 8008510:	109aa204 	addi	r2,r2,27272
 8008514:	10800217 	ldw	r2,8(r2)
 8008518:	e13fe417 	ldw	r4,-112(fp)
 800851c:	e0fff117 	ldw	r3,-60(fp)
 8008520:	20c7c83a 	sub	r3,r4,r3
 8008524:	18c00054 	ori	r3,r3,1
 8008528:	10c00115 	stw	r3,4(r2)
          set_head_size(oldp, nb);
 800852c:	e0bfef17 	ldw	r2,-68(fp)
 8008530:	10800117 	ldw	r2,4(r2)
 8008534:	10c0004c 	andi	r3,r2,1
 8008538:	e0bff117 	ldw	r2,-60(fp)
 800853c:	1886b03a 	or	r3,r3,r2
 8008540:	e0bfef17 	ldw	r2,-68(fp)
 8008544:	10c00115 	stw	r3,4(r2)
	  MALLOC_UNLOCK;
 8008548:	e13ffd17 	ldw	r4,-12(fp)
 800854c:	800aa880 	call	800aa88 <__malloc_unlock>
          return chunk2mem(oldp);
 8008550:	e0bfef17 	ldw	r2,-68(fp)
 8008554:	10800204 	addi	r2,r2,8
 8008558:	00028306 	br	8008f68 <_realloc_r+0xbdc>
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
 800855c:	e0ffe617 	ldw	r3,-104(fp)
 8008560:	e0bfe417 	ldw	r2,-112(fp)
 8008564:	1885883a 	add	r2,r3,r2
 8008568:	1007883a 	mov	r3,r2
 800856c:	e0bff117 	ldw	r2,-60(fp)
 8008570:	18801416 	blt	r3,r2,80085c4 <_realloc_r+0x238>
      { 
        unlink(next, bck, fwd);
 8008574:	e0bfe517 	ldw	r2,-108(fp)
 8008578:	10800317 	ldw	r2,12(r2)
 800857c:	e0bff215 	stw	r2,-56(fp)
 8008580:	e0bfe517 	ldw	r2,-108(fp)
 8008584:	10800217 	ldw	r2,8(r2)
 8008588:	e0bff315 	stw	r2,-52(fp)
 800858c:	e0bff317 	ldw	r2,-52(fp)
 8008590:	e0fff217 	ldw	r3,-56(fp)
 8008594:	10c00315 	stw	r3,12(r2)
 8008598:	e0bff217 	ldw	r2,-56(fp)
 800859c:	e0fff317 	ldw	r3,-52(fp)
 80085a0:	10c00215 	stw	r3,8(r2)
        newsize  += nextsize;
 80085a4:	e0ffe417 	ldw	r3,-112(fp)
 80085a8:	e0bfe617 	ldw	r2,-104(fp)
 80085ac:	1885883a 	add	r2,r3,r2
 80085b0:	e0bfe415 	stw	r2,-112(fp)
        goto split;
 80085b4:	00023306 	br	8008e84 <_realloc_r+0xaf8>
      }
    }
    else
    {
      next = 0;
 80085b8:	e03fe515 	stw	zero,-108(fp)
      nextsize = 0;
 80085bc:	e03fe615 	stw	zero,-104(fp)
 80085c0:	00000106 	br	80085c8 <_realloc_r+0x23c>
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
 80085c4:	0001883a 	nop
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
 80085c8:	e0bfef17 	ldw	r2,-68(fp)
 80085cc:	10800117 	ldw	r2,4(r2)
 80085d0:	1080004c 	andi	r2,r2,1
 80085d4:	1001a91e 	bne	r2,zero,8008c7c <_realloc_r+0x8f0>
    {
      prev = prev_chunk(oldp);
 80085d8:	e0bfef17 	ldw	r2,-68(fp)
 80085dc:	10800017 	ldw	r2,0(r2)
 80085e0:	0085c83a 	sub	r2,zero,r2
 80085e4:	e0ffef17 	ldw	r3,-68(fp)
 80085e8:	1885883a 	add	r2,r3,r2
 80085ec:	e0bff415 	stw	r2,-48(fp)
      prevsize = chunksize(prev);
 80085f0:	e0bff417 	ldw	r2,-48(fp)
 80085f4:	10c00117 	ldw	r3,4(r2)
 80085f8:	00bfff04 	movi	r2,-4
 80085fc:	1884703a 	and	r2,r3,r2
 8008600:	e0bff515 	stw	r2,-44(fp)

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
 8008604:	e0bfe517 	ldw	r2,-108(fp)
 8008608:	10012226 	beq	r2,zero,8008a94 <_realloc_r+0x708>
      {
        /* into top */
        if (next == top)
 800860c:	00820134 	movhi	r2,2052
 8008610:	109aa204 	addi	r2,r2,27272
 8008614:	10c00217 	ldw	r3,8(r2)
 8008618:	e0bfe517 	ldw	r2,-108(fp)
 800861c:	1880951e 	bne	r3,r2,8008874 <_realloc_r+0x4e8>
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
 8008620:	e0ffe617 	ldw	r3,-104(fp)
 8008624:	e0bff517 	ldw	r2,-44(fp)
 8008628:	1887883a 	add	r3,r3,r2
 800862c:	e0bfe417 	ldw	r2,-112(fp)
 8008630:	1885883a 	add	r2,r3,r2
 8008634:	1007883a 	mov	r3,r2
 8008638:	e0bff117 	ldw	r2,-60(fp)
 800863c:	10800404 	addi	r2,r2,16
 8008640:	18811416 	blt	r3,r2,8008a94 <_realloc_r+0x708>
          {
            unlink(prev, bck, fwd);
 8008644:	e0bff417 	ldw	r2,-48(fp)
 8008648:	10800317 	ldw	r2,12(r2)
 800864c:	e0bff215 	stw	r2,-56(fp)
 8008650:	e0bff417 	ldw	r2,-48(fp)
 8008654:	10800217 	ldw	r2,8(r2)
 8008658:	e0bff315 	stw	r2,-52(fp)
 800865c:	e0bff317 	ldw	r2,-52(fp)
 8008660:	e0fff217 	ldw	r3,-56(fp)
 8008664:	10c00315 	stw	r3,12(r2)
 8008668:	e0bff217 	ldw	r2,-56(fp)
 800866c:	e0fff317 	ldw	r3,-52(fp)
 8008670:	10c00215 	stw	r3,8(r2)
            newp = prev;
 8008674:	e0bff417 	ldw	r2,-48(fp)
 8008678:	e0bfe315 	stw	r2,-116(fp)
            newsize += prevsize + nextsize;
 800867c:	e0fff517 	ldw	r3,-44(fp)
 8008680:	e0bfe617 	ldw	r2,-104(fp)
 8008684:	1885883a 	add	r2,r3,r2
 8008688:	e0ffe417 	ldw	r3,-112(fp)
 800868c:	1885883a 	add	r2,r3,r2
 8008690:	e0bfe415 	stw	r2,-112(fp)
            newmem = chunk2mem(newp);
 8008694:	e0bfe317 	ldw	r2,-116(fp)
 8008698:	10800204 	addi	r2,r2,8
 800869c:	e0bff615 	stw	r2,-40(fp)
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 80086a0:	e0bff017 	ldw	r2,-64(fp)
 80086a4:	10bfff04 	addi	r2,r2,-4
 80086a8:	e0bff715 	stw	r2,-36(fp)
 80086ac:	e0bff717 	ldw	r2,-36(fp)
 80086b0:	10800968 	cmpgeui	r2,r2,37
 80086b4:	1000521e 	bne	r2,zero,8008800 <_realloc_r+0x474>
 80086b8:	e0bffe17 	ldw	r2,-8(fp)
 80086bc:	e0bfe715 	stw	r2,-100(fp)
 80086c0:	e0bff617 	ldw	r2,-40(fp)
 80086c4:	e0bfe815 	stw	r2,-96(fp)
 80086c8:	e0bff717 	ldw	r2,-36(fp)
 80086cc:	10800530 	cmpltui	r2,r2,20
 80086d0:	1000361e 	bne	r2,zero,80087ac <_realloc_r+0x420>
 80086d4:	e0bfe817 	ldw	r2,-96(fp)
 80086d8:	10c00104 	addi	r3,r2,4
 80086dc:	e0ffe815 	stw	r3,-96(fp)
 80086e0:	e0ffe717 	ldw	r3,-100(fp)
 80086e4:	19000104 	addi	r4,r3,4
 80086e8:	e13fe715 	stw	r4,-100(fp)
 80086ec:	18c00017 	ldw	r3,0(r3)
 80086f0:	10c00015 	stw	r3,0(r2)
 80086f4:	e0bfe817 	ldw	r2,-96(fp)
 80086f8:	10c00104 	addi	r3,r2,4
 80086fc:	e0ffe815 	stw	r3,-96(fp)
 8008700:	e0ffe717 	ldw	r3,-100(fp)
 8008704:	19000104 	addi	r4,r3,4
 8008708:	e13fe715 	stw	r4,-100(fp)
 800870c:	18c00017 	ldw	r3,0(r3)
 8008710:	10c00015 	stw	r3,0(r2)
 8008714:	e0bff717 	ldw	r2,-36(fp)
 8008718:	10800730 	cmpltui	r2,r2,28
 800871c:	1000231e 	bne	r2,zero,80087ac <_realloc_r+0x420>
 8008720:	e0bfe817 	ldw	r2,-96(fp)
 8008724:	10c00104 	addi	r3,r2,4
 8008728:	e0ffe815 	stw	r3,-96(fp)
 800872c:	e0ffe717 	ldw	r3,-100(fp)
 8008730:	19000104 	addi	r4,r3,4
 8008734:	e13fe715 	stw	r4,-100(fp)
 8008738:	18c00017 	ldw	r3,0(r3)
 800873c:	10c00015 	stw	r3,0(r2)
 8008740:	e0bfe817 	ldw	r2,-96(fp)
 8008744:	10c00104 	addi	r3,r2,4
 8008748:	e0ffe815 	stw	r3,-96(fp)
 800874c:	e0ffe717 	ldw	r3,-100(fp)
 8008750:	19000104 	addi	r4,r3,4
 8008754:	e13fe715 	stw	r4,-100(fp)
 8008758:	18c00017 	ldw	r3,0(r3)
 800875c:	10c00015 	stw	r3,0(r2)
 8008760:	e0bff717 	ldw	r2,-36(fp)
 8008764:	10800930 	cmpltui	r2,r2,36
 8008768:	1000101e 	bne	r2,zero,80087ac <_realloc_r+0x420>
 800876c:	e0bfe817 	ldw	r2,-96(fp)
 8008770:	10c00104 	addi	r3,r2,4
 8008774:	e0ffe815 	stw	r3,-96(fp)
 8008778:	e0ffe717 	ldw	r3,-100(fp)
 800877c:	19000104 	addi	r4,r3,4
 8008780:	e13fe715 	stw	r4,-100(fp)
 8008784:	18c00017 	ldw	r3,0(r3)
 8008788:	10c00015 	stw	r3,0(r2)
 800878c:	e0bfe817 	ldw	r2,-96(fp)
 8008790:	10c00104 	addi	r3,r2,4
 8008794:	e0ffe815 	stw	r3,-96(fp)
 8008798:	e0ffe717 	ldw	r3,-100(fp)
 800879c:	19000104 	addi	r4,r3,4
 80087a0:	e13fe715 	stw	r4,-100(fp)
 80087a4:	18c00017 	ldw	r3,0(r3)
 80087a8:	10c00015 	stw	r3,0(r2)
 80087ac:	e0bfe817 	ldw	r2,-96(fp)
 80087b0:	10c00104 	addi	r3,r2,4
 80087b4:	e0ffe815 	stw	r3,-96(fp)
 80087b8:	e0ffe717 	ldw	r3,-100(fp)
 80087bc:	19000104 	addi	r4,r3,4
 80087c0:	e13fe715 	stw	r4,-100(fp)
 80087c4:	18c00017 	ldw	r3,0(r3)
 80087c8:	10c00015 	stw	r3,0(r2)
 80087cc:	e0bfe817 	ldw	r2,-96(fp)
 80087d0:	10c00104 	addi	r3,r2,4
 80087d4:	e0ffe815 	stw	r3,-96(fp)
 80087d8:	e0ffe717 	ldw	r3,-100(fp)
 80087dc:	19000104 	addi	r4,r3,4
 80087e0:	e13fe715 	stw	r4,-100(fp)
 80087e4:	18c00017 	ldw	r3,0(r3)
 80087e8:	10c00015 	stw	r3,0(r2)
 80087ec:	e0bfe717 	ldw	r2,-100(fp)
 80087f0:	10c00017 	ldw	r3,0(r2)
 80087f4:	e0bfe817 	ldw	r2,-96(fp)
 80087f8:	10c00015 	stw	r3,0(r2)
 80087fc:	00000406 	br	8008810 <_realloc_r+0x484>
 8008800:	e1bff717 	ldw	r6,-36(fp)
 8008804:	e17ffe17 	ldw	r5,-8(fp)
 8008808:	e13ff617 	ldw	r4,-40(fp)
 800880c:	8007fc00 	call	8007fc0 <memmove>
            top = chunk_at_offset(newp, nb);
 8008810:	00820134 	movhi	r2,2052
 8008814:	109aa204 	addi	r2,r2,27272
 8008818:	e13fe317 	ldw	r4,-116(fp)
 800881c:	e0fff117 	ldw	r3,-60(fp)
 8008820:	20c7883a 	add	r3,r4,r3
 8008824:	10c00215 	stw	r3,8(r2)
            set_head(top, (newsize - nb) | PREV_INUSE);
 8008828:	00820134 	movhi	r2,2052
 800882c:	109aa204 	addi	r2,r2,27272
 8008830:	10800217 	ldw	r2,8(r2)
 8008834:	e13fe417 	ldw	r4,-112(fp)
 8008838:	e0fff117 	ldw	r3,-60(fp)
 800883c:	20c7c83a 	sub	r3,r4,r3
 8008840:	18c00054 	ori	r3,r3,1
 8008844:	10c00115 	stw	r3,4(r2)
            set_head_size(newp, nb);
 8008848:	e0bfe317 	ldw	r2,-116(fp)
 800884c:	10800117 	ldw	r2,4(r2)
 8008850:	10c0004c 	andi	r3,r2,1
 8008854:	e0bff117 	ldw	r2,-60(fp)
 8008858:	1886b03a 	or	r3,r3,r2
 800885c:	e0bfe317 	ldw	r2,-116(fp)
 8008860:	10c00115 	stw	r3,4(r2)
	    MALLOC_UNLOCK;
 8008864:	e13ffd17 	ldw	r4,-12(fp)
 8008868:	800aa880 	call	800aa88 <__malloc_unlock>
            return newmem;
 800886c:	e0bff617 	ldw	r2,-40(fp)
 8008870:	0001bd06 	br	8008f68 <_realloc_r+0xbdc>
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
 8008874:	e0ffe617 	ldw	r3,-104(fp)
 8008878:	e0bff517 	ldw	r2,-44(fp)
 800887c:	1887883a 	add	r3,r3,r2
 8008880:	e0bfe417 	ldw	r2,-112(fp)
 8008884:	1885883a 	add	r2,r3,r2
 8008888:	1007883a 	mov	r3,r2
 800888c:	e0bff117 	ldw	r2,-60(fp)
 8008890:	18808016 	blt	r3,r2,8008a94 <_realloc_r+0x708>
        {
          unlink(next, bck, fwd);
 8008894:	e0bfe517 	ldw	r2,-108(fp)
 8008898:	10800317 	ldw	r2,12(r2)
 800889c:	e0bff215 	stw	r2,-56(fp)
 80088a0:	e0bfe517 	ldw	r2,-108(fp)
 80088a4:	10800217 	ldw	r2,8(r2)
 80088a8:	e0bff315 	stw	r2,-52(fp)
 80088ac:	e0bff317 	ldw	r2,-52(fp)
 80088b0:	e0fff217 	ldw	r3,-56(fp)
 80088b4:	10c00315 	stw	r3,12(r2)
 80088b8:	e0bff217 	ldw	r2,-56(fp)
 80088bc:	e0fff317 	ldw	r3,-52(fp)
 80088c0:	10c00215 	stw	r3,8(r2)
          unlink(prev, bck, fwd);
 80088c4:	e0bff417 	ldw	r2,-48(fp)
 80088c8:	10800317 	ldw	r2,12(r2)
 80088cc:	e0bff215 	stw	r2,-56(fp)
 80088d0:	e0bff417 	ldw	r2,-48(fp)
 80088d4:	10800217 	ldw	r2,8(r2)
 80088d8:	e0bff315 	stw	r2,-52(fp)
 80088dc:	e0bff317 	ldw	r2,-52(fp)
 80088e0:	e0fff217 	ldw	r3,-56(fp)
 80088e4:	10c00315 	stw	r3,12(r2)
 80088e8:	e0bff217 	ldw	r2,-56(fp)
 80088ec:	e0fff317 	ldw	r3,-52(fp)
 80088f0:	10c00215 	stw	r3,8(r2)
          newp = prev;
 80088f4:	e0bff417 	ldw	r2,-48(fp)
 80088f8:	e0bfe315 	stw	r2,-116(fp)
          newsize += nextsize + prevsize;
 80088fc:	e0ffe617 	ldw	r3,-104(fp)
 8008900:	e0bff517 	ldw	r2,-44(fp)
 8008904:	1885883a 	add	r2,r3,r2
 8008908:	e0ffe417 	ldw	r3,-112(fp)
 800890c:	1885883a 	add	r2,r3,r2
 8008910:	e0bfe415 	stw	r2,-112(fp)
          newmem = chunk2mem(newp);
 8008914:	e0bfe317 	ldw	r2,-116(fp)
 8008918:	10800204 	addi	r2,r2,8
 800891c:	e0bff615 	stw	r2,-40(fp)
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008920:	e0bff017 	ldw	r2,-64(fp)
 8008924:	10bfff04 	addi	r2,r2,-4
 8008928:	e0bff815 	stw	r2,-32(fp)
 800892c:	e0bff817 	ldw	r2,-32(fp)
 8008930:	10800968 	cmpgeui	r2,r2,37
 8008934:	1000521e 	bne	r2,zero,8008a80 <_realloc_r+0x6f4>
 8008938:	e0bffe17 	ldw	r2,-8(fp)
 800893c:	e0bfe915 	stw	r2,-92(fp)
 8008940:	e0bff617 	ldw	r2,-40(fp)
 8008944:	e0bfea15 	stw	r2,-88(fp)
 8008948:	e0bff817 	ldw	r2,-32(fp)
 800894c:	10800530 	cmpltui	r2,r2,20
 8008950:	1000361e 	bne	r2,zero,8008a2c <_realloc_r+0x6a0>
 8008954:	e0bfea17 	ldw	r2,-88(fp)
 8008958:	10c00104 	addi	r3,r2,4
 800895c:	e0ffea15 	stw	r3,-88(fp)
 8008960:	e0ffe917 	ldw	r3,-92(fp)
 8008964:	19000104 	addi	r4,r3,4
 8008968:	e13fe915 	stw	r4,-92(fp)
 800896c:	18c00017 	ldw	r3,0(r3)
 8008970:	10c00015 	stw	r3,0(r2)
 8008974:	e0bfea17 	ldw	r2,-88(fp)
 8008978:	10c00104 	addi	r3,r2,4
 800897c:	e0ffea15 	stw	r3,-88(fp)
 8008980:	e0ffe917 	ldw	r3,-92(fp)
 8008984:	19000104 	addi	r4,r3,4
 8008988:	e13fe915 	stw	r4,-92(fp)
 800898c:	18c00017 	ldw	r3,0(r3)
 8008990:	10c00015 	stw	r3,0(r2)
 8008994:	e0bff817 	ldw	r2,-32(fp)
 8008998:	10800730 	cmpltui	r2,r2,28
 800899c:	1000231e 	bne	r2,zero,8008a2c <_realloc_r+0x6a0>
 80089a0:	e0bfea17 	ldw	r2,-88(fp)
 80089a4:	10c00104 	addi	r3,r2,4
 80089a8:	e0ffea15 	stw	r3,-88(fp)
 80089ac:	e0ffe917 	ldw	r3,-92(fp)
 80089b0:	19000104 	addi	r4,r3,4
 80089b4:	e13fe915 	stw	r4,-92(fp)
 80089b8:	18c00017 	ldw	r3,0(r3)
 80089bc:	10c00015 	stw	r3,0(r2)
 80089c0:	e0bfea17 	ldw	r2,-88(fp)
 80089c4:	10c00104 	addi	r3,r2,4
 80089c8:	e0ffea15 	stw	r3,-88(fp)
 80089cc:	e0ffe917 	ldw	r3,-92(fp)
 80089d0:	19000104 	addi	r4,r3,4
 80089d4:	e13fe915 	stw	r4,-92(fp)
 80089d8:	18c00017 	ldw	r3,0(r3)
 80089dc:	10c00015 	stw	r3,0(r2)
 80089e0:	e0bff817 	ldw	r2,-32(fp)
 80089e4:	10800930 	cmpltui	r2,r2,36
 80089e8:	1000101e 	bne	r2,zero,8008a2c <_realloc_r+0x6a0>
 80089ec:	e0bfea17 	ldw	r2,-88(fp)
 80089f0:	10c00104 	addi	r3,r2,4
 80089f4:	e0ffea15 	stw	r3,-88(fp)
 80089f8:	e0ffe917 	ldw	r3,-92(fp)
 80089fc:	19000104 	addi	r4,r3,4
 8008a00:	e13fe915 	stw	r4,-92(fp)
 8008a04:	18c00017 	ldw	r3,0(r3)
 8008a08:	10c00015 	stw	r3,0(r2)
 8008a0c:	e0bfea17 	ldw	r2,-88(fp)
 8008a10:	10c00104 	addi	r3,r2,4
 8008a14:	e0ffea15 	stw	r3,-88(fp)
 8008a18:	e0ffe917 	ldw	r3,-92(fp)
 8008a1c:	19000104 	addi	r4,r3,4
 8008a20:	e13fe915 	stw	r4,-92(fp)
 8008a24:	18c00017 	ldw	r3,0(r3)
 8008a28:	10c00015 	stw	r3,0(r2)
 8008a2c:	e0bfea17 	ldw	r2,-88(fp)
 8008a30:	10c00104 	addi	r3,r2,4
 8008a34:	e0ffea15 	stw	r3,-88(fp)
 8008a38:	e0ffe917 	ldw	r3,-92(fp)
 8008a3c:	19000104 	addi	r4,r3,4
 8008a40:	e13fe915 	stw	r4,-92(fp)
 8008a44:	18c00017 	ldw	r3,0(r3)
 8008a48:	10c00015 	stw	r3,0(r2)
 8008a4c:	e0bfea17 	ldw	r2,-88(fp)
 8008a50:	10c00104 	addi	r3,r2,4
 8008a54:	e0ffea15 	stw	r3,-88(fp)
 8008a58:	e0ffe917 	ldw	r3,-92(fp)
 8008a5c:	19000104 	addi	r4,r3,4
 8008a60:	e13fe915 	stw	r4,-92(fp)
 8008a64:	18c00017 	ldw	r3,0(r3)
 8008a68:	10c00015 	stw	r3,0(r2)
 8008a6c:	e0bfe917 	ldw	r2,-92(fp)
 8008a70:	10c00017 	ldw	r3,0(r2)
 8008a74:	e0bfea17 	ldw	r2,-88(fp)
 8008a78:	10c00015 	stw	r3,0(r2)
          goto split;
 8008a7c:	00010106 	br	8008e84 <_realloc_r+0xaf8>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008a80:	e1bff817 	ldw	r6,-32(fp)
 8008a84:	e17ffe17 	ldw	r5,-8(fp)
 8008a88:	e13ff617 	ldw	r4,-40(fp)
 8008a8c:	8007fc00 	call	8007fc0 <memmove>
          goto split;
 8008a90:	0000fc06 	br	8008e84 <_realloc_r+0xaf8>
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
 8008a94:	e0bff417 	ldw	r2,-48(fp)
 8008a98:	10007826 	beq	r2,zero,8008c7c <_realloc_r+0x8f0>
 8008a9c:	e0fff517 	ldw	r3,-44(fp)
 8008aa0:	e0bfe417 	ldw	r2,-112(fp)
 8008aa4:	1885883a 	add	r2,r3,r2
 8008aa8:	1007883a 	mov	r3,r2
 8008aac:	e0bff117 	ldw	r2,-60(fp)
 8008ab0:	18807216 	blt	r3,r2,8008c7c <_realloc_r+0x8f0>
      {
        unlink(prev, bck, fwd);
 8008ab4:	e0bff417 	ldw	r2,-48(fp)
 8008ab8:	10800317 	ldw	r2,12(r2)
 8008abc:	e0bff215 	stw	r2,-56(fp)
 8008ac0:	e0bff417 	ldw	r2,-48(fp)
 8008ac4:	10800217 	ldw	r2,8(r2)
 8008ac8:	e0bff315 	stw	r2,-52(fp)
 8008acc:	e0bff317 	ldw	r2,-52(fp)
 8008ad0:	e0fff217 	ldw	r3,-56(fp)
 8008ad4:	10c00315 	stw	r3,12(r2)
 8008ad8:	e0bff217 	ldw	r2,-56(fp)
 8008adc:	e0fff317 	ldw	r3,-52(fp)
 8008ae0:	10c00215 	stw	r3,8(r2)
        newp = prev;
 8008ae4:	e0bff417 	ldw	r2,-48(fp)
 8008ae8:	e0bfe315 	stw	r2,-116(fp)
        newsize += prevsize;
 8008aec:	e0ffe417 	ldw	r3,-112(fp)
 8008af0:	e0bff517 	ldw	r2,-44(fp)
 8008af4:	1885883a 	add	r2,r3,r2
 8008af8:	e0bfe415 	stw	r2,-112(fp)
        newmem = chunk2mem(newp);
 8008afc:	e0bfe317 	ldw	r2,-116(fp)
 8008b00:	10800204 	addi	r2,r2,8
 8008b04:	e0bff615 	stw	r2,-40(fp)
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008b08:	e0bff017 	ldw	r2,-64(fp)
 8008b0c:	10bfff04 	addi	r2,r2,-4
 8008b10:	e0bff915 	stw	r2,-28(fp)
 8008b14:	e0bff917 	ldw	r2,-28(fp)
 8008b18:	10800968 	cmpgeui	r2,r2,37
 8008b1c:	1000521e 	bne	r2,zero,8008c68 <_realloc_r+0x8dc>
 8008b20:	e0bffe17 	ldw	r2,-8(fp)
 8008b24:	e0bfeb15 	stw	r2,-84(fp)
 8008b28:	e0bff617 	ldw	r2,-40(fp)
 8008b2c:	e0bfec15 	stw	r2,-80(fp)
 8008b30:	e0bff917 	ldw	r2,-28(fp)
 8008b34:	10800530 	cmpltui	r2,r2,20
 8008b38:	1000361e 	bne	r2,zero,8008c14 <_realloc_r+0x888>
 8008b3c:	e0bfec17 	ldw	r2,-80(fp)
 8008b40:	10c00104 	addi	r3,r2,4
 8008b44:	e0ffec15 	stw	r3,-80(fp)
 8008b48:	e0ffeb17 	ldw	r3,-84(fp)
 8008b4c:	19000104 	addi	r4,r3,4
 8008b50:	e13feb15 	stw	r4,-84(fp)
 8008b54:	18c00017 	ldw	r3,0(r3)
 8008b58:	10c00015 	stw	r3,0(r2)
 8008b5c:	e0bfec17 	ldw	r2,-80(fp)
 8008b60:	10c00104 	addi	r3,r2,4
 8008b64:	e0ffec15 	stw	r3,-80(fp)
 8008b68:	e0ffeb17 	ldw	r3,-84(fp)
 8008b6c:	19000104 	addi	r4,r3,4
 8008b70:	e13feb15 	stw	r4,-84(fp)
 8008b74:	18c00017 	ldw	r3,0(r3)
 8008b78:	10c00015 	stw	r3,0(r2)
 8008b7c:	e0bff917 	ldw	r2,-28(fp)
 8008b80:	10800730 	cmpltui	r2,r2,28
 8008b84:	1000231e 	bne	r2,zero,8008c14 <_realloc_r+0x888>
 8008b88:	e0bfec17 	ldw	r2,-80(fp)
 8008b8c:	10c00104 	addi	r3,r2,4
 8008b90:	e0ffec15 	stw	r3,-80(fp)
 8008b94:	e0ffeb17 	ldw	r3,-84(fp)
 8008b98:	19000104 	addi	r4,r3,4
 8008b9c:	e13feb15 	stw	r4,-84(fp)
 8008ba0:	18c00017 	ldw	r3,0(r3)
 8008ba4:	10c00015 	stw	r3,0(r2)
 8008ba8:	e0bfec17 	ldw	r2,-80(fp)
 8008bac:	10c00104 	addi	r3,r2,4
 8008bb0:	e0ffec15 	stw	r3,-80(fp)
 8008bb4:	e0ffeb17 	ldw	r3,-84(fp)
 8008bb8:	19000104 	addi	r4,r3,4
 8008bbc:	e13feb15 	stw	r4,-84(fp)
 8008bc0:	18c00017 	ldw	r3,0(r3)
 8008bc4:	10c00015 	stw	r3,0(r2)
 8008bc8:	e0bff917 	ldw	r2,-28(fp)
 8008bcc:	10800930 	cmpltui	r2,r2,36
 8008bd0:	1000101e 	bne	r2,zero,8008c14 <_realloc_r+0x888>
 8008bd4:	e0bfec17 	ldw	r2,-80(fp)
 8008bd8:	10c00104 	addi	r3,r2,4
 8008bdc:	e0ffec15 	stw	r3,-80(fp)
 8008be0:	e0ffeb17 	ldw	r3,-84(fp)
 8008be4:	19000104 	addi	r4,r3,4
 8008be8:	e13feb15 	stw	r4,-84(fp)
 8008bec:	18c00017 	ldw	r3,0(r3)
 8008bf0:	10c00015 	stw	r3,0(r2)
 8008bf4:	e0bfec17 	ldw	r2,-80(fp)
 8008bf8:	10c00104 	addi	r3,r2,4
 8008bfc:	e0ffec15 	stw	r3,-80(fp)
 8008c00:	e0ffeb17 	ldw	r3,-84(fp)
 8008c04:	19000104 	addi	r4,r3,4
 8008c08:	e13feb15 	stw	r4,-84(fp)
 8008c0c:	18c00017 	ldw	r3,0(r3)
 8008c10:	10c00015 	stw	r3,0(r2)
 8008c14:	e0bfec17 	ldw	r2,-80(fp)
 8008c18:	10c00104 	addi	r3,r2,4
 8008c1c:	e0ffec15 	stw	r3,-80(fp)
 8008c20:	e0ffeb17 	ldw	r3,-84(fp)
 8008c24:	19000104 	addi	r4,r3,4
 8008c28:	e13feb15 	stw	r4,-84(fp)
 8008c2c:	18c00017 	ldw	r3,0(r3)
 8008c30:	10c00015 	stw	r3,0(r2)
 8008c34:	e0bfec17 	ldw	r2,-80(fp)
 8008c38:	10c00104 	addi	r3,r2,4
 8008c3c:	e0ffec15 	stw	r3,-80(fp)
 8008c40:	e0ffeb17 	ldw	r3,-84(fp)
 8008c44:	19000104 	addi	r4,r3,4
 8008c48:	e13feb15 	stw	r4,-84(fp)
 8008c4c:	18c00017 	ldw	r3,0(r3)
 8008c50:	10c00015 	stw	r3,0(r2)
 8008c54:	e0bfeb17 	ldw	r2,-84(fp)
 8008c58:	10c00017 	ldw	r3,0(r2)
 8008c5c:	e0bfec17 	ldw	r2,-80(fp)
 8008c60:	10c00015 	stw	r3,0(r2)
        goto split;
 8008c64:	00008706 	br	8008e84 <_realloc_r+0xaf8>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008c68:	e1bff917 	ldw	r6,-28(fp)
 8008c6c:	e17ffe17 	ldw	r5,-8(fp)
 8008c70:	e13ff617 	ldw	r4,-40(fp)
 8008c74:	8007fc00 	call	8007fc0 <memmove>
        goto split;
 8008c78:	00008206 	br	8008e84 <_realloc_r+0xaf8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
 8008c7c:	e17fff17 	ldw	r5,-4(fp)
 8008c80:	e13ffd17 	ldw	r4,-12(fp)
 8008c84:	80071000 	call	8007100 <_malloc_r>
 8008c88:	e0bff615 	stw	r2,-40(fp)

    if (newmem == 0)  /* propagate failure */
 8008c8c:	e0bff617 	ldw	r2,-40(fp)
 8008c90:	1000041e 	bne	r2,zero,8008ca4 <_realloc_r+0x918>
    {
      MALLOC_UNLOCK;
 8008c94:	e13ffd17 	ldw	r4,-12(fp)
 8008c98:	800aa880 	call	800aa88 <__malloc_unlock>
      return 0;
 8008c9c:	0005883a 	mov	r2,zero
 8008ca0:	0000b106 	br	8008f68 <_realloc_r+0xbdc>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
 8008ca4:	e0bff617 	ldw	r2,-40(fp)
 8008ca8:	10bffe04 	addi	r2,r2,-8
 8008cac:	e0bfe315 	stw	r2,-116(fp)
 8008cb0:	e0bfef17 	ldw	r2,-68(fp)
 8008cb4:	10c00117 	ldw	r3,4(r2)
 8008cb8:	00bfff84 	movi	r2,-2
 8008cbc:	1884703a 	and	r2,r3,r2
 8008cc0:	e0ffef17 	ldw	r3,-68(fp)
 8008cc4:	1885883a 	add	r2,r3,r2
 8008cc8:	e0ffe317 	ldw	r3,-116(fp)
 8008ccc:	18800a1e 	bne	r3,r2,8008cf8 <_realloc_r+0x96c>
    {
      newsize += chunksize(newp);
 8008cd0:	e0bfe317 	ldw	r2,-116(fp)
 8008cd4:	10c00117 	ldw	r3,4(r2)
 8008cd8:	00bfff04 	movi	r2,-4
 8008cdc:	1884703a 	and	r2,r3,r2
 8008ce0:	e0ffe417 	ldw	r3,-112(fp)
 8008ce4:	1885883a 	add	r2,r3,r2
 8008ce8:	e0bfe415 	stw	r2,-112(fp)
      newp = oldp;
 8008cec:	e0bfef17 	ldw	r2,-68(fp)
 8008cf0:	e0bfe315 	stw	r2,-116(fp)
      goto split;
 8008cf4:	00006306 	br	8008e84 <_realloc_r+0xaf8>
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008cf8:	e0bff017 	ldw	r2,-64(fp)
 8008cfc:	10bfff04 	addi	r2,r2,-4
 8008d00:	e0bffa15 	stw	r2,-24(fp)
 8008d04:	e0bffa17 	ldw	r2,-24(fp)
 8008d08:	10800968 	cmpgeui	r2,r2,37
 8008d0c:	1000521e 	bne	r2,zero,8008e58 <_realloc_r+0xacc>
 8008d10:	e0bffe17 	ldw	r2,-8(fp)
 8008d14:	e0bfed15 	stw	r2,-76(fp)
 8008d18:	e0bff617 	ldw	r2,-40(fp)
 8008d1c:	e0bfee15 	stw	r2,-72(fp)
 8008d20:	e0bffa17 	ldw	r2,-24(fp)
 8008d24:	10800530 	cmpltui	r2,r2,20
 8008d28:	1000361e 	bne	r2,zero,8008e04 <_realloc_r+0xa78>
 8008d2c:	e0bfee17 	ldw	r2,-72(fp)
 8008d30:	10c00104 	addi	r3,r2,4
 8008d34:	e0ffee15 	stw	r3,-72(fp)
 8008d38:	e0ffed17 	ldw	r3,-76(fp)
 8008d3c:	19000104 	addi	r4,r3,4
 8008d40:	e13fed15 	stw	r4,-76(fp)
 8008d44:	18c00017 	ldw	r3,0(r3)
 8008d48:	10c00015 	stw	r3,0(r2)
 8008d4c:	e0bfee17 	ldw	r2,-72(fp)
 8008d50:	10c00104 	addi	r3,r2,4
 8008d54:	e0ffee15 	stw	r3,-72(fp)
 8008d58:	e0ffed17 	ldw	r3,-76(fp)
 8008d5c:	19000104 	addi	r4,r3,4
 8008d60:	e13fed15 	stw	r4,-76(fp)
 8008d64:	18c00017 	ldw	r3,0(r3)
 8008d68:	10c00015 	stw	r3,0(r2)
 8008d6c:	e0bffa17 	ldw	r2,-24(fp)
 8008d70:	10800730 	cmpltui	r2,r2,28
 8008d74:	1000231e 	bne	r2,zero,8008e04 <_realloc_r+0xa78>
 8008d78:	e0bfee17 	ldw	r2,-72(fp)
 8008d7c:	10c00104 	addi	r3,r2,4
 8008d80:	e0ffee15 	stw	r3,-72(fp)
 8008d84:	e0ffed17 	ldw	r3,-76(fp)
 8008d88:	19000104 	addi	r4,r3,4
 8008d8c:	e13fed15 	stw	r4,-76(fp)
 8008d90:	18c00017 	ldw	r3,0(r3)
 8008d94:	10c00015 	stw	r3,0(r2)
 8008d98:	e0bfee17 	ldw	r2,-72(fp)
 8008d9c:	10c00104 	addi	r3,r2,4
 8008da0:	e0ffee15 	stw	r3,-72(fp)
 8008da4:	e0ffed17 	ldw	r3,-76(fp)
 8008da8:	19000104 	addi	r4,r3,4
 8008dac:	e13fed15 	stw	r4,-76(fp)
 8008db0:	18c00017 	ldw	r3,0(r3)
 8008db4:	10c00015 	stw	r3,0(r2)
 8008db8:	e0bffa17 	ldw	r2,-24(fp)
 8008dbc:	10800930 	cmpltui	r2,r2,36
 8008dc0:	1000101e 	bne	r2,zero,8008e04 <_realloc_r+0xa78>
 8008dc4:	e0bfee17 	ldw	r2,-72(fp)
 8008dc8:	10c00104 	addi	r3,r2,4
 8008dcc:	e0ffee15 	stw	r3,-72(fp)
 8008dd0:	e0ffed17 	ldw	r3,-76(fp)
 8008dd4:	19000104 	addi	r4,r3,4
 8008dd8:	e13fed15 	stw	r4,-76(fp)
 8008ddc:	18c00017 	ldw	r3,0(r3)
 8008de0:	10c00015 	stw	r3,0(r2)
 8008de4:	e0bfee17 	ldw	r2,-72(fp)
 8008de8:	10c00104 	addi	r3,r2,4
 8008dec:	e0ffee15 	stw	r3,-72(fp)
 8008df0:	e0ffed17 	ldw	r3,-76(fp)
 8008df4:	19000104 	addi	r4,r3,4
 8008df8:	e13fed15 	stw	r4,-76(fp)
 8008dfc:	18c00017 	ldw	r3,0(r3)
 8008e00:	10c00015 	stw	r3,0(r2)
 8008e04:	e0bfee17 	ldw	r2,-72(fp)
 8008e08:	10c00104 	addi	r3,r2,4
 8008e0c:	e0ffee15 	stw	r3,-72(fp)
 8008e10:	e0ffed17 	ldw	r3,-76(fp)
 8008e14:	19000104 	addi	r4,r3,4
 8008e18:	e13fed15 	stw	r4,-76(fp)
 8008e1c:	18c00017 	ldw	r3,0(r3)
 8008e20:	10c00015 	stw	r3,0(r2)
 8008e24:	e0bfee17 	ldw	r2,-72(fp)
 8008e28:	10c00104 	addi	r3,r2,4
 8008e2c:	e0ffee15 	stw	r3,-72(fp)
 8008e30:	e0ffed17 	ldw	r3,-76(fp)
 8008e34:	19000104 	addi	r4,r3,4
 8008e38:	e13fed15 	stw	r4,-76(fp)
 8008e3c:	18c00017 	ldw	r3,0(r3)
 8008e40:	10c00015 	stw	r3,0(r2)
 8008e44:	e0bfed17 	ldw	r2,-76(fp)
 8008e48:	10c00017 	ldw	r3,0(r2)
 8008e4c:	e0bfee17 	ldw	r2,-72(fp)
 8008e50:	10c00015 	stw	r3,0(r2)
 8008e54:	00000406 	br	8008e68 <_realloc_r+0xadc>
 8008e58:	e1bffa17 	ldw	r6,-24(fp)
 8008e5c:	e17ffe17 	ldw	r5,-8(fp)
 8008e60:	e13ff617 	ldw	r4,-40(fp)
 8008e64:	8007fc00 	call	8007fc0 <memmove>
    fREe(RCALL oldmem);
 8008e68:	e17ffe17 	ldw	r5,-8(fp)
 8008e6c:	e13ffd17 	ldw	r4,-12(fp)
 8008e70:	8009a040 	call	8009a04 <_free_r>
    MALLOC_UNLOCK;
 8008e74:	e13ffd17 	ldw	r4,-12(fp)
 8008e78:	800aa880 	call	800aa88 <__malloc_unlock>
    return newmem;
 8008e7c:	e0bff617 	ldw	r2,-40(fp)
 8008e80:	00003906 	br	8008f68 <_realloc_r+0xbdc>
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
 8008e84:	e0ffe417 	ldw	r3,-112(fp)
 8008e88:	e0bff117 	ldw	r2,-60(fp)
 8008e8c:	1885c83a 	sub	r2,r3,r2
 8008e90:	e0bffb15 	stw	r2,-20(fp)

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
 8008e94:	e0bffb17 	ldw	r2,-20(fp)
 8008e98:	10800430 	cmpltui	r2,r2,16
 8008e9c:	10001e1e 	bne	r2,zero,8008f18 <_realloc_r+0xb8c>
  {
    remainder = chunk_at_offset(newp, nb);
 8008ea0:	e0ffe317 	ldw	r3,-116(fp)
 8008ea4:	e0bff117 	ldw	r2,-60(fp)
 8008ea8:	1885883a 	add	r2,r3,r2
 8008eac:	e0bffc15 	stw	r2,-16(fp)
    set_head_size(newp, nb);
 8008eb0:	e0bfe317 	ldw	r2,-116(fp)
 8008eb4:	10800117 	ldw	r2,4(r2)
 8008eb8:	10c0004c 	andi	r3,r2,1
 8008ebc:	e0bff117 	ldw	r2,-60(fp)
 8008ec0:	1886b03a 	or	r3,r3,r2
 8008ec4:	e0bfe317 	ldw	r2,-116(fp)
 8008ec8:	10c00115 	stw	r3,4(r2)
    set_head(remainder, remainder_size | PREV_INUSE);
 8008ecc:	e0bffb17 	ldw	r2,-20(fp)
 8008ed0:	10c00054 	ori	r3,r2,1
 8008ed4:	e0bffc17 	ldw	r2,-16(fp)
 8008ed8:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(remainder, remainder_size);
 8008edc:	e0fffc17 	ldw	r3,-16(fp)
 8008ee0:	e0bffb17 	ldw	r2,-20(fp)
 8008ee4:	1885883a 	add	r2,r3,r2
 8008ee8:	e13ffc17 	ldw	r4,-16(fp)
 8008eec:	e0fffb17 	ldw	r3,-20(fp)
 8008ef0:	20c7883a 	add	r3,r4,r3
 8008ef4:	18c00117 	ldw	r3,4(r3)
 8008ef8:	18c00054 	ori	r3,r3,1
 8008efc:	10c00115 	stw	r3,4(r2)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
 8008f00:	e0bffc17 	ldw	r2,-16(fp)
 8008f04:	10800204 	addi	r2,r2,8
 8008f08:	100b883a 	mov	r5,r2
 8008f0c:	e13ffd17 	ldw	r4,-12(fp)
 8008f10:	8009a040 	call	8009a04 <_free_r>
 8008f14:	00001006 	br	8008f58 <_realloc_r+0xbcc>
  }
  else
  {
    set_head_size(newp, newsize);
 8008f18:	e0bfe317 	ldw	r2,-116(fp)
 8008f1c:	10800117 	ldw	r2,4(r2)
 8008f20:	10c0004c 	andi	r3,r2,1
 8008f24:	e0bfe417 	ldw	r2,-112(fp)
 8008f28:	1886b03a 	or	r3,r3,r2
 8008f2c:	e0bfe317 	ldw	r2,-116(fp)
 8008f30:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(newp, newsize);
 8008f34:	e0ffe317 	ldw	r3,-116(fp)
 8008f38:	e0bfe417 	ldw	r2,-112(fp)
 8008f3c:	1885883a 	add	r2,r3,r2
 8008f40:	e13fe317 	ldw	r4,-116(fp)
 8008f44:	e0ffe417 	ldw	r3,-112(fp)
 8008f48:	20c7883a 	add	r3,r4,r3
 8008f4c:	18c00117 	ldw	r3,4(r3)
 8008f50:	18c00054 	ori	r3,r3,1
 8008f54:	10c00115 	stw	r3,4(r2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
 8008f58:	e13ffd17 	ldw	r4,-12(fp)
 8008f5c:	800aa880 	call	800aa88 <__malloc_unlock>
  return chunk2mem(newp);
 8008f60:	e0bfe317 	ldw	r2,-116(fp)
 8008f64:	10800204 	addi	r2,r2,8

#endif /* MALLOC_PROVIDED */
}
 8008f68:	e037883a 	mov	sp,fp
 8008f6c:	dfc00117 	ldw	ra,4(sp)
 8008f70:	df000017 	ldw	fp,0(sp)
 8008f74:	dec00204 	addi	sp,sp,8
 8008f78:	f800283a 	ret

08008f7c <_sbrk_r>:

void *
_DEFUN (_sbrk_r, (ptr, incr),
     struct _reent *ptr _AND
     ptrdiff_t incr)
{
 8008f7c:	defffb04 	addi	sp,sp,-20
 8008f80:	dfc00415 	stw	ra,16(sp)
 8008f84:	df000315 	stw	fp,12(sp)
 8008f88:	df000304 	addi	fp,sp,12
 8008f8c:	e13ffe15 	stw	r4,-8(fp)
 8008f90:	e17fff15 	stw	r5,-4(fp)
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
 8008f94:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
 8008f98:	e13fff17 	ldw	r4,-4(fp)
 8008f9c:	800ac480 	call	800ac48 <sbrk>
 8008fa0:	e0bffd15 	stw	r2,-12(fp)
 8008fa4:	e0bffd17 	ldw	r2,-12(fp)
 8008fa8:	10bfffd8 	cmpnei	r2,r2,-1
 8008fac:	1000051e 	bne	r2,zero,8008fc4 <_sbrk_r+0x48>
 8008fb0:	d0a76a17 	ldw	r2,-25176(gp)
 8008fb4:	10000326 	beq	r2,zero,8008fc4 <_sbrk_r+0x48>
    ptr->_errno = errno;
 8008fb8:	d0e76a17 	ldw	r3,-25176(gp)
 8008fbc:	e0bffe17 	ldw	r2,-8(fp)
 8008fc0:	10c00015 	stw	r3,0(r2)
  return ret;
 8008fc4:	e0bffd17 	ldw	r2,-12(fp)
}
 8008fc8:	e037883a 	mov	sp,fp
 8008fcc:	dfc00117 	ldw	ra,4(sp)
 8008fd0:	df000017 	ldw	fp,0(sp)
 8008fd4:	dec00204 	addi	sp,sp,8
 8008fd8:	f800283a 	ret

08008fdc <__sread>:
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
 8008fdc:	defff804 	addi	sp,sp,-32
 8008fe0:	dfc00715 	stw	ra,28(sp)
 8008fe4:	df000615 	stw	fp,24(sp)
 8008fe8:	dc400515 	stw	r17,20(sp)
 8008fec:	dc000415 	stw	r16,16(sp)
 8008ff0:	df000604 	addi	fp,sp,24
 8008ff4:	e13ffa15 	stw	r4,-24(fp)
 8008ff8:	e17ffb15 	stw	r5,-20(fp)
 8008ffc:	e1bffc15 	stw	r6,-16(fp)
 8009000:	e1fffd15 	stw	r7,-12(fp)
  register FILE *fp = (FILE *) cookie;
 8009004:	e43ffb17 	ldw	r16,-20(fp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
 8009008:	8080038b 	ldhu	r2,14(r16)
 800900c:	10bfffcc 	andi	r2,r2,65535
 8009010:	10a0001c 	xori	r2,r2,32768
 8009014:	10a00004 	addi	r2,r2,-32768
 8009018:	e0fffd17 	ldw	r3,-12(fp)
 800901c:	180f883a 	mov	r7,r3
 8009020:	e1bffc17 	ldw	r6,-16(fp)
 8009024:	100b883a 	mov	r5,r2
 8009028:	e13ffa17 	ldw	r4,-24(fp)
 800902c:	800a3cc0 	call	800a3cc <_read_r>
 8009030:	1023883a 	mov	r17,r2
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
 8009034:	88000416 	blt	r17,zero,8009048 <__sread+0x6c>
    fp->_offset += ret;
 8009038:	80801417 	ldw	r2,80(r16)
 800903c:	1445883a 	add	r2,r2,r17
 8009040:	80801415 	stw	r2,80(r16)
 8009044:	00000406 	br	8009058 <__sread+0x7c>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
 8009048:	80c0030b 	ldhu	r3,12(r16)
 800904c:	00bbffc4 	movi	r2,-4097
 8009050:	1884703a 	and	r2,r3,r2
 8009054:	8080030d 	sth	r2,12(r16)
  return ret;
 8009058:	8805883a 	mov	r2,r17
}
 800905c:	e6fffe04 	addi	sp,fp,-8
 8009060:	dfc00317 	ldw	ra,12(sp)
 8009064:	df000217 	ldw	fp,8(sp)
 8009068:	dc400117 	ldw	r17,4(sp)
 800906c:	dc000017 	ldw	r16,0(sp)
 8009070:	dec00404 	addi	sp,sp,16
 8009074:	f800283a 	ret

08009078 <__seofread>:
_DEFUN(__seofread, (ptr, cookie, buf, len),
       struct _reent *_ptr _AND
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
 8009078:	defffb04 	addi	sp,sp,-20
 800907c:	df000415 	stw	fp,16(sp)
 8009080:	df000404 	addi	fp,sp,16
 8009084:	e13ffc15 	stw	r4,-16(fp)
 8009088:	e17ffd15 	stw	r5,-12(fp)
 800908c:	e1bffe15 	stw	r6,-8(fp)
 8009090:	e1ffff15 	stw	r7,-4(fp)
  return 0;
 8009094:	0005883a 	mov	r2,zero
}
 8009098:	e037883a 	mov	sp,fp
 800909c:	df000017 	ldw	fp,0(sp)
 80090a0:	dec00104 	addi	sp,sp,4
 80090a4:	f800283a 	ret

080090a8 <__swrite>:
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
 80090a8:	defff804 	addi	sp,sp,-32
 80090ac:	dfc00715 	stw	ra,28(sp)
 80090b0:	df000615 	stw	fp,24(sp)
 80090b4:	dc000515 	stw	r16,20(sp)
 80090b8:	df000604 	addi	fp,sp,24
 80090bc:	e13ffb15 	stw	r4,-20(fp)
 80090c0:	e17ffc15 	stw	r5,-16(fp)
 80090c4:	e1bffd15 	stw	r6,-12(fp)
 80090c8:	e1fffe15 	stw	r7,-8(fp)
  register FILE *fp = (FILE *) cookie;
 80090cc:	e43ffc17 	ldw	r16,-16(fp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
 80090d0:	8080030b 	ldhu	r2,12(r16)
 80090d4:	10bfffcc 	andi	r2,r2,65535
 80090d8:	1080400c 	andi	r2,r2,256
 80090dc:	10000926 	beq	r2,zero,8009104 <__swrite+0x5c>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
 80090e0:	8080038b 	ldhu	r2,14(r16)
 80090e4:	10bfffcc 	andi	r2,r2,65535
 80090e8:	10a0001c 	xori	r2,r2,32768
 80090ec:	10a00004 	addi	r2,r2,-32768
 80090f0:	01c00084 	movi	r7,2
 80090f4:	000d883a 	mov	r6,zero
 80090f8:	100b883a 	mov	r5,r2
 80090fc:	e13ffb17 	ldw	r4,-20(fp)
 8009100:	800a1300 	call	800a130 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
 8009104:	80c0030b 	ldhu	r3,12(r16)
 8009108:	00bbffc4 	movi	r2,-4097
 800910c:	1884703a 	and	r2,r3,r2
 8009110:	8080030d 	sth	r2,12(r16)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
 8009114:	8080038b 	ldhu	r2,14(r16)
 8009118:	10bfffcc 	andi	r2,r2,65535
 800911c:	10a0001c 	xori	r2,r2,32768
 8009120:	10a00004 	addi	r2,r2,-32768
 8009124:	e0fffe17 	ldw	r3,-8(fp)
 8009128:	180f883a 	mov	r7,r3
 800912c:	e1bffd17 	ldw	r6,-12(fp)
 8009130:	100b883a 	mov	r5,r2
 8009134:	e13ffb17 	ldw	r4,-20(fp)
 8009138:	80092500 	call	8009250 <_write_r>
 800913c:	e0bffa15 	stw	r2,-24(fp)
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
 8009140:	e0bffa17 	ldw	r2,-24(fp)
}
 8009144:	e6ffff04 	addi	sp,fp,-4
 8009148:	dfc00217 	ldw	ra,8(sp)
 800914c:	df000117 	ldw	fp,4(sp)
 8009150:	dc000017 	ldw	r16,0(sp)
 8009154:	dec00304 	addi	sp,sp,12
 8009158:	f800283a 	ret

0800915c <__sseek>:
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
 800915c:	defff804 	addi	sp,sp,-32
 8009160:	dfc00715 	stw	ra,28(sp)
 8009164:	df000615 	stw	fp,24(sp)
 8009168:	dc400515 	stw	r17,20(sp)
 800916c:	dc000415 	stw	r16,16(sp)
 8009170:	df000604 	addi	fp,sp,24
 8009174:	e13ffa15 	stw	r4,-24(fp)
 8009178:	e17ffb15 	stw	r5,-20(fp)
 800917c:	e1bffc15 	stw	r6,-16(fp)
 8009180:	e1fffd15 	stw	r7,-12(fp)
  register FILE *fp = (FILE *) cookie;
 8009184:	e43ffb17 	ldw	r16,-20(fp)
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
 8009188:	8080038b 	ldhu	r2,14(r16)
 800918c:	10bfffcc 	andi	r2,r2,65535
 8009190:	10a0001c 	xori	r2,r2,32768
 8009194:	10a00004 	addi	r2,r2,-32768
 8009198:	e1fffd17 	ldw	r7,-12(fp)
 800919c:	e1bffc17 	ldw	r6,-16(fp)
 80091a0:	100b883a 	mov	r5,r2
 80091a4:	e13ffa17 	ldw	r4,-24(fp)
 80091a8:	800a1300 	call	800a130 <_lseek_r>
 80091ac:	1023883a 	mov	r17,r2
  if (ret == -1L)
 80091b0:	88bfffd8 	cmpnei	r2,r17,-1
 80091b4:	1000051e 	bne	r2,zero,80091cc <__sseek+0x70>
    fp->_flags &= ~__SOFF;
 80091b8:	80c0030b 	ldhu	r3,12(r16)
 80091bc:	00bbffc4 	movi	r2,-4097
 80091c0:	1884703a 	and	r2,r3,r2
 80091c4:	8080030d 	sth	r2,12(r16)
 80091c8:	00000406 	br	80091dc <__sseek+0x80>
  else
    {
      fp->_flags |= __SOFF;
 80091cc:	8080030b 	ldhu	r2,12(r16)
 80091d0:	10840014 	ori	r2,r2,4096
 80091d4:	8080030d 	sth	r2,12(r16)
      fp->_offset = ret;
 80091d8:	84401415 	stw	r17,80(r16)
    }
  return ret;
 80091dc:	8805883a 	mov	r2,r17
}
 80091e0:	e6fffe04 	addi	sp,fp,-8
 80091e4:	dfc00317 	ldw	ra,12(sp)
 80091e8:	df000217 	ldw	fp,8(sp)
 80091ec:	dc400117 	ldw	r17,4(sp)
 80091f0:	dc000017 	ldw	r16,0(sp)
 80091f4:	dec00404 	addi	sp,sp,16
 80091f8:	f800283a 	ret

080091fc <__sclose>:

int
_DEFUN(__sclose, (ptr, cookie),
       struct _reent *ptr _AND
       void *cookie)
{
 80091fc:	defffb04 	addi	sp,sp,-20
 8009200:	dfc00415 	stw	ra,16(sp)
 8009204:	df000315 	stw	fp,12(sp)
 8009208:	df000304 	addi	fp,sp,12
 800920c:	e13ffe15 	stw	r4,-8(fp)
 8009210:	e17fff15 	stw	r5,-4(fp)
  FILE *fp = (FILE *) cookie;
 8009214:	e0bfff17 	ldw	r2,-4(fp)
 8009218:	e0bffd15 	stw	r2,-12(fp)

  return _close_r (ptr, fp->_file);
 800921c:	e0bffd17 	ldw	r2,-12(fp)
 8009220:	1080038b 	ldhu	r2,14(r2)
 8009224:	10bfffcc 	andi	r2,r2,65535
 8009228:	10a0001c 	xori	r2,r2,32768
 800922c:	10a00004 	addi	r2,r2,-32768
 8009230:	100b883a 	mov	r5,r2
 8009234:	e13ffe17 	ldw	r4,-8(fp)
 8009238:	80094600 	call	8009460 <_close_r>
}
 800923c:	e037883a 	mov	sp,fp
 8009240:	dfc00117 	ldw	ra,4(sp)
 8009244:	df000017 	ldw	fp,0(sp)
 8009248:	dec00204 	addi	sp,sp,8
 800924c:	f800283a 	ret

08009250 <_write_r>:
_DEFUN (_write_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _CONST _PTR buf _AND
     size_t cnt)
{
 8009250:	defff904 	addi	sp,sp,-28
 8009254:	dfc00615 	stw	ra,24(sp)
 8009258:	df000515 	stw	fp,20(sp)
 800925c:	df000504 	addi	fp,sp,20
 8009260:	e13ffc15 	stw	r4,-16(fp)
 8009264:	e17ffd15 	stw	r5,-12(fp)
 8009268:	e1bffe15 	stw	r6,-8(fp)
 800926c:	e1ffff15 	stw	r7,-4(fp)
  _ssize_t ret;

  errno = 0;
 8009270:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
 8009274:	e1bfff17 	ldw	r6,-4(fp)
 8009278:	e17ffe17 	ldw	r5,-8(fp)
 800927c:	e13ffd17 	ldw	r4,-12(fp)
 8009280:	800ad340 	call	800ad34 <write>
 8009284:	e0bffb15 	stw	r2,-20(fp)
 8009288:	e0bffb17 	ldw	r2,-20(fp)
 800928c:	10bfffd8 	cmpnei	r2,r2,-1
 8009290:	1000051e 	bne	r2,zero,80092a8 <_write_r+0x58>
 8009294:	d0a76a17 	ldw	r2,-25176(gp)
 8009298:	10000326 	beq	r2,zero,80092a8 <_write_r+0x58>
    ptr->_errno = errno;
 800929c:	d0e76a17 	ldw	r3,-25176(gp)
 80092a0:	e0bffc17 	ldw	r2,-16(fp)
 80092a4:	10c00015 	stw	r3,0(r2)
  return ret;
 80092a8:	e0bffb17 	ldw	r2,-20(fp)
}
 80092ac:	e037883a 	mov	sp,fp
 80092b0:	dfc00117 	ldw	ra,4(sp)
 80092b4:	df000017 	ldw	fp,0(sp)
 80092b8:	dec00204 	addi	sp,sp,8
 80092bc:	f800283a 	ret

080092c0 <__swsetup_r>:

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 80092c0:	defffb04 	addi	sp,sp,-20
 80092c4:	dfc00415 	stw	ra,16(sp)
 80092c8:	df000315 	stw	fp,12(sp)
 80092cc:	dc000215 	stw	r16,8(sp)
 80092d0:	df000304 	addi	fp,sp,12
 80092d4:	e13ffe15 	stw	r4,-8(fp)
 80092d8:	2821883a 	mov	r16,r5
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
 80092dc:	d0a04217 	ldw	r2,-32504(gp)
 80092e0:	e0bffd15 	stw	r2,-12(fp)
 80092e4:	e0bffd17 	ldw	r2,-12(fp)
 80092e8:	10000526 	beq	r2,zero,8009300 <__swsetup_r+0x40>
 80092ec:	e0bffd17 	ldw	r2,-12(fp)
 80092f0:	10800e17 	ldw	r2,56(r2)
 80092f4:	1000021e 	bne	r2,zero,8009300 <__swsetup_r+0x40>
 80092f8:	e13ffd17 	ldw	r4,-12(fp)
 80092fc:	800639c0 	call	800639c <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
 8009300:	8080030b 	ldhu	r2,12(r16)
 8009304:	10bfffcc 	andi	r2,r2,65535
 8009308:	1080020c 	andi	r2,r2,8
 800930c:	1000241e 	bne	r2,zero,80093a0 <__swsetup_r+0xe0>
    {
      if ((fp->_flags & __SRW) == 0)
 8009310:	8080030b 	ldhu	r2,12(r16)
 8009314:	10bfffcc 	andi	r2,r2,65535
 8009318:	1080040c 	andi	r2,r2,16
 800931c:	1000081e 	bne	r2,zero,8009340 <__swsetup_r+0x80>
        {
	  ptr->_errno = EBADF;
 8009320:	e0bffe17 	ldw	r2,-8(fp)
 8009324:	00c00244 	movi	r3,9
 8009328:	10c00015 	stw	r3,0(r2)
	  fp->_flags |= __SERR;
 800932c:	8080030b 	ldhu	r2,12(r16)
 8009330:	10801014 	ori	r2,r2,64
 8009334:	8080030d 	sth	r2,12(r16)
	  return EOF;
 8009338:	00bfffc4 	movi	r2,-1
 800933c:	00004206 	br	8009448 <__swsetup_r+0x188>
        }
      if (fp->_flags & __SRD)
 8009340:	8080030b 	ldhu	r2,12(r16)
 8009344:	10bfffcc 	andi	r2,r2,65535
 8009348:	1080010c 	andi	r2,r2,4
 800934c:	10001126 	beq	r2,zero,8009394 <__swsetup_r+0xd4>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
 8009350:	80800c17 	ldw	r2,48(r16)
 8009354:	10000826 	beq	r2,zero,8009378 <__swsetup_r+0xb8>
	    FREEUB (ptr, fp);
 8009358:	80c00c17 	ldw	r3,48(r16)
 800935c:	80801004 	addi	r2,r16,64
 8009360:	18800426 	beq	r3,r2,8009374 <__swsetup_r+0xb4>
 8009364:	80800c17 	ldw	r2,48(r16)
 8009368:	100b883a 	mov	r5,r2
 800936c:	e13ffe17 	ldw	r4,-8(fp)
 8009370:	8009a040 	call	8009a04 <_free_r>
 8009374:	80000c15 	stw	zero,48(r16)
	  fp->_flags &= ~(__SRD | __SEOF);
 8009378:	80c0030b 	ldhu	r3,12(r16)
 800937c:	00bff6c4 	movi	r2,-37
 8009380:	1884703a 	and	r2,r3,r2
 8009384:	8080030d 	sth	r2,12(r16)
	  fp->_r = 0;
 8009388:	80000115 	stw	zero,4(r16)
	  fp->_p = fp->_bf._base;
 800938c:	80800417 	ldw	r2,16(r16)
 8009390:	80800015 	stw	r2,0(r16)
	}
      fp->_flags |= __SWR;
 8009394:	8080030b 	ldhu	r2,12(r16)
 8009398:	10800214 	ori	r2,r2,8
 800939c:	8080030d 	sth	r2,12(r16)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
 80093a0:	80800417 	ldw	r2,16(r16)
 80093a4:	10000b1e 	bne	r2,zero,80093d4 <__swsetup_r+0x114>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
 80093a8:	8080030b 	ldhu	r2,12(r16)
 80093ac:	10bfffcc 	andi	r2,r2,65535
 80093b0:	1080800c 	andi	r2,r2,512
 80093b4:	10000426 	beq	r2,zero,80093c8 <__swsetup_r+0x108>
 80093b8:	8080030b 	ldhu	r2,12(r16)
 80093bc:	10bfffcc 	andi	r2,r2,65535
 80093c0:	1080200c 	andi	r2,r2,128
 80093c4:	10000326 	beq	r2,zero,80093d4 <__swsetup_r+0x114>
    __smakebuf_r (ptr, fp);
 80093c8:	800b883a 	mov	r5,r16
 80093cc:	e13ffe17 	ldw	r4,-8(fp)
 80093d0:	800a1a00 	call	800a1a0 <__smakebuf_r>

  if (fp->_flags & __SLBF)
 80093d4:	8080030b 	ldhu	r2,12(r16)
 80093d8:	10bfffcc 	andi	r2,r2,65535
 80093dc:	1080004c 	andi	r2,r2,1
 80093e0:	10000526 	beq	r2,zero,80093f8 <__swsetup_r+0x138>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
 80093e4:	80000215 	stw	zero,8(r16)
      fp->_lbfsize = -fp->_bf._size;
 80093e8:	80800517 	ldw	r2,20(r16)
 80093ec:	0085c83a 	sub	r2,zero,r2
 80093f0:	80800615 	stw	r2,24(r16)
 80093f4:	00000806 	br	8009418 <__swsetup_r+0x158>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
 80093f8:	8080030b 	ldhu	r2,12(r16)
 80093fc:	10bfffcc 	andi	r2,r2,65535
 8009400:	1080008c 	andi	r2,r2,2
 8009404:	1000021e 	bne	r2,zero,8009410 <__swsetup_r+0x150>
 8009408:	80800517 	ldw	r2,20(r16)
 800940c:	00000106 	br	8009414 <__swsetup_r+0x154>
 8009410:	0005883a 	mov	r2,zero
 8009414:	80800215 	stw	r2,8(r16)

  if (!fp->_bf._base && (fp->_flags & __SMBF))
 8009418:	80800417 	ldw	r2,16(r16)
 800941c:	1000091e 	bne	r2,zero,8009444 <__swsetup_r+0x184>
 8009420:	8080030b 	ldhu	r2,12(r16)
 8009424:	10bfffcc 	andi	r2,r2,65535
 8009428:	1080200c 	andi	r2,r2,128
 800942c:	10000526 	beq	r2,zero,8009444 <__swsetup_r+0x184>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
 8009430:	8080030b 	ldhu	r2,12(r16)
 8009434:	10801014 	ori	r2,r2,64
 8009438:	8080030d 	sth	r2,12(r16)
      return EOF;
 800943c:	00bfffc4 	movi	r2,-1
 8009440:	00000106 	br	8009448 <__swsetup_r+0x188>
    }
  return 0;
 8009444:	0005883a 	mov	r2,zero
}
 8009448:	e6ffff04 	addi	sp,fp,-4
 800944c:	dfc00217 	ldw	ra,8(sp)
 8009450:	df000117 	ldw	fp,4(sp)
 8009454:	dc000017 	ldw	r16,0(sp)
 8009458:	dec00304 	addi	sp,sp,12
 800945c:	f800283a 	ret

08009460 <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 8009460:	defffb04 	addi	sp,sp,-20
 8009464:	dfc00415 	stw	ra,16(sp)
 8009468:	df000315 	stw	fp,12(sp)
 800946c:	df000304 	addi	fp,sp,12
 8009470:	e13ffe15 	stw	r4,-8(fp)
 8009474:	e17fff15 	stw	r5,-4(fp)
  int ret;

  errno = 0;
 8009478:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = _close (fd)) == -1 && errno != 0)
 800947c:	e13fff17 	ldw	r4,-4(fp)
 8009480:	800a5400 	call	800a540 <close>
 8009484:	e0bffd15 	stw	r2,-12(fp)
 8009488:	e0bffd17 	ldw	r2,-12(fp)
 800948c:	10bfffd8 	cmpnei	r2,r2,-1
 8009490:	1000051e 	bne	r2,zero,80094a8 <_close_r+0x48>
 8009494:	d0a76a17 	ldw	r2,-25176(gp)
 8009498:	10000326 	beq	r2,zero,80094a8 <_close_r+0x48>
    ptr->_errno = errno;
 800949c:	d0e76a17 	ldw	r3,-25176(gp)
 80094a0:	e0bffe17 	ldw	r2,-8(fp)
 80094a4:	10c00015 	stw	r3,0(r2)
  return ret;
 80094a8:	e0bffd17 	ldw	r2,-12(fp)
}
 80094ac:	e037883a 	mov	sp,fp
 80094b0:	dfc00117 	ldw	ra,4(sp)
 80094b4:	df000017 	ldw	fp,0(sp)
 80094b8:	dec00204 	addi	sp,sp,8
 80094bc:	f800283a 	ret

080094c0 <_fclose_r>:

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
 80094c0:	defffa04 	addi	sp,sp,-24
 80094c4:	dfc00515 	stw	ra,20(sp)
 80094c8:	df000415 	stw	fp,16(sp)
 80094cc:	dc000315 	stw	r16,12(sp)
 80094d0:	df000404 	addi	fp,sp,16
 80094d4:	e13ffe15 	stw	r4,-8(fp)
 80094d8:	2821883a 	mov	r16,r5
  int r;

  if (fp == NULL)
 80094dc:	8000021e 	bne	r16,zero,80094e8 <_fclose_r+0x28>
    return (0);			/* on NULL */
 80094e0:	0005883a 	mov	r2,zero
 80094e4:	00003b06 	br	80095d4 <_fclose_r+0x114>

  CHECK_INIT (rptr, fp);
 80094e8:	e0bffe17 	ldw	r2,-8(fp)
 80094ec:	e0bffd15 	stw	r2,-12(fp)
 80094f0:	e0bffd17 	ldw	r2,-12(fp)
 80094f4:	10000526 	beq	r2,zero,800950c <_fclose_r+0x4c>
 80094f8:	e0bffd17 	ldw	r2,-12(fp)
 80094fc:	10800e17 	ldw	r2,56(r2)
 8009500:	1000021e 	bne	r2,zero,800950c <_fclose_r+0x4c>
 8009504:	e13ffd17 	ldw	r4,-12(fp)
 8009508:	800639c0 	call	800639c <__sinit>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
 800950c:	8080030b 	ldhu	r2,12(r16)
 8009510:	10bfffcc 	andi	r2,r2,65535
 8009514:	10a0001c 	xori	r2,r2,32768
 8009518:	10a00004 	addi	r2,r2,-32768
 800951c:	1000021e 	bne	r2,zero,8009528 <_fclose_r+0x68>
    {
      _funlockfile (fp);
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
 8009520:	0005883a 	mov	r2,zero
 8009524:	00002b06 	br	80095d4 <_fclose_r+0x114>
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
 8009528:	800b883a 	mov	r5,r16
 800952c:	e13ffe17 	ldw	r4,-8(fp)
 8009530:	80096240 	call	8009624 <__sflush_r>
 8009534:	e0bffc15 	stw	r2,-16(fp)
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
 8009538:	80800b17 	ldw	r2,44(r16)
 800953c:	10000826 	beq	r2,zero,8009560 <_fclose_r+0xa0>
 8009540:	80800b17 	ldw	r2,44(r16)
 8009544:	80c00717 	ldw	r3,28(r16)
 8009548:	180b883a 	mov	r5,r3
 800954c:	e13ffe17 	ldw	r4,-8(fp)
 8009550:	103ee83a 	callr	r2
 8009554:	1000020e 	bge	r2,zero,8009560 <_fclose_r+0xa0>
    r = EOF;
 8009558:	00bfffc4 	movi	r2,-1
 800955c:	e0bffc15 	stw	r2,-16(fp)
  if (fp->_flags & __SMBF)
 8009560:	8080030b 	ldhu	r2,12(r16)
 8009564:	10bfffcc 	andi	r2,r2,65535
 8009568:	1080200c 	andi	r2,r2,128
 800956c:	10000426 	beq	r2,zero,8009580 <_fclose_r+0xc0>
    _free_r (rptr, (char *) fp->_bf._base);
 8009570:	80800417 	ldw	r2,16(r16)
 8009574:	100b883a 	mov	r5,r2
 8009578:	e13ffe17 	ldw	r4,-8(fp)
 800957c:	8009a040 	call	8009a04 <_free_r>
  if (HASUB (fp))
 8009580:	80800c17 	ldw	r2,48(r16)
 8009584:	10000826 	beq	r2,zero,80095a8 <_fclose_r+0xe8>
    FREEUB (rptr, fp);
 8009588:	80c00c17 	ldw	r3,48(r16)
 800958c:	80801004 	addi	r2,r16,64
 8009590:	18800426 	beq	r3,r2,80095a4 <_fclose_r+0xe4>
 8009594:	80800c17 	ldw	r2,48(r16)
 8009598:	100b883a 	mov	r5,r2
 800959c:	e13ffe17 	ldw	r4,-8(fp)
 80095a0:	8009a040 	call	8009a04 <_free_r>
 80095a4:	80000c15 	stw	zero,48(r16)
  if (HASLB (fp))
 80095a8:	80801117 	ldw	r2,68(r16)
 80095ac:	10000526 	beq	r2,zero,80095c4 <_fclose_r+0x104>
    FREELB (rptr, fp);
 80095b0:	80801117 	ldw	r2,68(r16)
 80095b4:	100b883a 	mov	r5,r2
 80095b8:	e13ffe17 	ldw	r4,-8(fp)
 80095bc:	8009a040 	call	8009a04 <_free_r>
 80095c0:	80001115 	stw	zero,68(r16)
  __sfp_lock_acquire ();
 80095c4:	80064740 	call	8006474 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
 80095c8:	8000030d 	sth	zero,12(r16)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
 80095cc:	80064940 	call	8006494 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
 80095d0:	e0bffc17 	ldw	r2,-16(fp)
}
 80095d4:	e6ffff04 	addi	sp,fp,-4
 80095d8:	dfc00217 	ldw	ra,8(sp)
 80095dc:	df000117 	ldw	fp,4(sp)
 80095e0:	dc000017 	ldw	r16,0(sp)
 80095e4:	dec00304 	addi	sp,sp,12
 80095e8:	f800283a 	ret

080095ec <fclose>:
#ifndef _REENT_ONLY

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
 80095ec:	defffe04 	addi	sp,sp,-8
 80095f0:	dfc00115 	stw	ra,4(sp)
 80095f4:	df000015 	stw	fp,0(sp)
 80095f8:	d839883a 	mov	fp,sp
 80095fc:	2007883a 	mov	r3,r4
  return _fclose_r(_REENT, fp);
 8009600:	d0a04217 	ldw	r2,-32504(gp)
 8009604:	180b883a 	mov	r5,r3
 8009608:	1009883a 	mov	r4,r2
 800960c:	80094c00 	call	80094c0 <_fclose_r>
}
 8009610:	e037883a 	mov	sp,fp
 8009614:	dfc00117 	ldw	ra,4(sp)
 8009618:	df000017 	ldw	fp,0(sp)
 800961c:	dec00204 	addi	sp,sp,8
 8009620:	f800283a 	ret

08009624 <__sflush_r>:
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 8009624:	defff504 	addi	sp,sp,-44
 8009628:	dfc00a15 	stw	ra,40(sp)
 800962c:	df000915 	stw	fp,36(sp)
 8009630:	dcc00815 	stw	r19,32(sp)
 8009634:	dc800715 	stw	r18,28(sp)
 8009638:	dc400615 	stw	r17,24(sp)
 800963c:	dc000515 	stw	r16,20(sp)
 8009640:	df000904 	addi	fp,sp,36
 8009644:	e13ffb15 	stw	r4,-20(fp)
 8009648:	2821883a 	mov	r16,r5
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
 800964c:	8080030b 	ldhu	r2,12(r16)
 8009650:	e0bff90d 	sth	r2,-28(fp)
  if ((flags & __SWR) == 0)
 8009654:	e0bff90b 	ldhu	r2,-28(fp)
 8009658:	10bfffcc 	andi	r2,r2,65535
 800965c:	1080020c 	andi	r2,r2,8
 8009660:	1000831e 	bne	r2,zero,8009870 <__sflush_r+0x24c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
 8009664:	8080030b 	ldhu	r2,12(r16)
 8009668:	10820014 	ori	r2,r2,2048
 800966c:	8080030d 	sth	r2,12(r16)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
 8009670:	80800117 	ldw	r2,4(r16)
 8009674:	00800216 	blt	zero,r2,8009680 <__sflush_r+0x5c>
 8009678:	80800f17 	ldw	r2,60(r16)
 800967c:	00807a0e 	bge	zero,r2,8009868 <__sflush_r+0x244>
 8009680:	80800a17 	ldw	r2,40(r16)
 8009684:	10007826 	beq	r2,zero,8009868 <__sflush_r+0x244>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
 8009688:	e0bffb17 	ldw	r2,-20(fp)
 800968c:	10800017 	ldw	r2,0(r2)
 8009690:	e0bffa15 	stw	r2,-24(fp)
	  ptr->_errno = 0;
 8009694:	e0bffb17 	ldw	r2,-20(fp)
 8009698:	10000015 	stw	zero,0(r2)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
 800969c:	8080030b 	ldhu	r2,12(r16)
 80096a0:	10bfffcc 	andi	r2,r2,65535
 80096a4:	1084000c 	andi	r2,r2,4096
 80096a8:	10000326 	beq	r2,zero,80096b8 <__sflush_r+0x94>
	    curoff = fp->_offset;
 80096ac:	80801417 	ldw	r2,80(r16)
 80096b0:	e0bff715 	stw	r2,-36(fp)
 80096b4:	00002206 	br	8009740 <__sflush_r+0x11c>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
 80096b8:	80800a17 	ldw	r2,40(r16)
 80096bc:	80c00717 	ldw	r3,28(r16)
 80096c0:	01c00044 	movi	r7,1
 80096c4:	000d883a 	mov	r6,zero
 80096c8:	180b883a 	mov	r5,r3
 80096cc:	e13ffb17 	ldw	r4,-20(fp)
 80096d0:	103ee83a 	callr	r2
 80096d4:	e0bff715 	stw	r2,-36(fp)
	      if (curoff == -1L && ptr->_errno != 0)
 80096d8:	e0bff717 	ldw	r2,-36(fp)
 80096dc:	10bfffd8 	cmpnei	r2,r2,-1
 80096e0:	1000171e 	bne	r2,zero,8009740 <__sflush_r+0x11c>
 80096e4:	e0bffb17 	ldw	r2,-20(fp)
 80096e8:	10800017 	ldw	r2,0(r2)
 80096ec:	10001426 	beq	r2,zero,8009740 <__sflush_r+0x11c>
		{
		  int result = EOF;
 80096f0:	00bfffc4 	movi	r2,-1
 80096f4:	e0bff815 	stw	r2,-32(fp)
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 80096f8:	e0bffb17 	ldw	r2,-20(fp)
 80096fc:	10800017 	ldw	r2,0(r2)
 8009700:	10800760 	cmpeqi	r2,r2,29
 8009704:	1000041e 	bne	r2,zero,8009718 <__sflush_r+0xf4>
 8009708:	e0bffb17 	ldw	r2,-20(fp)
 800970c:	10800017 	ldw	r2,0(r2)
 8009710:	10800598 	cmpnei	r2,r2,22
 8009714:	1000051e 	bne	r2,zero,800972c <__sflush_r+0x108>
		    {
		      result = 0;
 8009718:	e03ff815 	stw	zero,-32(fp)
		      ptr->_errno = tmp_errno;
 800971c:	e0bffb17 	ldw	r2,-20(fp)
 8009720:	e0fffa17 	ldw	r3,-24(fp)
 8009724:	10c00015 	stw	r3,0(r2)
 8009728:	00000306 	br	8009738 <__sflush_r+0x114>
		    }
		  else
		    fp->_flags |= __SERR;
 800972c:	8080030b 	ldhu	r2,12(r16)
 8009730:	10801014 	ori	r2,r2,64
 8009734:	8080030d 	sth	r2,12(r16)
		  return result;
 8009738:	e0bff817 	ldw	r2,-32(fp)
 800973c:	00007106 	br	8009904 <__sflush_r+0x2e0>
		}
            }
          if (fp->_flags & __SRD)
 8009740:	8080030b 	ldhu	r2,12(r16)
 8009744:	10bfffcc 	andi	r2,r2,65535
 8009748:	1080010c 	andi	r2,r2,4
 800974c:	10000a26 	beq	r2,zero,8009778 <__sflush_r+0x154>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
 8009750:	80800117 	ldw	r2,4(r16)
 8009754:	e0fff717 	ldw	r3,-36(fp)
 8009758:	1885c83a 	sub	r2,r3,r2
 800975c:	e0bff715 	stw	r2,-36(fp)
              if (HASUB (fp))
 8009760:	80800c17 	ldw	r2,48(r16)
 8009764:	10000426 	beq	r2,zero,8009778 <__sflush_r+0x154>
                curoff -= fp->_ur;
 8009768:	80800f17 	ldw	r2,60(r16)
 800976c:	e0fff717 	ldw	r3,-36(fp)
 8009770:	1885c83a 	sub	r2,r3,r2
 8009774:	e0bff715 	stw	r2,-36(fp)
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
 8009778:	80800a17 	ldw	r2,40(r16)
 800977c:	80c00717 	ldw	r3,28(r16)
 8009780:	000f883a 	mov	r7,zero
 8009784:	e1bff717 	ldw	r6,-36(fp)
 8009788:	180b883a 	mov	r5,r3
 800978c:	e13ffb17 	ldw	r4,-20(fp)
 8009790:	103ee83a 	callr	r2
 8009794:	e0bff715 	stw	r2,-36(fp)
	  if (curoff != -1 || ptr->_errno == 0
 8009798:	e0bff717 	ldw	r2,-36(fp)
 800979c:	10bfffd8 	cmpnei	r2,r2,-1
 80097a0:	10000b1e 	bne	r2,zero,80097d0 <__sflush_r+0x1ac>
 80097a4:	e0bffb17 	ldw	r2,-20(fp)
 80097a8:	10800017 	ldw	r2,0(r2)
 80097ac:	10000826 	beq	r2,zero,80097d0 <__sflush_r+0x1ac>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 80097b0:	e0bffb17 	ldw	r2,-20(fp)
 80097b4:	10800017 	ldw	r2,0(r2)
 80097b8:	10800760 	cmpeqi	r2,r2,29
 80097bc:	1000041e 	bne	r2,zero,80097d0 <__sflush_r+0x1ac>
 80097c0:	e0bffb17 	ldw	r2,-20(fp)
 80097c4:	10800017 	ldw	r2,0(r2)
 80097c8:	10800598 	cmpnei	r2,r2,22
 80097cc:	1000211e 	bne	r2,zero,8009854 <__sflush_r+0x230>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
 80097d0:	80c0030b 	ldhu	r3,12(r16)
 80097d4:	00bdffc4 	movi	r2,-2049
 80097d8:	1884703a 	and	r2,r3,r2
 80097dc:	8080030d 	sth	r2,12(r16)
#endif
	      fp->_r = 0;
 80097e0:	80000115 	stw	zero,4(r16)
	      fp->_p = fp->_bf._base;
 80097e4:	80800417 	ldw	r2,16(r16)
 80097e8:	80800015 	stw	r2,0(r16)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
 80097ec:	8080030b 	ldhu	r2,12(r16)
 80097f0:	10bfffcc 	andi	r2,r2,65535
 80097f4:	1084000c 	andi	r2,r2,4096
 80097f8:	10000826 	beq	r2,zero,800981c <__sflush_r+0x1f8>
 80097fc:	e0bff717 	ldw	r2,-36(fp)
 8009800:	10bfffd8 	cmpnei	r2,r2,-1
 8009804:	1000031e 	bne	r2,zero,8009814 <__sflush_r+0x1f0>
 8009808:	e0bffb17 	ldw	r2,-20(fp)
 800980c:	10800017 	ldw	r2,0(r2)
 8009810:	1000021e 	bne	r2,zero,800981c <__sflush_r+0x1f8>
		fp->_offset = curoff;
 8009814:	e0bff717 	ldw	r2,-36(fp)
 8009818:	80801415 	stw	r2,80(r16)
	      ptr->_errno = tmp_errno;
 800981c:	e0bffb17 	ldw	r2,-20(fp)
 8009820:	e0fffa17 	ldw	r3,-24(fp)
 8009824:	10c00015 	stw	r3,0(r2)
	      if (HASUB (fp))
 8009828:	80800c17 	ldw	r2,48(r16)
 800982c:	10000e26 	beq	r2,zero,8009868 <__sflush_r+0x244>
		FREEUB (ptr, fp);
 8009830:	80c00c17 	ldw	r3,48(r16)
 8009834:	80801004 	addi	r2,r16,64
 8009838:	18800426 	beq	r3,r2,800984c <__sflush_r+0x228>
 800983c:	80800c17 	ldw	r2,48(r16)
 8009840:	100b883a 	mov	r5,r2
 8009844:	e13ffb17 	ldw	r4,-20(fp)
 8009848:	8009a040 	call	8009a04 <_free_r>
 800984c:	80000c15 	stw	zero,48(r16)
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
 8009850:	00000506 	br	8009868 <__sflush_r+0x244>
		FREEUB (ptr, fp);
	    }
	  else
	    {
	      fp->_flags |= __SERR;
 8009854:	8080030b 	ldhu	r2,12(r16)
 8009858:	10801014 	ori	r2,r2,64
 800985c:	8080030d 	sth	r2,12(r16)
	      return EOF;
 8009860:	00bfffc4 	movi	r2,-1
 8009864:	00002706 	br	8009904 <__sflush_r+0x2e0>
	    }
	}
      return 0;
 8009868:	0005883a 	mov	r2,zero
 800986c:	00002506 	br	8009904 <__sflush_r+0x2e0>
    }
  if ((p = fp->_bf._base) == NULL)
 8009870:	84400417 	ldw	r17,16(r16)
 8009874:	8800021e 	bne	r17,zero,8009880 <__sflush_r+0x25c>
    {
      /* Nothing to flush.  */
      return 0;
 8009878:	0005883a 	mov	r2,zero
 800987c:	00002106 	br	8009904 <__sflush_r+0x2e0>
    }
  n = fp->_p - p;		/* write this much */
 8009880:	80800017 	ldw	r2,0(r16)
 8009884:	1007883a 	mov	r3,r2
 8009888:	8805883a 	mov	r2,r17
 800988c:	18a5c83a 	sub	r18,r3,r2
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
 8009890:	84400015 	stw	r17,0(r16)
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
 8009894:	e0bff90b 	ldhu	r2,-28(fp)
 8009898:	10bfffcc 	andi	r2,r2,65535
 800989c:	108000cc 	andi	r2,r2,3
 80098a0:	1000021e 	bne	r2,zero,80098ac <__sflush_r+0x288>
 80098a4:	80800517 	ldw	r2,20(r16)
 80098a8:	00000106 	br	80098b0 <__sflush_r+0x28c>
 80098ac:	0005883a 	mov	r2,zero
 80098b0:	80800215 	stw	r2,8(r16)

  while (n > 0)
 80098b4:	00001106 	br	80098fc <__sflush_r+0x2d8>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
 80098b8:	80800917 	ldw	r2,36(r16)
 80098bc:	80c00717 	ldw	r3,28(r16)
 80098c0:	900f883a 	mov	r7,r18
 80098c4:	880d883a 	mov	r6,r17
 80098c8:	180b883a 	mov	r5,r3
 80098cc:	e13ffb17 	ldw	r4,-20(fp)
 80098d0:	103ee83a 	callr	r2
 80098d4:	1027883a 	mov	r19,r2
      if (t <= 0)
 80098d8:	04c00516 	blt	zero,r19,80098f0 <__sflush_r+0x2cc>
	{
          fp->_flags |= __SERR;
 80098dc:	8080030b 	ldhu	r2,12(r16)
 80098e0:	10801014 	ori	r2,r2,64
 80098e4:	8080030d 	sth	r2,12(r16)
          return EOF;
 80098e8:	00bfffc4 	movi	r2,-1
 80098ec:	00000506 	br	8009904 <__sflush_r+0x2e0>
	}
      p += t;
 80098f0:	9805883a 	mov	r2,r19
 80098f4:	88a3883a 	add	r17,r17,r2
      n -= t;
 80098f8:	94e5c83a 	sub	r18,r18,r19
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
 80098fc:	04bfee16 	blt	zero,r18,80098b8 <__sflush_r+0x294>
          return EOF;
	}
      p += t;
      n -= t;
    }
  return 0;
 8009900:	0005883a 	mov	r2,zero
}
 8009904:	e6fffc04 	addi	sp,fp,-16
 8009908:	dfc00517 	ldw	ra,20(sp)
 800990c:	df000417 	ldw	fp,16(sp)
 8009910:	dcc00317 	ldw	r19,12(sp)
 8009914:	dc800217 	ldw	r18,8(sp)
 8009918:	dc400117 	ldw	r17,4(sp)
 800991c:	dc000017 	ldw	r16,0(sp)
 8009920:	dec00604 	addi	sp,sp,24
 8009924:	f800283a 	ret

08009928 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 8009928:	defffa04 	addi	sp,sp,-24
 800992c:	dfc00515 	stw	ra,20(sp)
 8009930:	df000415 	stw	fp,16(sp)
 8009934:	dc000315 	stw	r16,12(sp)
 8009938:	df000404 	addi	fp,sp,16
 800993c:	e13ffe15 	stw	r4,-8(fp)
 8009940:	2821883a 	mov	r16,r5
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
 8009944:	e0bffe17 	ldw	r2,-8(fp)
 8009948:	e0bffc15 	stw	r2,-16(fp)
 800994c:	e0bffc17 	ldw	r2,-16(fp)
 8009950:	10000526 	beq	r2,zero,8009968 <_fflush_r+0x40>
 8009954:	e0bffc17 	ldw	r2,-16(fp)
 8009958:	10800e17 	ldw	r2,56(r2)
 800995c:	1000021e 	bne	r2,zero,8009968 <_fflush_r+0x40>
 8009960:	e13ffc17 	ldw	r4,-16(fp)
 8009964:	800639c0 	call	800639c <__sinit>

  if (!fp->_flags)
 8009968:	8080030b 	ldhu	r2,12(r16)
 800996c:	10bfffcc 	andi	r2,r2,65535
 8009970:	10a0001c 	xori	r2,r2,32768
 8009974:	10a00004 	addi	r2,r2,-32768
 8009978:	1000021e 	bne	r2,zero,8009984 <_fflush_r+0x5c>
    return 0;
 800997c:	0005883a 	mov	r2,zero
 8009980:	00000506 	br	8009998 <_fflush_r+0x70>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
 8009984:	800b883a 	mov	r5,r16
 8009988:	e13ffe17 	ldw	r4,-8(fp)
 800998c:	80096240 	call	8009624 <__sflush_r>
 8009990:	e0bffd15 	stw	r2,-12(fp)
  _newlib_flockfile_end (fp);
  return ret;
 8009994:	e0bffd17 	ldw	r2,-12(fp)
}
 8009998:	e6ffff04 	addi	sp,fp,-4
 800999c:	dfc00217 	ldw	ra,8(sp)
 80099a0:	df000117 	ldw	fp,4(sp)
 80099a4:	dc000017 	ldw	r16,0(sp)
 80099a8:	dec00304 	addi	sp,sp,12
 80099ac:	f800283a 	ret

080099b0 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
 80099b0:	defffe04 	addi	sp,sp,-8
 80099b4:	dfc00115 	stw	ra,4(sp)
 80099b8:	df000015 	stw	fp,0(sp)
 80099bc:	d839883a 	mov	fp,sp
 80099c0:	2005883a 	mov	r2,r4
  if (fp == NULL)
 80099c4:	1000061e 	bne	r2,zero,80099e0 <fflush+0x30>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
 80099c8:	d0a04317 	ldw	r2,-32500(gp)
 80099cc:	01420074 	movhi	r5,2049
 80099d0:	29664a04 	addi	r5,r5,-26328
 80099d4:	1009883a 	mov	r4,r2
 80099d8:	8006c700 	call	8006c70 <_fwalk_reent>
 80099dc:	00000406 	br	80099f0 <fflush+0x40>

  return _fflush_r (_REENT, fp);
 80099e0:	d0e04217 	ldw	r3,-32504(gp)
 80099e4:	100b883a 	mov	r5,r2
 80099e8:	1809883a 	mov	r4,r3
 80099ec:	80099280 	call	8009928 <_fflush_r>
}
 80099f0:	e037883a 	mov	sp,fp
 80099f4:	dfc00117 	ldw	ra,4(sp)
 80099f8:	df000017 	ldw	fp,0(sp)
 80099fc:	dec00204 	addi	sp,sp,8
 8009a00:	f800283a 	ret

08009a04 <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
 8009a04:	defff204 	addi	sp,sp,-56
 8009a08:	dfc00d15 	stw	ra,52(sp)
 8009a0c:	df000c15 	stw	fp,48(sp)
 8009a10:	df000c04 	addi	fp,sp,48
 8009a14:	e13ffe15 	stw	r4,-8(fp)
 8009a18:	e17fff15 	stw	r5,-4(fp)
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
 8009a1c:	e0bfff17 	ldw	r2,-4(fp)
 8009a20:	10014a26 	beq	r2,zero,8009f4c <_free_r+0x548>
    return;

  MALLOC_LOCK;
 8009a24:	e13ffe17 	ldw	r4,-8(fp)
 8009a28:	800aa640 	call	800aa64 <__malloc_lock>

  p = mem2chunk(mem);
 8009a2c:	e0bfff17 	ldw	r2,-4(fp)
 8009a30:	10bffe04 	addi	r2,r2,-8
 8009a34:	e0bff415 	stw	r2,-48(fp)
  hd = p->size;
 8009a38:	e0bff417 	ldw	r2,-48(fp)
 8009a3c:	10800117 	ldw	r2,4(r2)
 8009a40:	e0bff915 	stw	r2,-28(fp)
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
 8009a44:	e0fff917 	ldw	r3,-28(fp)
 8009a48:	00bfff84 	movi	r2,-2
 8009a4c:	1884703a 	and	r2,r3,r2
 8009a50:	e0bff515 	stw	r2,-44(fp)
  next = chunk_at_offset(p, sz);
 8009a54:	e0fff417 	ldw	r3,-48(fp)
 8009a58:	e0bff517 	ldw	r2,-44(fp)
 8009a5c:	1885883a 	add	r2,r3,r2
 8009a60:	e0bffa15 	stw	r2,-24(fp)
  nextsz = chunksize(next);
 8009a64:	e0bffa17 	ldw	r2,-24(fp)
 8009a68:	10c00117 	ldw	r3,4(r2)
 8009a6c:	00bfff04 	movi	r2,-4
 8009a70:	1884703a 	and	r2,r3,r2
 8009a74:	e0bffb15 	stw	r2,-20(fp)
  
  if (next == top)                            /* merge with top */
 8009a78:	00820134 	movhi	r2,2052
 8009a7c:	109aa204 	addi	r2,r2,27272
 8009a80:	10c00217 	ldw	r3,8(r2)
 8009a84:	e0bffa17 	ldw	r2,-24(fp)
 8009a88:	1880311e 	bne	r3,r2,8009b50 <_free_r+0x14c>
  {
    sz += nextsz;
 8009a8c:	e0fff517 	ldw	r3,-44(fp)
 8009a90:	e0bffb17 	ldw	r2,-20(fp)
 8009a94:	1885883a 	add	r2,r3,r2
 8009a98:	e0bff515 	stw	r2,-44(fp)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
 8009a9c:	e0bff917 	ldw	r2,-28(fp)
 8009aa0:	1080004c 	andi	r2,r2,1
 8009aa4:	1000181e 	bne	r2,zero,8009b08 <_free_r+0x104>
    {
      prevsz = p->prev_size;
 8009aa8:	e0bff417 	ldw	r2,-48(fp)
 8009aac:	10800017 	ldw	r2,0(r2)
 8009ab0:	e0bffc15 	stw	r2,-16(fp)
      p = chunk_at_offset(p, -prevsz);
 8009ab4:	e0bffc17 	ldw	r2,-16(fp)
 8009ab8:	0085c83a 	sub	r2,zero,r2
 8009abc:	e0fff417 	ldw	r3,-48(fp)
 8009ac0:	1885883a 	add	r2,r3,r2
 8009ac4:	e0bff415 	stw	r2,-48(fp)
      sz += prevsz;
 8009ac8:	e0fff517 	ldw	r3,-44(fp)
 8009acc:	e0bffc17 	ldw	r2,-16(fp)
 8009ad0:	1885883a 	add	r2,r3,r2
 8009ad4:	e0bff515 	stw	r2,-44(fp)
      unlink(p, bck, fwd);
 8009ad8:	e0bff417 	ldw	r2,-48(fp)
 8009adc:	10800317 	ldw	r2,12(r2)
 8009ae0:	e0bff615 	stw	r2,-40(fp)
 8009ae4:	e0bff417 	ldw	r2,-48(fp)
 8009ae8:	10800217 	ldw	r2,8(r2)
 8009aec:	e0bff715 	stw	r2,-36(fp)
 8009af0:	e0bff717 	ldw	r2,-36(fp)
 8009af4:	e0fff617 	ldw	r3,-40(fp)
 8009af8:	10c00315 	stw	r3,12(r2)
 8009afc:	e0bff617 	ldw	r2,-40(fp)
 8009b00:	e0fff717 	ldw	r3,-36(fp)
 8009b04:	10c00215 	stw	r3,8(r2)
    }

    set_head(p, sz | PREV_INUSE);
 8009b08:	e0bff517 	ldw	r2,-44(fp)
 8009b0c:	10c00054 	ori	r3,r2,1
 8009b10:	e0bff417 	ldw	r2,-48(fp)
 8009b14:	10c00115 	stw	r3,4(r2)
    top = p;
 8009b18:	00820134 	movhi	r2,2052
 8009b1c:	109aa204 	addi	r2,r2,27272
 8009b20:	e0fff417 	ldw	r3,-48(fp)
 8009b24:	10c00215 	stw	r3,8(r2)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
 8009b28:	d0a04417 	ldw	r2,-32496(gp)
 8009b2c:	e0fff517 	ldw	r3,-44(fp)
 8009b30:	18800436 	bltu	r3,r2,8009b44 <_free_r+0x140>
      malloc_trim(RCALL top_pad); 
 8009b34:	d0a76717 	ldw	r2,-25188(gp)
 8009b38:	100b883a 	mov	r5,r2
 8009b3c:	e13ffe17 	ldw	r4,-8(fp)
 8009b40:	8009f640 	call	8009f64 <_malloc_trim_r>
    MALLOC_UNLOCK;
 8009b44:	e13ffe17 	ldw	r4,-8(fp)
 8009b48:	800aa880 	call	800aa88 <__malloc_unlock>
    return;
 8009b4c:	00010006 	br	8009f50 <_free_r+0x54c>
  }

  set_head(next, nextsz);                    /* clear inuse bit */
 8009b50:	e0bffa17 	ldw	r2,-24(fp)
 8009b54:	e0fffb17 	ldw	r3,-20(fp)
 8009b58:	10c00115 	stw	r3,4(r2)

  islr = 0;
 8009b5c:	e03ff815 	stw	zero,-32(fp)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
 8009b60:	e0bff917 	ldw	r2,-28(fp)
 8009b64:	1080004c 	andi	r2,r2,1
 8009b68:	1000201e 	bne	r2,zero,8009bec <_free_r+0x1e8>
  {
    prevsz = p->prev_size;
 8009b6c:	e0bff417 	ldw	r2,-48(fp)
 8009b70:	10800017 	ldw	r2,0(r2)
 8009b74:	e0bffc15 	stw	r2,-16(fp)
    p = chunk_at_offset(p, -prevsz);
 8009b78:	e0bffc17 	ldw	r2,-16(fp)
 8009b7c:	0085c83a 	sub	r2,zero,r2
 8009b80:	e0fff417 	ldw	r3,-48(fp)
 8009b84:	1885883a 	add	r2,r3,r2
 8009b88:	e0bff415 	stw	r2,-48(fp)
    sz += prevsz;
 8009b8c:	e0fff517 	ldw	r3,-44(fp)
 8009b90:	e0bffc17 	ldw	r2,-16(fp)
 8009b94:	1885883a 	add	r2,r3,r2
 8009b98:	e0bff515 	stw	r2,-44(fp)
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
 8009b9c:	e0bff417 	ldw	r2,-48(fp)
 8009ba0:	10c00217 	ldw	r3,8(r2)
 8009ba4:	00820134 	movhi	r2,2052
 8009ba8:	109aa404 	addi	r2,r2,27280
 8009bac:	1880031e 	bne	r3,r2,8009bbc <_free_r+0x1b8>
      islr = 1;
 8009bb0:	00800044 	movi	r2,1
 8009bb4:	e0bff815 	stw	r2,-32(fp)
 8009bb8:	00000c06 	br	8009bec <_free_r+0x1e8>
    else
      unlink(p, bck, fwd);
 8009bbc:	e0bff417 	ldw	r2,-48(fp)
 8009bc0:	10800317 	ldw	r2,12(r2)
 8009bc4:	e0bff615 	stw	r2,-40(fp)
 8009bc8:	e0bff417 	ldw	r2,-48(fp)
 8009bcc:	10800217 	ldw	r2,8(r2)
 8009bd0:	e0bff715 	stw	r2,-36(fp)
 8009bd4:	e0bff717 	ldw	r2,-36(fp)
 8009bd8:	e0fff617 	ldw	r3,-40(fp)
 8009bdc:	10c00315 	stw	r3,12(r2)
 8009be0:	e0bff617 	ldw	r2,-40(fp)
 8009be4:	e0fff717 	ldw	r3,-36(fp)
 8009be8:	10c00215 	stw	r3,8(r2)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
 8009bec:	e0fffa17 	ldw	r3,-24(fp)
 8009bf0:	e0bffb17 	ldw	r2,-20(fp)
 8009bf4:	1885883a 	add	r2,r3,r2
 8009bf8:	10800117 	ldw	r2,4(r2)
 8009bfc:	1080004c 	andi	r2,r2,1
 8009c00:	10002a1e 	bne	r2,zero,8009cac <_free_r+0x2a8>
  {
    sz += nextsz;
 8009c04:	e0fff517 	ldw	r3,-44(fp)
 8009c08:	e0bffb17 	ldw	r2,-20(fp)
 8009c0c:	1885883a 	add	r2,r3,r2
 8009c10:	e0bff515 	stw	r2,-44(fp)
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
 8009c14:	e0bff817 	ldw	r2,-32(fp)
 8009c18:	1000181e 	bne	r2,zero,8009c7c <_free_r+0x278>
 8009c1c:	e0bffa17 	ldw	r2,-24(fp)
 8009c20:	10c00217 	ldw	r3,8(r2)
 8009c24:	00820134 	movhi	r2,2052
 8009c28:	109aa404 	addi	r2,r2,27280
 8009c2c:	1880131e 	bne	r3,r2,8009c7c <_free_r+0x278>
    {
      islr = 1;
 8009c30:	00800044 	movi	r2,1
 8009c34:	e0bff815 	stw	r2,-32(fp)
      link_last_remainder(p);   
 8009c38:	00c20134 	movhi	r3,2052
 8009c3c:	18daa404 	addi	r3,r3,27280
 8009c40:	00820134 	movhi	r2,2052
 8009c44:	109aa404 	addi	r2,r2,27280
 8009c48:	e13ff417 	ldw	r4,-48(fp)
 8009c4c:	11000315 	stw	r4,12(r2)
 8009c50:	10800317 	ldw	r2,12(r2)
 8009c54:	18800215 	stw	r2,8(r3)
 8009c58:	00820134 	movhi	r2,2052
 8009c5c:	109aa404 	addi	r2,r2,27280
 8009c60:	e0fff417 	ldw	r3,-48(fp)
 8009c64:	18800315 	stw	r2,12(r3)
 8009c68:	e0bff417 	ldw	r2,-48(fp)
 8009c6c:	10c00317 	ldw	r3,12(r2)
 8009c70:	e0bff417 	ldw	r2,-48(fp)
 8009c74:	10c00215 	stw	r3,8(r2)
 8009c78:	00000c06 	br	8009cac <_free_r+0x2a8>
    }
    else
      unlink(next, bck, fwd);
 8009c7c:	e0bffa17 	ldw	r2,-24(fp)
 8009c80:	10800317 	ldw	r2,12(r2)
 8009c84:	e0bff615 	stw	r2,-40(fp)
 8009c88:	e0bffa17 	ldw	r2,-24(fp)
 8009c8c:	10800217 	ldw	r2,8(r2)
 8009c90:	e0bff715 	stw	r2,-36(fp)
 8009c94:	e0bff717 	ldw	r2,-36(fp)
 8009c98:	e0fff617 	ldw	r3,-40(fp)
 8009c9c:	10c00315 	stw	r3,12(r2)
 8009ca0:	e0bff617 	ldw	r2,-40(fp)
 8009ca4:	e0fff717 	ldw	r3,-36(fp)
 8009ca8:	10c00215 	stw	r3,8(r2)
  }


  set_head(p, sz | PREV_INUSE);
 8009cac:	e0bff517 	ldw	r2,-44(fp)
 8009cb0:	10c00054 	ori	r3,r2,1
 8009cb4:	e0bff417 	ldw	r2,-48(fp)
 8009cb8:	10c00115 	stw	r3,4(r2)
  set_foot(p, sz);
 8009cbc:	e0fff417 	ldw	r3,-48(fp)
 8009cc0:	e0bff517 	ldw	r2,-44(fp)
 8009cc4:	1885883a 	add	r2,r3,r2
 8009cc8:	e0fff517 	ldw	r3,-44(fp)
 8009ccc:	10c00015 	stw	r3,0(r2)
  if (!islr)
 8009cd0:	e0bff817 	ldw	r2,-32(fp)
 8009cd4:	10009a1e 	bne	r2,zero,8009f40 <_free_r+0x53c>
    frontlink(p, sz, idx, bck, fwd);  
 8009cd8:	e0bff517 	ldw	r2,-44(fp)
 8009cdc:	10808028 	cmpgeui	r2,r2,512
 8009ce0:	10002c1e 	bne	r2,zero,8009d94 <_free_r+0x390>
 8009ce4:	e0bff517 	ldw	r2,-44(fp)
 8009ce8:	1004d0fa 	srli	r2,r2,3
 8009cec:	e0bffd15 	stw	r2,-12(fp)
 8009cf0:	00c20134 	movhi	r3,2052
 8009cf4:	18daa204 	addi	r3,r3,27272
 8009cf8:	00820134 	movhi	r2,2052
 8009cfc:	109aa204 	addi	r2,r2,27272
 8009d00:	11000117 	ldw	r4,4(r2)
 8009d04:	e0bffd17 	ldw	r2,-12(fp)
 8009d08:	1000010e 	bge	r2,zero,8009d10 <_free_r+0x30c>
 8009d0c:	108000c4 	addi	r2,r2,3
 8009d10:	1005d0ba 	srai	r2,r2,2
 8009d14:	100b883a 	mov	r5,r2
 8009d18:	00800044 	movi	r2,1
 8009d1c:	1144983a 	sll	r2,r2,r5
 8009d20:	2084b03a 	or	r2,r4,r2
 8009d24:	18800115 	stw	r2,4(r3)
 8009d28:	e0bffd17 	ldw	r2,-12(fp)
 8009d2c:	10800044 	addi	r2,r2,1
 8009d30:	1085883a 	add	r2,r2,r2
 8009d34:	1085883a 	add	r2,r2,r2
 8009d38:	1087883a 	add	r3,r2,r2
 8009d3c:	00820134 	movhi	r2,2052
 8009d40:	109aa204 	addi	r2,r2,27272
 8009d44:	1885883a 	add	r2,r3,r2
 8009d48:	10bffe04 	addi	r2,r2,-8
 8009d4c:	e0bff615 	stw	r2,-40(fp)
 8009d50:	e0bff617 	ldw	r2,-40(fp)
 8009d54:	10800217 	ldw	r2,8(r2)
 8009d58:	e0bff715 	stw	r2,-36(fp)
 8009d5c:	e0bff417 	ldw	r2,-48(fp)
 8009d60:	e0fff617 	ldw	r3,-40(fp)
 8009d64:	10c00315 	stw	r3,12(r2)
 8009d68:	e0bff417 	ldw	r2,-48(fp)
 8009d6c:	e0fff717 	ldw	r3,-36(fp)
 8009d70:	10c00215 	stw	r3,8(r2)
 8009d74:	e0bff617 	ldw	r2,-40(fp)
 8009d78:	e0fff417 	ldw	r3,-48(fp)
 8009d7c:	10c00215 	stw	r3,8(r2)
 8009d80:	e0bff617 	ldw	r2,-40(fp)
 8009d84:	10c00217 	ldw	r3,8(r2)
 8009d88:	e0bff717 	ldw	r2,-36(fp)
 8009d8c:	10c00315 	stw	r3,12(r2)
 8009d90:	00006b06 	br	8009f40 <_free_r+0x53c>
 8009d94:	e0bff517 	ldw	r2,-44(fp)
 8009d98:	1004d27a 	srli	r2,r2,9
 8009d9c:	1000031e 	bne	r2,zero,8009dac <_free_r+0x3a8>
 8009da0:	e0bff517 	ldw	r2,-44(fp)
 8009da4:	1004d0fa 	srli	r2,r2,3
 8009da8:	00002906 	br	8009e50 <_free_r+0x44c>
 8009dac:	e0bff517 	ldw	r2,-44(fp)
 8009db0:	1004d27a 	srli	r2,r2,9
 8009db4:	10800168 	cmpgeui	r2,r2,5
 8009db8:	1000041e 	bne	r2,zero,8009dcc <_free_r+0x3c8>
 8009dbc:	e0bff517 	ldw	r2,-44(fp)
 8009dc0:	1004d1ba 	srli	r2,r2,6
 8009dc4:	10800e04 	addi	r2,r2,56
 8009dc8:	00002106 	br	8009e50 <_free_r+0x44c>
 8009dcc:	e0bff517 	ldw	r2,-44(fp)
 8009dd0:	1004d27a 	srli	r2,r2,9
 8009dd4:	10800568 	cmpgeui	r2,r2,21
 8009dd8:	1000041e 	bne	r2,zero,8009dec <_free_r+0x3e8>
 8009ddc:	e0bff517 	ldw	r2,-44(fp)
 8009de0:	1004d27a 	srli	r2,r2,9
 8009de4:	108016c4 	addi	r2,r2,91
 8009de8:	00001906 	br	8009e50 <_free_r+0x44c>
 8009dec:	e0bff517 	ldw	r2,-44(fp)
 8009df0:	1004d27a 	srli	r2,r2,9
 8009df4:	10801568 	cmpgeui	r2,r2,85
 8009df8:	1000041e 	bne	r2,zero,8009e0c <_free_r+0x408>
 8009dfc:	e0bff517 	ldw	r2,-44(fp)
 8009e00:	1004d33a 	srli	r2,r2,12
 8009e04:	10801b84 	addi	r2,r2,110
 8009e08:	00001106 	br	8009e50 <_free_r+0x44c>
 8009e0c:	e0bff517 	ldw	r2,-44(fp)
 8009e10:	1004d27a 	srli	r2,r2,9
 8009e14:	10805568 	cmpgeui	r2,r2,341
 8009e18:	1000041e 	bne	r2,zero,8009e2c <_free_r+0x428>
 8009e1c:	e0bff517 	ldw	r2,-44(fp)
 8009e20:	1004d3fa 	srli	r2,r2,15
 8009e24:	10801dc4 	addi	r2,r2,119
 8009e28:	00000906 	br	8009e50 <_free_r+0x44c>
 8009e2c:	e0bff517 	ldw	r2,-44(fp)
 8009e30:	1004d27a 	srli	r2,r2,9
 8009e34:	10815568 	cmpgeui	r2,r2,1365
 8009e38:	1000041e 	bne	r2,zero,8009e4c <_free_r+0x448>
 8009e3c:	e0bff517 	ldw	r2,-44(fp)
 8009e40:	1004d4ba 	srli	r2,r2,18
 8009e44:	10801f04 	addi	r2,r2,124
 8009e48:	00000106 	br	8009e50 <_free_r+0x44c>
 8009e4c:	00801f84 	movi	r2,126
 8009e50:	e0bffd15 	stw	r2,-12(fp)
 8009e54:	e0bffd17 	ldw	r2,-12(fp)
 8009e58:	10800044 	addi	r2,r2,1
 8009e5c:	1085883a 	add	r2,r2,r2
 8009e60:	1085883a 	add	r2,r2,r2
 8009e64:	1087883a 	add	r3,r2,r2
 8009e68:	00820134 	movhi	r2,2052
 8009e6c:	109aa204 	addi	r2,r2,27272
 8009e70:	1885883a 	add	r2,r3,r2
 8009e74:	10bffe04 	addi	r2,r2,-8
 8009e78:	e0bff615 	stw	r2,-40(fp)
 8009e7c:	e0bff617 	ldw	r2,-40(fp)
 8009e80:	10800217 	ldw	r2,8(r2)
 8009e84:	e0bff715 	stw	r2,-36(fp)
 8009e88:	e0fff717 	ldw	r3,-36(fp)
 8009e8c:	e0bff617 	ldw	r2,-40(fp)
 8009e90:	1880121e 	bne	r3,r2,8009edc <_free_r+0x4d8>
 8009e94:	00c20134 	movhi	r3,2052
 8009e98:	18daa204 	addi	r3,r3,27272
 8009e9c:	00820134 	movhi	r2,2052
 8009ea0:	109aa204 	addi	r2,r2,27272
 8009ea4:	11000117 	ldw	r4,4(r2)
 8009ea8:	e0bffd17 	ldw	r2,-12(fp)
 8009eac:	1000010e 	bge	r2,zero,8009eb4 <_free_r+0x4b0>
 8009eb0:	108000c4 	addi	r2,r2,3
 8009eb4:	1005d0ba 	srai	r2,r2,2
 8009eb8:	100b883a 	mov	r5,r2
 8009ebc:	00800044 	movi	r2,1
 8009ec0:	1144983a 	sll	r2,r2,r5
 8009ec4:	2084b03a 	or	r2,r4,r2
 8009ec8:	18800115 	stw	r2,4(r3)
 8009ecc:	00000f06 	br	8009f0c <_free_r+0x508>
 8009ed0:	e0bff717 	ldw	r2,-36(fp)
 8009ed4:	10800217 	ldw	r2,8(r2)
 8009ed8:	e0bff715 	stw	r2,-36(fp)
 8009edc:	e0fff717 	ldw	r3,-36(fp)
 8009ee0:	e0bff617 	ldw	r2,-40(fp)
 8009ee4:	18800626 	beq	r3,r2,8009f00 <_free_r+0x4fc>
 8009ee8:	e0bff717 	ldw	r2,-36(fp)
 8009eec:	10c00117 	ldw	r3,4(r2)
 8009ef0:	00bfff04 	movi	r2,-4
 8009ef4:	1884703a 	and	r2,r3,r2
 8009ef8:	e0fff517 	ldw	r3,-44(fp)
 8009efc:	18bff436 	bltu	r3,r2,8009ed0 <_free_r+0x4cc>
 8009f00:	e0bff717 	ldw	r2,-36(fp)
 8009f04:	10800317 	ldw	r2,12(r2)
 8009f08:	e0bff615 	stw	r2,-40(fp)
 8009f0c:	e0bff417 	ldw	r2,-48(fp)
 8009f10:	e0fff617 	ldw	r3,-40(fp)
 8009f14:	10c00315 	stw	r3,12(r2)
 8009f18:	e0bff417 	ldw	r2,-48(fp)
 8009f1c:	e0fff717 	ldw	r3,-36(fp)
 8009f20:	10c00215 	stw	r3,8(r2)
 8009f24:	e0bff617 	ldw	r2,-40(fp)
 8009f28:	e0fff417 	ldw	r3,-48(fp)
 8009f2c:	10c00215 	stw	r3,8(r2)
 8009f30:	e0bff617 	ldw	r2,-40(fp)
 8009f34:	10c00217 	ldw	r3,8(r2)
 8009f38:	e0bff717 	ldw	r2,-36(fp)
 8009f3c:	10c00315 	stw	r3,12(r2)

  MALLOC_UNLOCK;
 8009f40:	e13ffe17 	ldw	r4,-8(fp)
 8009f44:	800aa880 	call	800aa88 <__malloc_unlock>
 8009f48:	00000106 	br	8009f50 <_free_r+0x54c>
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;
 8009f4c:	0001883a 	nop
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
 8009f50:	e037883a 	mov	sp,fp
 8009f54:	dfc00117 	ldw	ra,4(sp)
 8009f58:	df000017 	ldw	fp,0(sp)
 8009f5c:	dec00204 	addi	sp,sp,8
 8009f60:	f800283a 	ret

08009f64 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
 8009f64:	defff704 	addi	sp,sp,-36
 8009f68:	dfc00815 	stw	ra,32(sp)
 8009f6c:	df000715 	stw	fp,28(sp)
 8009f70:	df000704 	addi	fp,sp,28
 8009f74:	e13ffe15 	stw	r4,-8(fp)
 8009f78:	e17fff15 	stw	r5,-4(fp)
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
 8009f7c:	00840004 	movi	r2,4096
 8009f80:	e0bff915 	stw	r2,-28(fp)

  MALLOC_LOCK;
 8009f84:	e13ffe17 	ldw	r4,-8(fp)
 8009f88:	800aa640 	call	800aa64 <__malloc_lock>

  top_size = chunksize(top);
 8009f8c:	00820134 	movhi	r2,2052
 8009f90:	109aa204 	addi	r2,r2,27272
 8009f94:	10800217 	ldw	r2,8(r2)
 8009f98:	10800117 	ldw	r2,4(r2)
 8009f9c:	1007883a 	mov	r3,r2
 8009fa0:	00bfff04 	movi	r2,-4
 8009fa4:	1884703a 	and	r2,r3,r2
 8009fa8:	e0bffa15 	stw	r2,-24(fp)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
 8009fac:	e0fffa17 	ldw	r3,-24(fp)
 8009fb0:	e0bfff17 	ldw	r2,-4(fp)
 8009fb4:	1887c83a 	sub	r3,r3,r2
 8009fb8:	e0bff917 	ldw	r2,-28(fp)
 8009fbc:	1885883a 	add	r2,r3,r2
 8009fc0:	10bffbc4 	addi	r2,r2,-17
 8009fc4:	e17ff917 	ldw	r5,-28(fp)
 8009fc8:	1009883a 	mov	r4,r2
 8009fcc:	80040040 	call	8004004 <__udivsi3>
 8009fd0:	10ffffc4 	addi	r3,r2,-1
 8009fd4:	e0bff917 	ldw	r2,-28(fp)
 8009fd8:	1885383a 	mul	r2,r3,r2
 8009fdc:	e0bffb15 	stw	r2,-20(fp)

  if (extra < (long)pagesz)  /* Not enough memory to release */
 8009fe0:	e0bff917 	ldw	r2,-28(fp)
 8009fe4:	e0fffb17 	ldw	r3,-20(fp)
 8009fe8:	1880040e 	bge	r3,r2,8009ffc <_malloc_trim_r+0x98>
  {
    MALLOC_UNLOCK;
 8009fec:	e13ffe17 	ldw	r4,-8(fp)
 8009ff0:	800aa880 	call	800aa88 <__malloc_unlock>
    return 0;
 8009ff4:	0005883a 	mov	r2,zero
 8009ff8:	00004806 	br	800a11c <_malloc_trim_r+0x1b8>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
 8009ffc:	000b883a 	mov	r5,zero
 800a000:	e13ffe17 	ldw	r4,-8(fp)
 800a004:	8008f7c0 	call	8008f7c <_sbrk_r>
 800a008:	e0bffc15 	stw	r2,-16(fp)
    if (current_brk != (char*)(top) + top_size)
 800a00c:	00820134 	movhi	r2,2052
 800a010:	109aa204 	addi	r2,r2,27272
 800a014:	10c00217 	ldw	r3,8(r2)
 800a018:	e0bffa17 	ldw	r2,-24(fp)
 800a01c:	1887883a 	add	r3,r3,r2
 800a020:	e0bffc17 	ldw	r2,-16(fp)
 800a024:	18800426 	beq	r3,r2,800a038 <_malloc_trim_r+0xd4>
    {
      MALLOC_UNLOCK;
 800a028:	e13ffe17 	ldw	r4,-8(fp)
 800a02c:	800aa880 	call	800aa88 <__malloc_unlock>
      return 0;     /* Apparently we don't own memory; must fail */
 800a030:	0005883a 	mov	r2,zero
 800a034:	00003906 	br	800a11c <_malloc_trim_r+0x1b8>
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
 800a038:	e0bffb17 	ldw	r2,-20(fp)
 800a03c:	0085c83a 	sub	r2,zero,r2
 800a040:	100b883a 	mov	r5,r2
 800a044:	e13ffe17 	ldw	r4,-8(fp)
 800a048:	8008f7c0 	call	8008f7c <_sbrk_r>
 800a04c:	e0bffd15 	stw	r2,-12(fp)
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
 800a050:	e0bffd17 	ldw	r2,-12(fp)
 800a054:	10bfffd8 	cmpnei	r2,r2,-1
 800a058:	10001d1e 	bne	r2,zero,800a0d0 <_malloc_trim_r+0x16c>
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
 800a05c:	000b883a 	mov	r5,zero
 800a060:	e13ffe17 	ldw	r4,-8(fp)
 800a064:	8008f7c0 	call	8008f7c <_sbrk_r>
 800a068:	e0bffc15 	stw	r2,-16(fp)
        top_size = current_brk - (char*)top;
 800a06c:	e0fffc17 	ldw	r3,-16(fp)
 800a070:	00820134 	movhi	r2,2052
 800a074:	109aa204 	addi	r2,r2,27272
 800a078:	10800217 	ldw	r2,8(r2)
 800a07c:	1885c83a 	sub	r2,r3,r2
 800a080:	e0bffa15 	stw	r2,-24(fp)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
 800a084:	e0bffa17 	ldw	r2,-24(fp)
 800a088:	10800410 	cmplti	r2,r2,16
 800a08c:	10000c1e 	bne	r2,zero,800a0c0 <_malloc_trim_r+0x15c>
        {
          sbrked_mem = current_brk - sbrk_base;
 800a090:	e0bffc17 	ldw	r2,-16(fp)
 800a094:	d0e04517 	ldw	r3,-32492(gp)
 800a098:	10c7c83a 	sub	r3,r2,r3
 800a09c:	00820174 	movhi	r2,2053
 800a0a0:	10a7d104 	addi	r2,r2,-24764
 800a0a4:	10c00015 	stw	r3,0(r2)
          set_head(top, top_size | PREV_INUSE);
 800a0a8:	00820134 	movhi	r2,2052
 800a0ac:	109aa204 	addi	r2,r2,27272
 800a0b0:	10800217 	ldw	r2,8(r2)
 800a0b4:	e0fffa17 	ldw	r3,-24(fp)
 800a0b8:	18c00054 	ori	r3,r3,1
 800a0bc:	10c00115 	stw	r3,4(r2)
        }
        check_chunk(top);
	MALLOC_UNLOCK;
 800a0c0:	e13ffe17 	ldw	r4,-8(fp)
 800a0c4:	800aa880 	call	800aa88 <__malloc_unlock>
        return 0; 
 800a0c8:	0005883a 	mov	r2,zero
 800a0cc:	00001306 	br	800a11c <_malloc_trim_r+0x1b8>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
 800a0d0:	00820134 	movhi	r2,2052
 800a0d4:	109aa204 	addi	r2,r2,27272
 800a0d8:	10800217 	ldw	r2,8(r2)
 800a0dc:	e13ffa17 	ldw	r4,-24(fp)
 800a0e0:	e0fffb17 	ldw	r3,-20(fp)
 800a0e4:	20c7c83a 	sub	r3,r4,r3
 800a0e8:	18c00054 	ori	r3,r3,1
 800a0ec:	10c00115 	stw	r3,4(r2)
        sbrked_mem -= extra;
 800a0f0:	00820174 	movhi	r2,2053
 800a0f4:	10a7d104 	addi	r2,r2,-24764
 800a0f8:	10c00017 	ldw	r3,0(r2)
 800a0fc:	e0bffb17 	ldw	r2,-20(fp)
 800a100:	1887c83a 	sub	r3,r3,r2
 800a104:	00820174 	movhi	r2,2053
 800a108:	10a7d104 	addi	r2,r2,-24764
 800a10c:	10c00015 	stw	r3,0(r2)
        check_chunk(top);
	MALLOC_UNLOCK;
 800a110:	e13ffe17 	ldw	r4,-8(fp)
 800a114:	800aa880 	call	800aa88 <__malloc_unlock>
        return 1;
 800a118:	00800044 	movi	r2,1
      }
    }
  }
}
 800a11c:	e037883a 	mov	sp,fp
 800a120:	dfc00117 	ldw	ra,4(sp)
 800a124:	df000017 	ldw	fp,0(sp)
 800a128:	dec00204 	addi	sp,sp,8
 800a12c:	f800283a 	ret

0800a130 <_lseek_r>:
_DEFUN (_lseek_r, (ptr, fd, pos, whence),
     struct _reent *ptr _AND
     int fd _AND
     _off_t pos _AND
     int whence)
{
 800a130:	defff904 	addi	sp,sp,-28
 800a134:	dfc00615 	stw	ra,24(sp)
 800a138:	df000515 	stw	fp,20(sp)
 800a13c:	df000504 	addi	fp,sp,20
 800a140:	e13ffc15 	stw	r4,-16(fp)
 800a144:	e17ffd15 	stw	r5,-12(fp)
 800a148:	e1bffe15 	stw	r6,-8(fp)
 800a14c:	e1ffff15 	stw	r7,-4(fp)
  _off_t ret;

  errno = 0;
 800a150:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
 800a154:	e1bfff17 	ldw	r6,-4(fp)
 800a158:	e17ffe17 	ldw	r5,-8(fp)
 800a15c:	e13ffd17 	ldw	r4,-12(fp)
 800a160:	800a9300 	call	800a930 <lseek>
 800a164:	e0bffb15 	stw	r2,-20(fp)
 800a168:	e0bffb17 	ldw	r2,-20(fp)
 800a16c:	10bfffd8 	cmpnei	r2,r2,-1
 800a170:	1000051e 	bne	r2,zero,800a188 <_lseek_r+0x58>
 800a174:	d0a76a17 	ldw	r2,-25176(gp)
 800a178:	10000326 	beq	r2,zero,800a188 <_lseek_r+0x58>
    ptr->_errno = errno;
 800a17c:	d0e76a17 	ldw	r3,-25176(gp)
 800a180:	e0bffc17 	ldw	r2,-16(fp)
 800a184:	10c00015 	stw	r3,0(r2)
  return ret;
 800a188:	e0bffb17 	ldw	r2,-20(fp)
}
 800a18c:	e037883a 	mov	sp,fp
 800a190:	dfc00117 	ldw	ra,4(sp)
 800a194:	df000017 	ldw	fp,0(sp)
 800a198:	dec00204 	addi	sp,sp,8
 800a19c:	f800283a 	ret

0800a1a0 <__smakebuf_r>:

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
 800a1a0:	deffea04 	addi	sp,sp,-88
 800a1a4:	dfc01515 	stw	ra,84(sp)
 800a1a8:	df001415 	stw	fp,80(sp)
 800a1ac:	dcc01315 	stw	r19,76(sp)
 800a1b0:	dc801215 	stw	r18,72(sp)
 800a1b4:	dc401115 	stw	r17,68(sp)
 800a1b8:	dc001015 	stw	r16,64(sp)
 800a1bc:	df001404 	addi	fp,sp,80
 800a1c0:	e13ffb15 	stw	r4,-20(fp)
 800a1c4:	2821883a 	mov	r16,r5
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
 800a1c8:	8080030b 	ldhu	r2,12(r16)
 800a1cc:	10bfffcc 	andi	r2,r2,65535
 800a1d0:	1080008c 	andi	r2,r2,2
 800a1d4:	10000726 	beq	r2,zero,800a1f4 <__smakebuf_r+0x54>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
 800a1d8:	808010c4 	addi	r2,r16,67
 800a1dc:	80800015 	stw	r2,0(r16)
 800a1e0:	80800017 	ldw	r2,0(r16)
 800a1e4:	80800415 	stw	r2,16(r16)
      fp->_bf._size = 1;
 800a1e8:	00800044 	movi	r2,1
 800a1ec:	80800515 	stw	r2,20(r16)
 800a1f0:	00006d06 	br	800a3a8 <__smakebuf_r+0x208>
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
 800a1f4:	8080038b 	ldhu	r2,14(r16)
 800a1f8:	10bfffcc 	andi	r2,r2,65535
 800a1fc:	10a0001c 	xori	r2,r2,32768
 800a200:	10a00004 	addi	r2,r2,-32768
 800a204:	10000916 	blt	r2,zero,800a22c <__smakebuf_r+0x8c>
 800a208:	8080038b 	ldhu	r2,14(r16)
 800a20c:	10bfffcc 	andi	r2,r2,65535
 800a210:	10a0001c 	xori	r2,r2,32768
 800a214:	10a00004 	addi	r2,r2,-32768
 800a218:	e1bfec04 	addi	r6,fp,-80
 800a21c:	100b883a 	mov	r5,r2
 800a220:	e13ffb17 	ldw	r4,-20(fp)
 800a224:	800a43c0 	call	800a43c <_fstat_r>
 800a228:	10000c0e 	bge	r2,zero,800a25c <__smakebuf_r+0xbc>
#endif
    {
      couldbetty = 0;
 800a22c:	0025883a 	mov	r18,zero
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
 800a230:	8080030b 	ldhu	r2,12(r16)
 800a234:	10bfffcc 	andi	r2,r2,65535
 800a238:	1080200c 	andi	r2,r2,128
 800a23c:	10000226 	beq	r2,zero,800a248 <__smakebuf_r+0xa8>
        size = _DEFAULT_ASPRINTF_BUFSIZE;
 800a240:	04401004 	movi	r17,64
 800a244:	00000106 	br	800a24c <__smakebuf_r+0xac>
      else
        size = BUFSIZ;
 800a248:	04410004 	movi	r17,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
 800a24c:	8080030b 	ldhu	r2,12(r16)
 800a250:	10820014 	ori	r2,r2,2048
 800a254:	8080030d 	sth	r2,12(r16)
 800a258:	00001606 	br	800a2b4 <__smakebuf_r+0x114>
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
 800a25c:	e0bfed17 	ldw	r2,-76(fp)
 800a260:	10bc000c 	andi	r2,r2,61440
 800a264:	10880020 	cmpeqi	r2,r2,8192
 800a268:	14803fcc 	andi	r18,r2,255
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
 800a26c:	04410004 	movi	r17,1024
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
 800a270:	e0bfed17 	ldw	r2,-76(fp)
 800a274:	10fc000c 	andi	r3,r2,61440
 800a278:	00a00014 	movui	r2,32768
 800a27c:	18800a1e 	bne	r3,r2,800a2a8 <__smakebuf_r+0x108>
 800a280:	80c00a17 	ldw	r3,40(r16)
 800a284:	00820074 	movhi	r2,2049
 800a288:	10a45704 	addi	r2,r2,-28324
 800a28c:	1880061e 	bne	r3,r2,800a2a8 <__smakebuf_r+0x108>
	{
	  fp->_flags |= __SOPT;
 800a290:	8080030b 	ldhu	r2,12(r16)
 800a294:	10810014 	ori	r2,r2,1024
 800a298:	8080030d 	sth	r2,12(r16)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
 800a29c:	00810004 	movi	r2,1024
 800a2a0:	80801315 	stw	r2,76(r16)
 800a2a4:	00000306 	br	800a2b4 <__smakebuf_r+0x114>
#endif
	}
      else
	fp->_flags |= __SNPT;
 800a2a8:	8080030b 	ldhu	r2,12(r16)
 800a2ac:	10820014 	ori	r2,r2,2048
 800a2b0:	8080030d 	sth	r2,12(r16)
#endif
    }

  /* Make unbuffered by default: */			/* AlteraSpecific */
  if (couldbetty && _isatty_r (ptr, fp->_file))		/* AlteraSpecific */
 800a2b4:	90001126 	beq	r18,zero,800a2fc <__smakebuf_r+0x15c>
 800a2b8:	8080038b 	ldhu	r2,14(r16)
 800a2bc:	10bfffcc 	andi	r2,r2,65535
 800a2c0:	10a0001c 	xori	r2,r2,32768
 800a2c4:	10a00004 	addi	r2,r2,-32768
 800a2c8:	100b883a 	mov	r5,r2
 800a2cc:	e13ffb17 	ldw	r4,-20(fp)
 800a2d0:	800a4a40 	call	800a4a4 <_isatty_r>
 800a2d4:	10000926 	beq	r2,zero,800a2fc <__smakebuf_r+0x15c>
  {							/* AlteraSpecific */
    fp->_flags |= __SLBF;				/* AlteraSpecific __SLBF == "line buffered */
 800a2d8:	8080030b 	ldhu	r2,12(r16)
 800a2dc:	10800054 	ori	r2,r2,1
 800a2e0:	8080030d 	sth	r2,12(r16)
    fp->_bf._base = fp->_p = fp->_nbuf;			/* AlteraSpecific (see newlib/libc/include/stdio.h) */
 800a2e4:	808010c4 	addi	r2,r16,67
 800a2e8:	80800015 	stw	r2,0(r16)
 800a2ec:	80800017 	ldw	r2,0(r16)
 800a2f0:	80800415 	stw	r2,16(r16)
    fp->_bf._size = 1;					/* AlteraSpecific */
 800a2f4:	00800044 	movi	r2,1
 800a2f8:	80800515 	stw	r2,20(r16)
  }							/* AlteraSpecific */

  if ((p = _malloc_r (ptr, size)) == NULL)
 800a2fc:	880b883a 	mov	r5,r17
 800a300:	e13ffb17 	ldw	r4,-20(fp)
 800a304:	80071000 	call	8007100 <_malloc_r>
 800a308:	1027883a 	mov	r19,r2
 800a30c:	98000e1e 	bne	r19,zero,800a348 <__smakebuf_r+0x1a8>
    {
      if (!(fp->_flags & __SSTR))
 800a310:	8080030b 	ldhu	r2,12(r16)
 800a314:	10bfffcc 	andi	r2,r2,65535
 800a318:	1080800c 	andi	r2,r2,512
 800a31c:	1000221e 	bne	r2,zero,800a3a8 <__smakebuf_r+0x208>
	{
	  fp->_flags |= __SNBF;
 800a320:	8080030b 	ldhu	r2,12(r16)
 800a324:	10800094 	ori	r2,r2,2
 800a328:	8080030d 	sth	r2,12(r16)
	  fp->_bf._base = fp->_p = fp->_nbuf;
 800a32c:	808010c4 	addi	r2,r16,67
 800a330:	80800015 	stw	r2,0(r16)
 800a334:	80800017 	ldw	r2,0(r16)
 800a338:	80800415 	stw	r2,16(r16)
	  fp->_bf._size = 1;
 800a33c:	00800044 	movi	r2,1
 800a340:	80800515 	stw	r2,20(r16)
 800a344:	00001806 	br	800a3a8 <__smakebuf_r+0x208>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
 800a348:	e0fffb17 	ldw	r3,-20(fp)
 800a34c:	00820034 	movhi	r2,2048
 800a350:	1098c904 	addi	r2,r2,25380
 800a354:	18800f15 	stw	r2,60(r3)
      fp->_flags |= __SMBF;
 800a358:	8080030b 	ldhu	r2,12(r16)
 800a35c:	10802014 	ori	r2,r2,128
 800a360:	8080030d 	sth	r2,12(r16)
      fp->_bf._base = fp->_p = (unsigned char *) p;
 800a364:	84c00015 	stw	r19,0(r16)
 800a368:	80800017 	ldw	r2,0(r16)
 800a36c:	80800415 	stw	r2,16(r16)
      fp->_bf._size = size;
 800a370:	8805883a 	mov	r2,r17
 800a374:	80800515 	stw	r2,20(r16)
      if (couldbetty && _isatty_r (ptr, fp->_file))
 800a378:	90000b26 	beq	r18,zero,800a3a8 <__smakebuf_r+0x208>
 800a37c:	8080038b 	ldhu	r2,14(r16)
 800a380:	10bfffcc 	andi	r2,r2,65535
 800a384:	10a0001c 	xori	r2,r2,32768
 800a388:	10a00004 	addi	r2,r2,-32768
 800a38c:	100b883a 	mov	r5,r2
 800a390:	e13ffb17 	ldw	r4,-20(fp)
 800a394:	800a4a40 	call	800a4a4 <_isatty_r>
 800a398:	10000326 	beq	r2,zero,800a3a8 <__smakebuf_r+0x208>
	fp->_flags |= __SLBF;
 800a39c:	8080030b 	ldhu	r2,12(r16)
 800a3a0:	10800054 	ori	r2,r2,1
 800a3a4:	8080030d 	sth	r2,12(r16)
    }
}
 800a3a8:	e6fffc04 	addi	sp,fp,-16
 800a3ac:	dfc00517 	ldw	ra,20(sp)
 800a3b0:	df000417 	ldw	fp,16(sp)
 800a3b4:	dcc00317 	ldw	r19,12(sp)
 800a3b8:	dc800217 	ldw	r18,8(sp)
 800a3bc:	dc400117 	ldw	r17,4(sp)
 800a3c0:	dc000017 	ldw	r16,0(sp)
 800a3c4:	dec00604 	addi	sp,sp,24
 800a3c8:	f800283a 	ret

0800a3cc <_read_r>:
_DEFUN (_read_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _PTR buf _AND
     size_t cnt)
{
 800a3cc:	defff904 	addi	sp,sp,-28
 800a3d0:	dfc00615 	stw	ra,24(sp)
 800a3d4:	df000515 	stw	fp,20(sp)
 800a3d8:	df000504 	addi	fp,sp,20
 800a3dc:	e13ffc15 	stw	r4,-16(fp)
 800a3e0:	e17ffd15 	stw	r5,-12(fp)
 800a3e4:	e1bffe15 	stw	r6,-8(fp)
 800a3e8:	e1ffff15 	stw	r7,-4(fp)
  _ssize_t ret;

  errno = 0;
 800a3ec:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
 800a3f0:	e1bfff17 	ldw	r6,-4(fp)
 800a3f4:	e17ffe17 	ldw	r5,-8(fp)
 800a3f8:	e13ffd17 	ldw	r4,-12(fp)
 800a3fc:	800aae80 	call	800aae8 <read>
 800a400:	e0bffb15 	stw	r2,-20(fp)
 800a404:	e0bffb17 	ldw	r2,-20(fp)
 800a408:	10bfffd8 	cmpnei	r2,r2,-1
 800a40c:	1000051e 	bne	r2,zero,800a424 <_read_r+0x58>
 800a410:	d0a76a17 	ldw	r2,-25176(gp)
 800a414:	10000326 	beq	r2,zero,800a424 <_read_r+0x58>
    ptr->_errno = errno;
 800a418:	d0e76a17 	ldw	r3,-25176(gp)
 800a41c:	e0bffc17 	ldw	r2,-16(fp)
 800a420:	10c00015 	stw	r3,0(r2)
  return ret;
 800a424:	e0bffb17 	ldw	r2,-20(fp)
}
 800a428:	e037883a 	mov	sp,fp
 800a42c:	dfc00117 	ldw	ra,4(sp)
 800a430:	df000017 	ldw	fp,0(sp)
 800a434:	dec00204 	addi	sp,sp,8
 800a438:	f800283a 	ret

0800a43c <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
 800a43c:	defffa04 	addi	sp,sp,-24
 800a440:	dfc00515 	stw	ra,20(sp)
 800a444:	df000415 	stw	fp,16(sp)
 800a448:	df000404 	addi	fp,sp,16
 800a44c:	e13ffd15 	stw	r4,-12(fp)
 800a450:	e17ffe15 	stw	r5,-8(fp)
 800a454:	e1bfff15 	stw	r6,-4(fp)
  int ret;

  errno = 0;
 800a458:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
 800a45c:	e17fff17 	ldw	r5,-4(fp)
 800a460:	e13ffe17 	ldw	r4,-8(fp)
 800a464:	800a6780 	call	800a678 <fstat>
 800a468:	e0bffc15 	stw	r2,-16(fp)
 800a46c:	e0bffc17 	ldw	r2,-16(fp)
 800a470:	10bfffd8 	cmpnei	r2,r2,-1
 800a474:	1000051e 	bne	r2,zero,800a48c <_fstat_r+0x50>
 800a478:	d0a76a17 	ldw	r2,-25176(gp)
 800a47c:	10000326 	beq	r2,zero,800a48c <_fstat_r+0x50>
    ptr->_errno = errno;
 800a480:	d0e76a17 	ldw	r3,-25176(gp)
 800a484:	e0bffd17 	ldw	r2,-12(fp)
 800a488:	10c00015 	stw	r3,0(r2)
  return ret;
 800a48c:	e0bffc17 	ldw	r2,-16(fp)
}
 800a490:	e037883a 	mov	sp,fp
 800a494:	dfc00117 	ldw	ra,4(sp)
 800a498:	df000017 	ldw	fp,0(sp)
 800a49c:	dec00204 	addi	sp,sp,8
 800a4a0:	f800283a 	ret

0800a4a4 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 800a4a4:	defffb04 	addi	sp,sp,-20
 800a4a8:	dfc00415 	stw	ra,16(sp)
 800a4ac:	df000315 	stw	fp,12(sp)
 800a4b0:	df000304 	addi	fp,sp,12
 800a4b4:	e13ffe15 	stw	r4,-8(fp)
 800a4b8:	e17fff15 	stw	r5,-4(fp)
  int ret;

  errno = 0;
 800a4bc:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = _isatty (fd)) == -1 && errno != 0)
 800a4c0:	e13fff17 	ldw	r4,-4(fp)
 800a4c4:	800a7640 	call	800a764 <isatty>
 800a4c8:	e0bffd15 	stw	r2,-12(fp)
 800a4cc:	e0bffd17 	ldw	r2,-12(fp)
 800a4d0:	10bfffd8 	cmpnei	r2,r2,-1
 800a4d4:	1000051e 	bne	r2,zero,800a4ec <_isatty_r+0x48>
 800a4d8:	d0a76a17 	ldw	r2,-25176(gp)
 800a4dc:	10000326 	beq	r2,zero,800a4ec <_isatty_r+0x48>
    ptr->_errno = errno;
 800a4e0:	d0e76a17 	ldw	r3,-25176(gp)
 800a4e4:	e0bffe17 	ldw	r2,-8(fp)
 800a4e8:	10c00015 	stw	r3,0(r2)
  return ret;
 800a4ec:	e0bffd17 	ldw	r2,-12(fp)
}
 800a4f0:	e037883a 	mov	sp,fp
 800a4f4:	dfc00117 	ldw	ra,4(sp)
 800a4f8:	df000017 	ldw	fp,0(sp)
 800a4fc:	dec00204 	addi	sp,sp,8
 800a500:	f800283a 	ret

0800a504 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a504:	defffe04 	addi	sp,sp,-8
 800a508:	dfc00115 	stw	ra,4(sp)
 800a50c:	df000015 	stw	fp,0(sp)
 800a510:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a514:	d0a04b17 	ldw	r2,-32468(gp)
 800a518:	10000326 	beq	r2,zero,800a528 <alt_get_errno+0x24>
 800a51c:	d0a04b17 	ldw	r2,-32468(gp)
 800a520:	103ee83a 	callr	r2
 800a524:	00000106 	br	800a52c <alt_get_errno+0x28>
 800a528:	d0a76a04 	addi	r2,gp,-25176
}
 800a52c:	e037883a 	mov	sp,fp
 800a530:	dfc00117 	ldw	ra,4(sp)
 800a534:	df000017 	ldw	fp,0(sp)
 800a538:	dec00204 	addi	sp,sp,8
 800a53c:	f800283a 	ret

0800a540 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 800a540:	defffb04 	addi	sp,sp,-20
 800a544:	dfc00415 	stw	ra,16(sp)
 800a548:	df000315 	stw	fp,12(sp)
 800a54c:	df000304 	addi	fp,sp,12
 800a550:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 800a554:	e0bfff17 	ldw	r2,-4(fp)
 800a558:	10000616 	blt	r2,zero,800a574 <close+0x34>
 800a55c:	e0bfff17 	ldw	r2,-4(fp)
 800a560:	10c00324 	muli	r3,r2,12
 800a564:	00820134 	movhi	r2,2052
 800a568:	109bae04 	addi	r2,r2,28344
 800a56c:	1885883a 	add	r2,r3,r2
 800a570:	00000106 	br	800a578 <close+0x38>
 800a574:	0005883a 	mov	r2,zero
 800a578:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 800a57c:	e0bffd17 	ldw	r2,-12(fp)
 800a580:	10001926 	beq	r2,zero,800a5e8 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 800a584:	e0bffd17 	ldw	r2,-12(fp)
 800a588:	10800017 	ldw	r2,0(r2)
 800a58c:	10800417 	ldw	r2,16(r2)
 800a590:	10000626 	beq	r2,zero,800a5ac <close+0x6c>
 800a594:	e0bffd17 	ldw	r2,-12(fp)
 800a598:	10800017 	ldw	r2,0(r2)
 800a59c:	10800417 	ldw	r2,16(r2)
 800a5a0:	e13ffd17 	ldw	r4,-12(fp)
 800a5a4:	103ee83a 	callr	r2
 800a5a8:	00000106 	br	800a5b0 <close+0x70>
 800a5ac:	0005883a 	mov	r2,zero
 800a5b0:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 800a5b4:	e13fff17 	ldw	r4,-4(fp)
 800a5b8:	800abe40 	call	800abe4 <alt_release_fd>
    if (rval < 0)
 800a5bc:	e0bffe17 	ldw	r2,-8(fp)
 800a5c0:	1000070e 	bge	r2,zero,800a5e0 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 800a5c4:	800a5040 	call	800a504 <alt_get_errno>
 800a5c8:	1007883a 	mov	r3,r2
 800a5cc:	e0bffe17 	ldw	r2,-8(fp)
 800a5d0:	0085c83a 	sub	r2,zero,r2
 800a5d4:	18800015 	stw	r2,0(r3)
      return -1;
 800a5d8:	00bfffc4 	movi	r2,-1
 800a5dc:	00000706 	br	800a5fc <close+0xbc>
    }
    return 0;
 800a5e0:	0005883a 	mov	r2,zero
 800a5e4:	00000506 	br	800a5fc <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 800a5e8:	800a5040 	call	800a504 <alt_get_errno>
 800a5ec:	1007883a 	mov	r3,r2
 800a5f0:	00801444 	movi	r2,81
 800a5f4:	18800015 	stw	r2,0(r3)
    return -1;
 800a5f8:	00bfffc4 	movi	r2,-1
  }
}
 800a5fc:	e037883a 	mov	sp,fp
 800a600:	dfc00117 	ldw	ra,4(sp)
 800a604:	df000017 	ldw	fp,0(sp)
 800a608:	dec00204 	addi	sp,sp,8
 800a60c:	f800283a 	ret

0800a610 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 800a610:	defffc04 	addi	sp,sp,-16
 800a614:	df000315 	stw	fp,12(sp)
 800a618:	df000304 	addi	fp,sp,12
 800a61c:	e13ffd15 	stw	r4,-12(fp)
 800a620:	e17ffe15 	stw	r5,-8(fp)
 800a624:	e1bfff15 	stw	r6,-4(fp)
  return len;
 800a628:	e0bfff17 	ldw	r2,-4(fp)
}
 800a62c:	e037883a 	mov	sp,fp
 800a630:	df000017 	ldw	fp,0(sp)
 800a634:	dec00104 	addi	sp,sp,4
 800a638:	f800283a 	ret

0800a63c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a63c:	defffe04 	addi	sp,sp,-8
 800a640:	dfc00115 	stw	ra,4(sp)
 800a644:	df000015 	stw	fp,0(sp)
 800a648:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a64c:	d0a04b17 	ldw	r2,-32468(gp)
 800a650:	10000326 	beq	r2,zero,800a660 <alt_get_errno+0x24>
 800a654:	d0a04b17 	ldw	r2,-32468(gp)
 800a658:	103ee83a 	callr	r2
 800a65c:	00000106 	br	800a664 <alt_get_errno+0x28>
 800a660:	d0a76a04 	addi	r2,gp,-25176
}
 800a664:	e037883a 	mov	sp,fp
 800a668:	dfc00117 	ldw	ra,4(sp)
 800a66c:	df000017 	ldw	fp,0(sp)
 800a670:	dec00204 	addi	sp,sp,8
 800a674:	f800283a 	ret

0800a678 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 800a678:	defffb04 	addi	sp,sp,-20
 800a67c:	dfc00415 	stw	ra,16(sp)
 800a680:	df000315 	stw	fp,12(sp)
 800a684:	df000304 	addi	fp,sp,12
 800a688:	e13ffe15 	stw	r4,-8(fp)
 800a68c:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a690:	e0bffe17 	ldw	r2,-8(fp)
 800a694:	10000616 	blt	r2,zero,800a6b0 <fstat+0x38>
 800a698:	e0bffe17 	ldw	r2,-8(fp)
 800a69c:	10c00324 	muli	r3,r2,12
 800a6a0:	00820134 	movhi	r2,2052
 800a6a4:	109bae04 	addi	r2,r2,28344
 800a6a8:	1885883a 	add	r2,r3,r2
 800a6ac:	00000106 	br	800a6b4 <fstat+0x3c>
 800a6b0:	0005883a 	mov	r2,zero
 800a6b4:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 800a6b8:	e0bffd17 	ldw	r2,-12(fp)
 800a6bc:	10001026 	beq	r2,zero,800a700 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 800a6c0:	e0bffd17 	ldw	r2,-12(fp)
 800a6c4:	10800017 	ldw	r2,0(r2)
 800a6c8:	10800817 	ldw	r2,32(r2)
 800a6cc:	10000726 	beq	r2,zero,800a6ec <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 800a6d0:	e0bffd17 	ldw	r2,-12(fp)
 800a6d4:	10800017 	ldw	r2,0(r2)
 800a6d8:	10800817 	ldw	r2,32(r2)
 800a6dc:	e17fff17 	ldw	r5,-4(fp)
 800a6e0:	e13ffd17 	ldw	r4,-12(fp)
 800a6e4:	103ee83a 	callr	r2
 800a6e8:	00000a06 	br	800a714 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 800a6ec:	e0bfff17 	ldw	r2,-4(fp)
 800a6f0:	00c80004 	movi	r3,8192
 800a6f4:	10c00115 	stw	r3,4(r2)
      return 0;
 800a6f8:	0005883a 	mov	r2,zero
 800a6fc:	00000506 	br	800a714 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 800a700:	800a63c0 	call	800a63c <alt_get_errno>
 800a704:	1007883a 	mov	r3,r2
 800a708:	00801444 	movi	r2,81
 800a70c:	18800015 	stw	r2,0(r3)
    return -1;
 800a710:	00bfffc4 	movi	r2,-1
  }
}
 800a714:	e037883a 	mov	sp,fp
 800a718:	dfc00117 	ldw	ra,4(sp)
 800a71c:	df000017 	ldw	fp,0(sp)
 800a720:	dec00204 	addi	sp,sp,8
 800a724:	f800283a 	ret

0800a728 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a728:	defffe04 	addi	sp,sp,-8
 800a72c:	dfc00115 	stw	ra,4(sp)
 800a730:	df000015 	stw	fp,0(sp)
 800a734:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a738:	d0a04b17 	ldw	r2,-32468(gp)
 800a73c:	10000326 	beq	r2,zero,800a74c <alt_get_errno+0x24>
 800a740:	d0a04b17 	ldw	r2,-32468(gp)
 800a744:	103ee83a 	callr	r2
 800a748:	00000106 	br	800a750 <alt_get_errno+0x28>
 800a74c:	d0a76a04 	addi	r2,gp,-25176
}
 800a750:	e037883a 	mov	sp,fp
 800a754:	dfc00117 	ldw	ra,4(sp)
 800a758:	df000017 	ldw	fp,0(sp)
 800a75c:	dec00204 	addi	sp,sp,8
 800a760:	f800283a 	ret

0800a764 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 800a764:	deffed04 	addi	sp,sp,-76
 800a768:	dfc01215 	stw	ra,72(sp)
 800a76c:	df001115 	stw	fp,68(sp)
 800a770:	df001104 	addi	fp,sp,68
 800a774:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a778:	e0bfff17 	ldw	r2,-4(fp)
 800a77c:	10000616 	blt	r2,zero,800a798 <isatty+0x34>
 800a780:	e0bfff17 	ldw	r2,-4(fp)
 800a784:	10c00324 	muli	r3,r2,12
 800a788:	00820134 	movhi	r2,2052
 800a78c:	109bae04 	addi	r2,r2,28344
 800a790:	1885883a 	add	r2,r3,r2
 800a794:	00000106 	br	800a79c <isatty+0x38>
 800a798:	0005883a 	mov	r2,zero
 800a79c:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 800a7a0:	e0bfef17 	ldw	r2,-68(fp)
 800a7a4:	10000e26 	beq	r2,zero,800a7e0 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 800a7a8:	e0bfef17 	ldw	r2,-68(fp)
 800a7ac:	10800017 	ldw	r2,0(r2)
 800a7b0:	10800817 	ldw	r2,32(r2)
 800a7b4:	1000021e 	bne	r2,zero,800a7c0 <isatty+0x5c>
    {
      return 1;
 800a7b8:	00800044 	movi	r2,1
 800a7bc:	00000d06 	br	800a7f4 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 800a7c0:	e0bff004 	addi	r2,fp,-64
 800a7c4:	100b883a 	mov	r5,r2
 800a7c8:	e13fff17 	ldw	r4,-4(fp)
 800a7cc:	800a6780 	call	800a678 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 800a7d0:	e0bff117 	ldw	r2,-60(fp)
 800a7d4:	10880020 	cmpeqi	r2,r2,8192
 800a7d8:	10803fcc 	andi	r2,r2,255
 800a7dc:	00000506 	br	800a7f4 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 800a7e0:	800a7280 	call	800a728 <alt_get_errno>
 800a7e4:	1007883a 	mov	r3,r2
 800a7e8:	00801444 	movi	r2,81
 800a7ec:	18800015 	stw	r2,0(r3)
    return 0;
 800a7f0:	0005883a 	mov	r2,zero
  }
}
 800a7f4:	e037883a 	mov	sp,fp
 800a7f8:	dfc00117 	ldw	ra,4(sp)
 800a7fc:	df000017 	ldw	fp,0(sp)
 800a800:	dec00204 	addi	sp,sp,8
 800a804:	f800283a 	ret

0800a808 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 800a808:	defffc04 	addi	sp,sp,-16
 800a80c:	df000315 	stw	fp,12(sp)
 800a810:	df000304 	addi	fp,sp,12
 800a814:	e13ffd15 	stw	r4,-12(fp)
 800a818:	e17ffe15 	stw	r5,-8(fp)
 800a81c:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 800a820:	e0fffe17 	ldw	r3,-8(fp)
 800a824:	e0bffd17 	ldw	r2,-12(fp)
 800a828:	18800c26 	beq	r3,r2,800a85c <alt_load_section+0x54>
  {
    while( to != end )
 800a82c:	00000806 	br	800a850 <alt_load_section+0x48>
    {
      *to++ = *from++;
 800a830:	e0bffe17 	ldw	r2,-8(fp)
 800a834:	10c00104 	addi	r3,r2,4
 800a838:	e0fffe15 	stw	r3,-8(fp)
 800a83c:	e0fffd17 	ldw	r3,-12(fp)
 800a840:	19000104 	addi	r4,r3,4
 800a844:	e13ffd15 	stw	r4,-12(fp)
 800a848:	18c00017 	ldw	r3,0(r3)
 800a84c:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 800a850:	e0fffe17 	ldw	r3,-8(fp)
 800a854:	e0bfff17 	ldw	r2,-4(fp)
 800a858:	18bff51e 	bne	r3,r2,800a830 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 800a85c:	0001883a 	nop
 800a860:	e037883a 	mov	sp,fp
 800a864:	df000017 	ldw	fp,0(sp)
 800a868:	dec00104 	addi	sp,sp,4
 800a86c:	f800283a 	ret

0800a870 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 800a870:	defffe04 	addi	sp,sp,-8
 800a874:	dfc00115 	stw	ra,4(sp)
 800a878:	df000015 	stw	fp,0(sp)
 800a87c:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 800a880:	01820174 	movhi	r6,2053
 800a884:	31a0ae04 	addi	r6,r6,-32072
 800a888:	01420134 	movhi	r5,2052
 800a88c:	29599904 	addi	r5,r5,26212
 800a890:	01020174 	movhi	r4,2053
 800a894:	2120ae04 	addi	r4,r4,-32072
 800a898:	800a8080 	call	800a808 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 800a89c:	01820034 	movhi	r6,2048
 800a8a0:	31809104 	addi	r6,r6,580
 800a8a4:	01420034 	movhi	r5,2048
 800a8a8:	29400804 	addi	r5,r5,32
 800a8ac:	01020034 	movhi	r4,2048
 800a8b0:	21000804 	addi	r4,r4,32
 800a8b4:	800a8080 	call	800a808 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 800a8b8:	01820134 	movhi	r6,2052
 800a8bc:	31999904 	addi	r6,r6,26212
 800a8c0:	01420074 	movhi	r5,2049
 800a8c4:	29779104 	addi	r5,r5,-8636
 800a8c8:	01020074 	movhi	r4,2049
 800a8cc:	21379104 	addi	r4,r4,-8636
 800a8d0:	800a8080 	call	800a808 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 800a8d4:	800cf7c0 	call	800cf7c <alt_dcache_flush_all>
  alt_icache_flush_all();
 800a8d8:	800d1f40 	call	800d1f4 <alt_icache_flush_all>
}
 800a8dc:	0001883a 	nop
 800a8e0:	e037883a 	mov	sp,fp
 800a8e4:	dfc00117 	ldw	ra,4(sp)
 800a8e8:	df000017 	ldw	fp,0(sp)
 800a8ec:	dec00204 	addi	sp,sp,8
 800a8f0:	f800283a 	ret

0800a8f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a8f4:	defffe04 	addi	sp,sp,-8
 800a8f8:	dfc00115 	stw	ra,4(sp)
 800a8fc:	df000015 	stw	fp,0(sp)
 800a900:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a904:	d0a04b17 	ldw	r2,-32468(gp)
 800a908:	10000326 	beq	r2,zero,800a918 <alt_get_errno+0x24>
 800a90c:	d0a04b17 	ldw	r2,-32468(gp)
 800a910:	103ee83a 	callr	r2
 800a914:	00000106 	br	800a91c <alt_get_errno+0x28>
 800a918:	d0a76a04 	addi	r2,gp,-25176
}
 800a91c:	e037883a 	mov	sp,fp
 800a920:	dfc00117 	ldw	ra,4(sp)
 800a924:	df000017 	ldw	fp,0(sp)
 800a928:	dec00204 	addi	sp,sp,8
 800a92c:	f800283a 	ret

0800a930 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 800a930:	defff904 	addi	sp,sp,-28
 800a934:	dfc00615 	stw	ra,24(sp)
 800a938:	df000515 	stw	fp,20(sp)
 800a93c:	df000504 	addi	fp,sp,20
 800a940:	e13ffd15 	stw	r4,-12(fp)
 800a944:	e17ffe15 	stw	r5,-8(fp)
 800a948:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 800a94c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a950:	e0bffd17 	ldw	r2,-12(fp)
 800a954:	10000616 	blt	r2,zero,800a970 <lseek+0x40>
 800a958:	e0bffd17 	ldw	r2,-12(fp)
 800a95c:	10c00324 	muli	r3,r2,12
 800a960:	00820134 	movhi	r2,2052
 800a964:	109bae04 	addi	r2,r2,28344
 800a968:	1885883a 	add	r2,r3,r2
 800a96c:	00000106 	br	800a974 <lseek+0x44>
 800a970:	0005883a 	mov	r2,zero
 800a974:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 800a978:	e0bffc17 	ldw	r2,-16(fp)
 800a97c:	10001026 	beq	r2,zero,800a9c0 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 800a980:	e0bffc17 	ldw	r2,-16(fp)
 800a984:	10800017 	ldw	r2,0(r2)
 800a988:	10800717 	ldw	r2,28(r2)
 800a98c:	10000926 	beq	r2,zero,800a9b4 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 800a990:	e0bffc17 	ldw	r2,-16(fp)
 800a994:	10800017 	ldw	r2,0(r2)
 800a998:	10800717 	ldw	r2,28(r2)
 800a99c:	e1bfff17 	ldw	r6,-4(fp)
 800a9a0:	e17ffe17 	ldw	r5,-8(fp)
 800a9a4:	e13ffc17 	ldw	r4,-16(fp)
 800a9a8:	103ee83a 	callr	r2
 800a9ac:	e0bffb15 	stw	r2,-20(fp)
 800a9b0:	00000506 	br	800a9c8 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 800a9b4:	00bfde84 	movi	r2,-134
 800a9b8:	e0bffb15 	stw	r2,-20(fp)
 800a9bc:	00000206 	br	800a9c8 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 800a9c0:	00bfebc4 	movi	r2,-81
 800a9c4:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 800a9c8:	e0bffb17 	ldw	r2,-20(fp)
 800a9cc:	1000070e 	bge	r2,zero,800a9ec <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 800a9d0:	800a8f40 	call	800a8f4 <alt_get_errno>
 800a9d4:	1007883a 	mov	r3,r2
 800a9d8:	e0bffb17 	ldw	r2,-20(fp)
 800a9dc:	0085c83a 	sub	r2,zero,r2
 800a9e0:	18800015 	stw	r2,0(r3)
    rc = -1;
 800a9e4:	00bfffc4 	movi	r2,-1
 800a9e8:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 800a9ec:	e0bffb17 	ldw	r2,-20(fp)
}
 800a9f0:	e037883a 	mov	sp,fp
 800a9f4:	dfc00117 	ldw	ra,4(sp)
 800a9f8:	df000017 	ldw	fp,0(sp)
 800a9fc:	dec00204 	addi	sp,sp,8
 800aa00:	f800283a 	ret

0800aa04 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 800aa04:	defffd04 	addi	sp,sp,-12
 800aa08:	dfc00215 	stw	ra,8(sp)
 800aa0c:	df000115 	stw	fp,4(sp)
 800aa10:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 800aa14:	0009883a 	mov	r4,zero
 800aa18:	800ae600 	call	800ae60 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 800aa1c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 800aa20:	800ae980 	call	800ae98 <alt_sys_init>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 800aa24:	800d0a40 	call	800d0a4 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 800aa28:	01020074 	movhi	r4,2049
 800aa2c:	21344104 	addi	r4,r4,-12028
 800aa30:	800d7bc0 	call	800d7bc <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 800aa34:	d0a76b17 	ldw	r2,-25172(gp)
 800aa38:	d0e76c17 	ldw	r3,-25168(gp)
 800aa3c:	d1276d17 	ldw	r4,-25164(gp)
 800aa40:	200d883a 	mov	r6,r4
 800aa44:	180b883a 	mov	r5,r3
 800aa48:	1009883a 	mov	r4,r2
 800aa4c:	80006c00 	call	80006c0 <main>
 800aa50:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 800aa54:	01000044 	movi	r4,1
 800aa58:	800a5400 	call	800a540 <close>
  exit (result);
 800aa5c:	e13fff17 	ldw	r4,-4(fp)
 800aa60:	800d7f80 	call	800d7f8 <exit>

0800aa64 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 800aa64:	defffe04 	addi	sp,sp,-8
 800aa68:	df000115 	stw	fp,4(sp)
 800aa6c:	df000104 	addi	fp,sp,4
 800aa70:	e13fff15 	stw	r4,-4(fp)
}
 800aa74:	0001883a 	nop
 800aa78:	e037883a 	mov	sp,fp
 800aa7c:	df000017 	ldw	fp,0(sp)
 800aa80:	dec00104 	addi	sp,sp,4
 800aa84:	f800283a 	ret

0800aa88 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 800aa88:	defffe04 	addi	sp,sp,-8
 800aa8c:	df000115 	stw	fp,4(sp)
 800aa90:	df000104 	addi	fp,sp,4
 800aa94:	e13fff15 	stw	r4,-4(fp)
}
 800aa98:	0001883a 	nop
 800aa9c:	e037883a 	mov	sp,fp
 800aaa0:	df000017 	ldw	fp,0(sp)
 800aaa4:	dec00104 	addi	sp,sp,4
 800aaa8:	f800283a 	ret

0800aaac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800aaac:	defffe04 	addi	sp,sp,-8
 800aab0:	dfc00115 	stw	ra,4(sp)
 800aab4:	df000015 	stw	fp,0(sp)
 800aab8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800aabc:	d0a04b17 	ldw	r2,-32468(gp)
 800aac0:	10000326 	beq	r2,zero,800aad0 <alt_get_errno+0x24>
 800aac4:	d0a04b17 	ldw	r2,-32468(gp)
 800aac8:	103ee83a 	callr	r2
 800aacc:	00000106 	br	800aad4 <alt_get_errno+0x28>
 800aad0:	d0a76a04 	addi	r2,gp,-25176
}
 800aad4:	e037883a 	mov	sp,fp
 800aad8:	dfc00117 	ldw	ra,4(sp)
 800aadc:	df000017 	ldw	fp,0(sp)
 800aae0:	dec00204 	addi	sp,sp,8
 800aae4:	f800283a 	ret

0800aae8 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 800aae8:	defff904 	addi	sp,sp,-28
 800aaec:	dfc00615 	stw	ra,24(sp)
 800aaf0:	df000515 	stw	fp,20(sp)
 800aaf4:	df000504 	addi	fp,sp,20
 800aaf8:	e13ffd15 	stw	r4,-12(fp)
 800aafc:	e17ffe15 	stw	r5,-8(fp)
 800ab00:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800ab04:	e0bffd17 	ldw	r2,-12(fp)
 800ab08:	10000616 	blt	r2,zero,800ab24 <read+0x3c>
 800ab0c:	e0bffd17 	ldw	r2,-12(fp)
 800ab10:	10c00324 	muli	r3,r2,12
 800ab14:	00820134 	movhi	r2,2052
 800ab18:	109bae04 	addi	r2,r2,28344
 800ab1c:	1885883a 	add	r2,r3,r2
 800ab20:	00000106 	br	800ab28 <read+0x40>
 800ab24:	0005883a 	mov	r2,zero
 800ab28:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 800ab2c:	e0bffb17 	ldw	r2,-20(fp)
 800ab30:	10002226 	beq	r2,zero,800abbc <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 800ab34:	e0bffb17 	ldw	r2,-20(fp)
 800ab38:	10800217 	ldw	r2,8(r2)
 800ab3c:	108000cc 	andi	r2,r2,3
 800ab40:	10800060 	cmpeqi	r2,r2,1
 800ab44:	1000181e 	bne	r2,zero,800aba8 <read+0xc0>
        (fd->dev->read))
 800ab48:	e0bffb17 	ldw	r2,-20(fp)
 800ab4c:	10800017 	ldw	r2,0(r2)
 800ab50:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 800ab54:	10001426 	beq	r2,zero,800aba8 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 800ab58:	e0bffb17 	ldw	r2,-20(fp)
 800ab5c:	10800017 	ldw	r2,0(r2)
 800ab60:	10800517 	ldw	r2,20(r2)
 800ab64:	e0ffff17 	ldw	r3,-4(fp)
 800ab68:	180d883a 	mov	r6,r3
 800ab6c:	e17ffe17 	ldw	r5,-8(fp)
 800ab70:	e13ffb17 	ldw	r4,-20(fp)
 800ab74:	103ee83a 	callr	r2
 800ab78:	e0bffc15 	stw	r2,-16(fp)
 800ab7c:	e0bffc17 	ldw	r2,-16(fp)
 800ab80:	1000070e 	bge	r2,zero,800aba0 <read+0xb8>
        {
          ALT_ERRNO = -rval;
 800ab84:	800aaac0 	call	800aaac <alt_get_errno>
 800ab88:	1007883a 	mov	r3,r2
 800ab8c:	e0bffc17 	ldw	r2,-16(fp)
 800ab90:	0085c83a 	sub	r2,zero,r2
 800ab94:	18800015 	stw	r2,0(r3)
          return -1;
 800ab98:	00bfffc4 	movi	r2,-1
 800ab9c:	00000c06 	br	800abd0 <read+0xe8>
        }
        return rval;
 800aba0:	e0bffc17 	ldw	r2,-16(fp)
 800aba4:	00000a06 	br	800abd0 <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 800aba8:	800aaac0 	call	800aaac <alt_get_errno>
 800abac:	1007883a 	mov	r3,r2
 800abb0:	00800344 	movi	r2,13
 800abb4:	18800015 	stw	r2,0(r3)
 800abb8:	00000406 	br	800abcc <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 800abbc:	800aaac0 	call	800aaac <alt_get_errno>
 800abc0:	1007883a 	mov	r3,r2
 800abc4:	00801444 	movi	r2,81
 800abc8:	18800015 	stw	r2,0(r3)
  }
  return -1;
 800abcc:	00bfffc4 	movi	r2,-1
}
 800abd0:	e037883a 	mov	sp,fp
 800abd4:	dfc00117 	ldw	ra,4(sp)
 800abd8:	df000017 	ldw	fp,0(sp)
 800abdc:	dec00204 	addi	sp,sp,8
 800abe0:	f800283a 	ret

0800abe4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 800abe4:	defffe04 	addi	sp,sp,-8
 800abe8:	df000115 	stw	fp,4(sp)
 800abec:	df000104 	addi	fp,sp,4
 800abf0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 800abf4:	e0bfff17 	ldw	r2,-4(fp)
 800abf8:	108000d0 	cmplti	r2,r2,3
 800abfc:	10000d1e 	bne	r2,zero,800ac34 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 800ac00:	00820134 	movhi	r2,2052
 800ac04:	109bae04 	addi	r2,r2,28344
 800ac08:	e0ffff17 	ldw	r3,-4(fp)
 800ac0c:	18c00324 	muli	r3,r3,12
 800ac10:	10c5883a 	add	r2,r2,r3
 800ac14:	10800204 	addi	r2,r2,8
 800ac18:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 800ac1c:	00820134 	movhi	r2,2052
 800ac20:	109bae04 	addi	r2,r2,28344
 800ac24:	e0ffff17 	ldw	r3,-4(fp)
 800ac28:	18c00324 	muli	r3,r3,12
 800ac2c:	10c5883a 	add	r2,r2,r3
 800ac30:	10000015 	stw	zero,0(r2)
  }
}
 800ac34:	0001883a 	nop
 800ac38:	e037883a 	mov	sp,fp
 800ac3c:	df000017 	ldw	fp,0(sp)
 800ac40:	dec00104 	addi	sp,sp,4
 800ac44:	f800283a 	ret

0800ac48 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 800ac48:	defff904 	addi	sp,sp,-28
 800ac4c:	df000615 	stw	fp,24(sp)
 800ac50:	df000604 	addi	fp,sp,24
 800ac54:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800ac58:	0005303a 	rdctl	r2,status
 800ac5c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800ac60:	e0fffe17 	ldw	r3,-8(fp)
 800ac64:	00bfff84 	movi	r2,-2
 800ac68:	1884703a 	and	r2,r3,r2
 800ac6c:	1001703a 	wrctl	status,r2
  
  return context;
 800ac70:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 800ac74:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 800ac78:	d0a04c17 	ldw	r2,-32464(gp)
 800ac7c:	10c000c4 	addi	r3,r2,3
 800ac80:	00bfff04 	movi	r2,-4
 800ac84:	1884703a 	and	r2,r3,r2
 800ac88:	d0a04c15 	stw	r2,-32464(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 800ac8c:	d0e04c17 	ldw	r3,-32464(gp)
 800ac90:	e0bfff17 	ldw	r2,-4(fp)
 800ac94:	1887883a 	add	r3,r3,r2
 800ac98:	00840034 	movhi	r2,4096
 800ac9c:	10800004 	addi	r2,r2,0
 800aca0:	10c0062e 	bgeu	r2,r3,800acbc <sbrk+0x74>
 800aca4:	e0bffb17 	ldw	r2,-20(fp)
 800aca8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800acac:	e0bffa17 	ldw	r2,-24(fp)
 800acb0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 800acb4:	00bfffc4 	movi	r2,-1
 800acb8:	00000b06 	br	800ace8 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 800acbc:	d0a04c17 	ldw	r2,-32464(gp)
 800acc0:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 800acc4:	d0e04c17 	ldw	r3,-32464(gp)
 800acc8:	e0bfff17 	ldw	r2,-4(fp)
 800accc:	1885883a 	add	r2,r3,r2
 800acd0:	d0a04c15 	stw	r2,-32464(gp)
 800acd4:	e0bffb17 	ldw	r2,-20(fp)
 800acd8:	e0bffc15 	stw	r2,-16(fp)
 800acdc:	e0bffc17 	ldw	r2,-16(fp)
 800ace0:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 800ace4:	e0bffd17 	ldw	r2,-12(fp)
} 
 800ace8:	e037883a 	mov	sp,fp
 800acec:	df000017 	ldw	fp,0(sp)
 800acf0:	dec00104 	addi	sp,sp,4
 800acf4:	f800283a 	ret

0800acf8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800acf8:	defffe04 	addi	sp,sp,-8
 800acfc:	dfc00115 	stw	ra,4(sp)
 800ad00:	df000015 	stw	fp,0(sp)
 800ad04:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800ad08:	d0a04b17 	ldw	r2,-32468(gp)
 800ad0c:	10000326 	beq	r2,zero,800ad1c <alt_get_errno+0x24>
 800ad10:	d0a04b17 	ldw	r2,-32468(gp)
 800ad14:	103ee83a 	callr	r2
 800ad18:	00000106 	br	800ad20 <alt_get_errno+0x28>
 800ad1c:	d0a76a04 	addi	r2,gp,-25176
}
 800ad20:	e037883a 	mov	sp,fp
 800ad24:	dfc00117 	ldw	ra,4(sp)
 800ad28:	df000017 	ldw	fp,0(sp)
 800ad2c:	dec00204 	addi	sp,sp,8
 800ad30:	f800283a 	ret

0800ad34 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 800ad34:	defff904 	addi	sp,sp,-28
 800ad38:	dfc00615 	stw	ra,24(sp)
 800ad3c:	df000515 	stw	fp,20(sp)
 800ad40:	df000504 	addi	fp,sp,20
 800ad44:	e13ffd15 	stw	r4,-12(fp)
 800ad48:	e17ffe15 	stw	r5,-8(fp)
 800ad4c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800ad50:	e0bffd17 	ldw	r2,-12(fp)
 800ad54:	10000616 	blt	r2,zero,800ad70 <write+0x3c>
 800ad58:	e0bffd17 	ldw	r2,-12(fp)
 800ad5c:	10c00324 	muli	r3,r2,12
 800ad60:	00820134 	movhi	r2,2052
 800ad64:	109bae04 	addi	r2,r2,28344
 800ad68:	1885883a 	add	r2,r3,r2
 800ad6c:	00000106 	br	800ad74 <write+0x40>
 800ad70:	0005883a 	mov	r2,zero
 800ad74:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 800ad78:	e0bffb17 	ldw	r2,-20(fp)
 800ad7c:	10002126 	beq	r2,zero,800ae04 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 800ad80:	e0bffb17 	ldw	r2,-20(fp)
 800ad84:	10800217 	ldw	r2,8(r2)
 800ad88:	108000cc 	andi	r2,r2,3
 800ad8c:	10001826 	beq	r2,zero,800adf0 <write+0xbc>
 800ad90:	e0bffb17 	ldw	r2,-20(fp)
 800ad94:	10800017 	ldw	r2,0(r2)
 800ad98:	10800617 	ldw	r2,24(r2)
 800ad9c:	10001426 	beq	r2,zero,800adf0 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 800ada0:	e0bffb17 	ldw	r2,-20(fp)
 800ada4:	10800017 	ldw	r2,0(r2)
 800ada8:	10800617 	ldw	r2,24(r2)
 800adac:	e0ffff17 	ldw	r3,-4(fp)
 800adb0:	180d883a 	mov	r6,r3
 800adb4:	e17ffe17 	ldw	r5,-8(fp)
 800adb8:	e13ffb17 	ldw	r4,-20(fp)
 800adbc:	103ee83a 	callr	r2
 800adc0:	e0bffc15 	stw	r2,-16(fp)
 800adc4:	e0bffc17 	ldw	r2,-16(fp)
 800adc8:	1000070e 	bge	r2,zero,800ade8 <write+0xb4>
      {
        ALT_ERRNO = -rval;
 800adcc:	800acf80 	call	800acf8 <alt_get_errno>
 800add0:	1007883a 	mov	r3,r2
 800add4:	e0bffc17 	ldw	r2,-16(fp)
 800add8:	0085c83a 	sub	r2,zero,r2
 800addc:	18800015 	stw	r2,0(r3)
        return -1;
 800ade0:	00bfffc4 	movi	r2,-1
 800ade4:	00000c06 	br	800ae18 <write+0xe4>
      }
      return rval;
 800ade8:	e0bffc17 	ldw	r2,-16(fp)
 800adec:	00000a06 	br	800ae18 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 800adf0:	800acf80 	call	800acf8 <alt_get_errno>
 800adf4:	1007883a 	mov	r3,r2
 800adf8:	00800344 	movi	r2,13
 800adfc:	18800015 	stw	r2,0(r3)
 800ae00:	00000406 	br	800ae14 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 800ae04:	800acf80 	call	800acf8 <alt_get_errno>
 800ae08:	1007883a 	mov	r3,r2
 800ae0c:	00801444 	movi	r2,81
 800ae10:	18800015 	stw	r2,0(r3)
  }
  return -1;
 800ae14:	00bfffc4 	movi	r2,-1
}
 800ae18:	e037883a 	mov	sp,fp
 800ae1c:	dfc00117 	ldw	ra,4(sp)
 800ae20:	df000017 	ldw	fp,0(sp)
 800ae24:	dec00204 	addi	sp,sp,8
 800ae28:	f800283a 	ret

0800ae2c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 800ae2c:	defffd04 	addi	sp,sp,-12
 800ae30:	dfc00215 	stw	ra,8(sp)
 800ae34:	df000115 	stw	fp,4(sp)
 800ae38:	df000104 	addi	fp,sp,4
 800ae3c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 800ae40:	d1604804 	addi	r5,gp,-32480
 800ae44:	e13fff17 	ldw	r4,-4(fp)
 800ae48:	800d0000 	call	800d000 <alt_dev_llist_insert>
}
 800ae4c:	e037883a 	mov	sp,fp
 800ae50:	dfc00117 	ldw	ra,4(sp)
 800ae54:	df000017 	ldw	fp,0(sp)
 800ae58:	dec00204 	addi	sp,sp,8
 800ae5c:	f800283a 	ret

0800ae60 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 800ae60:	defffd04 	addi	sp,sp,-12
 800ae64:	dfc00215 	stw	ra,8(sp)
 800ae68:	df000115 	stw	fp,4(sp)
 800ae6c:	df000104 	addi	fp,sp,4
 800ae70:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
 800ae74:	800d66c0 	call	800d66c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 800ae78:	00800044 	movi	r2,1
 800ae7c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 800ae80:	0001883a 	nop
 800ae84:	e037883a 	mov	sp,fp
 800ae88:	dfc00117 	ldw	ra,4(sp)
 800ae8c:	df000017 	ldw	fp,0(sp)
 800ae90:	dec00204 	addi	sp,sp,8
 800ae94:	f800283a 	ret

0800ae98 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 800ae98:	defffd04 	addi	sp,sp,-12
 800ae9c:	dfc00215 	stw	ra,8(sp)
 800aea0:	df000115 	stw	fp,4(sp)
 800aea4:	df000104 	addi	fp,sp,4
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 800aea8:	000d883a 	mov	r6,zero
 800aeac:	000b883a 	mov	r5,zero
 800aeb0:	01020134 	movhi	r4,2052
 800aeb4:	211c1804 	addi	r4,r4,28768
 800aeb8:	800b3b80 	call	800b3b8 <altera_avalon_jtag_uart_init>
 800aebc:	01020134 	movhi	r4,2052
 800aec0:	211c0e04 	addi	r4,r4,28728
 800aec4:	800ae2c0 	call	800ae2c <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_CHARACTER_BUFFER_WITH_DMA_INIT ( VIDEO_CHARACTER_BUFFER_WITH_DMA_0, video_character_buffer_with_dma_0);
 800aec8:	00820174 	movhi	r2,2053
 800aecc:	10a02604 	addi	r2,r2,-32616
 800aed0:	10800a17 	ldw	r2,40(r2)
 800aed4:	10800104 	addi	r2,r2,4
 800aed8:	10800017 	ldw	r2,0(r2)
 800aedc:	10ffffcc 	andi	r3,r2,65535
 800aee0:	00820174 	movhi	r2,2053
 800aee4:	10a02604 	addi	r2,r2,-32616
 800aee8:	10c00c15 	stw	r3,48(r2)
 800aeec:	00820174 	movhi	r2,2053
 800aef0:	10a02604 	addi	r2,r2,-32616
 800aef4:	10800a17 	ldw	r2,40(r2)
 800aef8:	10800104 	addi	r2,r2,4
 800aefc:	10800017 	ldw	r2,0(r2)
 800af00:	1006d43a 	srli	r3,r2,16
 800af04:	00820174 	movhi	r2,2053
 800af08:	10a02604 	addi	r2,r2,-32616
 800af0c:	10c00d15 	stw	r3,52(r2)
 800af10:	00820174 	movhi	r2,2053
 800af14:	10a02604 	addi	r2,r2,-32616
 800af18:	10800c17 	ldw	r2,48(r2)
 800af1c:	10801068 	cmpgeui	r2,r2,65
 800af20:	1000081e 	bne	r2,zero,800af44 <alt_sys_init+0xac>
 800af24:	00820174 	movhi	r2,2053
 800af28:	10a02604 	addi	r2,r2,-32616
 800af2c:	00c00fc4 	movi	r3,63
 800af30:	10c00f15 	stw	r3,60(r2)
 800af34:	00820174 	movhi	r2,2053
 800af38:	10a02604 	addi	r2,r2,-32616
 800af3c:	00c00184 	movi	r3,6
 800af40:	10c01015 	stw	r3,64(r2)
 800af44:	00820174 	movhi	r2,2053
 800af48:	10a02604 	addi	r2,r2,-32616
 800af4c:	10800d17 	ldw	r2,52(r2)
 800af50:	10800868 	cmpgeui	r2,r2,33
 800af54:	1000041e 	bne	r2,zero,800af68 <alt_sys_init+0xd0>
 800af58:	00820174 	movhi	r2,2053
 800af5c:	10a02604 	addi	r2,r2,-32616
 800af60:	00c007c4 	movi	r3,31
 800af64:	10c01115 	stw	r3,68(r2)
 800af68:	01020174 	movhi	r4,2053
 800af6c:	21202604 	addi	r4,r4,-32616
 800af70:	800bcbc0 	call	800bcbc <alt_up_char_buffer_init>
 800af74:	01020174 	movhi	r4,2053
 800af78:	21202604 	addi	r4,r4,-32616
 800af7c:	800ae2c0 	call	800ae2c <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_PIXEL_BUFFER_DMA_INIT ( VIDEO_PIXEL_BUFFER_DMA_0, video_pixel_buffer_dma_0);
 800af80:	00820174 	movhi	r2,2053
 800af84:	10a03804 	addi	r2,r2,-32544
 800af88:	10800a17 	ldw	r2,40(r2)
 800af8c:	10800017 	ldw	r2,0(r2)
 800af90:	1007883a 	mov	r3,r2
 800af94:	00820174 	movhi	r2,2053
 800af98:	10a03804 	addi	r2,r2,-32544
 800af9c:	10c00b15 	stw	r3,44(r2)
 800afa0:	00820174 	movhi	r2,2053
 800afa4:	10a03804 	addi	r2,r2,-32544
 800afa8:	10800a17 	ldw	r2,40(r2)
 800afac:	10800104 	addi	r2,r2,4
 800afb0:	10800017 	ldw	r2,0(r2)
 800afb4:	1007883a 	mov	r3,r2
 800afb8:	00820174 	movhi	r2,2053
 800afbc:	10a03804 	addi	r2,r2,-32544
 800afc0:	10c00c15 	stw	r3,48(r2)
 800afc4:	00820174 	movhi	r2,2053
 800afc8:	10a03804 	addi	r2,r2,-32544
 800afcc:	10800a17 	ldw	r2,40(r2)
 800afd0:	10800204 	addi	r2,r2,8
 800afd4:	10800017 	ldw	r2,0(r2)
 800afd8:	10ffffcc 	andi	r3,r2,65535
 800afdc:	00820174 	movhi	r2,2053
 800afe0:	10a03804 	addi	r2,r2,-32544
 800afe4:	10c00f15 	stw	r3,60(r2)
 800afe8:	00820174 	movhi	r2,2053
 800afec:	10a03804 	addi	r2,r2,-32544
 800aff0:	10800a17 	ldw	r2,40(r2)
 800aff4:	10800204 	addi	r2,r2,8
 800aff8:	10800017 	ldw	r2,0(r2)
 800affc:	1006d43a 	srli	r3,r2,16
 800b000:	00820174 	movhi	r2,2053
 800b004:	10a03804 	addi	r2,r2,-32544
 800b008:	10c01015 	stw	r3,64(r2)
 800b00c:	00820174 	movhi	r2,2053
 800b010:	10a03804 	addi	r2,r2,-32544
 800b014:	10800a17 	ldw	r2,40(r2)
 800b018:	10800304 	addi	r2,r2,12
 800b01c:	10800017 	ldw	r2,0(r2)
 800b020:	1005d07a 	srai	r2,r2,1
 800b024:	10c0004c 	andi	r3,r2,1
 800b028:	00820174 	movhi	r2,2053
 800b02c:	10a03804 	addi	r2,r2,-32544
 800b030:	10c00d15 	stw	r3,52(r2)
 800b034:	00820174 	movhi	r2,2053
 800b038:	10a03804 	addi	r2,r2,-32544
 800b03c:	10800a17 	ldw	r2,40(r2)
 800b040:	10800304 	addi	r2,r2,12
 800b044:	10800017 	ldw	r2,0(r2)
 800b048:	1005d13a 	srai	r2,r2,4
 800b04c:	10c003cc 	andi	r3,r2,15
 800b050:	00820174 	movhi	r2,2053
 800b054:	10a03804 	addi	r2,r2,-32544
 800b058:	10c00e15 	stw	r3,56(r2)
 800b05c:	00820174 	movhi	r2,2053
 800b060:	10a03804 	addi	r2,r2,-32544
 800b064:	10800a17 	ldw	r2,40(r2)
 800b068:	10800304 	addi	r2,r2,12
 800b06c:	10800017 	ldw	r2,0(r2)
 800b070:	1005d43a 	srai	r2,r2,16
 800b074:	e0bfff05 	stb	r2,-4(fp)
 800b078:	00820174 	movhi	r2,2053
 800b07c:	10a03804 	addi	r2,r2,-32544
 800b080:	10800a17 	ldw	r2,40(r2)
 800b084:	10800304 	addi	r2,r2,12
 800b088:	10800017 	ldw	r2,0(r2)
 800b08c:	1004d63a 	srli	r2,r2,24
 800b090:	e0bfff45 	stb	r2,-3(fp)
 800b094:	00820174 	movhi	r2,2053
 800b098:	10a03804 	addi	r2,r2,-32544
 800b09c:	10800e17 	ldw	r2,56(r2)
 800b0a0:	10800058 	cmpnei	r2,r2,1
 800b0a4:	1000041e 	bne	r2,zero,800b0b8 <alt_sys_init+0x220>
 800b0a8:	00820174 	movhi	r2,2053
 800b0ac:	10a03804 	addi	r2,r2,-32544
 800b0b0:	10001115 	stw	zero,68(r2)
 800b0b4:	00000e06 	br	800b0f0 <alt_sys_init+0x258>
 800b0b8:	00820174 	movhi	r2,2053
 800b0bc:	10a03804 	addi	r2,r2,-32544
 800b0c0:	10800e17 	ldw	r2,56(r2)
 800b0c4:	10800098 	cmpnei	r2,r2,2
 800b0c8:	1000051e 	bne	r2,zero,800b0e0 <alt_sys_init+0x248>
 800b0cc:	00820174 	movhi	r2,2053
 800b0d0:	10a03804 	addi	r2,r2,-32544
 800b0d4:	00c00044 	movi	r3,1
 800b0d8:	10c01115 	stw	r3,68(r2)
 800b0dc:	00000406 	br	800b0f0 <alt_sys_init+0x258>
 800b0e0:	00820174 	movhi	r2,2053
 800b0e4:	10a03804 	addi	r2,r2,-32544
 800b0e8:	00c00084 	movi	r3,2
 800b0ec:	10c01115 	stw	r3,68(r2)
 800b0f0:	e0bfff03 	ldbu	r2,-4(fp)
 800b0f4:	00c00804 	movi	r3,32
 800b0f8:	1885c83a 	sub	r2,r3,r2
 800b0fc:	00ffffc4 	movi	r3,-1
 800b100:	1886d83a 	srl	r3,r3,r2
 800b104:	00820174 	movhi	r2,2053
 800b108:	10a03804 	addi	r2,r2,-32544
 800b10c:	10c01215 	stw	r3,72(r2)
 800b110:	e0ffff03 	ldbu	r3,-4(fp)
 800b114:	00820174 	movhi	r2,2053
 800b118:	10a03804 	addi	r2,r2,-32544
 800b11c:	10801117 	ldw	r2,68(r2)
 800b120:	1887883a 	add	r3,r3,r2
 800b124:	00820174 	movhi	r2,2053
 800b128:	10a03804 	addi	r2,r2,-32544
 800b12c:	10c01315 	stw	r3,76(r2)
 800b130:	e0bfff43 	ldbu	r2,-3(fp)
 800b134:	00c00804 	movi	r3,32
 800b138:	1885c83a 	sub	r2,r3,r2
 800b13c:	00ffffc4 	movi	r3,-1
 800b140:	1886d83a 	srl	r3,r3,r2
 800b144:	00820174 	movhi	r2,2053
 800b148:	10a03804 	addi	r2,r2,-32544
 800b14c:	10c01415 	stw	r3,80(r2)
 800b150:	01020174 	movhi	r4,2053
 800b154:	21203804 	addi	r4,r4,-32544
 800b158:	800ae2c0 	call	800ae2c <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_RGB_RESAMPLER_INIT ( VIDEO_RGB_RESAMPLER_0, video_rgb_resampler_0);
 800b15c:	00820174 	movhi	r2,2053
 800b160:	10a04d04 	addi	r2,r2,-32460
 800b164:	10800a17 	ldw	r2,40(r2)
 800b168:	10800017 	ldw	r2,0(r2)
 800b16c:	10c003cc 	andi	r3,r2,15
 800b170:	00820174 	movhi	r2,2053
 800b174:	10a04d04 	addi	r2,r2,-32460
 800b178:	10c00b15 	stw	r3,44(r2)
 800b17c:	00820174 	movhi	r2,2053
 800b180:	10a04d04 	addi	r2,r2,-32460
 800b184:	10800a17 	ldw	r2,40(r2)
 800b188:	10800017 	ldw	r2,0(r2)
 800b18c:	1005d13a 	srai	r2,r2,4
 800b190:	10c0004c 	andi	r3,r2,1
 800b194:	00820174 	movhi	r2,2053
 800b198:	10a04d04 	addi	r2,r2,-32460
 800b19c:	10c00c15 	stw	r3,48(r2)
 800b1a0:	00820174 	movhi	r2,2053
 800b1a4:	10a04d04 	addi	r2,r2,-32460
 800b1a8:	10800a17 	ldw	r2,40(r2)
 800b1ac:	10800017 	ldw	r2,0(r2)
 800b1b0:	1005d17a 	srai	r2,r2,5
 800b1b4:	10c0004c 	andi	r3,r2,1
 800b1b8:	00820174 	movhi	r2,2053
 800b1bc:	10a04d04 	addi	r2,r2,-32460
 800b1c0:	10c00d15 	stw	r3,52(r2)
 800b1c4:	00820174 	movhi	r2,2053
 800b1c8:	10a04d04 	addi	r2,r2,-32460
 800b1cc:	10800a17 	ldw	r2,40(r2)
 800b1d0:	10800017 	ldw	r2,0(r2)
 800b1d4:	1005d43a 	srai	r2,r2,16
 800b1d8:	10c003cc 	andi	r3,r2,15
 800b1dc:	00820174 	movhi	r2,2053
 800b1e0:	10a04d04 	addi	r2,r2,-32460
 800b1e4:	10c00e15 	stw	r3,56(r2)
 800b1e8:	00820174 	movhi	r2,2053
 800b1ec:	10a04d04 	addi	r2,r2,-32460
 800b1f0:	10800a17 	ldw	r2,40(r2)
 800b1f4:	10800017 	ldw	r2,0(r2)
 800b1f8:	1005d53a 	srai	r2,r2,20
 800b1fc:	10c0004c 	andi	r3,r2,1
 800b200:	00820174 	movhi	r2,2053
 800b204:	10a04d04 	addi	r2,r2,-32460
 800b208:	10c00f15 	stw	r3,60(r2)
 800b20c:	00820174 	movhi	r2,2053
 800b210:	10a04d04 	addi	r2,r2,-32460
 800b214:	10800a17 	ldw	r2,40(r2)
 800b218:	10800017 	ldw	r2,0(r2)
 800b21c:	1005d57a 	srai	r2,r2,21
 800b220:	10c0004c 	andi	r3,r2,1
 800b224:	00820174 	movhi	r2,2053
 800b228:	10a04d04 	addi	r2,r2,-32460
 800b22c:	10c01015 	stw	r3,64(r2)
 800b230:	01020174 	movhi	r4,2053
 800b234:	21204d04 	addi	r4,r4,-32460
 800b238:	800ae2c0 	call	800ae2c <alt_dev_reg>
}
 800b23c:	0001883a 	nop
 800b240:	e037883a 	mov	sp,fp
 800b244:	dfc00117 	ldw	ra,4(sp)
 800b248:	df000017 	ldw	fp,0(sp)
 800b24c:	dec00204 	addi	sp,sp,8
 800b250:	f800283a 	ret

0800b254 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 800b254:	defffa04 	addi	sp,sp,-24
 800b258:	dfc00515 	stw	ra,20(sp)
 800b25c:	df000415 	stw	fp,16(sp)
 800b260:	df000404 	addi	fp,sp,16
 800b264:	e13ffd15 	stw	r4,-12(fp)
 800b268:	e17ffe15 	stw	r5,-8(fp)
 800b26c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800b270:	e0bffd17 	ldw	r2,-12(fp)
 800b274:	10800017 	ldw	r2,0(r2)
 800b278:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 800b27c:	e0bffc17 	ldw	r2,-16(fp)
 800b280:	10c00a04 	addi	r3,r2,40
 800b284:	e0bffd17 	ldw	r2,-12(fp)
 800b288:	10800217 	ldw	r2,8(r2)
 800b28c:	100f883a 	mov	r7,r2
 800b290:	e1bfff17 	ldw	r6,-4(fp)
 800b294:	e17ffe17 	ldw	r5,-8(fp)
 800b298:	1809883a 	mov	r4,r3
 800b29c:	800b87c0 	call	800b87c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 800b2a0:	e037883a 	mov	sp,fp
 800b2a4:	dfc00117 	ldw	ra,4(sp)
 800b2a8:	df000017 	ldw	fp,0(sp)
 800b2ac:	dec00204 	addi	sp,sp,8
 800b2b0:	f800283a 	ret

0800b2b4 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 800b2b4:	defffa04 	addi	sp,sp,-24
 800b2b8:	dfc00515 	stw	ra,20(sp)
 800b2bc:	df000415 	stw	fp,16(sp)
 800b2c0:	df000404 	addi	fp,sp,16
 800b2c4:	e13ffd15 	stw	r4,-12(fp)
 800b2c8:	e17ffe15 	stw	r5,-8(fp)
 800b2cc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800b2d0:	e0bffd17 	ldw	r2,-12(fp)
 800b2d4:	10800017 	ldw	r2,0(r2)
 800b2d8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 800b2dc:	e0bffc17 	ldw	r2,-16(fp)
 800b2e0:	10c00a04 	addi	r3,r2,40
 800b2e4:	e0bffd17 	ldw	r2,-12(fp)
 800b2e8:	10800217 	ldw	r2,8(r2)
 800b2ec:	100f883a 	mov	r7,r2
 800b2f0:	e1bfff17 	ldw	r6,-4(fp)
 800b2f4:	e17ffe17 	ldw	r5,-8(fp)
 800b2f8:	1809883a 	mov	r4,r3
 800b2fc:	800ba980 	call	800ba98 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 800b300:	e037883a 	mov	sp,fp
 800b304:	dfc00117 	ldw	ra,4(sp)
 800b308:	df000017 	ldw	fp,0(sp)
 800b30c:	dec00204 	addi	sp,sp,8
 800b310:	f800283a 	ret

0800b314 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 800b314:	defffc04 	addi	sp,sp,-16
 800b318:	dfc00315 	stw	ra,12(sp)
 800b31c:	df000215 	stw	fp,8(sp)
 800b320:	df000204 	addi	fp,sp,8
 800b324:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800b328:	e0bfff17 	ldw	r2,-4(fp)
 800b32c:	10800017 	ldw	r2,0(r2)
 800b330:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 800b334:	e0bffe17 	ldw	r2,-8(fp)
 800b338:	10c00a04 	addi	r3,r2,40
 800b33c:	e0bfff17 	ldw	r2,-4(fp)
 800b340:	10800217 	ldw	r2,8(r2)
 800b344:	100b883a 	mov	r5,r2
 800b348:	1809883a 	mov	r4,r3
 800b34c:	800b7240 	call	800b724 <altera_avalon_jtag_uart_close>
}
 800b350:	e037883a 	mov	sp,fp
 800b354:	dfc00117 	ldw	ra,4(sp)
 800b358:	df000017 	ldw	fp,0(sp)
 800b35c:	dec00204 	addi	sp,sp,8
 800b360:	f800283a 	ret

0800b364 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 800b364:	defffa04 	addi	sp,sp,-24
 800b368:	dfc00515 	stw	ra,20(sp)
 800b36c:	df000415 	stw	fp,16(sp)
 800b370:	df000404 	addi	fp,sp,16
 800b374:	e13ffd15 	stw	r4,-12(fp)
 800b378:	e17ffe15 	stw	r5,-8(fp)
 800b37c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 800b380:	e0bffd17 	ldw	r2,-12(fp)
 800b384:	10800017 	ldw	r2,0(r2)
 800b388:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 800b38c:	e0bffc17 	ldw	r2,-16(fp)
 800b390:	10800a04 	addi	r2,r2,40
 800b394:	e1bfff17 	ldw	r6,-4(fp)
 800b398:	e17ffe17 	ldw	r5,-8(fp)
 800b39c:	1009883a 	mov	r4,r2
 800b3a0:	800b78c0 	call	800b78c <altera_avalon_jtag_uart_ioctl>
}
 800b3a4:	e037883a 	mov	sp,fp
 800b3a8:	dfc00117 	ldw	ra,4(sp)
 800b3ac:	df000017 	ldw	fp,0(sp)
 800b3b0:	dec00204 	addi	sp,sp,8
 800b3b4:	f800283a 	ret

0800b3b8 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 800b3b8:	defffa04 	addi	sp,sp,-24
 800b3bc:	dfc00515 	stw	ra,20(sp)
 800b3c0:	df000415 	stw	fp,16(sp)
 800b3c4:	df000404 	addi	fp,sp,16
 800b3c8:	e13ffd15 	stw	r4,-12(fp)
 800b3cc:	e17ffe15 	stw	r5,-8(fp)
 800b3d0:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800b3d4:	e0bffd17 	ldw	r2,-12(fp)
 800b3d8:	00c00044 	movi	r3,1
 800b3dc:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 800b3e0:	e0bffd17 	ldw	r2,-12(fp)
 800b3e4:	10800017 	ldw	r2,0(r2)
 800b3e8:	10800104 	addi	r2,r2,4
 800b3ec:	1007883a 	mov	r3,r2
 800b3f0:	e0bffd17 	ldw	r2,-12(fp)
 800b3f4:	10800817 	ldw	r2,32(r2)
 800b3f8:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 800b3fc:	e0bffe17 	ldw	r2,-8(fp)
 800b400:	e0ffff17 	ldw	r3,-4(fp)
 800b404:	d8000015 	stw	zero,0(sp)
 800b408:	e1fffd17 	ldw	r7,-12(fp)
 800b40c:	01820074 	movhi	r6,2049
 800b410:	31ad1e04 	addi	r6,r6,-19336
 800b414:	180b883a 	mov	r5,r3
 800b418:	1009883a 	mov	r4,r2
 800b41c:	800d2280 	call	800d228 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 800b420:	e0bffd17 	ldw	r2,-12(fp)
 800b424:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 800b428:	e0bffd17 	ldw	r2,-12(fp)
 800b42c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 800b430:	d0e76f17 	ldw	r3,-25156(gp)
 800b434:	e1fffd17 	ldw	r7,-12(fp)
 800b438:	01820074 	movhi	r6,2049
 800b43c:	31ada104 	addi	r6,r6,-18812
 800b440:	180b883a 	mov	r5,r3
 800b444:	1009883a 	mov	r4,r2
 800b448:	800ce500 	call	800ce50 <alt_alarm_start>
 800b44c:	1000040e 	bge	r2,zero,800b460 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 800b450:	e0fffd17 	ldw	r3,-12(fp)
 800b454:	00a00034 	movhi	r2,32768
 800b458:	10bfffc4 	addi	r2,r2,-1
 800b45c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 800b460:	0001883a 	nop
 800b464:	e037883a 	mov	sp,fp
 800b468:	dfc00117 	ldw	ra,4(sp)
 800b46c:	df000017 	ldw	fp,0(sp)
 800b470:	dec00204 	addi	sp,sp,8
 800b474:	f800283a 	ret

0800b478 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 800b478:	defff804 	addi	sp,sp,-32
 800b47c:	df000715 	stw	fp,28(sp)
 800b480:	df000704 	addi	fp,sp,28
 800b484:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 800b488:	e0bfff17 	ldw	r2,-4(fp)
 800b48c:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 800b490:	e0bffb17 	ldw	r2,-20(fp)
 800b494:	10800017 	ldw	r2,0(r2)
 800b498:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800b49c:	e0bffc17 	ldw	r2,-16(fp)
 800b4a0:	10800104 	addi	r2,r2,4
 800b4a4:	10800037 	ldwio	r2,0(r2)
 800b4a8:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 800b4ac:	e0bffd17 	ldw	r2,-12(fp)
 800b4b0:	1080c00c 	andi	r2,r2,768
 800b4b4:	10006d26 	beq	r2,zero,800b66c <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 800b4b8:	e0bffd17 	ldw	r2,-12(fp)
 800b4bc:	1080400c 	andi	r2,r2,256
 800b4c0:	10003526 	beq	r2,zero,800b598 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 800b4c4:	00800074 	movhi	r2,1
 800b4c8:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800b4cc:	e0bffb17 	ldw	r2,-20(fp)
 800b4d0:	10800a17 	ldw	r2,40(r2)
 800b4d4:	10800044 	addi	r2,r2,1
 800b4d8:	1081ffcc 	andi	r2,r2,2047
 800b4dc:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 800b4e0:	e0bffb17 	ldw	r2,-20(fp)
 800b4e4:	10c00b17 	ldw	r3,44(r2)
 800b4e8:	e0bffe17 	ldw	r2,-8(fp)
 800b4ec:	18801526 	beq	r3,r2,800b544 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 800b4f0:	e0bffc17 	ldw	r2,-16(fp)
 800b4f4:	10800037 	ldwio	r2,0(r2)
 800b4f8:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 800b4fc:	e0bff917 	ldw	r2,-28(fp)
 800b500:	10a0000c 	andi	r2,r2,32768
 800b504:	10001126 	beq	r2,zero,800b54c <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 800b508:	e0bffb17 	ldw	r2,-20(fp)
 800b50c:	10800a17 	ldw	r2,40(r2)
 800b510:	e0fff917 	ldw	r3,-28(fp)
 800b514:	1809883a 	mov	r4,r3
 800b518:	e0fffb17 	ldw	r3,-20(fp)
 800b51c:	1885883a 	add	r2,r3,r2
 800b520:	10800e04 	addi	r2,r2,56
 800b524:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800b528:	e0bffb17 	ldw	r2,-20(fp)
 800b52c:	10800a17 	ldw	r2,40(r2)
 800b530:	10800044 	addi	r2,r2,1
 800b534:	10c1ffcc 	andi	r3,r2,2047
 800b538:	e0bffb17 	ldw	r2,-20(fp)
 800b53c:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 800b540:	003fe206 	br	800b4cc <altera_avalon_jtag_uart_irq+0x54>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 800b544:	0001883a 	nop
 800b548:	00000106 	br	800b550 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 800b54c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 800b550:	e0bff917 	ldw	r2,-28(fp)
 800b554:	10bfffec 	andhi	r2,r2,65535
 800b558:	10000f26 	beq	r2,zero,800b598 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800b55c:	e0bffb17 	ldw	r2,-20(fp)
 800b560:	10c00817 	ldw	r3,32(r2)
 800b564:	00bfff84 	movi	r2,-2
 800b568:	1886703a 	and	r3,r3,r2
 800b56c:	e0bffb17 	ldw	r2,-20(fp)
 800b570:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 800b574:	e0bffc17 	ldw	r2,-16(fp)
 800b578:	10800104 	addi	r2,r2,4
 800b57c:	1007883a 	mov	r3,r2
 800b580:	e0bffb17 	ldw	r2,-20(fp)
 800b584:	10800817 	ldw	r2,32(r2)
 800b588:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800b58c:	e0bffc17 	ldw	r2,-16(fp)
 800b590:	10800104 	addi	r2,r2,4
 800b594:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 800b598:	e0bffd17 	ldw	r2,-12(fp)
 800b59c:	1080800c 	andi	r2,r2,512
 800b5a0:	103fbe26 	beq	r2,zero,800b49c <altera_avalon_jtag_uart_irq+0x24>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 800b5a4:	e0bffd17 	ldw	r2,-12(fp)
 800b5a8:	1004d43a 	srli	r2,r2,16
 800b5ac:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 800b5b0:	00001406 	br	800b604 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 800b5b4:	e0bffc17 	ldw	r2,-16(fp)
 800b5b8:	e0fffb17 	ldw	r3,-20(fp)
 800b5bc:	18c00d17 	ldw	r3,52(r3)
 800b5c0:	e13ffb17 	ldw	r4,-20(fp)
 800b5c4:	20c7883a 	add	r3,r4,r3
 800b5c8:	18c20e04 	addi	r3,r3,2104
 800b5cc:	18c00003 	ldbu	r3,0(r3)
 800b5d0:	18c03fcc 	andi	r3,r3,255
 800b5d4:	18c0201c 	xori	r3,r3,128
 800b5d8:	18ffe004 	addi	r3,r3,-128
 800b5dc:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800b5e0:	e0bffb17 	ldw	r2,-20(fp)
 800b5e4:	10800d17 	ldw	r2,52(r2)
 800b5e8:	10800044 	addi	r2,r2,1
 800b5ec:	10c1ffcc 	andi	r3,r2,2047
 800b5f0:	e0bffb17 	ldw	r2,-20(fp)
 800b5f4:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 800b5f8:	e0bffa17 	ldw	r2,-24(fp)
 800b5fc:	10bfffc4 	addi	r2,r2,-1
 800b600:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 800b604:	e0bffa17 	ldw	r2,-24(fp)
 800b608:	10000526 	beq	r2,zero,800b620 <altera_avalon_jtag_uart_irq+0x1a8>
 800b60c:	e0bffb17 	ldw	r2,-20(fp)
 800b610:	10c00d17 	ldw	r3,52(r2)
 800b614:	e0bffb17 	ldw	r2,-20(fp)
 800b618:	10800c17 	ldw	r2,48(r2)
 800b61c:	18bfe51e 	bne	r3,r2,800b5b4 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 800b620:	e0bffa17 	ldw	r2,-24(fp)
 800b624:	103f9d26 	beq	r2,zero,800b49c <altera_avalon_jtag_uart_irq+0x24>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 800b628:	e0bffb17 	ldw	r2,-20(fp)
 800b62c:	10c00817 	ldw	r3,32(r2)
 800b630:	00bfff44 	movi	r2,-3
 800b634:	1886703a 	and	r3,r3,r2
 800b638:	e0bffb17 	ldw	r2,-20(fp)
 800b63c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800b640:	e0bffb17 	ldw	r2,-20(fp)
 800b644:	10800017 	ldw	r2,0(r2)
 800b648:	10800104 	addi	r2,r2,4
 800b64c:	1007883a 	mov	r3,r2
 800b650:	e0bffb17 	ldw	r2,-20(fp)
 800b654:	10800817 	ldw	r2,32(r2)
 800b658:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800b65c:	e0bffc17 	ldw	r2,-16(fp)
 800b660:	10800104 	addi	r2,r2,4
 800b664:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 800b668:	003f8c06 	br	800b49c <altera_avalon_jtag_uart_irq+0x24>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 800b66c:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 800b670:	0001883a 	nop
 800b674:	e037883a 	mov	sp,fp
 800b678:	df000017 	ldw	fp,0(sp)
 800b67c:	dec00104 	addi	sp,sp,4
 800b680:	f800283a 	ret

0800b684 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 800b684:	defff804 	addi	sp,sp,-32
 800b688:	df000715 	stw	fp,28(sp)
 800b68c:	df000704 	addi	fp,sp,28
 800b690:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 800b694:	e0bffb17 	ldw	r2,-20(fp)
 800b698:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 800b69c:	e0bff917 	ldw	r2,-28(fp)
 800b6a0:	10800017 	ldw	r2,0(r2)
 800b6a4:	10800104 	addi	r2,r2,4
 800b6a8:	10800037 	ldwio	r2,0(r2)
 800b6ac:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 800b6b0:	e0bffa17 	ldw	r2,-24(fp)
 800b6b4:	1081000c 	andi	r2,r2,1024
 800b6b8:	10000b26 	beq	r2,zero,800b6e8 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 800b6bc:	e0bff917 	ldw	r2,-28(fp)
 800b6c0:	10800017 	ldw	r2,0(r2)
 800b6c4:	10800104 	addi	r2,r2,4
 800b6c8:	1007883a 	mov	r3,r2
 800b6cc:	e0bff917 	ldw	r2,-28(fp)
 800b6d0:	10800817 	ldw	r2,32(r2)
 800b6d4:	10810014 	ori	r2,r2,1024
 800b6d8:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 800b6dc:	e0bff917 	ldw	r2,-28(fp)
 800b6e0:	10000915 	stw	zero,36(r2)
 800b6e4:	00000a06 	br	800b710 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 800b6e8:	e0bff917 	ldw	r2,-28(fp)
 800b6ec:	10c00917 	ldw	r3,36(r2)
 800b6f0:	00a00034 	movhi	r2,32768
 800b6f4:	10bfff04 	addi	r2,r2,-4
 800b6f8:	10c00536 	bltu	r2,r3,800b710 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 800b6fc:	e0bff917 	ldw	r2,-28(fp)
 800b700:	10800917 	ldw	r2,36(r2)
 800b704:	10c00044 	addi	r3,r2,1
 800b708:	e0bff917 	ldw	r2,-28(fp)
 800b70c:	10c00915 	stw	r3,36(r2)
 800b710:	d0a76f17 	ldw	r2,-25156(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 800b714:	e037883a 	mov	sp,fp
 800b718:	df000017 	ldw	fp,0(sp)
 800b71c:	dec00104 	addi	sp,sp,4
 800b720:	f800283a 	ret

0800b724 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 800b724:	defffd04 	addi	sp,sp,-12
 800b728:	df000215 	stw	fp,8(sp)
 800b72c:	df000204 	addi	fp,sp,8
 800b730:	e13ffe15 	stw	r4,-8(fp)
 800b734:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 800b738:	00000506 	br	800b750 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 800b73c:	e0bfff17 	ldw	r2,-4(fp)
 800b740:	1090000c 	andi	r2,r2,16384
 800b744:	10000226 	beq	r2,zero,800b750 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 800b748:	00bffd44 	movi	r2,-11
 800b74c:	00000b06 	br	800b77c <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 800b750:	e0bffe17 	ldw	r2,-8(fp)
 800b754:	10c00d17 	ldw	r3,52(r2)
 800b758:	e0bffe17 	ldw	r2,-8(fp)
 800b75c:	10800c17 	ldw	r2,48(r2)
 800b760:	18800526 	beq	r3,r2,800b778 <altera_avalon_jtag_uart_close+0x54>
 800b764:	e0bffe17 	ldw	r2,-8(fp)
 800b768:	10c00917 	ldw	r3,36(r2)
 800b76c:	e0bffe17 	ldw	r2,-8(fp)
 800b770:	10800117 	ldw	r2,4(r2)
 800b774:	18bff136 	bltu	r3,r2,800b73c <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 800b778:	0005883a 	mov	r2,zero
}
 800b77c:	e037883a 	mov	sp,fp
 800b780:	df000017 	ldw	fp,0(sp)
 800b784:	dec00104 	addi	sp,sp,4
 800b788:	f800283a 	ret

0800b78c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 800b78c:	defffa04 	addi	sp,sp,-24
 800b790:	df000515 	stw	fp,20(sp)
 800b794:	df000504 	addi	fp,sp,20
 800b798:	e13ffd15 	stw	r4,-12(fp)
 800b79c:	e17ffe15 	stw	r5,-8(fp)
 800b7a0:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 800b7a4:	00bff9c4 	movi	r2,-25
 800b7a8:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 800b7ac:	e0bffe17 	ldw	r2,-8(fp)
 800b7b0:	10da8060 	cmpeqi	r3,r2,27137
 800b7b4:	1800031e 	bne	r3,zero,800b7c4 <altera_avalon_jtag_uart_ioctl+0x38>
 800b7b8:	109a80a0 	cmpeqi	r2,r2,27138
 800b7bc:	1000181e 	bne	r2,zero,800b820 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 800b7c0:	00002906 	br	800b868 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 800b7c4:	e0bffd17 	ldw	r2,-12(fp)
 800b7c8:	10c00117 	ldw	r3,4(r2)
 800b7cc:	00a00034 	movhi	r2,32768
 800b7d0:	10bfffc4 	addi	r2,r2,-1
 800b7d4:	18802126 	beq	r3,r2,800b85c <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 800b7d8:	e0bfff17 	ldw	r2,-4(fp)
 800b7dc:	10800017 	ldw	r2,0(r2)
 800b7e0:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 800b7e4:	e0bffc17 	ldw	r2,-16(fp)
 800b7e8:	10800090 	cmplti	r2,r2,2
 800b7ec:	1000061e 	bne	r2,zero,800b808 <altera_avalon_jtag_uart_ioctl+0x7c>
 800b7f0:	e0fffc17 	ldw	r3,-16(fp)
 800b7f4:	00a00034 	movhi	r2,32768
 800b7f8:	10bfffc4 	addi	r2,r2,-1
 800b7fc:	18800226 	beq	r3,r2,800b808 <altera_avalon_jtag_uart_ioctl+0x7c>
 800b800:	e0bffc17 	ldw	r2,-16(fp)
 800b804:	00000206 	br	800b810 <altera_avalon_jtag_uart_ioctl+0x84>
 800b808:	00a00034 	movhi	r2,32768
 800b80c:	10bfff84 	addi	r2,r2,-2
 800b810:	e0fffd17 	ldw	r3,-12(fp)
 800b814:	18800115 	stw	r2,4(r3)
      rc = 0;
 800b818:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 800b81c:	00000f06 	br	800b85c <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 800b820:	e0bffd17 	ldw	r2,-12(fp)
 800b824:	10c00117 	ldw	r3,4(r2)
 800b828:	00a00034 	movhi	r2,32768
 800b82c:	10bfffc4 	addi	r2,r2,-1
 800b830:	18800c26 	beq	r3,r2,800b864 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 800b834:	e0bffd17 	ldw	r2,-12(fp)
 800b838:	10c00917 	ldw	r3,36(r2)
 800b83c:	e0bffd17 	ldw	r2,-12(fp)
 800b840:	10800117 	ldw	r2,4(r2)
 800b844:	1885803a 	cmpltu	r2,r3,r2
 800b848:	10c03fcc 	andi	r3,r2,255
 800b84c:	e0bfff17 	ldw	r2,-4(fp)
 800b850:	10c00015 	stw	r3,0(r2)
      rc = 0;
 800b854:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 800b858:	00000206 	br	800b864 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 800b85c:	0001883a 	nop
 800b860:	00000106 	br	800b868 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 800b864:	0001883a 	nop

  default:
    break;
  }

  return rc;
 800b868:	e0bffb17 	ldw	r2,-20(fp)
}
 800b86c:	e037883a 	mov	sp,fp
 800b870:	df000017 	ldw	fp,0(sp)
 800b874:	dec00104 	addi	sp,sp,4
 800b878:	f800283a 	ret

0800b87c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 800b87c:	defff304 	addi	sp,sp,-52
 800b880:	dfc00c15 	stw	ra,48(sp)
 800b884:	df000b15 	stw	fp,44(sp)
 800b888:	df000b04 	addi	fp,sp,44
 800b88c:	e13ffc15 	stw	r4,-16(fp)
 800b890:	e17ffd15 	stw	r5,-12(fp)
 800b894:	e1bffe15 	stw	r6,-8(fp)
 800b898:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 800b89c:	e0bffd17 	ldw	r2,-12(fp)
 800b8a0:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 800b8a4:	00004706 	br	800b9c4 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 800b8a8:	e0bffc17 	ldw	r2,-16(fp)
 800b8ac:	10800a17 	ldw	r2,40(r2)
 800b8b0:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 800b8b4:	e0bffc17 	ldw	r2,-16(fp)
 800b8b8:	10800b17 	ldw	r2,44(r2)
 800b8bc:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 800b8c0:	e0fff717 	ldw	r3,-36(fp)
 800b8c4:	e0bff817 	ldw	r2,-32(fp)
 800b8c8:	18800536 	bltu	r3,r2,800b8e0 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 800b8cc:	e0fff717 	ldw	r3,-36(fp)
 800b8d0:	e0bff817 	ldw	r2,-32(fp)
 800b8d4:	1885c83a 	sub	r2,r3,r2
 800b8d8:	e0bff615 	stw	r2,-40(fp)
 800b8dc:	00000406 	br	800b8f0 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 800b8e0:	00c20004 	movi	r3,2048
 800b8e4:	e0bff817 	ldw	r2,-32(fp)
 800b8e8:	1885c83a 	sub	r2,r3,r2
 800b8ec:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 800b8f0:	e0bff617 	ldw	r2,-40(fp)
 800b8f4:	10001e26 	beq	r2,zero,800b970 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 800b8f8:	e0fffe17 	ldw	r3,-8(fp)
 800b8fc:	e0bff617 	ldw	r2,-40(fp)
 800b900:	1880022e 	bgeu	r3,r2,800b90c <altera_avalon_jtag_uart_read+0x90>
        n = space;
 800b904:	e0bffe17 	ldw	r2,-8(fp)
 800b908:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 800b90c:	e0bffc17 	ldw	r2,-16(fp)
 800b910:	10c00e04 	addi	r3,r2,56
 800b914:	e0bff817 	ldw	r2,-32(fp)
 800b918:	1885883a 	add	r2,r3,r2
 800b91c:	e1bff617 	ldw	r6,-40(fp)
 800b920:	100b883a 	mov	r5,r2
 800b924:	e13ff517 	ldw	r4,-44(fp)
 800b928:	8007e380 	call	8007e38 <memcpy>
      ptr   += n;
 800b92c:	e0fff517 	ldw	r3,-44(fp)
 800b930:	e0bff617 	ldw	r2,-40(fp)
 800b934:	1885883a 	add	r2,r3,r2
 800b938:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 800b93c:	e0fffe17 	ldw	r3,-8(fp)
 800b940:	e0bff617 	ldw	r2,-40(fp)
 800b944:	1885c83a 	sub	r2,r3,r2
 800b948:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800b94c:	e0fff817 	ldw	r3,-32(fp)
 800b950:	e0bff617 	ldw	r2,-40(fp)
 800b954:	1885883a 	add	r2,r3,r2
 800b958:	10c1ffcc 	andi	r3,r2,2047
 800b95c:	e0bffc17 	ldw	r2,-16(fp)
 800b960:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 800b964:	e0bffe17 	ldw	r2,-8(fp)
 800b968:	00bfcf16 	blt	zero,r2,800b8a8 <altera_avalon_jtag_uart_read+0x2c>
 800b96c:	00000106 	br	800b974 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 800b970:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 800b974:	e0fff517 	ldw	r3,-44(fp)
 800b978:	e0bffd17 	ldw	r2,-12(fp)
 800b97c:	1880141e 	bne	r3,r2,800b9d0 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 800b980:	e0bfff17 	ldw	r2,-4(fp)
 800b984:	1090000c 	andi	r2,r2,16384
 800b988:	1000131e 	bne	r2,zero,800b9d8 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 800b98c:	0001883a 	nop
 800b990:	e0bffc17 	ldw	r2,-16(fp)
 800b994:	10c00a17 	ldw	r3,40(r2)
 800b998:	e0bff717 	ldw	r2,-36(fp)
 800b99c:	1880051e 	bne	r3,r2,800b9b4 <altera_avalon_jtag_uart_read+0x138>
 800b9a0:	e0bffc17 	ldw	r2,-16(fp)
 800b9a4:	10c00917 	ldw	r3,36(r2)
 800b9a8:	e0bffc17 	ldw	r2,-16(fp)
 800b9ac:	10800117 	ldw	r2,4(r2)
 800b9b0:	18bff736 	bltu	r3,r2,800b990 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 800b9b4:	e0bffc17 	ldw	r2,-16(fp)
 800b9b8:	10c00a17 	ldw	r3,40(r2)
 800b9bc:	e0bff717 	ldw	r2,-36(fp)
 800b9c0:	18800726 	beq	r3,r2,800b9e0 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 800b9c4:	e0bffe17 	ldw	r2,-8(fp)
 800b9c8:	00bfb716 	blt	zero,r2,800b8a8 <altera_avalon_jtag_uart_read+0x2c>
 800b9cc:	00000506 	br	800b9e4 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 800b9d0:	0001883a 	nop
 800b9d4:	00000306 	br	800b9e4 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 800b9d8:	0001883a 	nop
 800b9dc:	00000106 	br	800b9e4 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 800b9e0:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 800b9e4:	e0fff517 	ldw	r3,-44(fp)
 800b9e8:	e0bffd17 	ldw	r2,-12(fp)
 800b9ec:	18801826 	beq	r3,r2,800ba50 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800b9f0:	0005303a 	rdctl	r2,status
 800b9f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800b9f8:	e0fffb17 	ldw	r3,-20(fp)
 800b9fc:	00bfff84 	movi	r2,-2
 800ba00:	1884703a 	and	r2,r3,r2
 800ba04:	1001703a 	wrctl	status,r2
  
  return context;
 800ba08:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 800ba0c:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800ba10:	e0bffc17 	ldw	r2,-16(fp)
 800ba14:	10800817 	ldw	r2,32(r2)
 800ba18:	10c00054 	ori	r3,r2,1
 800ba1c:	e0bffc17 	ldw	r2,-16(fp)
 800ba20:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800ba24:	e0bffc17 	ldw	r2,-16(fp)
 800ba28:	10800017 	ldw	r2,0(r2)
 800ba2c:	10800104 	addi	r2,r2,4
 800ba30:	1007883a 	mov	r3,r2
 800ba34:	e0bffc17 	ldw	r2,-16(fp)
 800ba38:	10800817 	ldw	r2,32(r2)
 800ba3c:	18800035 	stwio	r2,0(r3)
 800ba40:	e0bffa17 	ldw	r2,-24(fp)
 800ba44:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800ba48:	e0bff917 	ldw	r2,-28(fp)
 800ba4c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 800ba50:	e0fff517 	ldw	r3,-44(fp)
 800ba54:	e0bffd17 	ldw	r2,-12(fp)
 800ba58:	18800426 	beq	r3,r2,800ba6c <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 800ba5c:	e0fff517 	ldw	r3,-44(fp)
 800ba60:	e0bffd17 	ldw	r2,-12(fp)
 800ba64:	1885c83a 	sub	r2,r3,r2
 800ba68:	00000606 	br	800ba84 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 800ba6c:	e0bfff17 	ldw	r2,-4(fp)
 800ba70:	1090000c 	andi	r2,r2,16384
 800ba74:	10000226 	beq	r2,zero,800ba80 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 800ba78:	00bffd44 	movi	r2,-11
 800ba7c:	00000106 	br	800ba84 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 800ba80:	00bffec4 	movi	r2,-5
}
 800ba84:	e037883a 	mov	sp,fp
 800ba88:	dfc00117 	ldw	ra,4(sp)
 800ba8c:	df000017 	ldw	fp,0(sp)
 800ba90:	dec00204 	addi	sp,sp,8
 800ba94:	f800283a 	ret

0800ba98 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 800ba98:	defff304 	addi	sp,sp,-52
 800ba9c:	dfc00c15 	stw	ra,48(sp)
 800baa0:	df000b15 	stw	fp,44(sp)
 800baa4:	df000b04 	addi	fp,sp,44
 800baa8:	e13ffc15 	stw	r4,-16(fp)
 800baac:	e17ffd15 	stw	r5,-12(fp)
 800bab0:	e1bffe15 	stw	r6,-8(fp)
 800bab4:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 800bab8:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 800babc:	e0bffd17 	ldw	r2,-12(fp)
 800bac0:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 800bac4:	00003706 	br	800bba4 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 800bac8:	e0bffc17 	ldw	r2,-16(fp)
 800bacc:	10800c17 	ldw	r2,48(r2)
 800bad0:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 800bad4:	e0bffc17 	ldw	r2,-16(fp)
 800bad8:	10800d17 	ldw	r2,52(r2)
 800badc:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 800bae0:	e0fff917 	ldw	r3,-28(fp)
 800bae4:	e0bff517 	ldw	r2,-44(fp)
 800bae8:	1880062e 	bgeu	r3,r2,800bb04 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 800baec:	e0fff517 	ldw	r3,-44(fp)
 800baf0:	e0bff917 	ldw	r2,-28(fp)
 800baf4:	1885c83a 	sub	r2,r3,r2
 800baf8:	10bfffc4 	addi	r2,r2,-1
 800bafc:	e0bff615 	stw	r2,-40(fp)
 800bb00:	00000b06 	br	800bb30 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 800bb04:	e0bff517 	ldw	r2,-44(fp)
 800bb08:	10000526 	beq	r2,zero,800bb20 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 800bb0c:	00c20004 	movi	r3,2048
 800bb10:	e0bff917 	ldw	r2,-28(fp)
 800bb14:	1885c83a 	sub	r2,r3,r2
 800bb18:	e0bff615 	stw	r2,-40(fp)
 800bb1c:	00000406 	br	800bb30 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 800bb20:	00c1ffc4 	movi	r3,2047
 800bb24:	e0bff917 	ldw	r2,-28(fp)
 800bb28:	1885c83a 	sub	r2,r3,r2
 800bb2c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 800bb30:	e0bff617 	ldw	r2,-40(fp)
 800bb34:	10001e26 	beq	r2,zero,800bbb0 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 800bb38:	e0fffe17 	ldw	r3,-8(fp)
 800bb3c:	e0bff617 	ldw	r2,-40(fp)
 800bb40:	1880022e 	bgeu	r3,r2,800bb4c <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 800bb44:	e0bffe17 	ldw	r2,-8(fp)
 800bb48:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 800bb4c:	e0bffc17 	ldw	r2,-16(fp)
 800bb50:	10c20e04 	addi	r3,r2,2104
 800bb54:	e0bff917 	ldw	r2,-28(fp)
 800bb58:	1885883a 	add	r2,r3,r2
 800bb5c:	e1bff617 	ldw	r6,-40(fp)
 800bb60:	e17ffd17 	ldw	r5,-12(fp)
 800bb64:	1009883a 	mov	r4,r2
 800bb68:	8007e380 	call	8007e38 <memcpy>
      ptr   += n;
 800bb6c:	e0fffd17 	ldw	r3,-12(fp)
 800bb70:	e0bff617 	ldw	r2,-40(fp)
 800bb74:	1885883a 	add	r2,r3,r2
 800bb78:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 800bb7c:	e0fffe17 	ldw	r3,-8(fp)
 800bb80:	e0bff617 	ldw	r2,-40(fp)
 800bb84:	1885c83a 	sub	r2,r3,r2
 800bb88:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800bb8c:	e0fff917 	ldw	r3,-28(fp)
 800bb90:	e0bff617 	ldw	r2,-40(fp)
 800bb94:	1885883a 	add	r2,r3,r2
 800bb98:	10c1ffcc 	andi	r3,r2,2047
 800bb9c:	e0bffc17 	ldw	r2,-16(fp)
 800bba0:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 800bba4:	e0bffe17 	ldw	r2,-8(fp)
 800bba8:	00bfc716 	blt	zero,r2,800bac8 <altera_avalon_jtag_uart_write+0x30>
 800bbac:	00000106 	br	800bbb4 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 800bbb0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800bbb4:	0005303a 	rdctl	r2,status
 800bbb8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800bbbc:	e0fffb17 	ldw	r3,-20(fp)
 800bbc0:	00bfff84 	movi	r2,-2
 800bbc4:	1884703a 	and	r2,r3,r2
 800bbc8:	1001703a 	wrctl	status,r2
  
  return context;
 800bbcc:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 800bbd0:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 800bbd4:	e0bffc17 	ldw	r2,-16(fp)
 800bbd8:	10800817 	ldw	r2,32(r2)
 800bbdc:	10c00094 	ori	r3,r2,2
 800bbe0:	e0bffc17 	ldw	r2,-16(fp)
 800bbe4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800bbe8:	e0bffc17 	ldw	r2,-16(fp)
 800bbec:	10800017 	ldw	r2,0(r2)
 800bbf0:	10800104 	addi	r2,r2,4
 800bbf4:	1007883a 	mov	r3,r2
 800bbf8:	e0bffc17 	ldw	r2,-16(fp)
 800bbfc:	10800817 	ldw	r2,32(r2)
 800bc00:	18800035 	stwio	r2,0(r3)
 800bc04:	e0bffa17 	ldw	r2,-24(fp)
 800bc08:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800bc0c:	e0bff817 	ldw	r2,-32(fp)
 800bc10:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 800bc14:	e0bffe17 	ldw	r2,-8(fp)
 800bc18:	0080100e 	bge	zero,r2,800bc5c <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 800bc1c:	e0bfff17 	ldw	r2,-4(fp)
 800bc20:	1090000c 	andi	r2,r2,16384
 800bc24:	1000101e 	bne	r2,zero,800bc68 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 800bc28:	0001883a 	nop
 800bc2c:	e0bffc17 	ldw	r2,-16(fp)
 800bc30:	10c00d17 	ldw	r3,52(r2)
 800bc34:	e0bff517 	ldw	r2,-44(fp)
 800bc38:	1880051e 	bne	r3,r2,800bc50 <altera_avalon_jtag_uart_write+0x1b8>
 800bc3c:	e0bffc17 	ldw	r2,-16(fp)
 800bc40:	10c00917 	ldw	r3,36(r2)
 800bc44:	e0bffc17 	ldw	r2,-16(fp)
 800bc48:	10800117 	ldw	r2,4(r2)
 800bc4c:	18bff736 	bltu	r3,r2,800bc2c <altera_avalon_jtag_uart_write+0x194>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 800bc50:	e0bffc17 	ldw	r2,-16(fp)
 800bc54:	10800917 	ldw	r2,36(r2)
 800bc58:	1000051e 	bne	r2,zero,800bc70 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 800bc5c:	e0bffe17 	ldw	r2,-8(fp)
 800bc60:	00bfd016 	blt	zero,r2,800bba4 <altera_avalon_jtag_uart_write+0x10c>
 800bc64:	00000306 	br	800bc74 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 800bc68:	0001883a 	nop
 800bc6c:	00000106 	br	800bc74 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 800bc70:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 800bc74:	e0fffd17 	ldw	r3,-12(fp)
 800bc78:	e0bff717 	ldw	r2,-36(fp)
 800bc7c:	18800426 	beq	r3,r2,800bc90 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 800bc80:	e0fffd17 	ldw	r3,-12(fp)
 800bc84:	e0bff717 	ldw	r2,-36(fp)
 800bc88:	1885c83a 	sub	r2,r3,r2
 800bc8c:	00000606 	br	800bca8 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 800bc90:	e0bfff17 	ldw	r2,-4(fp)
 800bc94:	1090000c 	andi	r2,r2,16384
 800bc98:	10000226 	beq	r2,zero,800bca4 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 800bc9c:	00bffd44 	movi	r2,-11
 800bca0:	00000106 	br	800bca8 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 800bca4:	00bffec4 	movi	r2,-5
}
 800bca8:	e037883a 	mov	sp,fp
 800bcac:	dfc00117 	ldw	ra,4(sp)
 800bcb0:	df000017 	ldw	fp,0(sp)
 800bcb4:	dec00204 	addi	sp,sp,8
 800bcb8:	f800283a 	ret

0800bcbc <alt_up_char_buffer_init>:
#include <priv/alt_file.h>

#include "altera_up_avalon_video_character_buffer_with_dma.h"
#include "altera_up_avalon_video_character_buffer_with_dma_regs.h"

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
 800bcbc:	defffc04 	addi	sp,sp,-16
 800bcc0:	dfc00315 	stw	ra,12(sp)
 800bcc4:	df000215 	stw	fp,8(sp)
 800bcc8:	df000204 	addi	fp,sp,8
 800bccc:	e13fff15 	stw	r4,-4(fp)
	char * name;
	name = (char *) char_buffer->dev.name;
 800bcd0:	e0bfff17 	ldw	r2,-4(fp)
 800bcd4:	10800217 	ldw	r2,8(r2)
 800bcd8:	e0bffe15 	stw	r2,-8(fp)

	for ( ; (*name) != '\0'; name++) {
 800bcdc:	00000b06 	br	800bd0c <alt_up_char_buffer_init+0x50>
		if (strcmp(name, "_avalon_char_buffer_slave") == 0) {
 800bce0:	01420134 	movhi	r5,2052
 800bce4:	29599204 	addi	r5,r5,26184
 800bce8:	e13ffe17 	ldw	r4,-8(fp)
 800bcec:	800d9740 	call	800d974 <strcmp>
 800bcf0:	1000031e 	bne	r2,zero,800bd00 <alt_up_char_buffer_init+0x44>
			(*name) = '\0';
 800bcf4:	e0bffe17 	ldw	r2,-8(fp)
 800bcf8:	10000005 	stb	zero,0(r2)
			break;
 800bcfc:	00000906 	br	800bd24 <alt_up_char_buffer_init+0x68>

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
	char * name;
	name = (char *) char_buffer->dev.name;

	for ( ; (*name) != '\0'; name++) {
 800bd00:	e0bffe17 	ldw	r2,-8(fp)
 800bd04:	10800044 	addi	r2,r2,1
 800bd08:	e0bffe15 	stw	r2,-8(fp)
 800bd0c:	e0bffe17 	ldw	r2,-8(fp)
 800bd10:	10800003 	ldbu	r2,0(r2)
 800bd14:	10803fcc 	andi	r2,r2,255
 800bd18:	1080201c 	xori	r2,r2,128
 800bd1c:	10bfe004 	addi	r2,r2,-128
 800bd20:	103fef1e 	bne	r2,zero,800bce0 <alt_up_char_buffer_init+0x24>
			(*name) = '\0';
			break;
		}
	}
	
	return;
 800bd24:	0001883a 	nop
}
 800bd28:	e037883a 	mov	sp,fp
 800bd2c:	dfc00117 	ldw	ra,4(sp)
 800bd30:	df000017 	ldw	fp,0(sp)
 800bd34:	dec00204 	addi	sp,sp,8
 800bd38:	f800283a 	ret

0800bd3c <alt_up_char_buffer_open_dev>:

alt_up_char_buffer_dev* alt_up_char_buffer_open_dev(const char* name) {
 800bd3c:	defffc04 	addi	sp,sp,-16
 800bd40:	dfc00315 	stw	ra,12(sp)
 800bd44:	df000215 	stw	fp,8(sp)
 800bd48:	df000204 	addi	fp,sp,8
 800bd4c:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_char_buffer_dev *dev = (alt_up_char_buffer_dev *)alt_find_dev(name, &alt_dev_list);
 800bd50:	d1604804 	addi	r5,gp,-32480
 800bd54:	e13fff17 	ldw	r4,-4(fp)
 800bd58:	800d1640 	call	800d164 <alt_find_dev>
 800bd5c:	e0bffe15 	stw	r2,-8(fp)

  return dev;
 800bd60:	e0bffe17 	ldw	r2,-8(fp)
}
 800bd64:	e037883a 	mov	sp,fp
 800bd68:	dfc00117 	ldw	ra,4(sp)
 800bd6c:	df000017 	ldw	fp,0(sp)
 800bd70:	dec00204 	addi	sp,sp,8
 800bd74:	f800283a 	ret

0800bd78 <alt_up_char_buffer_draw>:

int alt_up_char_buffer_draw(alt_up_char_buffer_dev *char_buffer, unsigned char ch, 
	unsigned int x, unsigned int y) {
 800bd78:	defffa04 	addi	sp,sp,-24
 800bd7c:	df000515 	stw	fp,20(sp)
 800bd80:	df000504 	addi	fp,sp,20
 800bd84:	e13ffc15 	stw	r4,-16(fp)
 800bd88:	2805883a 	mov	r2,r5
 800bd8c:	e1bffe15 	stw	r6,-8(fp)
 800bd90:	e1ffff15 	stw	r7,-4(fp)
 800bd94:	e0bffd05 	stb	r2,-12(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
 800bd98:	e0bffc17 	ldw	r2,-16(fp)
 800bd9c:	10800c17 	ldw	r2,48(r2)
 800bda0:	e0fffe17 	ldw	r3,-8(fp)
 800bda4:	1880042e 	bgeu	r3,r2,800bdb8 <alt_up_char_buffer_draw+0x40>
 800bda8:	e0bffc17 	ldw	r2,-16(fp)
 800bdac:	10800d17 	ldw	r2,52(r2)
 800bdb0:	e0ffff17 	ldw	r3,-4(fp)
 800bdb4:	18800236 	bltu	r3,r2,800bdc0 <alt_up_char_buffer_draw+0x48>
		return -1;
 800bdb8:	00bfffc4 	movi	r2,-1
 800bdbc:	00001d06 	br	800be34 <alt_up_char_buffer_draw+0xbc>
	
	unsigned int addr = 0;
 800bdc0:	e03ffb15 	stw	zero,-20(fp)
	addr |= ((x & char_buffer->x_coord_mask) << char_buffer->x_coord_offset);
 800bdc4:	e0bffc17 	ldw	r2,-16(fp)
 800bdc8:	10c00f17 	ldw	r3,60(r2)
 800bdcc:	e0bffe17 	ldw	r2,-8(fp)
 800bdd0:	1886703a 	and	r3,r3,r2
 800bdd4:	e0bffc17 	ldw	r2,-16(fp)
 800bdd8:	10800e17 	ldw	r2,56(r2)
 800bddc:	1884983a 	sll	r2,r3,r2
 800bde0:	e0fffb17 	ldw	r3,-20(fp)
 800bde4:	1884b03a 	or	r2,r3,r2
 800bde8:	e0bffb15 	stw	r2,-20(fp)
	addr |= ((y & char_buffer->y_coord_mask) << char_buffer->y_coord_offset);
 800bdec:	e0bffc17 	ldw	r2,-16(fp)
 800bdf0:	10c01117 	ldw	r3,68(r2)
 800bdf4:	e0bfff17 	ldw	r2,-4(fp)
 800bdf8:	1886703a 	and	r3,r3,r2
 800bdfc:	e0bffc17 	ldw	r2,-16(fp)
 800be00:	10801017 	ldw	r2,64(r2)
 800be04:	1884983a 	sll	r2,r3,r2
 800be08:	e0fffb17 	ldw	r3,-20(fp)
 800be0c:	1884b03a 	or	r2,r3,r2
 800be10:	e0bffb15 	stw	r2,-20(fp)
	IOWR_8DIRECT(char_buffer->buffer_base, addr, ch);
 800be14:	e0bffc17 	ldw	r2,-16(fp)
 800be18:	10c00b17 	ldw	r3,44(r2)
 800be1c:	e0bffb17 	ldw	r2,-20(fp)
 800be20:	1885883a 	add	r2,r3,r2
 800be24:	1007883a 	mov	r3,r2
 800be28:	e0bffd03 	ldbu	r2,-12(fp)
 800be2c:	18800025 	stbio	r2,0(r3)

	return 0;
 800be30:	0005883a 	mov	r2,zero
}
 800be34:	e037883a 	mov	sp,fp
 800be38:	df000017 	ldw	fp,0(sp)
 800be3c:	dec00104 	addi	sp,sp,4
 800be40:	f800283a 	ret

0800be44 <alt_up_char_buffer_string>:

int alt_up_char_buffer_string(alt_up_char_buffer_dev *char_buffer, const char *ptr, 
	unsigned int x, unsigned int y) {
 800be44:	defffa04 	addi	sp,sp,-24
 800be48:	df000515 	stw	fp,20(sp)
 800be4c:	df000504 	addi	fp,sp,20
 800be50:	e13ffc15 	stw	r4,-16(fp)
 800be54:	e17ffd15 	stw	r5,-12(fp)
 800be58:	e1bffe15 	stw	r6,-8(fp)
 800be5c:	e1ffff15 	stw	r7,-4(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
 800be60:	e0bffc17 	ldw	r2,-16(fp)
 800be64:	10800c17 	ldw	r2,48(r2)
 800be68:	e0fffe17 	ldw	r3,-8(fp)
 800be6c:	1880042e 	bgeu	r3,r2,800be80 <alt_up_char_buffer_string+0x3c>
 800be70:	e0bffc17 	ldw	r2,-16(fp)
 800be74:	10800d17 	ldw	r2,52(r2)
 800be78:	e0ffff17 	ldw	r3,-4(fp)
 800be7c:	18800236 	bltu	r3,r2,800be88 <alt_up_char_buffer_string+0x44>
		return -1;
 800be80:	00bfffc4 	movi	r2,-1
 800be84:	00002a06 	br	800bf30 <alt_up_char_buffer_string+0xec>
	
	unsigned int offset = 0;
 800be88:	e03ffb15 	stw	zero,-20(fp)
	offset = (y << char_buffer->y_coord_offset) + x;
 800be8c:	e0bffc17 	ldw	r2,-16(fp)
 800be90:	10801017 	ldw	r2,64(r2)
 800be94:	e0ffff17 	ldw	r3,-4(fp)
 800be98:	1886983a 	sll	r3,r3,r2
 800be9c:	e0bffe17 	ldw	r2,-8(fp)
 800bea0:	1885883a 	add	r2,r3,r2
 800bea4:	e0bffb15 	stw	r2,-20(fp)

	while ( *ptr )
 800bea8:	00001a06 	br	800bf14 <alt_up_char_buffer_string+0xd0>
	{
		IOWR_8DIRECT(char_buffer->buffer_base, offset, *ptr);
 800beac:	e0bffc17 	ldw	r2,-16(fp)
 800beb0:	10c00b17 	ldw	r3,44(r2)
 800beb4:	e0bffb17 	ldw	r2,-20(fp)
 800beb8:	1885883a 	add	r2,r3,r2
 800bebc:	1007883a 	mov	r3,r2
 800bec0:	e0bffd17 	ldw	r2,-12(fp)
 800bec4:	10800003 	ldbu	r2,0(r2)
 800bec8:	10803fcc 	andi	r2,r2,255
 800becc:	1080201c 	xori	r2,r2,128
 800bed0:	10bfe004 	addi	r2,r2,-128
 800bed4:	18800025 	stbio	r2,0(r3)
		++ptr;
 800bed8:	e0bffd17 	ldw	r2,-12(fp)
 800bedc:	10800044 	addi	r2,r2,1
 800bee0:	e0bffd15 	stw	r2,-12(fp)
		if (++x >= char_buffer->x_resolution)
 800bee4:	e0bffe17 	ldw	r2,-8(fp)
 800bee8:	10800044 	addi	r2,r2,1
 800beec:	e0bffe15 	stw	r2,-8(fp)
 800bef0:	e0bffc17 	ldw	r2,-16(fp)
 800bef4:	10800c17 	ldw	r2,48(r2)
 800bef8:	e0fffe17 	ldw	r3,-8(fp)
 800befc:	18800236 	bltu	r3,r2,800bf08 <alt_up_char_buffer_string+0xc4>
			return -1;
 800bf00:	00bfffc4 	movi	r2,-1
 800bf04:	00000a06 	br	800bf30 <alt_up_char_buffer_string+0xec>
		++offset;
 800bf08:	e0bffb17 	ldw	r2,-20(fp)
 800bf0c:	10800044 	addi	r2,r2,1
 800bf10:	e0bffb15 	stw	r2,-20(fp)
		return -1;
	
	unsigned int offset = 0;
	offset = (y << char_buffer->y_coord_offset) + x;

	while ( *ptr )
 800bf14:	e0bffd17 	ldw	r2,-12(fp)
 800bf18:	10800003 	ldbu	r2,0(r2)
 800bf1c:	10803fcc 	andi	r2,r2,255
 800bf20:	1080201c 	xori	r2,r2,128
 800bf24:	10bfe004 	addi	r2,r2,-128
 800bf28:	103fe01e 	bne	r2,zero,800beac <alt_up_char_buffer_string+0x68>
		++ptr;
		if (++x >= char_buffer->x_resolution)
			return -1;
		++offset;
	}
	return 0;
 800bf2c:	0005883a 	mov	r2,zero
}
 800bf30:	e037883a 	mov	sp,fp
 800bf34:	df000017 	ldw	fp,0(sp)
 800bf38:	dec00104 	addi	sp,sp,4
 800bf3c:	f800283a 	ret

0800bf40 <alt_up_char_buffer_clear>:

int alt_up_char_buffer_clear(alt_up_char_buffer_dev *char_buffer) {
 800bf40:	defffe04 	addi	sp,sp,-8
 800bf44:	df000115 	stw	fp,4(sp)
 800bf48:	df000104 	addi	fp,sp,4
 800bf4c:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base, 1);
 800bf50:	e0bfff17 	ldw	r2,-4(fp)
 800bf54:	10800a17 	ldw	r2,40(r2)
 800bf58:	10800084 	addi	r2,r2,2
 800bf5c:	1007883a 	mov	r3,r2
 800bf60:	00800044 	movi	r2,1
 800bf64:	18800025 	stbio	r2,0(r3)
	while ((IORD_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base) & ALT_UP_CHAR_BUFFER_CLR_SCRN_MSK) >> ALT_UP_CHAR_BUFFER_CLR_SCRN_OFST);
 800bf68:	0001883a 	nop
 800bf6c:	e0bfff17 	ldw	r2,-4(fp)
 800bf70:	10800a17 	ldw	r2,40(r2)
 800bf74:	10800084 	addi	r2,r2,2
 800bf78:	10800023 	ldbuio	r2,0(r2)
 800bf7c:	10803fcc 	andi	r2,r2,255
 800bf80:	1080004c 	andi	r2,r2,1
 800bf84:	103ff91e 	bne	r2,zero,800bf6c <alt_up_char_buffer_clear+0x2c>
	return 0;
 800bf88:	0005883a 	mov	r2,zero
}
 800bf8c:	e037883a 	mov	sp,fp
 800bf90:	df000017 	ldw	fp,0(sp)
 800bf94:	dec00104 	addi	sp,sp,4
 800bf98:	f800283a 	ret

0800bf9c <alt_up_pixel_buffer_dma_open_dev>:

#include "altera_up_avalon_video_pixel_buffer_dma.h"

#define ABS(x)	((x >= 0) ? (x) : (-(x)))

alt_up_pixel_buffer_dma_dev* alt_up_pixel_buffer_dma_open_dev(const char* name) {
 800bf9c:	defffc04 	addi	sp,sp,-16
 800bfa0:	dfc00315 	stw	ra,12(sp)
 800bfa4:	df000215 	stw	fp,8(sp)
 800bfa8:	df000204 	addi	fp,sp,8
 800bfac:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_pixel_buffer_dma_dev *dev = (alt_up_pixel_buffer_dma_dev*)alt_find_dev(name, &alt_dev_list);
 800bfb0:	d1604804 	addi	r5,gp,-32480
 800bfb4:	e13fff17 	ldw	r4,-4(fp)
 800bfb8:	800d1640 	call	800d164 <alt_find_dev>
 800bfbc:	e0bffe15 	stw	r2,-8(fp)

  return dev;
 800bfc0:	e0bffe17 	ldw	r2,-8(fp)
}
 800bfc4:	e037883a 	mov	sp,fp
 800bfc8:	dfc00117 	ldw	ra,4(sp)
 800bfcc:	df000017 	ldw	fp,0(sp)
 800bfd0:	dec00204 	addi	sp,sp,8
 800bfd4:	f800283a 	ret

0800bfd8 <alt_up_pixel_buffer_dma_draw>:

int alt_up_pixel_buffer_dma_draw(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int color, unsigned int x, unsigned int y)
/* This function draws a pixel to the back buffer.
 */
{
 800bfd8:	defffa04 	addi	sp,sp,-24
 800bfdc:	df000515 	stw	fp,20(sp)
 800bfe0:	df000504 	addi	fp,sp,20
 800bfe4:	e13ffc15 	stw	r4,-16(fp)
 800bfe8:	e17ffd15 	stw	r5,-12(fp)
 800bfec:	e1bffe15 	stw	r6,-8(fp)
 800bff0:	e1ffff15 	stw	r7,-4(fp)
	// boundary check
	if (x >= pixel_buffer->x_resolution || y >= pixel_buffer->y_resolution )
 800bff4:	e0bffc17 	ldw	r2,-16(fp)
 800bff8:	10800f17 	ldw	r2,60(r2)
 800bffc:	e0fffe17 	ldw	r3,-8(fp)
 800c000:	1880042e 	bgeu	r3,r2,800c014 <alt_up_pixel_buffer_dma_draw+0x3c>
 800c004:	e0bffc17 	ldw	r2,-16(fp)
 800c008:	10801017 	ldw	r2,64(r2)
 800c00c:	e0ffff17 	ldw	r3,-4(fp)
 800c010:	18800236 	bltu	r3,r2,800c01c <alt_up_pixel_buffer_dma_draw+0x44>
		return -1;
 800c014:	00bfffc4 	movi	r2,-1
 800c018:	00005006 	br	800c15c <alt_up_pixel_buffer_dma_draw+0x184>

	unsigned int addr = 0;
 800c01c:	e03ffb15 	stw	zero,-20(fp)
	/* Check the mode VGA Pixel Buffer is using. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c020:	e0bffc17 	ldw	r2,-16(fp)
 800c024:	10800d17 	ldw	r2,52(r2)
 800c028:	1000151e 	bne	r2,zero,800c080 <alt_up_pixel_buffer_dma_draw+0xa8>
		/* For X-Y addressing mode, the address format is | unused | Y | X |. So shift bits for coordinates X and Y into their respective locations. */
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
 800c02c:	e0bffc17 	ldw	r2,-16(fp)
 800c030:	10c01217 	ldw	r3,72(r2)
 800c034:	e0bffe17 	ldw	r2,-8(fp)
 800c038:	1886703a 	and	r3,r3,r2
 800c03c:	e0bffc17 	ldw	r2,-16(fp)
 800c040:	10801117 	ldw	r2,68(r2)
 800c044:	1884983a 	sll	r2,r3,r2
 800c048:	e0fffb17 	ldw	r3,-20(fp)
 800c04c:	1885883a 	add	r2,r3,r2
 800c050:	e0bffb15 	stw	r2,-20(fp)
		addr += ((y & pixel_buffer->y_coord_mask) << pixel_buffer->y_coord_offset);
 800c054:	e0bffc17 	ldw	r2,-16(fp)
 800c058:	10c01417 	ldw	r3,80(r2)
 800c05c:	e0bfff17 	ldw	r2,-4(fp)
 800c060:	1886703a 	and	r3,r3,r2
 800c064:	e0bffc17 	ldw	r2,-16(fp)
 800c068:	10801317 	ldw	r2,76(r2)
 800c06c:	1884983a 	sll	r2,r3,r2
 800c070:	e0fffb17 	ldw	r3,-20(fp)
 800c074:	1885883a 	add	r2,r3,r2
 800c078:	e0bffb15 	stw	r2,-20(fp)
 800c07c:	00001706 	br	800c0dc <alt_up_pixel_buffer_dma_draw+0x104>
	} else {
		/* In a consecutive addressing mode, the pixels are stored in consecutive memory locations. So the address of a pixel at (x,y) can be computed as
		 * (y*x_resolution + x).*/
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
 800c080:	e0bffc17 	ldw	r2,-16(fp)
 800c084:	10c01217 	ldw	r3,72(r2)
 800c088:	e0bffe17 	ldw	r2,-8(fp)
 800c08c:	1886703a 	and	r3,r3,r2
 800c090:	e0bffc17 	ldw	r2,-16(fp)
 800c094:	10801117 	ldw	r2,68(r2)
 800c098:	1884983a 	sll	r2,r3,r2
 800c09c:	e0fffb17 	ldw	r3,-20(fp)
 800c0a0:	1885883a 	add	r2,r3,r2
 800c0a4:	e0bffb15 	stw	r2,-20(fp)
		addr += (((y & pixel_buffer->y_coord_mask) * pixel_buffer->x_resolution) << pixel_buffer->x_coord_offset);
 800c0a8:	e0bffc17 	ldw	r2,-16(fp)
 800c0ac:	10c01417 	ldw	r3,80(r2)
 800c0b0:	e0bfff17 	ldw	r2,-4(fp)
 800c0b4:	1886703a 	and	r3,r3,r2
 800c0b8:	e0bffc17 	ldw	r2,-16(fp)
 800c0bc:	10800f17 	ldw	r2,60(r2)
 800c0c0:	1887383a 	mul	r3,r3,r2
 800c0c4:	e0bffc17 	ldw	r2,-16(fp)
 800c0c8:	10801117 	ldw	r2,68(r2)
 800c0cc:	1884983a 	sll	r2,r3,r2
 800c0d0:	e0fffb17 	ldw	r3,-20(fp)
 800c0d4:	1885883a 	add	r2,r3,r2
 800c0d8:	e0bffb15 	stw	r2,-20(fp)
	}
	/* Now, depending on the color depth, write the pixel color to the specified memory location. */
	if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c0dc:	e0bffc17 	ldw	r2,-16(fp)
 800c0e0:	10800e17 	ldw	r2,56(r2)
 800c0e4:	10800058 	cmpnei	r2,r2,1
 800c0e8:	1000081e 	bne	r2,zero,800c10c <alt_up_pixel_buffer_dma_draw+0x134>
		IOWR_8DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 800c0ec:	e0bffc17 	ldw	r2,-16(fp)
 800c0f0:	10c00c17 	ldw	r3,48(r2)
 800c0f4:	e0bffb17 	ldw	r2,-20(fp)
 800c0f8:	1885883a 	add	r2,r3,r2
 800c0fc:	1007883a 	mov	r3,r2
 800c100:	e0bffd17 	ldw	r2,-12(fp)
 800c104:	18800025 	stbio	r2,0(r3)
 800c108:	00001306 	br	800c158 <alt_up_pixel_buffer_dma_draw+0x180>
	} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c10c:	e0bffc17 	ldw	r2,-16(fp)
 800c110:	10800e17 	ldw	r2,56(r2)
 800c114:	10800098 	cmpnei	r2,r2,2
 800c118:	1000081e 	bne	r2,zero,800c13c <alt_up_pixel_buffer_dma_draw+0x164>
		IOWR_16DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 800c11c:	e0bffc17 	ldw	r2,-16(fp)
 800c120:	10c00c17 	ldw	r3,48(r2)
 800c124:	e0bffb17 	ldw	r2,-20(fp)
 800c128:	1885883a 	add	r2,r3,r2
 800c12c:	1007883a 	mov	r3,r2
 800c130:	e0bffd17 	ldw	r2,-12(fp)
 800c134:	1880002d 	sthio	r2,0(r3)
 800c138:	00000706 	br	800c158 <alt_up_pixel_buffer_dma_draw+0x180>
	} else {
		IOWR_32DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 800c13c:	e0bffc17 	ldw	r2,-16(fp)
 800c140:	10c00c17 	ldw	r3,48(r2)
 800c144:	e0bffb17 	ldw	r2,-20(fp)
 800c148:	1885883a 	add	r2,r3,r2
 800c14c:	1007883a 	mov	r3,r2
 800c150:	e0bffd17 	ldw	r2,-12(fp)
 800c154:	18800035 	stwio	r2,0(r3)
	}

	return 0;
 800c158:	0005883a 	mov	r2,zero
}
 800c15c:	e037883a 	mov	sp,fp
 800c160:	df000017 	ldw	fp,0(sp)
 800c164:	dec00104 	addi	sp,sp,4
 800c168:	f800283a 	ret

0800c16c <alt_up_pixel_buffer_dma_change_back_buffer_address>:

int alt_up_pixel_buffer_dma_change_back_buffer_address(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int new_address)
/* This function changes the memory address for the back buffer. */
{
 800c16c:	defffd04 	addi	sp,sp,-12
 800c170:	df000215 	stw	fp,8(sp)
 800c174:	df000204 	addi	fp,sp,8
 800c178:	e13ffe15 	stw	r4,-8(fp)
 800c17c:	e17fff15 	stw	r5,-4(fp)
	IOWR_32DIRECT(pixel_buffer->base, 4, new_address);
 800c180:	e0bffe17 	ldw	r2,-8(fp)
 800c184:	10800a17 	ldw	r2,40(r2)
 800c188:	10800104 	addi	r2,r2,4
 800c18c:	1007883a 	mov	r3,r2
 800c190:	e0bfff17 	ldw	r2,-4(fp)
 800c194:	18800035 	stwio	r2,0(r3)
	pixel_buffer->back_buffer_start_address = IORD_32DIRECT(pixel_buffer->base, 4);
 800c198:	e0bffe17 	ldw	r2,-8(fp)
 800c19c:	10800a17 	ldw	r2,40(r2)
 800c1a0:	10800104 	addi	r2,r2,4
 800c1a4:	10800037 	ldwio	r2,0(r2)
 800c1a8:	1007883a 	mov	r3,r2
 800c1ac:	e0bffe17 	ldw	r2,-8(fp)
 800c1b0:	10c00c15 	stw	r3,48(r2)
	return 0;
 800c1b4:	0005883a 	mov	r2,zero
}
 800c1b8:	e037883a 	mov	sp,fp
 800c1bc:	df000017 	ldw	fp,0(sp)
 800c1c0:	dec00104 	addi	sp,sp,4
 800c1c4:	f800283a 	ret

0800c1c8 <alt_up_pixel_buffer_dma_swap_buffers>:

int alt_up_pixel_buffer_dma_swap_buffers(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function swaps the front and back buffers. At the next refresh cycle the back buffer will be drawn on the screen
 * and will become the front buffer. */
{
 800c1c8:	defffd04 	addi	sp,sp,-12
 800c1cc:	df000215 	stw	fp,8(sp)
 800c1d0:	dc000115 	stw	r16,4(sp)
 800c1d4:	df000204 	addi	fp,sp,8
 800c1d8:	e13ffe15 	stw	r4,-8(fp)
	register unsigned int temp = pixel_buffer->back_buffer_start_address;
 800c1dc:	e0bffe17 	ldw	r2,-8(fp)
 800c1e0:	14000c17 	ldw	r16,48(r2)
	IOWR_32DIRECT(pixel_buffer->base, 0, 1);
 800c1e4:	e0bffe17 	ldw	r2,-8(fp)
 800c1e8:	10800a17 	ldw	r2,40(r2)
 800c1ec:	1007883a 	mov	r3,r2
 800c1f0:	00800044 	movi	r2,1
 800c1f4:	18800035 	stwio	r2,0(r3)
	pixel_buffer->back_buffer_start_address = pixel_buffer->buffer_start_address;
 800c1f8:	e0bffe17 	ldw	r2,-8(fp)
 800c1fc:	10c00b17 	ldw	r3,44(r2)
 800c200:	e0bffe17 	ldw	r2,-8(fp)
 800c204:	10c00c15 	stw	r3,48(r2)
	pixel_buffer->buffer_start_address = temp;
 800c208:	e0bffe17 	ldw	r2,-8(fp)
 800c20c:	14000b15 	stw	r16,44(r2)
	return 0;
 800c210:	0005883a 	mov	r2,zero
}
 800c214:	e6ffff04 	addi	sp,fp,-4
 800c218:	df000117 	ldw	fp,4(sp)
 800c21c:	dc000017 	ldw	r16,0(sp)
 800c220:	dec00204 	addi	sp,sp,8
 800c224:	f800283a 	ret

0800c228 <alt_up_pixel_buffer_dma_check_swap_buffers_status>:
int alt_up_pixel_buffer_dma_check_swap_buffers_status(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function checks if the buffer swap has occured. Since the buffer swap only happens after an entire screen is drawn,
 * it is important to wait for this function to return 0 before proceeding to draw on either buffer. When both front and the back buffers
 * have the same address calling the alt_up_pixel_buffer_dma_swap_buffers(...) function and then waiting for this function to return 0, causes your program to
 * wait for the screen to refresh. */
{
 800c228:	defffe04 	addi	sp,sp,-8
 800c22c:	df000115 	stw	fp,4(sp)
 800c230:	df000104 	addi	fp,sp,4
 800c234:	e13fff15 	stw	r4,-4(fp)
	return (IORD_32DIRECT(pixel_buffer->base, 12) & 0x1);
 800c238:	e0bfff17 	ldw	r2,-4(fp)
 800c23c:	10800a17 	ldw	r2,40(r2)
 800c240:	10800304 	addi	r2,r2,12
 800c244:	10800037 	ldwio	r2,0(r2)
 800c248:	1080004c 	andi	r2,r2,1
}
 800c24c:	e037883a 	mov	sp,fp
 800c250:	df000017 	ldw	fp,0(sp)
 800c254:	dec00104 	addi	sp,sp,4
 800c258:	f800283a 	ret

0800c25c <alt_up_pixel_buffer_dma_clear_screen>:

void alt_up_pixel_buffer_dma_clear_screen(alt_up_pixel_buffer_dma_dev *pixel_buffer, int backbuffer)
/* This function clears the screen by setting each pixel to a black color. */
{
 800c25c:	defff704 	addi	sp,sp,-36
 800c260:	df000815 	stw	fp,32(sp)
 800c264:	dd400715 	stw	r21,28(sp)
 800c268:	dd000615 	stw	r20,24(sp)
 800c26c:	dcc00515 	stw	r19,20(sp)
 800c270:	dc800415 	stw	r18,16(sp)
 800c274:	dc400315 	stw	r17,12(sp)
 800c278:	dc000215 	stw	r16,8(sp)
 800c27c:	df000804 	addi	fp,sp,32
 800c280:	e13ff815 	stw	r4,-32(fp)
 800c284:	e17ff915 	stw	r5,-28(fp)
	register unsigned int addr;
	register unsigned int limit_x, limit_y;
	
	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800c288:	e0bff917 	ldw	r2,-28(fp)
 800c28c:	10800058 	cmpnei	r2,r2,1
 800c290:	1000031e 	bne	r2,zero,800c2a0 <alt_up_pixel_buffer_dma_clear_screen+0x44>
		addr = pixel_buffer->back_buffer_start_address;
 800c294:	e0bff817 	ldw	r2,-32(fp)
 800c298:	14400c17 	ldw	r17,48(r2)
 800c29c:	00000206 	br	800c2a8 <alt_up_pixel_buffer_dma_clear_screen+0x4c>
	else
		addr = pixel_buffer->buffer_start_address;
 800c2a0:	e0bff817 	ldw	r2,-32(fp)
 800c2a4:	14400b17 	ldw	r17,44(r2)
	limit_x = pixel_buffer->x_resolution;
 800c2a8:	e0bff817 	ldw	r2,-32(fp)
 800c2ac:	14000f17 	ldw	r16,60(r2)
	/* In 16 and 32-bit color modes we use twice or four times more memory for the display buffer.*/
	if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c2b0:	e0bff817 	ldw	r2,-32(fp)
 800c2b4:	10800e17 	ldw	r2,56(r2)
 800c2b8:	10800098 	cmpnei	r2,r2,2
 800c2bc:	1000031e 	bne	r2,zero,800c2cc <alt_up_pixel_buffer_dma_clear_screen+0x70>
		limit_x = limit_x << 1;
 800c2c0:	8405883a 	add	r2,r16,r16
 800c2c4:	1021883a 	mov	r16,r2
 800c2c8:	00000306 	br	800c2d8 <alt_up_pixel_buffer_dma_clear_screen+0x7c>
	} else {
		limit_x = limit_x << 2;
 800c2cc:	8405883a 	add	r2,r16,r16
 800c2d0:	1085883a 	add	r2,r2,r2
 800c2d4:	1021883a 	mov	r16,r2
	}	
	limit_y = pixel_buffer->y_resolution;
 800c2d8:	e0bff817 	ldw	r2,-32(fp)
 800c2dc:	14801017 	ldw	r18,64(r2)

	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c2e0:	e0bff817 	ldw	r2,-32(fp)
 800c2e4:	10800d17 	ldw	r2,52(r2)
 800c2e8:	1000111e 	bne	r2,zero,800c330 <alt_up_pixel_buffer_dma_clear_screen+0xd4>
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 800c2ec:	e0bff817 	ldw	r2,-32(fp)
 800c2f0:	15401317 	ldw	r21,76(r2)

		for (y = 0; y < limit_y; y++)
 800c2f4:	0029883a 	mov	r20,zero
 800c2f8:	00000b06 	br	800c328 <alt_up_pixel_buffer_dma_clear_screen+0xcc>
		{
			for (x = 0; x < limit_x; x = x + 4)
 800c2fc:	0027883a 	mov	r19,zero
 800c300:	00000406 	br	800c314 <alt_up_pixel_buffer_dma_clear_screen+0xb8>
			{
				IOWR_32DIRECT(addr, x, 0);
 800c304:	9c45883a 	add	r2,r19,r17
 800c308:	0007883a 	mov	r3,zero
 800c30c:	10c00035 	stwio	r3,0(r2)
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
		{
			for (x = 0; x < limit_x; x = x + 4)
 800c310:	9cc00104 	addi	r19,r19,4
 800c314:	9c3ffb36 	bltu	r19,r16,800c304 <alt_up_pixel_buffer_dma_clear_screen+0xa8>
			{
				IOWR_32DIRECT(addr, x, 0);
			}
			addr = addr + (1 << offset_y);
 800c318:	00800044 	movi	r2,1
 800c31c:	1544983a 	sll	r2,r2,r21
 800c320:	88a3883a 	add	r17,r17,r2
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
 800c324:	a5000044 	addi	r20,r20,1
 800c328:	a4bff436 	bltu	r20,r18,800c2fc <alt_up_pixel_buffer_dma_clear_screen+0xa0>
		for (x = 0; x < limit_y; x = x + 4)
		{
			IOWR_32DIRECT(addr, x, 0);
		}
	}
}
 800c32c:	00000a06 	br	800c358 <alt_up_pixel_buffer_dma_clear_screen+0xfc>
			addr = addr + (1 << offset_y);
		}
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	
 800c330:	9425383a 	mul	r18,r18,r16

		for (x = 0; x < limit_y; x = x + 4)
 800c334:	0021883a 	mov	r16,zero
 800c338:	00000506 	br	800c350 <alt_up_pixel_buffer_dma_clear_screen+0xf4>
		{
			IOWR_32DIRECT(addr, x, 0);
 800c33c:	8005883a 	mov	r2,r16
 800c340:	1445883a 	add	r2,r2,r17
 800c344:	0007883a 	mov	r3,zero
 800c348:	10c00035 	stwio	r3,0(r2)
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	

		for (x = 0; x < limit_y; x = x + 4)
 800c34c:	84000104 	addi	r16,r16,4
 800c350:	8005883a 	mov	r2,r16
 800c354:	14bff936 	bltu	r2,r18,800c33c <alt_up_pixel_buffer_dma_clear_screen+0xe0>
		{
			IOWR_32DIRECT(addr, x, 0);
		}
	}
}
 800c358:	0001883a 	nop
 800c35c:	e6fffa04 	addi	sp,fp,-24
 800c360:	df000617 	ldw	fp,24(sp)
 800c364:	dd400517 	ldw	r21,20(sp)
 800c368:	dd000417 	ldw	r20,16(sp)
 800c36c:	dcc00317 	ldw	r19,12(sp)
 800c370:	dc800217 	ldw	r18,8(sp)
 800c374:	dc400117 	ldw	r17,4(sp)
 800c378:	dc000017 	ldw	r16,0(sp)
 800c37c:	dec00704 	addi	sp,sp,28
 800c380:	f800283a 	ret

0800c384 <alt_up_pixel_buffer_dma_draw_box>:

void alt_up_pixel_buffer_dma_draw_box(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a filled box. */
{
 800c384:	defff304 	addi	sp,sp,-52
 800c388:	df000c15 	stw	fp,48(sp)
 800c38c:	ddc00b15 	stw	r23,44(sp)
 800c390:	dd800a15 	stw	r22,40(sp)
 800c394:	dd400915 	stw	r21,36(sp)
 800c398:	dd000815 	stw	r20,32(sp)
 800c39c:	dcc00715 	stw	r19,28(sp)
 800c3a0:	dc800615 	stw	r18,24(sp)
 800c3a4:	dc400515 	stw	r17,20(sp)
 800c3a8:	dc000415 	stw	r16,16(sp)
 800c3ac:	df000c04 	addi	fp,sp,48
 800c3b0:	e13ff415 	stw	r4,-48(fp)
 800c3b4:	e17ff515 	stw	r5,-44(fp)
 800c3b8:	e1bff615 	stw	r6,-40(fp)
 800c3bc:	e1fff715 	stw	r7,-36(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 800c3c0:	e0bff417 	ldw	r2,-48(fp)
 800c3c4:	14800f17 	ldw	r18,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 800c3c8:	e0bff417 	ldw	r2,-48(fp)
 800c3cc:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int l_x = x0;
 800c3d0:	e5bff517 	ldw	r22,-44(fp)
	register unsigned int r_x = x1;
 800c3d4:	e53ff717 	ldw	r20,-36(fp)
	register unsigned int t_y = y0;
 800c3d8:	e47ff617 	ldw	r17,-40(fp)
	register unsigned int b_y = y1;
 800c3dc:	e4c00117 	ldw	r19,4(fp)
	register unsigned int local_color = color;
 800c3e0:	e5c00217 	ldw	r23,8(fp)
	
	/* Check coordinates */
	if (l_x > r_x)
 800c3e4:	a580032e 	bgeu	r20,r22,800c3f4 <alt_up_pixel_buffer_dma_draw_box+0x70>
	{
		temp = l_x;
 800c3e8:	b02b883a 	mov	r21,r22
		l_x = r_x;
 800c3ec:	a02d883a 	mov	r22,r20
		r_x = temp;
 800c3f0:	a829883a 	mov	r20,r21
	}
	if (t_y > b_y)
 800c3f4:	9c40032e 	bgeu	r19,r17,800c404 <alt_up_pixel_buffer_dma_draw_box+0x80>
	{
		temp = t_y;
 800c3f8:	882b883a 	mov	r21,r17
		t_y = b_y;
 800c3fc:	9823883a 	mov	r17,r19
		b_y = temp;
 800c400:	a827883a 	mov	r19,r21
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
 800c404:	b480892e 	bgeu	r22,r18,800c62c <alt_up_pixel_buffer_dma_draw_box+0x2a8>
 800c408:	8c00882e 	bgeu	r17,r16,800c62c <alt_up_pixel_buffer_dma_draw_box+0x2a8>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
 800c40c:	a4800136 	bltu	r20,r18,800c414 <alt_up_pixel_buffer_dma_draw_box+0x90>
	{
		r_x = limit_x - 1;
 800c410:	953fffc4 	addi	r20,r18,-1
	}
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
 800c414:	9c000136 	bltu	r19,r16,800c41c <alt_up_pixel_buffer_dma_draw_box+0x98>
	{
		b_y = limit_y - 1;
 800c418:	84ffffc4 	addi	r19,r16,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800c41c:	e0800317 	ldw	r2,12(fp)
 800c420:	10800058 	cmpnei	r2,r2,1
 800c424:	1000031e 	bne	r2,zero,800c434 <alt_up_pixel_buffer_dma_draw_box+0xb0>
		addr = pixel_buffer->back_buffer_start_address;
 800c428:	e0bff417 	ldw	r2,-48(fp)
 800c42c:	14000c17 	ldw	r16,48(r2)
 800c430:	00000206 	br	800c43c <alt_up_pixel_buffer_dma_draw_box+0xb8>
	else
		addr = pixel_buffer->buffer_start_address;
 800c434:	e0bff417 	ldw	r2,-48(fp)
 800c438:	14000b17 	ldw	r16,44(r2)

	/* Draw the box using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c43c:	e0bff417 	ldw	r2,-48(fp)
 800c440:	10800d17 	ldw	r2,52(r2)
 800c444:	10003c1e 	bne	r2,zero,800c538 <alt_up_pixel_buffer_dma_draw_box+0x1b4>
		/* Draw a box of a given color on the screen using the XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 800c448:	e0bff417 	ldw	r2,-48(fp)
 800c44c:	15401317 	ldw	r21,76(r2)
		addr = addr + (t_y << offset_y);
 800c450:	8d44983a 	sll	r2,r17,r21
 800c454:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c458:	e0bff417 	ldw	r2,-48(fp)
 800c45c:	10800e17 	ldw	r2,56(r2)
 800c460:	10800058 	cmpnei	r2,r2,1
 800c464:	10000f1e 	bne	r2,zero,800c4a4 <alt_up_pixel_buffer_dma_draw_box+0x120>
			for (y = t_y; y <= b_y; y++)
 800c468:	8825883a 	mov	r18,r17
 800c46c:	00000b06 	br	800c49c <alt_up_pixel_buffer_dma_draw_box+0x118>
			{
				for (x = l_x; x <= r_x; x++)
 800c470:	b023883a 	mov	r17,r22
 800c474:	00000406 	br	800c488 <alt_up_pixel_buffer_dma_draw_box+0x104>
				{
					IOWR_8DIRECT(addr, x, local_color);
 800c478:	8c05883a 	add	r2,r17,r16
 800c47c:	b807883a 	mov	r3,r23
 800c480:	10c00025 	stbio	r3,0(r2)
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c484:	8c400044 	addi	r17,r17,1
 800c488:	a47ffb2e 	bgeu	r20,r17,800c478 <alt_up_pixel_buffer_dma_draw_box+0xf4>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
 800c48c:	00800044 	movi	r2,1
 800c490:	1544983a 	sll	r2,r2,r21
 800c494:	80a1883a 	add	r16,r16,r2
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 800c498:	94800044 	addi	r18,r18,1
 800c49c:	9cbff42e 	bgeu	r19,r18,800c470 <alt_up_pixel_buffer_dma_draw_box+0xec>
 800c4a0:	00006306 	br	800c630 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c4a4:	e0bff417 	ldw	r2,-48(fp)
 800c4a8:	10800e17 	ldw	r2,56(r2)
 800c4ac:	10800098 	cmpnei	r2,r2,2
 800c4b0:	1000101e 	bne	r2,zero,800c4f4 <alt_up_pixel_buffer_dma_draw_box+0x170>
			for (y = t_y; y <= b_y; y++)
 800c4b4:	8825883a 	mov	r18,r17
 800c4b8:	00000c06 	br	800c4ec <alt_up_pixel_buffer_dma_draw_box+0x168>
			{
				for (x = l_x; x <= r_x; x++)
 800c4bc:	b023883a 	mov	r17,r22
 800c4c0:	00000506 	br	800c4d8 <alt_up_pixel_buffer_dma_draw_box+0x154>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
 800c4c4:	8c45883a 	add	r2,r17,r17
 800c4c8:	1405883a 	add	r2,r2,r16
 800c4cc:	b807883a 	mov	r3,r23
 800c4d0:	10c0002d 	sthio	r3,0(r2)
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c4d4:	8c400044 	addi	r17,r17,1
 800c4d8:	a47ffa2e 	bgeu	r20,r17,800c4c4 <alt_up_pixel_buffer_dma_draw_box+0x140>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + (1 << offset_y);
 800c4dc:	00800044 	movi	r2,1
 800c4e0:	1544983a 	sll	r2,r2,r21
 800c4e4:	80a1883a 	add	r16,r16,r2
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 800c4e8:	94800044 	addi	r18,r18,1
 800c4ec:	9cbff32e 	bgeu	r19,r18,800c4bc <alt_up_pixel_buffer_dma_draw_box+0x138>
 800c4f0:	00004f06 	br	800c630 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800c4f4:	8825883a 	mov	r18,r17
 800c4f8:	00000d06 	br	800c530 <alt_up_pixel_buffer_dma_draw_box+0x1ac>
			{
				for (x = l_x; x <= r_x; x++)
 800c4fc:	b023883a 	mov	r17,r22
 800c500:	00000606 	br	800c51c <alt_up_pixel_buffer_dma_draw_box+0x198>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
 800c504:	8c45883a 	add	r2,r17,r17
 800c508:	1085883a 	add	r2,r2,r2
 800c50c:	1405883a 	add	r2,r2,r16
 800c510:	b807883a 	mov	r3,r23
 800c514:	10c00035 	stwio	r3,0(r2)
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c518:	8c400044 	addi	r17,r17,1
 800c51c:	a47ff92e 	bgeu	r20,r17,800c504 <alt_up_pixel_buffer_dma_draw_box+0x180>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + (1 << offset_y);
 800c520:	00800044 	movi	r2,1
 800c524:	1544983a 	sll	r2,r2,r21
 800c528:	80a1883a 	add	r16,r16,r2
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800c52c:	94800044 	addi	r18,r18,1
 800c530:	9cbff22e 	bgeu	r19,r18,800c4fc <alt_up_pixel_buffer_dma_draw_box+0x178>
 800c534:	00003e06 	br	800c630 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
	} else {
		/* Draw a box of a given color on the screen using the linear addressing mode. */
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c538:	e0bff417 	ldw	r2,-48(fp)
 800c53c:	10800e17 	ldw	r2,56(r2)
 800c540:	10800058 	cmpnei	r2,r2,1
 800c544:	10000f1e 	bne	r2,zero,800c584 <alt_up_pixel_buffer_dma_draw_box+0x200>
			addr = addr + t_y * limit_x;
 800c548:	8c85383a 	mul	r2,r17,r18
 800c54c:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800c550:	882b883a 	mov	r21,r17
 800c554:	00000906 	br	800c57c <alt_up_pixel_buffer_dma_draw_box+0x1f8>
			{
				for (x = l_x; x <= r_x; x++)
 800c558:	b023883a 	mov	r17,r22
 800c55c:	00000406 	br	800c570 <alt_up_pixel_buffer_dma_draw_box+0x1ec>
				{
					IOWR_8DIRECT(addr, x, local_color);
 800c560:	8c05883a 	add	r2,r17,r16
 800c564:	b807883a 	mov	r3,r23
 800c568:	10c00025 	stbio	r3,0(r2)
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c56c:	8c400044 	addi	r17,r17,1
 800c570:	a47ffb2e 	bgeu	r20,r17,800c560 <alt_up_pixel_buffer_dma_draw_box+0x1dc>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
 800c574:	84a1883a 	add	r16,r16,r18
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800c578:	ad400044 	addi	r21,r21,1
 800c57c:	9d7ff62e 	bgeu	r19,r21,800c558 <alt_up_pixel_buffer_dma_draw_box+0x1d4>
 800c580:	00002b06 	br	800c630 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c584:	e0bff417 	ldw	r2,-48(fp)
 800c588:	10800e17 	ldw	r2,56(r2)
 800c58c:	10800098 	cmpnei	r2,r2,2
 800c590:	1000121e 	bne	r2,zero,800c5dc <alt_up_pixel_buffer_dma_draw_box+0x258>
			limit_x = limit_x << 1;
 800c594:	9485883a 	add	r2,r18,r18
 800c598:	1025883a 	mov	r18,r2
			addr = addr + t_y * limit_x;
 800c59c:	8c85383a 	mul	r2,r17,r18
 800c5a0:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800c5a4:	882b883a 	mov	r21,r17
 800c5a8:	00000a06 	br	800c5d4 <alt_up_pixel_buffer_dma_draw_box+0x250>
			{
				for (x = l_x; x <= r_x; x++)
 800c5ac:	b023883a 	mov	r17,r22
 800c5b0:	00000506 	br	800c5c8 <alt_up_pixel_buffer_dma_draw_box+0x244>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
 800c5b4:	8c45883a 	add	r2,r17,r17
 800c5b8:	1405883a 	add	r2,r2,r16
 800c5bc:	b807883a 	mov	r3,r23
 800c5c0:	10c0002d 	sthio	r3,0(r2)
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c5c4:	8c400044 	addi	r17,r17,1
 800c5c8:	a47ffa2e 	bgeu	r20,r17,800c5b4 <alt_up_pixel_buffer_dma_draw_box+0x230>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + limit_x;
 800c5cc:	84a1883a 	add	r16,r16,r18
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800c5d0:	ad400044 	addi	r21,r21,1
 800c5d4:	9d7ff52e 	bgeu	r19,r21,800c5ac <alt_up_pixel_buffer_dma_draw_box+0x228>
 800c5d8:	00001506 	br	800c630 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
 800c5dc:	9485883a 	add	r2,r18,r18
 800c5e0:	1085883a 	add	r2,r2,r2
 800c5e4:	1025883a 	mov	r18,r2
			addr = addr + t_y * limit_x;
 800c5e8:	8c85383a 	mul	r2,r17,r18
 800c5ec:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800c5f0:	882b883a 	mov	r21,r17
 800c5f4:	00000b06 	br	800c624 <alt_up_pixel_buffer_dma_draw_box+0x2a0>
			{
				for (x = l_x; x <= r_x; x++)
 800c5f8:	b023883a 	mov	r17,r22
 800c5fc:	00000606 	br	800c618 <alt_up_pixel_buffer_dma_draw_box+0x294>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
 800c600:	8c45883a 	add	r2,r17,r17
 800c604:	1085883a 	add	r2,r2,r2
 800c608:	1405883a 	add	r2,r2,r16
 800c60c:	b807883a 	mov	r3,r23
 800c610:	10c00035 	stwio	r3,0(r2)
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c614:	8c400044 	addi	r17,r17,1
 800c618:	a47ff92e 	bgeu	r20,r17,800c600 <alt_up_pixel_buffer_dma_draw_box+0x27c>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + limit_x;
 800c61c:	84a1883a 	add	r16,r16,r18
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800c620:	ad400044 	addi	r21,r21,1
 800c624:	9d7ff42e 	bgeu	r19,r21,800c5f8 <alt_up_pixel_buffer_dma_draw_box+0x274>
 800c628:	00000106 	br	800c630 <alt_up_pixel_buffer_dma_draw_box+0x2ac>
		b_y = temp;
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 800c62c:	0001883a 	nop
				}
				addr = addr + limit_x;
			}
		}
	}
}
 800c630:	e6fff804 	addi	sp,fp,-32
 800c634:	df000817 	ldw	fp,32(sp)
 800c638:	ddc00717 	ldw	r23,28(sp)
 800c63c:	dd800617 	ldw	r22,24(sp)
 800c640:	dd400517 	ldw	r21,20(sp)
 800c644:	dd000417 	ldw	r20,16(sp)
 800c648:	dcc00317 	ldw	r19,12(sp)
 800c64c:	dc800217 	ldw	r18,8(sp)
 800c650:	dc400117 	ldw	r17,4(sp)
 800c654:	dc000017 	ldw	r16,0(sp)
 800c658:	dec00904 	addi	sp,sp,36
 800c65c:	f800283a 	ret

0800c660 <alt_up_pixel_buffer_dma_draw_hline>:

void alt_up_pixel_buffer_dma_draw_hline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int x1, int y, int color, int backbuffer)
/* This method draws a horizontal line. This method is faster than using the line method because we know the direction of the line. */
{
 800c660:	defff404 	addi	sp,sp,-48
 800c664:	df000b15 	stw	fp,44(sp)
 800c668:	dd800a15 	stw	r22,40(sp)
 800c66c:	dd400915 	stw	r21,36(sp)
 800c670:	dd000815 	stw	r20,32(sp)
 800c674:	dcc00715 	stw	r19,28(sp)
 800c678:	dc800615 	stw	r18,24(sp)
 800c67c:	dc400515 	stw	r17,20(sp)
 800c680:	dc000415 	stw	r16,16(sp)
 800c684:	df000b04 	addi	fp,sp,44
 800c688:	e13ff515 	stw	r4,-44(fp)
 800c68c:	e17ff615 	stw	r5,-40(fp)
 800c690:	e1bff715 	stw	r6,-36(fp)
 800c694:	e1fff815 	stw	r7,-32(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 800c698:	e0bff517 	ldw	r2,-44(fp)
 800c69c:	14800f17 	ldw	r18,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 800c6a0:	e0bff517 	ldw	r2,-44(fp)
 800c6a4:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int l_x = x0;
 800c6a8:	e47ff617 	ldw	r17,-40(fp)
	register unsigned int r_x = x1;
 800c6ac:	e4fff717 	ldw	r19,-36(fp)
	register unsigned int line_y = y;
 800c6b0:	e53ff817 	ldw	r20,-32(fp)
	register unsigned int local_color = color;
 800c6b4:	e5400117 	ldw	r21,4(fp)
	
	/* Check coordinates */
	if (l_x > r_x)
 800c6b8:	9c40032e 	bgeu	r19,r17,800c6c8 <alt_up_pixel_buffer_dma_draw_hline+0x68>
	{
		temp = l_x;
 800c6bc:	882d883a 	mov	r22,r17
		l_x = r_x;
 800c6c0:	9823883a 	mov	r17,r19
		r_x = temp;
 800c6c4:	b027883a 	mov	r19,r22
	}
	if ((l_x >= limit_x) || (line_y >= limit_y) || (r_x < 0) || (line_y < 0))
 800c6c8:	8c805d2e 	bgeu	r17,r18,800c840 <alt_up_pixel_buffer_dma_draw_hline+0x1e0>
 800c6cc:	a4005c2e 	bgeu	r20,r16,800c840 <alt_up_pixel_buffer_dma_draw_hline+0x1e0>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
 800c6d0:	9c800136 	bltu	r19,r18,800c6d8 <alt_up_pixel_buffer_dma_draw_hline+0x78>
	{
		r_x = limit_x - 1;
 800c6d4:	94ffffc4 	addi	r19,r18,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800c6d8:	e0800217 	ldw	r2,8(fp)
 800c6dc:	10800058 	cmpnei	r2,r2,1
 800c6e0:	1000031e 	bne	r2,zero,800c6f0 <alt_up_pixel_buffer_dma_draw_hline+0x90>
		addr = pixel_buffer->back_buffer_start_address;
 800c6e4:	e0bff517 	ldw	r2,-44(fp)
 800c6e8:	14000c17 	ldw	r16,48(r2)
 800c6ec:	00000206 	br	800c6f8 <alt_up_pixel_buffer_dma_draw_hline+0x98>
	else
		addr = pixel_buffer->buffer_start_address;
 800c6f0:	e0bff517 	ldw	r2,-44(fp)
 800c6f4:	14000b17 	ldw	r16,44(r2)

	/* Draw a horizontal line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c6f8:	e0bff517 	ldw	r2,-44(fp)
 800c6fc:	10800d17 	ldw	r2,52(r2)
 800c700:	1000231e 	bne	r2,zero,800c790 <alt_up_pixel_buffer_dma_draw_hline+0x130>
		/* Draw a horizontal line of a given color on the screen using the XY addressing mode. */
		register unsigned int x;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 800c704:	e0bff517 	ldw	r2,-44(fp)
 800c708:	14801317 	ldw	r18,76(r2)
		addr = addr + (line_y << offset_y);
 800c70c:	a484983a 	sll	r2,r20,r18
 800c710:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c714:	e0bff517 	ldw	r2,-44(fp)
 800c718:	10800e17 	ldw	r2,56(r2)
 800c71c:	10800058 	cmpnei	r2,r2,1
 800c720:	1000071e 	bne	r2,zero,800c740 <alt_up_pixel_buffer_dma_draw_hline+0xe0>
			for (x = l_x; x <= r_x; x++)
 800c724:	00000406 	br	800c738 <alt_up_pixel_buffer_dma_draw_hline+0xd8>
			{
				IOWR_8DIRECT(addr, x, local_color);
 800c728:	8c05883a 	add	r2,r17,r16
 800c72c:	a807883a 	mov	r3,r21
 800c730:	10c00025 	stbio	r3,0(r2)
		addr = addr + (line_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
 800c734:	8c400044 	addi	r17,r17,1
 800c738:	9c7ffb2e 	bgeu	r19,r17,800c728 <alt_up_pixel_buffer_dma_draw_hline+0xc8>
 800c73c:	00004106 	br	800c844 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c740:	e0bff517 	ldw	r2,-44(fp)
 800c744:	10800e17 	ldw	r2,56(r2)
 800c748:	10800098 	cmpnei	r2,r2,2
 800c74c:	10000e1e 	bne	r2,zero,800c788 <alt_up_pixel_buffer_dma_draw_hline+0x128>
			for (x = l_x; x <= r_x; x++)
 800c750:	00000506 	br	800c768 <alt_up_pixel_buffer_dma_draw_hline+0x108>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
 800c754:	8c45883a 	add	r2,r17,r17
 800c758:	1405883a 	add	r2,r2,r16
 800c75c:	a807883a 	mov	r3,r21
 800c760:	10c0002d 	sthio	r3,0(r2)
			for (x = l_x; x <= r_x; x++)
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
 800c764:	8c400044 	addi	r17,r17,1
 800c768:	9c7ffa2e 	bgeu	r19,r17,800c754 <alt_up_pixel_buffer_dma_draw_hline+0xf4>
 800c76c:	00003506 	br	800c844 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
 800c770:	8c45883a 	add	r2,r17,r17
 800c774:	1085883a 	add	r2,r2,r2
 800c778:	1405883a 	add	r2,r2,r16
 800c77c:	a807883a 	mov	r3,r21
 800c780:	10c00035 	stwio	r3,0(r2)
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
 800c784:	8c400044 	addi	r17,r17,1
 800c788:	9c7ff92e 	bgeu	r19,r17,800c770 <alt_up_pixel_buffer_dma_draw_hline+0x110>
 800c78c:	00002d06 	br	800c844 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
	} else {
		/* Draw a horizontal line of a given color on the screen using the linear addressing mode. */
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c790:	e0bff517 	ldw	r2,-44(fp)
 800c794:	10800e17 	ldw	r2,56(r2)
 800c798:	10800058 	cmpnei	r2,r2,1
 800c79c:	1000091e 	bne	r2,zero,800c7c4 <alt_up_pixel_buffer_dma_draw_hline+0x164>
			addr = addr + line_y * limit_x;
 800c7a0:	a485383a 	mul	r2,r20,r18
 800c7a4:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 800c7a8:	00000406 	br	800c7bc <alt_up_pixel_buffer_dma_draw_hline+0x15c>
			{
				IOWR_8DIRECT(addr, x, local_color);
 800c7ac:	8c05883a 	add	r2,r17,r16
 800c7b0:	a807883a 	mov	r3,r21
 800c7b4:	10c00025 	stbio	r3,0(r2)
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 800c7b8:	8c400044 	addi	r17,r17,1
 800c7bc:	9c7ffb2e 	bgeu	r19,r17,800c7ac <alt_up_pixel_buffer_dma_draw_hline+0x14c>
 800c7c0:	00002006 	br	800c844 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c7c4:	e0bff517 	ldw	r2,-44(fp)
 800c7c8:	10800e17 	ldw	r2,56(r2)
 800c7cc:	10800098 	cmpnei	r2,r2,2
 800c7d0:	10000c1e 	bne	r2,zero,800c804 <alt_up_pixel_buffer_dma_draw_hline+0x1a4>
			limit_x = limit_x << 1;
 800c7d4:	9485883a 	add	r2,r18,r18
 800c7d8:	1025883a 	mov	r18,r2
			addr = addr + line_y * limit_x;
 800c7dc:	a485383a 	mul	r2,r20,r18
 800c7e0:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 800c7e4:	00000506 	br	800c7fc <alt_up_pixel_buffer_dma_draw_hline+0x19c>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
 800c7e8:	8c45883a 	add	r2,r17,r17
 800c7ec:	1405883a 	add	r2,r2,r16
 800c7f0:	a807883a 	mov	r3,r21
 800c7f4:	10c0002d 	sthio	r3,0(r2)
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 800c7f8:	8c400044 	addi	r17,r17,1
 800c7fc:	9c7ffa2e 	bgeu	r19,r17,800c7e8 <alt_up_pixel_buffer_dma_draw_hline+0x188>
 800c800:	00001006 	br	800c844 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			limit_x = limit_x << 2;
 800c804:	9485883a 	add	r2,r18,r18
 800c808:	1085883a 	add	r2,r2,r2
 800c80c:	1025883a 	mov	r18,r2
			addr = addr + line_y * limit_x;
 800c810:	a485383a 	mul	r2,r20,r18
 800c814:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 800c818:	00000606 	br	800c834 <alt_up_pixel_buffer_dma_draw_hline+0x1d4>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
 800c81c:	8c45883a 	add	r2,r17,r17
 800c820:	1085883a 	add	r2,r2,r2
 800c824:	1405883a 	add	r2,r2,r16
 800c828:	a807883a 	mov	r3,r21
 800c82c:	10c00035 	stwio	r3,0(r2)
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 800c830:	8c400044 	addi	r17,r17,1
 800c834:	9c7ff92e 	bgeu	r19,r17,800c81c <alt_up_pixel_buffer_dma_draw_hline+0x1bc>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
			}
			addr = addr + limit_x;
 800c838:	84a1883a 	add	r16,r16,r18
 800c83c:	00000106 	br	800c844 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
		r_x = temp;
	}
	if ((l_x >= limit_x) || (line_y >= limit_y) || (r_x < 0) || (line_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 800c840:	0001883a 	nop
				IOWR_32DIRECT(addr, x << 2, local_color);
			}
			addr = addr + limit_x;
		}
	}
}
 800c844:	e6fff904 	addi	sp,fp,-28
 800c848:	df000717 	ldw	fp,28(sp)
 800c84c:	dd800617 	ldw	r22,24(sp)
 800c850:	dd400517 	ldw	r21,20(sp)
 800c854:	dd000417 	ldw	r20,16(sp)
 800c858:	dcc00317 	ldw	r19,12(sp)
 800c85c:	dc800217 	ldw	r18,8(sp)
 800c860:	dc400117 	ldw	r17,4(sp)
 800c864:	dc000017 	ldw	r16,0(sp)
 800c868:	dec00804 	addi	sp,sp,32
 800c86c:	f800283a 	ret

0800c870 <alt_up_pixel_buffer_dma_draw_vline>:


void alt_up_pixel_buffer_dma_draw_vline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x, int y0, int y1, int color, int backbuffer)
/* This method draws a vertical line. This method is faster than using the line method because we know the direction of the line. */

{
 800c870:	defff404 	addi	sp,sp,-48
 800c874:	df000b15 	stw	fp,44(sp)
 800c878:	dd800a15 	stw	r22,40(sp)
 800c87c:	dd400915 	stw	r21,36(sp)
 800c880:	dd000815 	stw	r20,32(sp)
 800c884:	dcc00715 	stw	r19,28(sp)
 800c888:	dc800615 	stw	r18,24(sp)
 800c88c:	dc400515 	stw	r17,20(sp)
 800c890:	dc000415 	stw	r16,16(sp)
 800c894:	df000b04 	addi	fp,sp,44
 800c898:	e13ff515 	stw	r4,-44(fp)
 800c89c:	e17ff615 	stw	r5,-40(fp)
 800c8a0:	e1bff715 	stw	r6,-36(fp)
 800c8a4:	e1fff815 	stw	r7,-32(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 800c8a8:	e0bff517 	ldw	r2,-44(fp)
 800c8ac:	14400f17 	ldw	r17,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 800c8b0:	e0bff517 	ldw	r2,-44(fp)
 800c8b4:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int line_x = x;
 800c8b8:	e4bff617 	ldw	r18,-40(fp)
	register unsigned int t_y = y0;
 800c8bc:	e53ff717 	ldw	r20,-36(fp)
	register unsigned int b_y = y1;
 800c8c0:	e4fff817 	ldw	r19,-32(fp)
	register unsigned int local_color = color;
 800c8c4:	e5800117 	ldw	r22,4(fp)
	
	/* Check coordinates */
	if (t_y > b_y)
 800c8c8:	9d00032e 	bgeu	r19,r20,800c8d8 <alt_up_pixel_buffer_dma_draw_vline+0x68>
	{
		temp = t_y;
 800c8cc:	a02b883a 	mov	r21,r20
		t_y = b_y;
 800c8d0:	9829883a 	mov	r20,r19
		b_y = temp;
 800c8d4:	a827883a 	mov	r19,r21
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
 800c8d8:	94406c2e 	bgeu	r18,r17,800ca8c <alt_up_pixel_buffer_dma_draw_vline+0x21c>
 800c8dc:	a4006b2e 	bgeu	r20,r16,800ca8c <alt_up_pixel_buffer_dma_draw_vline+0x21c>
	/* Clip the box and draw only within the confines of the screen. */
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
 800c8e0:	9c000136 	bltu	r19,r16,800c8e8 <alt_up_pixel_buffer_dma_draw_vline+0x78>
	{
		b_y = limit_y - 1;
 800c8e4:	84ffffc4 	addi	r19,r16,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800c8e8:	e0800217 	ldw	r2,8(fp)
 800c8ec:	10800058 	cmpnei	r2,r2,1
 800c8f0:	1000031e 	bne	r2,zero,800c900 <alt_up_pixel_buffer_dma_draw_vline+0x90>
		addr = pixel_buffer->back_buffer_start_address;
 800c8f4:	e0bff517 	ldw	r2,-44(fp)
 800c8f8:	14000c17 	ldw	r16,48(r2)
 800c8fc:	00000206 	br	800c908 <alt_up_pixel_buffer_dma_draw_vline+0x98>
	else
		addr = pixel_buffer->buffer_start_address;
 800c900:	e0bff517 	ldw	r2,-44(fp)
 800c904:	14000b17 	ldw	r16,44(r2)

	/* Draw the vertical line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c908:	e0bff517 	ldw	r2,-44(fp)
 800c90c:	10800d17 	ldw	r2,52(r2)
 800c910:	1000301e 	bne	r2,zero,800c9d4 <alt_up_pixel_buffer_dma_draw_vline+0x164>
		/* Draw a vertical line of a given color on the screen using the XY addressing mode. */
		register unsigned int y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 800c914:	e0bff517 	ldw	r2,-44(fp)
 800c918:	15401317 	ldw	r21,76(r2)
		addr = addr + (t_y << offset_y);
 800c91c:	a544983a 	sll	r2,r20,r21
 800c920:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c924:	e0bff517 	ldw	r2,-44(fp)
 800c928:	10800e17 	ldw	r2,56(r2)
 800c92c:	10800058 	cmpnei	r2,r2,1
 800c930:	10000b1e 	bne	r2,zero,800c960 <alt_up_pixel_buffer_dma_draw_vline+0xf0>
			for (y = t_y; y <= b_y; y++)
 800c934:	a023883a 	mov	r17,r20
 800c938:	00000706 	br	800c958 <alt_up_pixel_buffer_dma_draw_vline+0xe8>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
 800c93c:	9405883a 	add	r2,r18,r16
 800c940:	b007883a 	mov	r3,r22
 800c944:	10c00025 	stbio	r3,0(r2)
				addr = addr + (1 << offset_y);
 800c948:	00800044 	movi	r2,1
 800c94c:	1544983a 	sll	r2,r2,r21
 800c950:	80a1883a 	add	r16,r16,r2
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 800c954:	8c400044 	addi	r17,r17,1
 800c958:	9c7ff82e 	bgeu	r19,r17,800c93c <alt_up_pixel_buffer_dma_draw_vline+0xcc>
 800c95c:	00004c06 	br	800ca90 <alt_up_pixel_buffer_dma_draw_vline+0x220>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c960:	e0bff517 	ldw	r2,-44(fp)
 800c964:	10800e17 	ldw	r2,56(r2)
 800c968:	10800098 	cmpnei	r2,r2,2
 800c96c:	10000c1e 	bne	r2,zero,800c9a0 <alt_up_pixel_buffer_dma_draw_vline+0x130>
			for (y = t_y; y <= b_y; y++)
 800c970:	a023883a 	mov	r17,r20
 800c974:	00000806 	br	800c998 <alt_up_pixel_buffer_dma_draw_vline+0x128>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
 800c978:	9485883a 	add	r2,r18,r18
 800c97c:	1405883a 	add	r2,r2,r16
 800c980:	b007883a 	mov	r3,r22
 800c984:	10c0002d 	sthio	r3,0(r2)
				addr = addr + (1 << offset_y);
 800c988:	00800044 	movi	r2,1
 800c98c:	1544983a 	sll	r2,r2,r21
 800c990:	80a1883a 	add	r16,r16,r2
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 800c994:	8c400044 	addi	r17,r17,1
 800c998:	9c7ff72e 	bgeu	r19,r17,800c978 <alt_up_pixel_buffer_dma_draw_vline+0x108>
 800c99c:	00003c06 	br	800ca90 <alt_up_pixel_buffer_dma_draw_vline+0x220>
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800c9a0:	a023883a 	mov	r17,r20
 800c9a4:	00000906 	br	800c9cc <alt_up_pixel_buffer_dma_draw_vline+0x15c>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
 800c9a8:	9485883a 	add	r2,r18,r18
 800c9ac:	1085883a 	add	r2,r2,r2
 800c9b0:	1405883a 	add	r2,r2,r16
 800c9b4:	b007883a 	mov	r3,r22
 800c9b8:	10c00035 	stwio	r3,0(r2)
				addr = addr + (1 << offset_y);
 800c9bc:	00800044 	movi	r2,1
 800c9c0:	1544983a 	sll	r2,r2,r21
 800c9c4:	80a1883a 	add	r16,r16,r2
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800c9c8:	8c400044 	addi	r17,r17,1
 800c9cc:	9c7ff62e 	bgeu	r19,r17,800c9a8 <alt_up_pixel_buffer_dma_draw_vline+0x138>
 800c9d0:	00002f06 	br	800ca90 <alt_up_pixel_buffer_dma_draw_vline+0x220>
	} else {
		/* Draw a vertical line of a given color on the screen using the linear addressing mode. */
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c9d4:	e0bff517 	ldw	r2,-44(fp)
 800c9d8:	10800e17 	ldw	r2,56(r2)
 800c9dc:	10800058 	cmpnei	r2,r2,1
 800c9e0:	10000a1e 	bne	r2,zero,800ca0c <alt_up_pixel_buffer_dma_draw_vline+0x19c>
			addr = addr + t_y * limit_x;
 800c9e4:	a445383a 	mul	r2,r20,r17
 800c9e8:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800c9ec:	00000506 	br	800ca04 <alt_up_pixel_buffer_dma_draw_vline+0x194>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
 800c9f0:	9405883a 	add	r2,r18,r16
 800c9f4:	b007883a 	mov	r3,r22
 800c9f8:	10c00025 	stbio	r3,0(r2)
				addr = addr + limit_x;
 800c9fc:	8461883a 	add	r16,r16,r17
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800ca00:	a5000044 	addi	r20,r20,1
 800ca04:	9d3ffa2e 	bgeu	r19,r20,800c9f0 <alt_up_pixel_buffer_dma_draw_vline+0x180>
 800ca08:	00002106 	br	800ca90 <alt_up_pixel_buffer_dma_draw_vline+0x220>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800ca0c:	e0bff517 	ldw	r2,-44(fp)
 800ca10:	10800e17 	ldw	r2,56(r2)
 800ca14:	10800098 	cmpnei	r2,r2,2
 800ca18:	10000d1e 	bne	r2,zero,800ca50 <alt_up_pixel_buffer_dma_draw_vline+0x1e0>
			limit_x = limit_x << 1;
 800ca1c:	8c45883a 	add	r2,r17,r17
 800ca20:	1023883a 	mov	r17,r2
			addr = addr + t_y * limit_x;
 800ca24:	a445383a 	mul	r2,r20,r17
 800ca28:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800ca2c:	00000606 	br	800ca48 <alt_up_pixel_buffer_dma_draw_vline+0x1d8>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
 800ca30:	9485883a 	add	r2,r18,r18
 800ca34:	1405883a 	add	r2,r2,r16
 800ca38:	b007883a 	mov	r3,r22
 800ca3c:	10c0002d 	sthio	r3,0(r2)
				addr = addr + limit_x;
 800ca40:	8461883a 	add	r16,r16,r17
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800ca44:	a5000044 	addi	r20,r20,1
 800ca48:	9d3ff92e 	bgeu	r19,r20,800ca30 <alt_up_pixel_buffer_dma_draw_vline+0x1c0>
 800ca4c:	00001006 	br	800ca90 <alt_up_pixel_buffer_dma_draw_vline+0x220>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
 800ca50:	8c45883a 	add	r2,r17,r17
 800ca54:	1085883a 	add	r2,r2,r2
 800ca58:	1023883a 	mov	r17,r2
			addr = addr + t_y * limit_x;
 800ca5c:	a445383a 	mul	r2,r20,r17
 800ca60:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800ca64:	00000706 	br	800ca84 <alt_up_pixel_buffer_dma_draw_vline+0x214>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
 800ca68:	9485883a 	add	r2,r18,r18
 800ca6c:	1085883a 	add	r2,r2,r2
 800ca70:	1405883a 	add	r2,r2,r16
 800ca74:	b007883a 	mov	r3,r22
 800ca78:	10c00035 	stwio	r3,0(r2)
				addr = addr + limit_x;
 800ca7c:	8461883a 	add	r16,r16,r17
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800ca80:	a5000044 	addi	r20,r20,1
 800ca84:	9d3ff82e 	bgeu	r19,r20,800ca68 <alt_up_pixel_buffer_dma_draw_vline+0x1f8>
 800ca88:	00000106 	br	800ca90 <alt_up_pixel_buffer_dma_draw_vline+0x220>
		b_y = temp;
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 800ca8c:	0001883a 	nop
				IOWR_32DIRECT(addr, line_x << 2, local_color);
				addr = addr + limit_x;
			}
		}
	}
}
 800ca90:	e6fff904 	addi	sp,fp,-28
 800ca94:	df000717 	ldw	fp,28(sp)
 800ca98:	dd800617 	ldw	r22,24(sp)
 800ca9c:	dd400517 	ldw	r21,20(sp)
 800caa0:	dd000417 	ldw	r20,16(sp)
 800caa4:	dcc00317 	ldw	r19,12(sp)
 800caa8:	dc800217 	ldw	r18,8(sp)
 800caac:	dc400117 	ldw	r17,4(sp)
 800cab0:	dc000017 	ldw	r16,0(sp)
 800cab4:	dec00804 	addi	sp,sp,32
 800cab8:	f800283a 	ret

0800cabc <alt_up_pixel_buffer_dma_draw_rectangle>:

void alt_up_pixel_buffer_dma_draw_rectangle(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
{
 800cabc:	defff804 	addi	sp,sp,-32
 800cac0:	dfc00715 	stw	ra,28(sp)
 800cac4:	df000615 	stw	fp,24(sp)
 800cac8:	df000604 	addi	fp,sp,24
 800cacc:	e13ffc15 	stw	r4,-16(fp)
 800cad0:	e17ffd15 	stw	r5,-12(fp)
 800cad4:	e1bffe15 	stw	r6,-8(fp)
 800cad8:	e1ffff15 	stw	r7,-4(fp)
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y0, color, backbuffer);
 800cadc:	e0800417 	ldw	r2,16(fp)
 800cae0:	d8800115 	stw	r2,4(sp)
 800cae4:	e0800317 	ldw	r2,12(fp)
 800cae8:	d8800015 	stw	r2,0(sp)
 800caec:	e1fffe17 	ldw	r7,-8(fp)
 800caf0:	e1bfff17 	ldw	r6,-4(fp)
 800caf4:	e17ffd17 	ldw	r5,-12(fp)
 800caf8:	e13ffc17 	ldw	r4,-16(fp)
 800cafc:	800c6600 	call	800c660 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y1, color, backbuffer);
 800cb00:	e0800417 	ldw	r2,16(fp)
 800cb04:	d8800115 	stw	r2,4(sp)
 800cb08:	e0800317 	ldw	r2,12(fp)
 800cb0c:	d8800015 	stw	r2,0(sp)
 800cb10:	e1c00217 	ldw	r7,8(fp)
 800cb14:	e1bfff17 	ldw	r6,-4(fp)
 800cb18:	e17ffd17 	ldw	r5,-12(fp)
 800cb1c:	e13ffc17 	ldw	r4,-16(fp)
 800cb20:	800c6600 	call	800c660 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x0, y0, y1, color, backbuffer);
 800cb24:	e0800417 	ldw	r2,16(fp)
 800cb28:	d8800115 	stw	r2,4(sp)
 800cb2c:	e0800317 	ldw	r2,12(fp)
 800cb30:	d8800015 	stw	r2,0(sp)
 800cb34:	e1c00217 	ldw	r7,8(fp)
 800cb38:	e1bffe17 	ldw	r6,-8(fp)
 800cb3c:	e17ffd17 	ldw	r5,-12(fp)
 800cb40:	e13ffc17 	ldw	r4,-16(fp)
 800cb44:	800c8700 	call	800c870 <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x1, y0, y1, color, backbuffer);
 800cb48:	e0800417 	ldw	r2,16(fp)
 800cb4c:	d8800115 	stw	r2,4(sp)
 800cb50:	e0800317 	ldw	r2,12(fp)
 800cb54:	d8800015 	stw	r2,0(sp)
 800cb58:	e1c00217 	ldw	r7,8(fp)
 800cb5c:	e1bffe17 	ldw	r6,-8(fp)
 800cb60:	e17fff17 	ldw	r5,-4(fp)
 800cb64:	e13ffc17 	ldw	r4,-16(fp)
 800cb68:	800c8700 	call	800c870 <alt_up_pixel_buffer_dma_draw_vline>
}
 800cb6c:	0001883a 	nop
 800cb70:	e037883a 	mov	sp,fp
 800cb74:	dfc00117 	ldw	ra,4(sp)
 800cb78:	df000017 	ldw	fp,0(sp)
 800cb7c:	dec00204 	addi	sp,sp,8
 800cb80:	f800283a 	ret

0800cb84 <helper_plot_pixel>:

void helper_plot_pixel(register unsigned int buffer_start, register int line_size, register int x, register int y, register int color, register int mode)
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
 800cb84:	deffff04 	addi	sp,sp,-4
 800cb88:	df000015 	stw	fp,0(sp)
 800cb8c:	d839883a 	mov	fp,sp
 800cb90:	2005883a 	mov	r2,r4
 800cb94:	3007883a 	mov	r3,r6
 800cb98:	3809883a 	mov	r4,r7
 800cb9c:	e1800117 	ldw	r6,4(fp)
 800cba0:	e1c00217 	ldw	r7,8(fp)
	if (mode == 0)
 800cba4:	3800051e 	bne	r7,zero,800cbbc <helper_plot_pixel+0x38>
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
 800cba8:	2909383a 	mul	r4,r5,r4
 800cbac:	20c7883a 	add	r3,r4,r3
 800cbb0:	1885883a 	add	r2,r3,r2
 800cbb4:	11800025 	stbio	r6,0(r2)
	else if (mode == 1)
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
}
 800cbb8:	00000e06 	br	800cbf4 <helper_plot_pixel+0x70>
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
	if (mode == 0)
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
	else if (mode == 1)
 800cbbc:	39c00058 	cmpnei	r7,r7,1
 800cbc0:	3800061e 	bne	r7,zero,800cbdc <helper_plot_pixel+0x58>
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
 800cbc4:	2909383a 	mul	r4,r5,r4
 800cbc8:	20c7883a 	add	r3,r4,r3
 800cbcc:	18c7883a 	add	r3,r3,r3
 800cbd0:	1885883a 	add	r2,r3,r2
 800cbd4:	1180002d 	sthio	r6,0(r2)
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
}
 800cbd8:	00000606 	br	800cbf4 <helper_plot_pixel+0x70>
	if (mode == 0)
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
	else if (mode == 1)
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
 800cbdc:	2909383a 	mul	r4,r5,r4
 800cbe0:	20c7883a 	add	r3,r4,r3
 800cbe4:	18c7883a 	add	r3,r3,r3
 800cbe8:	18c7883a 	add	r3,r3,r3
 800cbec:	1885883a 	add	r2,r3,r2
 800cbf0:	11800035 	stwio	r6,0(r2)
}
 800cbf4:	0001883a 	nop
 800cbf8:	e037883a 	mov	sp,fp
 800cbfc:	df000017 	ldw	fp,0(sp)
 800cc00:	dec00104 	addi	sp,sp,4
 800cc04:	f800283a 	ret

0800cc08 <alt_up_pixel_buffer_dma_draw_line>:

void alt_up_pixel_buffer_dma_draw_line(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a line between points (x0, y0) and (x1, y1). The function does not check if it draws a pixel within screen boundaries.
 * users should ensure that the line is drawn within the screen boundaries. */
{
 800cc08:	deffeb04 	addi	sp,sp,-84
 800cc0c:	dfc01415 	stw	ra,80(sp)
 800cc10:	df001315 	stw	fp,76(sp)
 800cc14:	ddc01215 	stw	r23,72(sp)
 800cc18:	dd801115 	stw	r22,68(sp)
 800cc1c:	dd401015 	stw	r21,64(sp)
 800cc20:	dd000f15 	stw	r20,60(sp)
 800cc24:	dcc00e15 	stw	r19,56(sp)
 800cc28:	dc800d15 	stw	r18,52(sp)
 800cc2c:	dc400c15 	stw	r17,48(sp)
 800cc30:	dc000b15 	stw	r16,44(sp)
 800cc34:	df001304 	addi	fp,sp,76
 800cc38:	e13fef15 	stw	r4,-68(fp)
 800cc3c:	e17ff015 	stw	r5,-64(fp)
 800cc40:	e1bff115 	stw	r6,-60(fp)
 800cc44:	e1fff215 	stw	r7,-56(fp)
	register int x_0 = x0;
 800cc48:	e47ff017 	ldw	r17,-64(fp)
	register int y_0 = y0;
 800cc4c:	e4fff117 	ldw	r19,-60(fp)
	register int x_1 = x1;
 800cc50:	e4bff217 	ldw	r18,-56(fp)
	register int y_1 = y1;
 800cc54:	e5000217 	ldw	r20,8(fp)
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
 800cc58:	a4c5c83a 	sub	r2,r20,r19
 800cc5c:	1000010e 	bge	r2,zero,800cc64 <alt_up_pixel_buffer_dma_draw_line+0x5c>
 800cc60:	0085c83a 	sub	r2,zero,r2
 800cc64:	1007883a 	mov	r3,r2
 800cc68:	9445c83a 	sub	r2,r18,r17
 800cc6c:	1000010e 	bge	r2,zero,800cc74 <alt_up_pixel_buffer_dma_draw_line+0x6c>
 800cc70:	0085c83a 	sub	r2,zero,r2
 800cc74:	10c4803a 	cmplt	r2,r2,r3
 800cc78:	e0bff305 	stb	r2,-52(fp)
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
 800cc7c:	e0bfef17 	ldw	r2,-68(fp)
 800cc80:	10800e17 	ldw	r2,56(r2)
 800cc84:	10800060 	cmpeqi	r2,r2,1
 800cc88:	1000081e 	bne	r2,zero,800ccac <alt_up_pixel_buffer_dma_draw_line+0xa4>
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
 800cc8c:	e0bfef17 	ldw	r2,-68(fp)
 800cc90:	10800e17 	ldw	r2,56(r2)
 800cc94:	10800098 	cmpnei	r2,r2,2
 800cc98:	1000021e 	bne	r2,zero,800cca4 <alt_up_pixel_buffer_dma_draw_line+0x9c>
 800cc9c:	00800044 	movi	r2,1
 800cca0:	00000306 	br	800ccb0 <alt_up_pixel_buffer_dma_draw_line+0xa8>
 800cca4:	00800084 	movi	r2,2
 800cca8:	00000106 	br	800ccb0 <alt_up_pixel_buffer_dma_draw_line+0xa8>
	register int y_0 = y0;
	register int x_1 = x1;
	register int y_1 = y1;
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
 800ccac:	0005883a 	mov	r2,zero
 800ccb0:	e0bff415 	stw	r2,-48(fp)
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
	register int line_color = color;
 800ccb4:	e0800317 	ldw	r2,12(fp)
 800ccb8:	e0bff515 	stw	r2,-44(fp)
	register unsigned int buffer_start;
	register int line_size = (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) ? (1 << (pixel_buffer->y_coord_offset-color_mode)) : pixel_buffer->x_resolution;
 800ccbc:	e0bfef17 	ldw	r2,-68(fp)
 800ccc0:	10800d17 	ldw	r2,52(r2)
 800ccc4:	1000071e 	bne	r2,zero,800cce4 <alt_up_pixel_buffer_dma_draw_line+0xdc>
 800ccc8:	e0bfef17 	ldw	r2,-68(fp)
 800cccc:	10801317 	ldw	r2,76(r2)
 800ccd0:	e0fff417 	ldw	r3,-48(fp)
 800ccd4:	10c5c83a 	sub	r2,r2,r3
 800ccd8:	00c00044 	movi	r3,1
 800ccdc:	1884983a 	sll	r2,r3,r2
 800cce0:	00000206 	br	800ccec <alt_up_pixel_buffer_dma_draw_line+0xe4>
 800cce4:	e0bfef17 	ldw	r2,-68(fp)
 800cce8:	10800f17 	ldw	r2,60(r2)
 800ccec:	e0bff615 	stw	r2,-40(fp)

	if (backbuffer == 1)
 800ccf0:	e0800417 	ldw	r2,16(fp)
 800ccf4:	10800058 	cmpnei	r2,r2,1
 800ccf8:	1000031e 	bne	r2,zero,800cd08 <alt_up_pixel_buffer_dma_draw_line+0x100>
		buffer_start = pixel_buffer->back_buffer_start_address;
 800ccfc:	e0bfef17 	ldw	r2,-68(fp)
 800cd00:	15c00c17 	ldw	r23,48(r2)
 800cd04:	00000206 	br	800cd10 <alt_up_pixel_buffer_dma_draw_line+0x108>
	else
		buffer_start = pixel_buffer->buffer_start_address;
 800cd08:	e0bfef17 	ldw	r2,-68(fp)
 800cd0c:	15c00b17 	ldw	r23,44(r2)

	/* Preprocessing inputs */
	if (steep > 0) {
 800cd10:	e0bff307 	ldb	r2,-52(fp)
 800cd14:	0080060e 	bge	zero,r2,800cd30 <alt_up_pixel_buffer_dma_draw_line+0x128>
		// Swap x_0 and y_0
		error = x_0;
 800cd18:	8821883a 	mov	r16,r17
		x_0 = y_0;
 800cd1c:	9823883a 	mov	r17,r19
		y_0 = error;
 800cd20:	8027883a 	mov	r19,r16
		// Swap x_1 and y_1
		error = x_1;
 800cd24:	9021883a 	mov	r16,r18
		x_1 = y_1;
 800cd28:	a025883a 	mov	r18,r20
		y_1 = error;
 800cd2c:	8029883a 	mov	r20,r16
	}
	if (x_0 > x_1) {
 800cd30:	9440060e 	bge	r18,r17,800cd4c <alt_up_pixel_buffer_dma_draw_line+0x144>
		// Swap x_0 and x_1
		error = x_0;
 800cd34:	8821883a 	mov	r16,r17
		x_0 = x_1;
 800cd38:	9023883a 	mov	r17,r18
		x_1 = error;
 800cd3c:	8025883a 	mov	r18,r16
		// Swap y_0 and y_1
		error = y_0;
 800cd40:	9821883a 	mov	r16,r19
		y_0 = y_1;
 800cd44:	a027883a 	mov	r19,r20
		y_1 = error;
 800cd48:	8029883a 	mov	r20,r16
	}

	/* Setup local variables */
	deltax = x_1 - x_0;
 800cd4c:	946bc83a 	sub	r21,r18,r17
	deltay = ABS(y_1 - y_0);
 800cd50:	a4c5c83a 	sub	r2,r20,r19
 800cd54:	1000010e 	bge	r2,zero,800cd5c <alt_up_pixel_buffer_dma_draw_line+0x154>
 800cd58:	0085c83a 	sub	r2,zero,r2
 800cd5c:	e0bff715 	stw	r2,-36(fp)
	error = -(deltax / 2); 
 800cd60:	a804d7fa 	srli	r2,r21,31
 800cd64:	1545883a 	add	r2,r2,r21
 800cd68:	1005d07a 	srai	r2,r2,1
 800cd6c:	00a1c83a 	sub	r16,zero,r2
	y = y_0;
 800cd70:	982d883a 	mov	r22,r19
	if (y_0 < y_1)
 800cd74:	9d00020e 	bge	r19,r20,800cd80 <alt_up_pixel_buffer_dma_draw_line+0x178>
		ystep = 1;
 800cd78:	04c00044 	movi	r19,1
 800cd7c:	00000106 	br	800cd84 <alt_up_pixel_buffer_dma_draw_line+0x17c>
	else
		ystep = -1;
 800cd80:	04ffffc4 	movi	r19,-1

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
 800cd84:	e0bff307 	ldb	r2,-52(fp)
 800cd88:	10800058 	cmpnei	r2,r2,1
 800cd8c:	1000211e 	bne	r2,zero,800ce14 <alt_up_pixel_buffer_dma_draw_line+0x20c>
	{
		for (x=x_0; x <= x_1; x++) {
 800cd90:	00000f06 	br	800cdd0 <alt_up_pixel_buffer_dma_draw_line+0x1c8>
			helper_plot_pixel(buffer_start, line_size, y, x, line_color, color_mode);
 800cd94:	e0bff417 	ldw	r2,-48(fp)
 800cd98:	d8800115 	stw	r2,4(sp)
 800cd9c:	e0bff517 	ldw	r2,-44(fp)
 800cda0:	d8800015 	stw	r2,0(sp)
 800cda4:	880f883a 	mov	r7,r17
 800cda8:	b00d883a 	mov	r6,r22
 800cdac:	e17ff617 	ldw	r5,-40(fp)
 800cdb0:	b809883a 	mov	r4,r23
 800cdb4:	800cb840 	call	800cb84 <helper_plot_pixel>
			error = error + deltay;
 800cdb8:	e0bff717 	ldw	r2,-36(fp)
 800cdbc:	80a1883a 	add	r16,r16,r2
			if (error > 0) {
 800cdc0:	0400020e 	bge	zero,r16,800cdcc <alt_up_pixel_buffer_dma_draw_line+0x1c4>
				y = y + ystep;
 800cdc4:	b4ed883a 	add	r22,r22,r19
				error = error - deltax;
 800cdc8:	8561c83a 	sub	r16,r16,r21

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
	{
		for (x=x_0; x <= x_1; x++) {
 800cdcc:	8c400044 	addi	r17,r17,1
 800cdd0:	947ff00e 	bge	r18,r17,800cd94 <alt_up_pixel_buffer_dma_draw_line+0x18c>
				y = y + ystep;
				error = error - deltax;
			}
		}
	}
}
 800cdd4:	00001006 	br	800ce18 <alt_up_pixel_buffer_dma_draw_line+0x210>
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
			helper_plot_pixel(buffer_start, line_size, x, y, line_color, color_mode);
 800cdd8:	e0bff417 	ldw	r2,-48(fp)
 800cddc:	d8800115 	stw	r2,4(sp)
 800cde0:	e0bff517 	ldw	r2,-44(fp)
 800cde4:	d8800015 	stw	r2,0(sp)
 800cde8:	b00f883a 	mov	r7,r22
 800cdec:	880d883a 	mov	r6,r17
 800cdf0:	e17ff617 	ldw	r5,-40(fp)
 800cdf4:	b809883a 	mov	r4,r23
 800cdf8:	800cb840 	call	800cb84 <helper_plot_pixel>
			error = error + deltay;
 800cdfc:	e0bff717 	ldw	r2,-36(fp)
 800ce00:	80a1883a 	add	r16,r16,r2
			if (error > 0) {
 800ce04:	0400020e 	bge	zero,r16,800ce10 <alt_up_pixel_buffer_dma_draw_line+0x208>
				y = y + ystep;
 800ce08:	b4ed883a 	add	r22,r22,r19
				error = error - deltax;
 800ce0c:	8561c83a 	sub	r16,r16,r21
			}
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
 800ce10:	8c400044 	addi	r17,r17,1
 800ce14:	947ff00e 	bge	r18,r17,800cdd8 <alt_up_pixel_buffer_dma_draw_line+0x1d0>
				y = y + ystep;
				error = error - deltax;
			}
		}
	}
}
 800ce18:	0001883a 	nop
 800ce1c:	e6fff804 	addi	sp,fp,-32
 800ce20:	dfc00917 	ldw	ra,36(sp)
 800ce24:	df000817 	ldw	fp,32(sp)
 800ce28:	ddc00717 	ldw	r23,28(sp)
 800ce2c:	dd800617 	ldw	r22,24(sp)
 800ce30:	dd400517 	ldw	r21,20(sp)
 800ce34:	dd000417 	ldw	r20,16(sp)
 800ce38:	dcc00317 	ldw	r19,12(sp)
 800ce3c:	dc800217 	ldw	r18,8(sp)
 800ce40:	dc400117 	ldw	r17,4(sp)
 800ce44:	dc000017 	ldw	r16,0(sp)
 800ce48:	dec00a04 	addi	sp,sp,40
 800ce4c:	f800283a 	ret

0800ce50 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 800ce50:	defff504 	addi	sp,sp,-44
 800ce54:	df000a15 	stw	fp,40(sp)
 800ce58:	df000a04 	addi	fp,sp,40
 800ce5c:	e13ffc15 	stw	r4,-16(fp)
 800ce60:	e17ffd15 	stw	r5,-12(fp)
 800ce64:	e1bffe15 	stw	r6,-8(fp)
 800ce68:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 800ce6c:	e03ff615 	stw	zero,-40(fp)
 800ce70:	d0a76f17 	ldw	r2,-25156(gp)
  
  if (alt_ticks_per_second ())
 800ce74:	10003c26 	beq	r2,zero,800cf68 <alt_alarm_start+0x118>
  {
    if (alarm)
 800ce78:	e0bffc17 	ldw	r2,-16(fp)
 800ce7c:	10003826 	beq	r2,zero,800cf60 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 800ce80:	e0bffc17 	ldw	r2,-16(fp)
 800ce84:	e0fffe17 	ldw	r3,-8(fp)
 800ce88:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 800ce8c:	e0bffc17 	ldw	r2,-16(fp)
 800ce90:	e0ffff17 	ldw	r3,-4(fp)
 800ce94:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800ce98:	0005303a 	rdctl	r2,status
 800ce9c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800cea0:	e0fff917 	ldw	r3,-28(fp)
 800cea4:	00bfff84 	movi	r2,-2
 800cea8:	1884703a 	and	r2,r3,r2
 800ceac:	1001703a 	wrctl	status,r2
  
  return context;
 800ceb0:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 800ceb4:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 800ceb8:	d0a77017 	ldw	r2,-25152(gp)
      
      current_nticks = alt_nticks();
 800cebc:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 800cec0:	e0fffd17 	ldw	r3,-12(fp)
 800cec4:	e0bff617 	ldw	r2,-40(fp)
 800cec8:	1885883a 	add	r2,r3,r2
 800cecc:	10c00044 	addi	r3,r2,1
 800ced0:	e0bffc17 	ldw	r2,-16(fp)
 800ced4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 800ced8:	e0bffc17 	ldw	r2,-16(fp)
 800cedc:	10c00217 	ldw	r3,8(r2)
 800cee0:	e0bff617 	ldw	r2,-40(fp)
 800cee4:	1880042e 	bgeu	r3,r2,800cef8 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 800cee8:	e0bffc17 	ldw	r2,-16(fp)
 800ceec:	00c00044 	movi	r3,1
 800cef0:	10c00405 	stb	r3,16(r2)
 800cef4:	00000206 	br	800cf00 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 800cef8:	e0bffc17 	ldw	r2,-16(fp)
 800cefc:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 800cf00:	e0bffc17 	ldw	r2,-16(fp)
 800cf04:	d0e04e04 	addi	r3,gp,-32456
 800cf08:	e0fffa15 	stw	r3,-24(fp)
 800cf0c:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 800cf10:	e0bffb17 	ldw	r2,-20(fp)
 800cf14:	e0fffa17 	ldw	r3,-24(fp)
 800cf18:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 800cf1c:	e0bffa17 	ldw	r2,-24(fp)
 800cf20:	10c00017 	ldw	r3,0(r2)
 800cf24:	e0bffb17 	ldw	r2,-20(fp)
 800cf28:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 800cf2c:	e0bffa17 	ldw	r2,-24(fp)
 800cf30:	10800017 	ldw	r2,0(r2)
 800cf34:	e0fffb17 	ldw	r3,-20(fp)
 800cf38:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 800cf3c:	e0bffa17 	ldw	r2,-24(fp)
 800cf40:	e0fffb17 	ldw	r3,-20(fp)
 800cf44:	10c00015 	stw	r3,0(r2)
 800cf48:	e0bff817 	ldw	r2,-32(fp)
 800cf4c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800cf50:	e0bff717 	ldw	r2,-36(fp)
 800cf54:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 800cf58:	0005883a 	mov	r2,zero
 800cf5c:	00000306 	br	800cf6c <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 800cf60:	00bffa84 	movi	r2,-22
 800cf64:	00000106 	br	800cf6c <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 800cf68:	00bfde84 	movi	r2,-134
  }
}
 800cf6c:	e037883a 	mov	sp,fp
 800cf70:	df000017 	ldw	fp,0(sp)
 800cf74:	dec00104 	addi	sp,sp,4
 800cf78:	f800283a 	ret

0800cf7c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 800cf7c:	defffe04 	addi	sp,sp,-8
 800cf80:	df000115 	stw	fp,4(sp)
 800cf84:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 800cf88:	e03fff15 	stw	zero,-4(fp)
 800cf8c:	00000506 	br	800cfa4 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 800cf90:	e0bfff17 	ldw	r2,-4(fp)
 800cf94:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 800cf98:	e0bfff17 	ldw	r2,-4(fp)
 800cf9c:	10800804 	addi	r2,r2,32
 800cfa0:	e0bfff15 	stw	r2,-4(fp)
 800cfa4:	e0bfff17 	ldw	r2,-4(fp)
 800cfa8:	10820030 	cmpltui	r2,r2,2048
 800cfac:	103ff81e 	bne	r2,zero,800cf90 <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 800cfb0:	0001883a 	nop
 800cfb4:	e037883a 	mov	sp,fp
 800cfb8:	df000017 	ldw	fp,0(sp)
 800cfbc:	dec00104 	addi	sp,sp,4
 800cfc0:	f800283a 	ret

0800cfc4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800cfc4:	defffe04 	addi	sp,sp,-8
 800cfc8:	dfc00115 	stw	ra,4(sp)
 800cfcc:	df000015 	stw	fp,0(sp)
 800cfd0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800cfd4:	d0a04b17 	ldw	r2,-32468(gp)
 800cfd8:	10000326 	beq	r2,zero,800cfe8 <alt_get_errno+0x24>
 800cfdc:	d0a04b17 	ldw	r2,-32468(gp)
 800cfe0:	103ee83a 	callr	r2
 800cfe4:	00000106 	br	800cfec <alt_get_errno+0x28>
 800cfe8:	d0a76a04 	addi	r2,gp,-25176
}
 800cfec:	e037883a 	mov	sp,fp
 800cff0:	dfc00117 	ldw	ra,4(sp)
 800cff4:	df000017 	ldw	fp,0(sp)
 800cff8:	dec00204 	addi	sp,sp,8
 800cffc:	f800283a 	ret

0800d000 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 800d000:	defffa04 	addi	sp,sp,-24
 800d004:	dfc00515 	stw	ra,20(sp)
 800d008:	df000415 	stw	fp,16(sp)
 800d00c:	df000404 	addi	fp,sp,16
 800d010:	e13ffe15 	stw	r4,-8(fp)
 800d014:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 800d018:	e0bffe17 	ldw	r2,-8(fp)
 800d01c:	10000326 	beq	r2,zero,800d02c <alt_dev_llist_insert+0x2c>
 800d020:	e0bffe17 	ldw	r2,-8(fp)
 800d024:	10800217 	ldw	r2,8(r2)
 800d028:	1000061e 	bne	r2,zero,800d044 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 800d02c:	800cfc40 	call	800cfc4 <alt_get_errno>
 800d030:	1007883a 	mov	r3,r2
 800d034:	00800584 	movi	r2,22
 800d038:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 800d03c:	00bffa84 	movi	r2,-22
 800d040:	00001306 	br	800d090 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 800d044:	e0bffe17 	ldw	r2,-8(fp)
 800d048:	e0ffff17 	ldw	r3,-4(fp)
 800d04c:	e0fffc15 	stw	r3,-16(fp)
 800d050:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 800d054:	e0bffd17 	ldw	r2,-12(fp)
 800d058:	e0fffc17 	ldw	r3,-16(fp)
 800d05c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 800d060:	e0bffc17 	ldw	r2,-16(fp)
 800d064:	10c00017 	ldw	r3,0(r2)
 800d068:	e0bffd17 	ldw	r2,-12(fp)
 800d06c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 800d070:	e0bffc17 	ldw	r2,-16(fp)
 800d074:	10800017 	ldw	r2,0(r2)
 800d078:	e0fffd17 	ldw	r3,-12(fp)
 800d07c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 800d080:	e0bffc17 	ldw	r2,-16(fp)
 800d084:	e0fffd17 	ldw	r3,-12(fp)
 800d088:	10c00015 	stw	r3,0(r2)

  return 0;  
 800d08c:	0005883a 	mov	r2,zero
}
 800d090:	e037883a 	mov	sp,fp
 800d094:	dfc00117 	ldw	ra,4(sp)
 800d098:	df000017 	ldw	fp,0(sp)
 800d09c:	dec00204 	addi	sp,sp,8
 800d0a0:	f800283a 	ret

0800d0a4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 800d0a4:	defffd04 	addi	sp,sp,-12
 800d0a8:	dfc00215 	stw	ra,8(sp)
 800d0ac:	df000115 	stw	fp,4(sp)
 800d0b0:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 800d0b4:	00820074 	movhi	r2,2049
 800d0b8:	10b79004 	addi	r2,r2,-8640
 800d0bc:	e0bfff15 	stw	r2,-4(fp)
 800d0c0:	00000606 	br	800d0dc <_do_ctors+0x38>
        (*ctor) (); 
 800d0c4:	e0bfff17 	ldw	r2,-4(fp)
 800d0c8:	10800017 	ldw	r2,0(r2)
 800d0cc:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 800d0d0:	e0bfff17 	ldw	r2,-4(fp)
 800d0d4:	10bfff04 	addi	r2,r2,-4
 800d0d8:	e0bfff15 	stw	r2,-4(fp)
 800d0dc:	e0ffff17 	ldw	r3,-4(fp)
 800d0e0:	00820074 	movhi	r2,2049
 800d0e4:	10b79104 	addi	r2,r2,-8636
 800d0e8:	18bff62e 	bgeu	r3,r2,800d0c4 <_do_ctors+0x20>
        (*ctor) (); 
}
 800d0ec:	0001883a 	nop
 800d0f0:	e037883a 	mov	sp,fp
 800d0f4:	dfc00117 	ldw	ra,4(sp)
 800d0f8:	df000017 	ldw	fp,0(sp)
 800d0fc:	dec00204 	addi	sp,sp,8
 800d100:	f800283a 	ret

0800d104 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 800d104:	defffd04 	addi	sp,sp,-12
 800d108:	dfc00215 	stw	ra,8(sp)
 800d10c:	df000115 	stw	fp,4(sp)
 800d110:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 800d114:	00820074 	movhi	r2,2049
 800d118:	10b79004 	addi	r2,r2,-8640
 800d11c:	e0bfff15 	stw	r2,-4(fp)
 800d120:	00000606 	br	800d13c <_do_dtors+0x38>
        (*dtor) (); 
 800d124:	e0bfff17 	ldw	r2,-4(fp)
 800d128:	10800017 	ldw	r2,0(r2)
 800d12c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 800d130:	e0bfff17 	ldw	r2,-4(fp)
 800d134:	10bfff04 	addi	r2,r2,-4
 800d138:	e0bfff15 	stw	r2,-4(fp)
 800d13c:	e0ffff17 	ldw	r3,-4(fp)
 800d140:	00820074 	movhi	r2,2049
 800d144:	10b79104 	addi	r2,r2,-8636
 800d148:	18bff62e 	bgeu	r3,r2,800d124 <_do_dtors+0x20>
        (*dtor) (); 
}
 800d14c:	0001883a 	nop
 800d150:	e037883a 	mov	sp,fp
 800d154:	dfc00117 	ldw	ra,4(sp)
 800d158:	df000017 	ldw	fp,0(sp)
 800d15c:	dec00204 	addi	sp,sp,8
 800d160:	f800283a 	ret

0800d164 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 800d164:	defffa04 	addi	sp,sp,-24
 800d168:	dfc00515 	stw	ra,20(sp)
 800d16c:	df000415 	stw	fp,16(sp)
 800d170:	df000404 	addi	fp,sp,16
 800d174:	e13ffe15 	stw	r4,-8(fp)
 800d178:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 800d17c:	e0bfff17 	ldw	r2,-4(fp)
 800d180:	10800017 	ldw	r2,0(r2)
 800d184:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 800d188:	e13ffe17 	ldw	r4,-8(fp)
 800d18c:	8005f040 	call	8005f04 <strlen>
 800d190:	10800044 	addi	r2,r2,1
 800d194:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 800d198:	00000d06 	br	800d1d0 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 800d19c:	e0bffc17 	ldw	r2,-16(fp)
 800d1a0:	10800217 	ldw	r2,8(r2)
 800d1a4:	e0fffd17 	ldw	r3,-12(fp)
 800d1a8:	180d883a 	mov	r6,r3
 800d1ac:	e17ffe17 	ldw	r5,-8(fp)
 800d1b0:	1009883a 	mov	r4,r2
 800d1b4:	800d8400 	call	800d840 <memcmp>
 800d1b8:	1000021e 	bne	r2,zero,800d1c4 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 800d1bc:	e0bffc17 	ldw	r2,-16(fp)
 800d1c0:	00000706 	br	800d1e0 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 800d1c4:	e0bffc17 	ldw	r2,-16(fp)
 800d1c8:	10800017 	ldw	r2,0(r2)
 800d1cc:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 800d1d0:	e0fffc17 	ldw	r3,-16(fp)
 800d1d4:	e0bfff17 	ldw	r2,-4(fp)
 800d1d8:	18bff01e 	bne	r3,r2,800d19c <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 800d1dc:	0005883a 	mov	r2,zero
}
 800d1e0:	e037883a 	mov	sp,fp
 800d1e4:	dfc00117 	ldw	ra,4(sp)
 800d1e8:	df000017 	ldw	fp,0(sp)
 800d1ec:	dec00204 	addi	sp,sp,8
 800d1f0:	f800283a 	ret

0800d1f4 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 800d1f4:	defffe04 	addi	sp,sp,-8
 800d1f8:	dfc00115 	stw	ra,4(sp)
 800d1fc:	df000015 	stw	fp,0(sp)
 800d200:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 800d204:	01440004 	movi	r5,4096
 800d208:	0009883a 	mov	r4,zero
 800d20c:	800d6900 	call	800d690 <alt_icache_flush>
#endif
}
 800d210:	0001883a 	nop
 800d214:	e037883a 	mov	sp,fp
 800d218:	dfc00117 	ldw	ra,4(sp)
 800d21c:	df000017 	ldw	fp,0(sp)
 800d220:	dec00204 	addi	sp,sp,8
 800d224:	f800283a 	ret

0800d228 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 800d228:	defff904 	addi	sp,sp,-28
 800d22c:	dfc00615 	stw	ra,24(sp)
 800d230:	df000515 	stw	fp,20(sp)
 800d234:	df000504 	addi	fp,sp,20
 800d238:	e13ffc15 	stw	r4,-16(fp)
 800d23c:	e17ffd15 	stw	r5,-12(fp)
 800d240:	e1bffe15 	stw	r6,-8(fp)
 800d244:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 800d248:	e0800217 	ldw	r2,8(fp)
 800d24c:	d8800015 	stw	r2,0(sp)
 800d250:	e1ffff17 	ldw	r7,-4(fp)
 800d254:	e1bffe17 	ldw	r6,-8(fp)
 800d258:	e17ffd17 	ldw	r5,-12(fp)
 800d25c:	e13ffc17 	ldw	r4,-16(fp)
 800d260:	800d3d80 	call	800d3d8 <alt_iic_isr_register>
}  
 800d264:	e037883a 	mov	sp,fp
 800d268:	dfc00117 	ldw	ra,4(sp)
 800d26c:	df000017 	ldw	fp,0(sp)
 800d270:	dec00204 	addi	sp,sp,8
 800d274:	f800283a 	ret

0800d278 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 800d278:	defff904 	addi	sp,sp,-28
 800d27c:	df000615 	stw	fp,24(sp)
 800d280:	df000604 	addi	fp,sp,24
 800d284:	e13ffe15 	stw	r4,-8(fp)
 800d288:	e17fff15 	stw	r5,-4(fp)
 800d28c:	e0bfff17 	ldw	r2,-4(fp)
 800d290:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800d294:	0005303a 	rdctl	r2,status
 800d298:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800d29c:	e0fffb17 	ldw	r3,-20(fp)
 800d2a0:	00bfff84 	movi	r2,-2
 800d2a4:	1884703a 	and	r2,r3,r2
 800d2a8:	1001703a 	wrctl	status,r2
  
  return context;
 800d2ac:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 800d2b0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 800d2b4:	00c00044 	movi	r3,1
 800d2b8:	e0bffa17 	ldw	r2,-24(fp)
 800d2bc:	1884983a 	sll	r2,r3,r2
 800d2c0:	1007883a 	mov	r3,r2
 800d2c4:	d0a76e17 	ldw	r2,-25160(gp)
 800d2c8:	1884b03a 	or	r2,r3,r2
 800d2cc:	d0a76e15 	stw	r2,-25160(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 800d2d0:	d0a76e17 	ldw	r2,-25160(gp)
 800d2d4:	100170fa 	wrctl	ienable,r2
 800d2d8:	e0bffc17 	ldw	r2,-16(fp)
 800d2dc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800d2e0:	e0bffd17 	ldw	r2,-12(fp)
 800d2e4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 800d2e8:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 800d2ec:	0001883a 	nop
}
 800d2f0:	e037883a 	mov	sp,fp
 800d2f4:	df000017 	ldw	fp,0(sp)
 800d2f8:	dec00104 	addi	sp,sp,4
 800d2fc:	f800283a 	ret

0800d300 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 800d300:	defff904 	addi	sp,sp,-28
 800d304:	df000615 	stw	fp,24(sp)
 800d308:	df000604 	addi	fp,sp,24
 800d30c:	e13ffe15 	stw	r4,-8(fp)
 800d310:	e17fff15 	stw	r5,-4(fp)
 800d314:	e0bfff17 	ldw	r2,-4(fp)
 800d318:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800d31c:	0005303a 	rdctl	r2,status
 800d320:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800d324:	e0fffb17 	ldw	r3,-20(fp)
 800d328:	00bfff84 	movi	r2,-2
 800d32c:	1884703a 	and	r2,r3,r2
 800d330:	1001703a 	wrctl	status,r2
  
  return context;
 800d334:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 800d338:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 800d33c:	00c00044 	movi	r3,1
 800d340:	e0bffa17 	ldw	r2,-24(fp)
 800d344:	1884983a 	sll	r2,r3,r2
 800d348:	0084303a 	nor	r2,zero,r2
 800d34c:	1007883a 	mov	r3,r2
 800d350:	d0a76e17 	ldw	r2,-25160(gp)
 800d354:	1884703a 	and	r2,r3,r2
 800d358:	d0a76e15 	stw	r2,-25160(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 800d35c:	d0a76e17 	ldw	r2,-25160(gp)
 800d360:	100170fa 	wrctl	ienable,r2
 800d364:	e0bffc17 	ldw	r2,-16(fp)
 800d368:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800d36c:	e0bffd17 	ldw	r2,-12(fp)
 800d370:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 800d374:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 800d378:	0001883a 	nop
}
 800d37c:	e037883a 	mov	sp,fp
 800d380:	df000017 	ldw	fp,0(sp)
 800d384:	dec00104 	addi	sp,sp,4
 800d388:	f800283a 	ret

0800d38c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 800d38c:	defffc04 	addi	sp,sp,-16
 800d390:	df000315 	stw	fp,12(sp)
 800d394:	df000304 	addi	fp,sp,12
 800d398:	e13ffe15 	stw	r4,-8(fp)
 800d39c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 800d3a0:	000530fa 	rdctl	r2,ienable
 800d3a4:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 800d3a8:	00c00044 	movi	r3,1
 800d3ac:	e0bfff17 	ldw	r2,-4(fp)
 800d3b0:	1884983a 	sll	r2,r3,r2
 800d3b4:	1007883a 	mov	r3,r2
 800d3b8:	e0bffd17 	ldw	r2,-12(fp)
 800d3bc:	1884703a 	and	r2,r3,r2
 800d3c0:	1004c03a 	cmpne	r2,r2,zero
 800d3c4:	10803fcc 	andi	r2,r2,255
}
 800d3c8:	e037883a 	mov	sp,fp
 800d3cc:	df000017 	ldw	fp,0(sp)
 800d3d0:	dec00104 	addi	sp,sp,4
 800d3d4:	f800283a 	ret

0800d3d8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 800d3d8:	defff504 	addi	sp,sp,-44
 800d3dc:	dfc00a15 	stw	ra,40(sp)
 800d3e0:	df000915 	stw	fp,36(sp)
 800d3e4:	df000904 	addi	fp,sp,36
 800d3e8:	e13ffc15 	stw	r4,-16(fp)
 800d3ec:	e17ffd15 	stw	r5,-12(fp)
 800d3f0:	e1bffe15 	stw	r6,-8(fp)
 800d3f4:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 800d3f8:	00bffa84 	movi	r2,-22
 800d3fc:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 800d400:	e0bffd17 	ldw	r2,-12(fp)
 800d404:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 800d408:	e0bff817 	ldw	r2,-32(fp)
 800d40c:	10800808 	cmpgei	r2,r2,32
 800d410:	1000271e 	bne	r2,zero,800d4b0 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800d414:	0005303a 	rdctl	r2,status
 800d418:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800d41c:	e0fffb17 	ldw	r3,-20(fp)
 800d420:	00bfff84 	movi	r2,-2
 800d424:	1884703a 	and	r2,r3,r2
 800d428:	1001703a 	wrctl	status,r2
  
  return context;
 800d42c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 800d430:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 800d434:	00820174 	movhi	r2,2053
 800d438:	10a7db04 	addi	r2,r2,-24724
 800d43c:	e0fff817 	ldw	r3,-32(fp)
 800d440:	180690fa 	slli	r3,r3,3
 800d444:	10c5883a 	add	r2,r2,r3
 800d448:	e0fffe17 	ldw	r3,-8(fp)
 800d44c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 800d450:	00820174 	movhi	r2,2053
 800d454:	10a7db04 	addi	r2,r2,-24724
 800d458:	e0fff817 	ldw	r3,-32(fp)
 800d45c:	180690fa 	slli	r3,r3,3
 800d460:	10c5883a 	add	r2,r2,r3
 800d464:	10800104 	addi	r2,r2,4
 800d468:	e0ffff17 	ldw	r3,-4(fp)
 800d46c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 800d470:	e0bffe17 	ldw	r2,-8(fp)
 800d474:	10000526 	beq	r2,zero,800d48c <alt_iic_isr_register+0xb4>
 800d478:	e0bff817 	ldw	r2,-32(fp)
 800d47c:	100b883a 	mov	r5,r2
 800d480:	e13ffc17 	ldw	r4,-16(fp)
 800d484:	800d2780 	call	800d278 <alt_ic_irq_enable>
 800d488:	00000406 	br	800d49c <alt_iic_isr_register+0xc4>
 800d48c:	e0bff817 	ldw	r2,-32(fp)
 800d490:	100b883a 	mov	r5,r2
 800d494:	e13ffc17 	ldw	r4,-16(fp)
 800d498:	800d3000 	call	800d300 <alt_ic_irq_disable>
 800d49c:	e0bff715 	stw	r2,-36(fp)
 800d4a0:	e0bffa17 	ldw	r2,-24(fp)
 800d4a4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800d4a8:	e0bff917 	ldw	r2,-28(fp)
 800d4ac:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 800d4b0:	e0bff717 	ldw	r2,-36(fp)
}
 800d4b4:	e037883a 	mov	sp,fp
 800d4b8:	dfc00117 	ldw	ra,4(sp)
 800d4bc:	df000017 	ldw	fp,0(sp)
 800d4c0:	dec00204 	addi	sp,sp,8
 800d4c4:	f800283a 	ret

0800d4c8 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 800d4c8:	defffa04 	addi	sp,sp,-24
 800d4cc:	df000515 	stw	fp,20(sp)
 800d4d0:	df000504 	addi	fp,sp,20
 800d4d4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800d4d8:	0005303a 	rdctl	r2,status
 800d4dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800d4e0:	e0fffc17 	ldw	r3,-16(fp)
 800d4e4:	00bfff84 	movi	r2,-2
 800d4e8:	1884703a 	and	r2,r3,r2
 800d4ec:	1001703a 	wrctl	status,r2
  
  return context;
 800d4f0:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 800d4f4:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 800d4f8:	e0bfff17 	ldw	r2,-4(fp)
 800d4fc:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 800d500:	e0bffd17 	ldw	r2,-12(fp)
 800d504:	10800017 	ldw	r2,0(r2)
 800d508:	e0fffd17 	ldw	r3,-12(fp)
 800d50c:	18c00117 	ldw	r3,4(r3)
 800d510:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 800d514:	e0bffd17 	ldw	r2,-12(fp)
 800d518:	10800117 	ldw	r2,4(r2)
 800d51c:	e0fffd17 	ldw	r3,-12(fp)
 800d520:	18c00017 	ldw	r3,0(r3)
 800d524:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 800d528:	e0bffd17 	ldw	r2,-12(fp)
 800d52c:	e0fffd17 	ldw	r3,-12(fp)
 800d530:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 800d534:	e0bffd17 	ldw	r2,-12(fp)
 800d538:	e0fffd17 	ldw	r3,-12(fp)
 800d53c:	10c00015 	stw	r3,0(r2)
 800d540:	e0bffb17 	ldw	r2,-20(fp)
 800d544:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800d548:	e0bffe17 	ldw	r2,-8(fp)
 800d54c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 800d550:	0001883a 	nop
 800d554:	e037883a 	mov	sp,fp
 800d558:	df000017 	ldw	fp,0(sp)
 800d55c:	dec00104 	addi	sp,sp,4
 800d560:	f800283a 	ret

0800d564 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 800d564:	defffb04 	addi	sp,sp,-20
 800d568:	dfc00415 	stw	ra,16(sp)
 800d56c:	df000315 	stw	fp,12(sp)
 800d570:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 800d574:	d0a04e17 	ldw	r2,-32456(gp)
 800d578:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 800d57c:	d0a77017 	ldw	r2,-25152(gp)
 800d580:	10800044 	addi	r2,r2,1
 800d584:	d0a77015 	stw	r2,-25152(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 800d588:	00002e06 	br	800d644 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 800d58c:	e0bffd17 	ldw	r2,-12(fp)
 800d590:	10800017 	ldw	r2,0(r2)
 800d594:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 800d598:	e0bffd17 	ldw	r2,-12(fp)
 800d59c:	10800403 	ldbu	r2,16(r2)
 800d5a0:	10803fcc 	andi	r2,r2,255
 800d5a4:	10000426 	beq	r2,zero,800d5b8 <alt_tick+0x54>
 800d5a8:	d0a77017 	ldw	r2,-25152(gp)
 800d5ac:	1000021e 	bne	r2,zero,800d5b8 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 800d5b0:	e0bffd17 	ldw	r2,-12(fp)
 800d5b4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 800d5b8:	e0bffd17 	ldw	r2,-12(fp)
 800d5bc:	10800217 	ldw	r2,8(r2)
 800d5c0:	d0e77017 	ldw	r3,-25152(gp)
 800d5c4:	18801d36 	bltu	r3,r2,800d63c <alt_tick+0xd8>
 800d5c8:	e0bffd17 	ldw	r2,-12(fp)
 800d5cc:	10800403 	ldbu	r2,16(r2)
 800d5d0:	10803fcc 	andi	r2,r2,255
 800d5d4:	1000191e 	bne	r2,zero,800d63c <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 800d5d8:	e0bffd17 	ldw	r2,-12(fp)
 800d5dc:	10800317 	ldw	r2,12(r2)
 800d5e0:	e0fffd17 	ldw	r3,-12(fp)
 800d5e4:	18c00517 	ldw	r3,20(r3)
 800d5e8:	1809883a 	mov	r4,r3
 800d5ec:	103ee83a 	callr	r2
 800d5f0:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 800d5f4:	e0bfff17 	ldw	r2,-4(fp)
 800d5f8:	1000031e 	bne	r2,zero,800d608 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 800d5fc:	e13ffd17 	ldw	r4,-12(fp)
 800d600:	800d4c80 	call	800d4c8 <alt_alarm_stop>
 800d604:	00000d06 	br	800d63c <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 800d608:	e0bffd17 	ldw	r2,-12(fp)
 800d60c:	10c00217 	ldw	r3,8(r2)
 800d610:	e0bfff17 	ldw	r2,-4(fp)
 800d614:	1887883a 	add	r3,r3,r2
 800d618:	e0bffd17 	ldw	r2,-12(fp)
 800d61c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 800d620:	e0bffd17 	ldw	r2,-12(fp)
 800d624:	10c00217 	ldw	r3,8(r2)
 800d628:	d0a77017 	ldw	r2,-25152(gp)
 800d62c:	1880032e 	bgeu	r3,r2,800d63c <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 800d630:	e0bffd17 	ldw	r2,-12(fp)
 800d634:	00c00044 	movi	r3,1
 800d638:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 800d63c:	e0bffe17 	ldw	r2,-8(fp)
 800d640:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 800d644:	e0fffd17 	ldw	r3,-12(fp)
 800d648:	d0a04e04 	addi	r2,gp,-32456
 800d64c:	18bfcf1e 	bne	r3,r2,800d58c <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 800d650:	0001883a 	nop
}
 800d654:	0001883a 	nop
 800d658:	e037883a 	mov	sp,fp
 800d65c:	dfc00117 	ldw	ra,4(sp)
 800d660:	df000017 	ldw	fp,0(sp)
 800d664:	dec00204 	addi	sp,sp,8
 800d668:	f800283a 	ret

0800d66c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 800d66c:	deffff04 	addi	sp,sp,-4
 800d670:	df000015 	stw	fp,0(sp)
 800d674:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 800d678:	000170fa 	wrctl	ienable,zero
}
 800d67c:	0001883a 	nop
 800d680:	e037883a 	mov	sp,fp
 800d684:	df000017 	ldw	fp,0(sp)
 800d688:	dec00104 	addi	sp,sp,4
 800d68c:	f800283a 	ret

0800d690 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 800d690:	defffb04 	addi	sp,sp,-20
 800d694:	df000415 	stw	fp,16(sp)
 800d698:	df000404 	addi	fp,sp,16
 800d69c:	e13ffe15 	stw	r4,-8(fp)
 800d6a0:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 800d6a4:	e0bfff17 	ldw	r2,-4(fp)
 800d6a8:	10840070 	cmpltui	r2,r2,4097
 800d6ac:	1000021e 	bne	r2,zero,800d6b8 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 800d6b0:	00840004 	movi	r2,4096
 800d6b4:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 800d6b8:	e0fffe17 	ldw	r3,-8(fp)
 800d6bc:	e0bfff17 	ldw	r2,-4(fp)
 800d6c0:	1885883a 	add	r2,r3,r2
 800d6c4:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 800d6c8:	e0bffe17 	ldw	r2,-8(fp)
 800d6cc:	e0bffc15 	stw	r2,-16(fp)
 800d6d0:	00000506 	br	800d6e8 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 800d6d4:	e0bffc17 	ldw	r2,-16(fp)
 800d6d8:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 800d6dc:	e0bffc17 	ldw	r2,-16(fp)
 800d6e0:	10800804 	addi	r2,r2,32
 800d6e4:	e0bffc15 	stw	r2,-16(fp)
 800d6e8:	e0fffc17 	ldw	r3,-16(fp)
 800d6ec:	e0bffd17 	ldw	r2,-12(fp)
 800d6f0:	18bff836 	bltu	r3,r2,800d6d4 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 800d6f4:	e0bffe17 	ldw	r2,-8(fp)
 800d6f8:	108007cc 	andi	r2,r2,31
 800d6fc:	10000226 	beq	r2,zero,800d708 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 800d700:	e0bffc17 	ldw	r2,-16(fp)
 800d704:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 800d708:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 800d70c:	0001883a 	nop
 800d710:	e037883a 	mov	sp,fp
 800d714:	df000017 	ldw	fp,0(sp)
 800d718:	dec00104 	addi	sp,sp,4
 800d71c:	f800283a 	ret

0800d720 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 800d720:	defffe04 	addi	sp,sp,-8
 800d724:	df000115 	stw	fp,4(sp)
 800d728:	df000104 	addi	fp,sp,4
 800d72c:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 800d730:	e0bfff17 	ldw	r2,-4(fp)
 800d734:	10bffe84 	addi	r2,r2,-6
 800d738:	10c00428 	cmpgeui	r3,r2,16
 800d73c:	18001a1e 	bne	r3,zero,800d7a8 <alt_exception_cause_generated_bad_addr+0x88>
 800d740:	100690ba 	slli	r3,r2,2
 800d744:	00820074 	movhi	r2,2049
 800d748:	10b5d604 	addi	r2,r2,-10408
 800d74c:	1885883a 	add	r2,r3,r2
 800d750:	10800017 	ldw	r2,0(r2)
 800d754:	1000683a 	jmp	r2
 800d758:	0800d798 	cmpnei	zero,at,862
 800d75c:	0800d798 	cmpnei	zero,at,862
 800d760:	0800d7a8 	cmpgeui	zero,at,862
 800d764:	0800d7a8 	cmpgeui	zero,at,862
 800d768:	0800d7a8 	cmpgeui	zero,at,862
 800d76c:	0800d798 	cmpnei	zero,at,862
 800d770:	0800d7a0 	cmpeqi	zero,at,862
 800d774:	0800d7a8 	cmpgeui	zero,at,862
 800d778:	0800d798 	cmpnei	zero,at,862
 800d77c:	0800d798 	cmpnei	zero,at,862
 800d780:	0800d7a8 	cmpgeui	zero,at,862
 800d784:	0800d798 	cmpnei	zero,at,862
 800d788:	0800d7a0 	cmpeqi	zero,at,862
 800d78c:	0800d7a8 	cmpgeui	zero,at,862
 800d790:	0800d7a8 	cmpgeui	zero,at,862
 800d794:	0800d798 	cmpnei	zero,at,862
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 800d798:	00800044 	movi	r2,1
 800d79c:	00000306 	br	800d7ac <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 800d7a0:	0005883a 	mov	r2,zero
 800d7a4:	00000106 	br	800d7ac <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
 800d7a8:	0005883a 	mov	r2,zero
  }
}
 800d7ac:	e037883a 	mov	sp,fp
 800d7b0:	df000017 	ldw	fp,0(sp)
 800d7b4:	dec00104 	addi	sp,sp,4
 800d7b8:	f800283a 	ret

0800d7bc <atexit>:

int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
 800d7bc:	defffd04 	addi	sp,sp,-12
 800d7c0:	dfc00215 	stw	ra,8(sp)
 800d7c4:	df000115 	stw	fp,4(sp)
 800d7c8:	df000104 	addi	fp,sp,4
 800d7cc:	e13fff15 	stw	r4,-4(fp)
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
 800d7d0:	000f883a 	mov	r7,zero
 800d7d4:	000d883a 	mov	r6,zero
 800d7d8:	e17fff17 	ldw	r5,-4(fp)
 800d7dc:	0009883a 	mov	r4,zero
 800d7e0:	800dab40 	call	800dab4 <__register_exitproc>
}
 800d7e4:	e037883a 	mov	sp,fp
 800d7e8:	dfc00117 	ldw	ra,4(sp)
 800d7ec:	df000017 	ldw	fp,0(sp)
 800d7f0:	dec00204 	addi	sp,sp,8
 800d7f4:	f800283a 	ret

0800d7f8 <exit>:
 */

void
_DEFUN (exit, (code),
	int code)
{
 800d7f8:	defffd04 	addi	sp,sp,-12
 800d7fc:	dfc00215 	stw	ra,8(sp)
 800d800:	df000115 	stw	fp,4(sp)
 800d804:	df000104 	addi	fp,sp,4
 800d808:	e13fff15 	stw	r4,-4(fp)
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs _PARAMS ((int, _PTR)) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
 800d80c:	000b883a 	mov	r5,zero
 800d810:	e13fff17 	ldw	r4,-4(fp)
 800d814:	800dc240 	call	800dc24 <__call_exitprocs>

#ifndef WANT_SMALL_STDIO				/* AlteraSpecific */
  if (_GLOBAL_REENT->__cleanup)
 800d818:	d0a04317 	ldw	r2,-32500(gp)
 800d81c:	10800f17 	ldw	r2,60(r2)
 800d820:	10000526 	beq	r2,zero,800d838 <exit+0x40>
    (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
 800d824:	d0a04317 	ldw	r2,-32500(gp)
 800d828:	10800f17 	ldw	r2,60(r2)
 800d82c:	d0e04317 	ldw	r3,-32500(gp)
 800d830:	1809883a 	mov	r4,r3
 800d834:	103ee83a 	callr	r2
#endif							/* AlteraSpecific */
  _exit (code);
 800d838:	e13fff17 	ldw	r4,-4(fp)
 800d83c:	800de100 	call	800de10 <_exit>

0800d840 <memcmp>:
int
_DEFUN (memcmp, (m1, m2, n),
	_CONST _PTR m1 _AND
	_CONST _PTR m2 _AND
	size_t n)
{
 800d840:	defff804 	addi	sp,sp,-32
 800d844:	df000715 	stw	fp,28(sp)
 800d848:	df000704 	addi	fp,sp,28
 800d84c:	e13ffd15 	stw	r4,-12(fp)
 800d850:	e17ffe15 	stw	r5,-8(fp)
 800d854:	e1bfff15 	stw	r6,-4(fp)
      s1++;
      s2++;
    }
  return 0;
#else  
  unsigned char *s1 = (unsigned char *) m1;
 800d858:	e0bffd17 	ldw	r2,-12(fp)
 800d85c:	e0bff915 	stw	r2,-28(fp)
  unsigned char *s2 = (unsigned char *) m2;
 800d860:	e0bffe17 	ldw	r2,-8(fp)
 800d864:	e0bffa15 	stw	r2,-24(fp)
  unsigned long *a2;

  /* If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.  */
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
 800d868:	e0bfff17 	ldw	r2,-4(fp)
 800d86c:	10800130 	cmpltui	r2,r2,4
 800d870:	1000371e 	bne	r2,zero,800d950 <memcmp+0x110>
 800d874:	e0fff917 	ldw	r3,-28(fp)
 800d878:	e0bffa17 	ldw	r2,-24(fp)
 800d87c:	1884b03a 	or	r2,r3,r2
 800d880:	108000cc 	andi	r2,r2,3
 800d884:	1000321e 	bne	r2,zero,800d950 <memcmp+0x110>
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
 800d888:	e0bff917 	ldw	r2,-28(fp)
 800d88c:	e0bffb15 	stw	r2,-20(fp)
      a2 = (unsigned long*) s2;
 800d890:	e0bffa17 	ldw	r2,-24(fp)
 800d894:	e0bffc15 	stw	r2,-16(fp)
      while (n >= LBLOCKSIZE)
 800d898:	00000e06 	br	800d8d4 <memcmp+0x94>
        {
          if (*a1 != *a2) 
 800d89c:	e0bffb17 	ldw	r2,-20(fp)
 800d8a0:	10c00017 	ldw	r3,0(r2)
 800d8a4:	e0bffc17 	ldw	r2,-16(fp)
 800d8a8:	10800017 	ldw	r2,0(r2)
 800d8ac:	18800d1e 	bne	r3,r2,800d8e4 <memcmp+0xa4>
   	    break;
          a1++;
 800d8b0:	e0bffb17 	ldw	r2,-20(fp)
 800d8b4:	10800104 	addi	r2,r2,4
 800d8b8:	e0bffb15 	stw	r2,-20(fp)
          a2++;
 800d8bc:	e0bffc17 	ldw	r2,-16(fp)
 800d8c0:	10800104 	addi	r2,r2,4
 800d8c4:	e0bffc15 	stw	r2,-16(fp)
          n -= LBLOCKSIZE;
 800d8c8:	e0bfff17 	ldw	r2,-4(fp)
 800d8cc:	10bfff04 	addi	r2,r2,-4
 800d8d0:	e0bfff15 	stw	r2,-4(fp)
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
      a2 = (unsigned long*) s2;
      while (n >= LBLOCKSIZE)
 800d8d4:	e0bfff17 	ldw	r2,-4(fp)
 800d8d8:	10800128 	cmpgeui	r2,r2,4
 800d8dc:	103fef1e 	bne	r2,zero,800d89c <memcmp+0x5c>
 800d8e0:	00000106 	br	800d8e8 <memcmp+0xa8>
        {
          if (*a1 != *a2) 
   	    break;
 800d8e4:	0001883a 	nop
          n -= LBLOCKSIZE;
        }

      /* check m mod LBLOCKSIZE remaining characters */

      s1 = (unsigned char*)a1;
 800d8e8:	e0bffb17 	ldw	r2,-20(fp)
 800d8ec:	e0bff915 	stw	r2,-28(fp)
      s2 = (unsigned char*)a2;
 800d8f0:	e0bffc17 	ldw	r2,-16(fp)
 800d8f4:	e0bffa15 	stw	r2,-24(fp)
    }

  while (n--)
 800d8f8:	00001506 	br	800d950 <memcmp+0x110>
    {
      if (*s1 != *s2)
 800d8fc:	e0bff917 	ldw	r2,-28(fp)
 800d900:	10c00003 	ldbu	r3,0(r2)
 800d904:	e0bffa17 	ldw	r2,-24(fp)
 800d908:	10800003 	ldbu	r2,0(r2)
 800d90c:	18c03fcc 	andi	r3,r3,255
 800d910:	10803fcc 	andi	r2,r2,255
 800d914:	18800826 	beq	r3,r2,800d938 <memcmp+0xf8>
	return *s1 - *s2;
 800d918:	e0bff917 	ldw	r2,-28(fp)
 800d91c:	10800003 	ldbu	r2,0(r2)
 800d920:	10c03fcc 	andi	r3,r2,255
 800d924:	e0bffa17 	ldw	r2,-24(fp)
 800d928:	10800003 	ldbu	r2,0(r2)
 800d92c:	10803fcc 	andi	r2,r2,255
 800d930:	1885c83a 	sub	r2,r3,r2
 800d934:	00000b06 	br	800d964 <memcmp+0x124>
      s1++;
 800d938:	e0bff917 	ldw	r2,-28(fp)
 800d93c:	10800044 	addi	r2,r2,1
 800d940:	e0bff915 	stw	r2,-28(fp)
      s2++;
 800d944:	e0bffa17 	ldw	r2,-24(fp)
 800d948:	10800044 	addi	r2,r2,1
 800d94c:	e0bffa15 	stw	r2,-24(fp)

      s1 = (unsigned char*)a1;
      s2 = (unsigned char*)a2;
    }

  while (n--)
 800d950:	e0bfff17 	ldw	r2,-4(fp)
 800d954:	10ffffc4 	addi	r3,r2,-1
 800d958:	e0ffff15 	stw	r3,-4(fp)
 800d95c:	103fe71e 	bne	r2,zero,800d8fc <memcmp+0xbc>
	return *s1 - *s2;
      s1++;
      s2++;
    }

  return 0;
 800d960:	0005883a 	mov	r2,zero
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 800d964:	e037883a 	mov	sp,fp
 800d968:	df000017 	ldw	fp,0(sp)
 800d96c:	dec00104 	addi	sp,sp,4
 800d970:	f800283a 	ret

0800d974 <strcmp>:

int
_DEFUN (strcmp, (s1, s2),
	_CONST char *s1 _AND
	_CONST char *s2)
{ 
 800d974:	defffb04 	addi	sp,sp,-20
 800d978:	df000415 	stw	fp,16(sp)
 800d97c:	df000404 	addi	fp,sp,16
 800d980:	e13ffe15 	stw	r4,-8(fp)
 800d984:	e17fff15 	stw	r5,-4(fp)
#else
  unsigned long *a1;
  unsigned long *a2;

  /* If s1 or s2 are unaligned, then compare bytes. */
  if (!UNALIGNED (s1, s2))
 800d988:	e0fffe17 	ldw	r3,-8(fp)
 800d98c:	e0bfff17 	ldw	r2,-4(fp)
 800d990:	1884b03a 	or	r2,r3,r2
 800d994:	108000cc 	andi	r2,r2,3
 800d998:	10002a1e 	bne	r2,zero,800da44 <strcmp+0xd0>
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
 800d99c:	e0bffe17 	ldw	r2,-8(fp)
 800d9a0:	e0bffc15 	stw	r2,-16(fp)
      a2 = (unsigned long*)s2;
 800d9a4:	e0bfff17 	ldw	r2,-4(fp)
 800d9a8:	e0bffd15 	stw	r2,-12(fp)
      while (*a1 == *a2)
 800d9ac:	00001506 	br	800da04 <strcmp+0x90>
        {
          /* To get here, *a1 == *a2, thus if we find a null in *a1,
	     then the strings must be equal, so return zero.  */
          if (DETECTNULL (*a1))
 800d9b0:	e0bffc17 	ldw	r2,-16(fp)
 800d9b4:	10c00017 	ldw	r3,0(r2)
 800d9b8:	00bfbff4 	movhi	r2,65279
 800d9bc:	10bfbfc4 	addi	r2,r2,-257
 800d9c0:	1887883a 	add	r3,r3,r2
 800d9c4:	e0bffc17 	ldw	r2,-16(fp)
 800d9c8:	10800017 	ldw	r2,0(r2)
 800d9cc:	0084303a 	nor	r2,zero,r2
 800d9d0:	1886703a 	and	r3,r3,r2
 800d9d4:	00a02074 	movhi	r2,32897
 800d9d8:	10a02004 	addi	r2,r2,-32640
 800d9dc:	1884703a 	and	r2,r3,r2
 800d9e0:	10000226 	beq	r2,zero,800d9ec <strcmp+0x78>
	    return 0;
 800d9e4:	0005883a 	mov	r2,zero
 800d9e8:	00002e06 	br	800daa4 <strcmp+0x130>

          a1++;
 800d9ec:	e0bffc17 	ldw	r2,-16(fp)
 800d9f0:	10800104 	addi	r2,r2,4
 800d9f4:	e0bffc15 	stw	r2,-16(fp)
          a2++;
 800d9f8:	e0bffd17 	ldw	r2,-12(fp)
 800d9fc:	10800104 	addi	r2,r2,4
 800da00:	e0bffd15 	stw	r2,-12(fp)
  if (!UNALIGNED (s1, s2))
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
      a2 = (unsigned long*)s2;
      while (*a1 == *a2)
 800da04:	e0bffc17 	ldw	r2,-16(fp)
 800da08:	10c00017 	ldw	r3,0(r2)
 800da0c:	e0bffd17 	ldw	r2,-12(fp)
 800da10:	10800017 	ldw	r2,0(r2)
 800da14:	18bfe626 	beq	r3,r2,800d9b0 <strcmp+0x3c>
          a1++;
          a2++;
        }

      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
 800da18:	e0bffc17 	ldw	r2,-16(fp)
 800da1c:	e0bffe15 	stw	r2,-8(fp)
      s2 = (char*)a2;
 800da20:	e0bffd17 	ldw	r2,-12(fp)
 800da24:	e0bfff15 	stw	r2,-4(fp)
    }

  while (*s1 != '\0' && *s1 == *s2)
 800da28:	00000606 	br	800da44 <strcmp+0xd0>
    {
      s1++;
 800da2c:	e0bffe17 	ldw	r2,-8(fp)
 800da30:	10800044 	addi	r2,r2,1
 800da34:	e0bffe15 	stw	r2,-8(fp)
      s2++;
 800da38:	e0bfff17 	ldw	r2,-4(fp)
 800da3c:	10800044 	addi	r2,r2,1
 800da40:	e0bfff15 	stw	r2,-4(fp)
      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
      s2 = (char*)a2;
    }

  while (*s1 != '\0' && *s1 == *s2)
 800da44:	e0bffe17 	ldw	r2,-8(fp)
 800da48:	10800003 	ldbu	r2,0(r2)
 800da4c:	10803fcc 	andi	r2,r2,255
 800da50:	1080201c 	xori	r2,r2,128
 800da54:	10bfe004 	addi	r2,r2,-128
 800da58:	10000b26 	beq	r2,zero,800da88 <strcmp+0x114>
 800da5c:	e0bffe17 	ldw	r2,-8(fp)
 800da60:	10c00003 	ldbu	r3,0(r2)
 800da64:	e0bfff17 	ldw	r2,-4(fp)
 800da68:	10800003 	ldbu	r2,0(r2)
 800da6c:	18c03fcc 	andi	r3,r3,255
 800da70:	18c0201c 	xori	r3,r3,128
 800da74:	18ffe004 	addi	r3,r3,-128
 800da78:	10803fcc 	andi	r2,r2,255
 800da7c:	1080201c 	xori	r2,r2,128
 800da80:	10bfe004 	addi	r2,r2,-128
 800da84:	18bfe926 	beq	r3,r2,800da2c <strcmp+0xb8>
    {
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 800da88:	e0bffe17 	ldw	r2,-8(fp)
 800da8c:	10800003 	ldbu	r2,0(r2)
 800da90:	10c03fcc 	andi	r3,r2,255
 800da94:	e0bfff17 	ldw	r2,-4(fp)
 800da98:	10800003 	ldbu	r2,0(r2)
 800da9c:	10803fcc 	andi	r2,r2,255
 800daa0:	1885c83a 	sub	r2,r3,r2
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 800daa4:	e037883a 	mov	sp,fp
 800daa8:	df000017 	ldw	fp,0(sp)
 800daac:	dec00104 	addi	sp,sp,4
 800dab0:	f800283a 	ret

0800dab4 <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
 800dab4:	defff804 	addi	sp,sp,-32
 800dab8:	dfc00715 	stw	ra,28(sp)
 800dabc:	df000615 	stw	fp,24(sp)
 800dac0:	dc000515 	stw	r16,20(sp)
 800dac4:	df000604 	addi	fp,sp,24
 800dac8:	e13ffb15 	stw	r4,-20(fp)
 800dacc:	e17ffc15 	stw	r5,-16(fp)
 800dad0:	e1bffd15 	stw	r6,-12(fp)
 800dad4:	e1fffe15 	stw	r7,-8(fp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
 800dad8:	d0a04317 	ldw	r2,-32500(gp)
 800dadc:	14005217 	ldw	r16,328(r2)
  if (p == NULL)
 800dae0:	8000041e 	bne	r16,zero,800daf4 <__register_exitproc+0x40>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
 800dae4:	d0a04317 	ldw	r2,-32500(gp)
 800dae8:	d0e04317 	ldw	r3,-32500(gp)
 800daec:	1c005304 	addi	r16,r3,332
 800daf0:	14005215 	stw	r16,328(r2)
  if (p->_ind >= _ATEXIT_SIZE)
 800daf4:	80800117 	ldw	r2,4(r16)
 800daf8:	10800810 	cmplti	r2,r2,32
 800dafc:	1000131e 	bne	r2,zero,800db4c <__register_exitproc+0x98>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
 800db00:	00800034 	movhi	r2,0
 800db04:	10800004 	addi	r2,r2,0
 800db08:	1000021e 	bne	r2,zero,800db14 <__register_exitproc+0x60>
	return -1;
 800db0c:	00bfffc4 	movi	r2,-1
 800db10:	00003e06 	br	800dc0c <__register_exitproc+0x158>

      p = (struct _atexit *) malloc (sizeof *p);
 800db14:	01006404 	movi	r4,400
 800db18:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>
 800db1c:	1021883a 	mov	r16,r2
      if (p == NULL)
 800db20:	8000021e 	bne	r16,zero,800db2c <__register_exitproc+0x78>
	{
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
 800db24:	00bfffc4 	movi	r2,-1
 800db28:	00003806 	br	800dc0c <__register_exitproc+0x158>
	}
      p->_ind = 0;
 800db2c:	80000115 	stw	zero,4(r16)
      p->_next = _GLOBAL_ATEXIT;
 800db30:	d0a04317 	ldw	r2,-32500(gp)
 800db34:	10805217 	ldw	r2,328(r2)
 800db38:	80800015 	stw	r2,0(r16)
      _GLOBAL_ATEXIT = p;
 800db3c:	d0a04317 	ldw	r2,-32500(gp)
 800db40:	14005215 	stw	r16,328(r2)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
 800db44:	80006215 	stw	zero,392(r16)
      p->_on_exit_args._is_cxa = 0;
 800db48:	80006315 	stw	zero,396(r16)
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
 800db4c:	e0bffb17 	ldw	r2,-20(fp)
 800db50:	10002426 	beq	r2,zero,800dbe4 <__register_exitproc+0x130>
	  args->_fntypes = 0;
	  args->_is_cxa = 0;
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
 800db54:	80802204 	addi	r2,r16,136
 800db58:	e0bffa15 	stw	r2,-24(fp)
#endif
      args->_fnargs[p->_ind] = arg;
 800db5c:	80800117 	ldw	r2,4(r16)
 800db60:	e0fffa17 	ldw	r3,-24(fp)
 800db64:	1085883a 	add	r2,r2,r2
 800db68:	1085883a 	add	r2,r2,r2
 800db6c:	1885883a 	add	r2,r3,r2
 800db70:	e0fffd17 	ldw	r3,-12(fp)
 800db74:	10c00015 	stw	r3,0(r2)
      args->_fntypes |= (1 << p->_ind);
 800db78:	e0bffa17 	ldw	r2,-24(fp)
 800db7c:	10804017 	ldw	r2,256(r2)
 800db80:	80c00117 	ldw	r3,4(r16)
 800db84:	01000044 	movi	r4,1
 800db88:	20c6983a 	sll	r3,r4,r3
 800db8c:	10c6b03a 	or	r3,r2,r3
 800db90:	e0bffa17 	ldw	r2,-24(fp)
 800db94:	10c04015 	stw	r3,256(r2)
      args->_dso_handle[p->_ind] = d;
 800db98:	80800117 	ldw	r2,4(r16)
 800db9c:	e0fffa17 	ldw	r3,-24(fp)
 800dba0:	10800804 	addi	r2,r2,32
 800dba4:	1085883a 	add	r2,r2,r2
 800dba8:	1085883a 	add	r2,r2,r2
 800dbac:	1885883a 	add	r2,r3,r2
 800dbb0:	e0fffe17 	ldw	r3,-8(fp)
 800dbb4:	10c00015 	stw	r3,0(r2)
      if (type == __et_cxa)
 800dbb8:	e0bffb17 	ldw	r2,-20(fp)
 800dbbc:	10800098 	cmpnei	r2,r2,2
 800dbc0:	1000081e 	bne	r2,zero,800dbe4 <__register_exitproc+0x130>
	args->_is_cxa |= (1 << p->_ind);
 800dbc4:	e0bffa17 	ldw	r2,-24(fp)
 800dbc8:	10804117 	ldw	r2,260(r2)
 800dbcc:	80c00117 	ldw	r3,4(r16)
 800dbd0:	01000044 	movi	r4,1
 800dbd4:	20c6983a 	sll	r3,r4,r3
 800dbd8:	10c6b03a 	or	r3,r2,r3
 800dbdc:	e0bffa17 	ldw	r2,-24(fp)
 800dbe0:	10c04115 	stw	r3,260(r2)
    }
  p->_fns[p->_ind++] = fn;
 800dbe4:	80800117 	ldw	r2,4(r16)
 800dbe8:	10c00044 	addi	r3,r2,1
 800dbec:	80c00115 	stw	r3,4(r16)
 800dbf0:	10800084 	addi	r2,r2,2
 800dbf4:	1085883a 	add	r2,r2,r2
 800dbf8:	1085883a 	add	r2,r2,r2
 800dbfc:	8085883a 	add	r2,r16,r2
 800dc00:	e0fffc17 	ldw	r3,-16(fp)
 800dc04:	10c00015 	stw	r3,0(r2)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
 800dc08:	0005883a 	mov	r2,zero
}
 800dc0c:	e6ffff04 	addi	sp,fp,-4
 800dc10:	dfc00217 	ldw	ra,8(sp)
 800dc14:	df000117 	ldw	fp,4(sp)
 800dc18:	dc000017 	ldw	r16,0(sp)
 800dc1c:	dec00304 	addi	sp,sp,12
 800dc20:	f800283a 	ret

0800dc24 <__call_exitprocs>:
 */

void 
_DEFUN (__call_exitprocs, (code, d),
	int code _AND _PTR d)
{
 800dc24:	defff504 	addi	sp,sp,-44
 800dc28:	dfc00a15 	stw	ra,40(sp)
 800dc2c:	df000915 	stw	fp,36(sp)
 800dc30:	dc800815 	stw	r18,32(sp)
 800dc34:	dc400715 	stw	r17,28(sp)
 800dc38:	dc000615 	stw	r16,24(sp)
 800dc3c:	df000904 	addi	fp,sp,36
 800dc40:	e13ffb15 	stw	r4,-20(fp)
 800dc44:	e17ffc15 	stw	r5,-16(fp)
  __lock_acquire_recursive(__atexit_lock);
#endif

 restart:

  p = _GLOBAL_ATEXIT;
 800dc48:	d0a04317 	ldw	r2,-32500(gp)
 800dc4c:	14005217 	ldw	r16,328(r2)
  lastp = &_GLOBAL_ATEXIT;
 800dc50:	d0a04317 	ldw	r2,-32500(gp)
 800dc54:	10805204 	addi	r2,r2,328
 800dc58:	e0bff715 	stw	r2,-36(fp)
  while (p)
 800dc5c:	00006006 	br	800dde0 <__call_exitprocs+0x1bc>
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
 800dc60:	84802204 	addi	r18,r16,136
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 800dc64:	80800117 	ldw	r2,4(r16)
 800dc68:	147fffc4 	addi	r17,r2,-1
 800dc6c:	00004a06 	br	800dd98 <__call_exitprocs+0x174>
	{
	  int ind;

	  i = 1 << n;
 800dc70:	00800044 	movi	r2,1
 800dc74:	1444983a 	sll	r2,r2,r17
 800dc78:	e0bff815 	stw	r2,-32(fp)

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
 800dc7c:	e0bffc17 	ldw	r2,-16(fp)
 800dc80:	10000826 	beq	r2,zero,800dca4 <__call_exitprocs+0x80>
 800dc84:	90004026 	beq	r18,zero,800dd88 <__call_exitprocs+0x164>
 800dc88:	88800804 	addi	r2,r17,32
 800dc8c:	1085883a 	add	r2,r2,r2
 800dc90:	1085883a 	add	r2,r2,r2
 800dc94:	9085883a 	add	r2,r18,r2
 800dc98:	10c00017 	ldw	r3,0(r2)
 800dc9c:	e0bffc17 	ldw	r2,-16(fp)
 800dca0:	1880391e 	bne	r3,r2,800dd88 <__call_exitprocs+0x164>
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
 800dca4:	88800084 	addi	r2,r17,2
 800dca8:	1085883a 	add	r2,r2,r2
 800dcac:	1085883a 	add	r2,r2,r2
 800dcb0:	8085883a 	add	r2,r16,r2
 800dcb4:	10800017 	ldw	r2,0(r2)
 800dcb8:	e0bff915 	stw	r2,-28(fp)
	  if (n == p->_ind - 1)
 800dcbc:	80800117 	ldw	r2,4(r16)
 800dcc0:	10bfffc4 	addi	r2,r2,-1
 800dcc4:	1440041e 	bne	r2,r17,800dcd8 <__call_exitprocs+0xb4>
	    p->_ind--;
 800dcc8:	80800117 	ldw	r2,4(r16)
 800dccc:	10bfffc4 	addi	r2,r2,-1
 800dcd0:	80800115 	stw	r2,4(r16)
 800dcd4:	00000506 	br	800dcec <__call_exitprocs+0xc8>
	  else
	    p->_fns[n] = NULL;
 800dcd8:	88800084 	addi	r2,r17,2
 800dcdc:	1085883a 	add	r2,r2,r2
 800dce0:	1085883a 	add	r2,r2,r2
 800dce4:	8085883a 	add	r2,r16,r2
 800dce8:	10000015 	stw	zero,0(r2)

	  /* Skip functions that have already been called.  */
	  if (!fn)
 800dcec:	e0bff917 	ldw	r2,-28(fp)
 800dcf0:	10002726 	beq	r2,zero,800dd90 <__call_exitprocs+0x16c>
	    continue;

	  ind = p->_ind;
 800dcf4:	80800117 	ldw	r2,4(r16)
 800dcf8:	e0bffa15 	stw	r2,-24(fp)

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
 800dcfc:	90000426 	beq	r18,zero,800dd10 <__call_exitprocs+0xec>
 800dd00:	90c04017 	ldw	r3,256(r18)
 800dd04:	e0bff817 	ldw	r2,-32(fp)
 800dd08:	1884703a 	and	r2,r3,r2
 800dd0c:	1000031e 	bne	r2,zero,800dd1c <__call_exitprocs+0xf8>
	    fn ();
 800dd10:	e0bff917 	ldw	r2,-28(fp)
 800dd14:	103ee83a 	callr	r2
 800dd18:	00001406 	br	800dd6c <__call_exitprocs+0x148>
	  else if ((args->_is_cxa & i) == 0)
 800dd1c:	90c04117 	ldw	r3,260(r18)
 800dd20:	e0bff817 	ldw	r2,-32(fp)
 800dd24:	1884703a 	and	r2,r3,r2
 800dd28:	1000091e 	bne	r2,zero,800dd50 <__call_exitprocs+0x12c>
	    (*((void (*)(int, _PTR)) fn))(code, args->_fnargs[n]);
 800dd2c:	8c45883a 	add	r2,r17,r17
 800dd30:	1085883a 	add	r2,r2,r2
 800dd34:	9085883a 	add	r2,r18,r2
 800dd38:	10c00017 	ldw	r3,0(r2)
 800dd3c:	e0bff917 	ldw	r2,-28(fp)
 800dd40:	180b883a 	mov	r5,r3
 800dd44:	e13ffb17 	ldw	r4,-20(fp)
 800dd48:	103ee83a 	callr	r2
 800dd4c:	00000706 	br	800dd6c <__call_exitprocs+0x148>
	  else
	    (*((void (*)(_PTR)) fn))(args->_fnargs[n]);
 800dd50:	8c45883a 	add	r2,r17,r17
 800dd54:	1085883a 	add	r2,r2,r2
 800dd58:	9085883a 	add	r2,r18,r2
 800dd5c:	10c00017 	ldw	r3,0(r2)
 800dd60:	e0bff917 	ldw	r2,-28(fp)
 800dd64:	1809883a 	mov	r4,r3
 800dd68:	103ee83a 	callr	r2

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
 800dd6c:	80c00117 	ldw	r3,4(r16)
 800dd70:	e0bffa17 	ldw	r2,-24(fp)
 800dd74:	18bfb41e 	bne	r3,r2,800dc48 <__call_exitprocs+0x24>
 800dd78:	e0bff717 	ldw	r2,-36(fp)
 800dd7c:	10800017 	ldw	r2,0(r2)
 800dd80:	143fb11e 	bne	r2,r16,800dc48 <__call_exitprocs+0x24>
 800dd84:	00000306 	br	800dd94 <__call_exitprocs+0x170>

	  i = 1 << n;

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
	    continue;
 800dd88:	0001883a 	nop
 800dd8c:	00000106 	br	800dd94 <__call_exitprocs+0x170>
	  else
	    p->_fns[n] = NULL;

	  /* Skip functions that have already been called.  */
	  if (!fn)
	    continue;
 800dd90:	0001883a 	nop
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 800dd94:	8c7fffc4 	addi	r17,r17,-1
 800dd98:	883fb50e 	bge	r17,zero,800dc70 <__call_exitprocs+0x4c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
 800dd9c:	00800034 	movhi	r2,0
 800dda0:	10800004 	addi	r2,r2,0
 800dda4:	10001026 	beq	r2,zero,800dde8 <__call_exitprocs+0x1c4>
	break;

      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
 800dda8:	80800117 	ldw	r2,4(r16)
 800ddac:	10000a1e 	bne	r2,zero,800ddd8 <__call_exitprocs+0x1b4>
 800ddb0:	80800017 	ldw	r2,0(r16)
 800ddb4:	10000826 	beq	r2,zero,800ddd8 <__call_exitprocs+0x1b4>
	{
	  /* Remove empty block from the list.  */
	  *lastp = p->_next;
 800ddb8:	80c00017 	ldw	r3,0(r16)
 800ddbc:	e0bff717 	ldw	r2,-36(fp)
 800ddc0:	10c00015 	stw	r3,0(r2)
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
 800ddc4:	8009883a 	mov	r4,r16
 800ddc8:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>
	  p = *lastp;
 800ddcc:	e0bff717 	ldw	r2,-36(fp)
 800ddd0:	14000017 	ldw	r16,0(r2)
 800ddd4:	00000206 	br	800dde0 <__call_exitprocs+0x1bc>
	}
      else
	{
	  lastp = &p->_next;
 800ddd8:	e43ff715 	stw	r16,-36(fp)
	  p = p->_next;
 800dddc:	84000017 	ldw	r16,0(r16)

 restart:

  p = _GLOBAL_ATEXIT;
  lastp = &_GLOBAL_ATEXIT;
  while (p)
 800dde0:	803f9f1e 	bne	r16,zero,800dc60 <__call_exitprocs+0x3c>
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
 800dde4:	00000106 	br	800ddec <__call_exitprocs+0x1c8>
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
	break;
 800dde8:	0001883a 	nop
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
 800ddec:	0001883a 	nop
 800ddf0:	e6fffd04 	addi	sp,fp,-12
 800ddf4:	dfc00417 	ldw	ra,16(sp)
 800ddf8:	df000317 	ldw	fp,12(sp)
 800ddfc:	dc800217 	ldw	r18,8(sp)
 800de00:	dc400117 	ldw	r17,4(sp)
 800de04:	dc000017 	ldw	r16,0(sp)
 800de08:	dec00504 	addi	sp,sp,20
 800de0c:	f800283a 	ret

0800de10 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 800de10:	defffd04 	addi	sp,sp,-12
 800de14:	df000215 	stw	fp,8(sp)
 800de18:	df000204 	addi	fp,sp,8
 800de1c:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 800de20:	0001883a 	nop
 800de24:	e0bfff17 	ldw	r2,-4(fp)
 800de28:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 800de2c:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 800de30:	10000226 	beq	r2,zero,800de3c <_exit+0x2c>
    ALT_SIM_FAIL();
 800de34:	002af070 	cmpltui	zero,zero,43969
 800de38:	00000106 	br	800de40 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 800de3c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 800de40:	003fff06 	br	800de40 <_exit+0x30>
