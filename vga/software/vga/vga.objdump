
vga.elf:     file format elf32-littlenios2
vga.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000244

Program Header:
    LOAD off    0x00001000 vaddr 0x08000000 paddr 0x08000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x08000020 paddr 0x08000020 align 2**12
         filesz 0x00046638 memsz 0x00046638 flags r-x
    LOAD off    0x00047658 vaddr 0x08046658 paddr 0x080482ac align 2**12
         filesz 0x00001c54 memsz 0x00001c54 flags rw-
    LOAD off    0x00049f00 vaddr 0x08049f00 paddr 0x08049f00 align 2**12
         filesz 0x00000000 memsz 0x00000160 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  08000000  08000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000224  08000020  08000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000dc08  08000244  08000244  00001244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0003880c  0800de4c  0800de4c  0000ee4c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001c54  08046658  080482ac  00047658  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000160  08049f00  08049f00  00049f00  2**2
                  ALLOC, SMALL_DATA
  6 .sdram_controller_0 00000000  0804a060  0804a060  000492ac  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000492ac  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000cc8  00000000  00000000  000492d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00018d87  00000000  00000000  00049f98  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00006bb8  00000000  00000000  00062d1f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00008d49  00000000  00000000  000698d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001e00  00000000  00000000  00072620  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003a88  00000000  00000000  00074420  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000048f2  00000000  00000000  00077ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000030  00000000  00000000  0007c79c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000cd0  00000000  00000000  0007c7d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0008049e  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  000804a1  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000804ad  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000804ae  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   00000004  00000000  00000000  000804af  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    00000004  00000000  00000000  000804b3  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   00000004  00000000  00000000  000804b7  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000b  00000000  00000000  000804bb  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000001a  00000000  00000000  000804c6  2**0
                  CONTENTS, READONLY
 26 .jdi          00005174  00000000  00000000  000804e0  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0006f578  00000000  00000000  00085654  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
08000000 l    d  .entry	00000000 .entry
08000020 l    d  .exceptions	00000000 .exceptions
08000244 l    d  .text	00000000 .text
0800de4c l    d  .rodata	00000000 .rodata
08046658 l    d  .rwdata	00000000 .rwdata
08049f00 l    d  .bss	00000000 .bss
0804a060 l    d  .sdram_controller_0	00000000 .sdram_controller_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../vga_bsp//obj/HAL/src/crt0.o
0800028c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 myfile.c
00000000 l    df *ABS*	00000000 s_cos.c
00000000 l    df *ABS*	00000000 s_sin.c
00000000 l    df *ABS*	00000000 e_rem_pio2.c
080462c0 l     O .rodata	00000108 two_over_pi
080463c8 l     O .rodata	00000080 npio2_hw
0804816c l     O .rwdata	00000008 zero
08048174 l     O .rwdata	00000008 half
0804817c l     O .rwdata	00000008 two24
08048184 l     O .rwdata	00000008 invpio2
0804818c l     O .rwdata	00000008 pio2_1
08048194 l     O .rwdata	00000008 pio2_1t
0804819c l     O .rwdata	00000008 pio2_2
080481a4 l     O .rwdata	00000008 pio2_2t
080481ac l     O .rwdata	00000008 pio2_3
080481b4 l     O .rwdata	00000008 pio2_3t
00000000 l    df *ABS*	00000000 k_cos.c
080481bc l     O .rwdata	00000008 one
080481c4 l     O .rwdata	00000008 C1
080481cc l     O .rwdata	00000008 C2
080481d4 l     O .rwdata	00000008 C3
080481dc l     O .rwdata	00000008 C4
080481e4 l     O .rwdata	00000008 C5
080481ec l     O .rwdata	00000008 C6
00000000 l    df *ABS*	00000000 k_rem_pio2.c
08046448 l     O .rodata	00000010 init_jk
08046458 l     O .rodata	00000040 PIo2
080481f4 l     O .rwdata	00000008 zero
080481fc l     O .rwdata	00000008 one
08048204 l     O .rwdata	00000008 two24
0804820c l     O .rwdata	00000008 twon24
00000000 l    df *ABS*	00000000 k_sin.c
08048214 l     O .rwdata	00000008 half
0804821c l     O .rwdata	00000008 S1
08048224 l     O .rwdata	00000008 S2
0804822c l     O .rwdata	00000008 S3
08048234 l     O .rwdata	00000008 S4
0804823c l     O .rwdata	00000008 S5
08048244 l     O .rwdata	00000008 S6
00000000 l    df *ABS*	00000000 s_fabs.c
00000000 l    df *ABS*	00000000 s_floor.c
0804824c l     O .rwdata	00000008 huge
00000000 l    df *ABS*	00000000 s_scalbn.c
08048254 l     O .rwdata	00000008 two54
0804825c l     O .rwdata	00000008 twom54
08048264 l     O .rwdata	00000008 huge
0804826c l     O .rwdata	00000008 tiny
00000000 l    df *ABS*	00000000 s_copysign.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 findfp.c
08006000 l     F .text	000000f4 std
08049f00 l     O .bss	00000004 __sfp_lock
08049f04 l     O .bss	00000004 __sinit_lock
080064fc l     F .text	00000024 __fp_lock
08006520 l     F .text	00000024 __fp_unlock
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
08046658 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
08006d54 l     F .text	000003b4 malloc_extend_top
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 alt_close.c
0800a50c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
0800a618 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0800a644 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
0800a730 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
0800a810 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0800a8fc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0800aab4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0804829c l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_write.c
0800aea4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0800afd8 l     F .text	00000034 alt_dev_reg
0804702c l     O .rwdata	00001060 jtag_uart_0
0804808c l     O .rwdata	00000048 video_character_buffer_with_dma_0
080480d4 l     O .rwdata	00000054 video_pixel_buffer_dma_0
08048128 l     O .rwdata	00000044 video_rgb_resampler_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0800b624 l     F .text	0000020c altera_avalon_jtag_uart_irq
0800b830 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_character_buffer_with_dma.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_pixel_buffer_dma.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0800d170 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
08049f34 l     O .bss	00000004 __atexit_lock
00000000 l    df *ABS*	00000000 alt_exit.c
08049f30 g     O .bss	00000004 alt_instruction_exception_handler
0800a4ac g     F .text	00000060 _isatty_r
0800aa0c g     F .text	00000060 alt_main
0800ca1c g     F .text	0000024c alt_up_pixel_buffer_dma_draw_vline
08005dbc g     F .text	00000118 _puts_r
08049f60 g     O .bss	00000100 alt_irq
08003678 g     F .text	00000088 fabs
0800a138 g     F .text	00000070 _lseek_r
080482ac g       *ABS*	00000000 __flash_rwdata_start
08004974 g     F .text	00000088 .hidden __eqdf2
08000290 g     F .text	00000034 measuringFrameRate
0804a060 g       *ABS*	00000000 __alt_heap_start
08009164 g     F .text	000000a0 __sseek
080063a4 g     F .text	000000d8 __sinit
0800bff0 g     F .text	000000fc alt_up_char_buffer_string
080060f4 g     F .text	000000a4 __sfmoreglue
0800aa90 g     F .text	00000024 __malloc_unlock
0800bf24 g     F .text	000000cc alt_up_char_buffer_draw
08007fc8 g     F .text	00000208 memmove
08006370 g     F .text	00000034 _cleanup
0800c184 g     F .text	00000194 alt_up_pixel_buffer_dma_draw
080049fc g     F .text	000000dc .hidden __gtdf2
0800d674 g     F .text	00000024 altera_nios2_gen2_irq_init
0800c148 g     F .text	0000003c alt_up_pixel_buffer_dma_open_dev
08000000 g     F .entry	0000001c __reset
08000020 g       *ABS*	00000000 __flash_exceptions_start
0800a444 g     F .text	00000068 _fstat_r
08049f14 g     O .bss	00000004 errno
08003700 g     F .text	00000344 floor
08009080 g     F .text	00000030 __seofread
08049f1c g     O .bss	00000004 alt_argv
0805016c g       *ABS*	00000000 _gp
0800c318 g     F .text	0000005c alt_up_pixel_buffer_dma_change_back_buffer_address
08046eac g     O .rwdata	00000180 alt_fd_list
08000c24 g     F .text	00000ce4 __ieee754_rem_pio2
0800d310 g     F .text	00000090 alt_find_dev
08007e40 g     F .text	00000188 memcpy
0800c0ec g     F .text	0000005c alt_up_char_buffer_clear
0800632c g     F .text	00000044 _cleanup_r
08005b6c g     F .text	000000dc .hidden __floatsidf
0800de4c g       *ABS*	00000000 __DTOR_END__
08005ed4 g     F .text	00000038 puts
0800d728 g     F .text	0000009c alt_exception_cause_generated_bad_addr
0800c3d4 g     F .text	00000034 alt_up_pixel_buffer_dma_check_swap_buffers_status
0800ba28 g     F .text	0000021c altera_avalon_jtag_uart_read
0800400c g     F .text	00000064 .hidden __udivsi3
0800a76c g     F .text	000000a4 isatty
0800c80c g     F .text	00000210 alt_up_pixel_buffer_dma_draw_hline
08001908 g     F .text	00000534 __kernel_cos
08003ea0 g     F .text	00000074 .hidden __fixunsdfsi
0800d698 g     F .text	00000090 alt_icache_flush
08049f08 g     O .bss	00000004 __malloc_top_pad
080065c4 g     F .text	000005dc __sfvwrite_r
08008f84 g     F .text	00000060 _sbrk_r
0800cd30 g     F .text	00000084 helper_plot_pixel
0800a3d4 g     F .text	00000070 _read_r
08048294 g     O .rwdata	00000004 alt_max_fd
080094c8 g     F .text	0000012c _fclose_r
080099b8 g     F .text	00000054 fflush
08049f0c g     O .bss	00000004 __malloc_max_sbrked_mem
08003234 g     F .text	00000444 __kernel_sin
08005c48 g     F .text	00000110 .hidden __extendsfdf2
080040c8 g     F .text	000008ac .hidden __adddf3
0800c408 g     F .text	00000128 alt_up_pixel_buffer_dma_clear_screen
0800a938 g     F .text	000000d4 lseek
08000000 g       *ABS*	00000000 __alt_mem_sdram_controller_0
08048278 g     O .rwdata	00000004 _global_impure_ptr
08008394 g     F .text	00000bf0 _realloc_r
0804a060 g       *ABS*	00000000 __bss_end
0800d584 g     F .text	000000f0 alt_iic_isr_register
0800c530 g     F .text	000002dc alt_up_pixel_buffer_dma_draw_box
0800ad9c g     F .text	00000108 alt_tick
08006544 g     F .text	00000040 __fp_lock_all
0800d538 g     F .text	0000004c alt_ic_irq_enabled
0800ad00 g     F .text	0000009c alt_alarm_stop
0800debe g     O .rodata	00038401 myimage
08049f2c g     O .bss	00000004 alt_irq_active
080000fc g     F .exceptions	000000d4 alt_irq_handler
08046e84 g     O .rwdata	00000028 alt_dev_null
08001e3c g     F .text	000013f8 __kernel_rem_pio2
0800d128 g     F .text	00000048 alt_dcache_flush_all
0800cc68 g     F .text	000000c8 alt_up_pixel_buffer_dma_draw_rectangle
08005aec g     F .text	00000080 .hidden __fixdfsi
080482ac g       *ABS*	00000000 __ram_rwdata_end
0804828c g     O .rwdata	00000008 alt_dev_list
0800aee0 g     F .text	000000f8 write
0800cdb4 g     F .text	00000248 alt_up_pixel_buffer_dma_draw_line
08046658 g       *ABS*	00000000 __ram_rodata_end
0800a680 g     F .text	000000b0 fstat
08004070 g     F .text	00000058 .hidden __umodsi3
0804a060 g       *ABS*	00000000 end
0800be68 g     F .text	00000080 alt_up_char_buffer_init
0800b564 g     F .text	000000c0 altera_avalon_jtag_uart_init
080001d0 g     F .exceptions	00000074 alt_instruction_exception_entry
0800de4c g       *ABS*	00000000 __CTOR_LIST__
10000000 g       *ABS*	00000000 __alt_stack_pointer
08005d58 g     F .text	00000064 .hidden __clzsi2
0800bc44 g     F .text	00000224 altera_avalon_jtag_uart_write
08000838 g     F .text	000001f4 cos
0800647c g     F .text	00000020 __sfp_lock_acquire
08007c84 g     F .text	000001bc memchr
08009a0c g     F .text	00000560 _free_r
0800dc2c g     F .text	000001ec __call_exitprocs
08048280 g     O .rwdata	00000004 __malloc_sbrk_base
08000244 g     F .text	0000004c _start
08049f24 g     O .bss	00000004 _alt_tick_rate
08000a2c g     F .text	000001f8 sin
08049f28 g     O .bss	00000004 _alt_nticks
0800aaf0 g     F .text	000000fc read
08000334 g     F .text	000003c0 displayImage
0800b044 g     F .text	000003bc alt_sys_init
0800dabc g     F .text	00000170 __register_exitproc
0800b8d0 g     F .text	00000068 altera_avalon_jtag_uart_close
08046658 g       *ABS*	00000000 __ram_rwdata_start
0800de4c g       *ABS*	00000000 __ram_rodata_start
08049f38 g     O .bss	00000028 __malloc_current_mallinfo
0800b400 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
080002c4 g     F .text	00000070 displayFrameRate
08009468 g     F .text	00000060 _close_r
0800d848 g     F .text	00000134 memcmp
0800b4c0 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0804a060 g       *ABS*	00000000 __alt_stack_base
0800b510 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
080092c8 g     F .text	000001a0 __swsetup_r
08006198 g     F .text	00000194 __sfp
08046a7c g     O .rwdata	00000408 __malloc_av_
080064dc g     F .text	00000020 __sinit_lock_release
08004ad8 g     F .text	00000718 .hidden __muldf3
08008fe4 g     F .text	0000009c __sread
0800d1ac g     F .text	000000a4 alt_dev_llist_insert
0800aa6c g     F .text	00000024 __malloc_lock
0800ac50 g     F .text	000000b0 sbrk
08009930 g     F .text	00000088 _fflush_r
08049f00 g       *ABS*	00000000 __bss_start
080081d0 g     F .text	000001c4 memset
080006f4 g     F .text	00000144 main
08049f20 g     O .bss	00000004 alt_envp
08049f10 g     O .bss	00000004 __malloc_max_total_mem
0800c374 g     F .text	00000060 alt_up_pixel_buffer_dma_swap_buffers
0800bee8 g     F .text	0000003c alt_up_char_buffer_open_dev
0800b460 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08009204 g     F .text	00000054 __sclose
10000000 g       *ABS*	00000000 __alt_heap_limit
080095f4 g     F .text	00000038 fclose
08007108 g     F .text	00000b7c _malloc_r
08048298 g     O .rwdata	00000004 alt_errno
08006ba0 g     F .text	000000d8 _fwalk
08003f14 g     F .text	00000084 .hidden __divsi3
08009f6c g     F .text	000001cc _malloc_trim_r
0800de4c g       *ABS*	00000000 __CTOR_END__
0800d97c g     F .text	00000140 strcmp
0800de4c g       *ABS*	00000000 __flash_rodata_start
0800de4c g       *ABS*	00000000 __DTOR_LIST__
08003dec g     F .text	000000b4 copysign
08004974 g     F .text	00000088 .hidden __nedf2
0800b00c g     F .text	00000038 alt_irq_init
0800abec g     F .text	00000064 alt_release_fd
08046498 g     O .rodata	00000100 .hidden __clz_tab
0800d7c4 g     F .text	0000003c atexit
08009258 g     F .text	00000070 _write_r
08048274 g     O .rwdata	00000004 _impure_ptr
08049f18 g     O .bss	00000004 alt_argc
0800962c g     F .text	00000304 __sflush_r
08003a44 g     F .text	000003a8 scalbn
0800d2b0 g     F .text	00000060 _do_dtors
08000020 g       .exceptions	00000000 alt_irq_entry
08006584 g     F .text	00000040 __fp_unlock_all
08048284 g     O .rwdata	00000008 alt_fs_list
08000020 g       *ABS*	00000000 __ram_exceptions_start
0800d3d4 g     F .text	00000050 alt_ic_isr_register
080482ac g       *ABS*	00000000 _edata
0804a060 g       *ABS*	00000000 _end
08000244 g       *ABS*	00000000 __ram_exceptions_end
0800b938 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0800d4ac g     F .text	0000008c alt_ic_irq_disable
080090b0 g     F .text	000000b4 __swrite
0804827c g     O .rwdata	00000004 __malloc_trim_threshold
0800d800 g     F .text	00000048 exit
08006c78 g     F .text	000000dc _fwalk_reent
08003f98 g     F .text	00000074 .hidden __modsi3
10000000 g       *ABS*	00000000 __alt_data_end
08000020 g     F .exceptions	00000000 alt_exception
0800649c g     F .text	00000020 __sfp_lock_release
0800de18 g     F .text	00000034 _exit
0800cffc g     F .text	0000012c alt_alarm_start
0800a1a8 g     F .text	0000022c __smakebuf_r
08005f0c g     F .text	000000f4 strlen
080049fc g     F .text	000000dc .hidden __gedf2
0800d3a0 g     F .text	00000034 alt_icache_flush_all
080482a8 g     O .rwdata	00000004 alt_priority_mask
0800d424 g     F .text	00000088 alt_ic_irq_enable
080051f0 g     F .text	000008fc .hidden __subdf3
080482a0 g     O .rwdata	00000008 alt_alarm_list
0800d250 g     F .text	00000060 _do_ctors
0800a548 g     F .text	000000d0 close
0800a878 g     F .text	00000084 alt_load
080064bc g     F .text	00000020 __sinit_lock_acquire



Disassembly of section .entry:

08000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 8000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 8000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 8000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 800000c:	00bffd16 	blt	zero,r2,8000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 8000010:	00420034 	movhi	at,2048
    ori r1, r1, %lo(_start)
 8000014:	08409114 	ori	at,at,580
    jmp r1
 8000018:	0800683a 	jmp	at
 800001c:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>

Disassembly of section .exceptions:

08000020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8000020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8000024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8000028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 800002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8000030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8000034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8000038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 800003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8000040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8000044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8000048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 800004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8000050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8000054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8000058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 800005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 8000060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 8000064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 8000068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 800006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 8000070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 8000074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 8000078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 800007c:	10000326 	beq	r2,zero,800008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 8000080:	20000226 	beq	r4,zero,800008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 8000084:	80000fc0 	call	80000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 8000088:	00000706 	br	80000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 800008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 8000090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 8000094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 8000098:	80001d00 	call	80001d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 800009c:	1000021e 	bne	r2,zero,80000a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 80000a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 80000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 80000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 80000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 80000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 80000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 80000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 80000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 80000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 80000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 80000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 80000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 80000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 80000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 80000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 80000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 80000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 80000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 80000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 80000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 80000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 80000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 80000f8:	ef80083a 	eret

080000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 80000fc:	defff904 	addi	sp,sp,-28
 8000100:	dfc00615 	stw	ra,24(sp)
 8000104:	df000515 	stw	fp,20(sp)
 8000108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 800010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8000110:	0005313a 	rdctl	r2,ipending
 8000114:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8000118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 800011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8000120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8000124:	00800044 	movi	r2,1
 8000128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 800012c:	e0fffb17 	ldw	r3,-20(fp)
 8000130:	e0bffc17 	ldw	r2,-16(fp)
 8000134:	1884703a 	and	r2,r3,r2
 8000138:	10001426 	beq	r2,zero,800018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 800013c:	00820174 	movhi	r2,2053
 8000140:	10a7d804 	addi	r2,r2,-24736
 8000144:	e0fffd17 	ldw	r3,-12(fp)
 8000148:	180690fa 	slli	r3,r3,3
 800014c:	10c5883a 	add	r2,r2,r3
 8000150:	10c00017 	ldw	r3,0(r2)
 8000154:	00820174 	movhi	r2,2053
 8000158:	10a7d804 	addi	r2,r2,-24736
 800015c:	e13ffd17 	ldw	r4,-12(fp)
 8000160:	200890fa 	slli	r4,r4,3
 8000164:	1105883a 	add	r2,r2,r4
 8000168:	10800104 	addi	r2,r2,4
 800016c:	10800017 	ldw	r2,0(r2)
 8000170:	1009883a 	mov	r4,r2
 8000174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 8000178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 800017c:	0005313a 	rdctl	r2,ipending
 8000180:	e0bfff15 	stw	r2,-4(fp)

  return active;
 8000184:	e0bfff17 	ldw	r2,-4(fp)
 8000188:	00000706 	br	80001a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 800018c:	e0bffc17 	ldw	r2,-16(fp)
 8000190:	1085883a 	add	r2,r2,r2
 8000194:	e0bffc15 	stw	r2,-16(fp)
      i++;
 8000198:	e0bffd17 	ldw	r2,-12(fp)
 800019c:	10800044 	addi	r2,r2,1
 80001a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 80001a4:	003fe106 	br	800012c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 80001a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 80001ac:	e0bffb17 	ldw	r2,-20(fp)
 80001b0:	103fdb1e 	bne	r2,zero,8000120 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 80001b4:	0001883a 	nop
}
 80001b8:	0001883a 	nop
 80001bc:	e037883a 	mov	sp,fp
 80001c0:	dfc00117 	ldw	ra,4(sp)
 80001c4:	df000017 	ldw	fp,0(sp)
 80001c8:	dec00204 	addi	sp,sp,8
 80001cc:	f800283a 	ret

080001d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 80001d0:	defffb04 	addi	sp,sp,-20
 80001d4:	dfc00415 	stw	ra,16(sp)
 80001d8:	df000315 	stw	fp,12(sp)
 80001dc:	df000304 	addi	fp,sp,12
 80001e0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
 80001e4:	000531fa 	rdctl	r2,exception
 80001e8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
 80001ec:	e0bffd17 	ldw	r2,-12(fp)
 80001f0:	10801f0c 	andi	r2,r2,124
 80001f4:	1004d0ba 	srli	r2,r2,2
 80001f8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
 80001fc:	0005333a 	rdctl	r2,badaddr
 8000200:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 8000204:	d0a77117 	ldw	r2,-25148(gp)
 8000208:	10000726 	beq	r2,zero,8000228 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 800020c:	d0a77117 	ldw	r2,-25148(gp)
 8000210:	e0fffd17 	ldw	r3,-12(fp)
 8000214:	e1bffe17 	ldw	r6,-8(fp)
 8000218:	e17fff17 	ldw	r5,-4(fp)
 800021c:	1809883a 	mov	r4,r3
 8000220:	103ee83a 	callr	r2
 8000224:	00000206 	br	8000230 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 8000228:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 800022c:	0005883a 	mov	r2,zero
}
 8000230:	e037883a 	mov	sp,fp
 8000234:	dfc00117 	ldw	ra,4(sp)
 8000238:	df000017 	ldw	fp,0(sp)
 800023c:	dec00204 	addi	sp,sp,8
 8000240:	f800283a 	ret

Disassembly of section .text:

08000244 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 8000244:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 8000248:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 800024c:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 8000250:	00bffd16 	blt	zero,r2,8000248 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8000254:	06c40034 	movhi	sp,4096
    ori sp, sp, %lo(__alt_stack_pointer)
 8000258:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 800025c:	06820174 	movhi	gp,2053
    ori gp, gp, %lo(_gp)
 8000260:	d6805b14 	ori	gp,gp,364
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8000264:	00820134 	movhi	r2,2052
    ori r2, r2, %lo(__bss_start)
 8000268:	10a7c014 	ori	r2,r2,40704

    movhi r3, %hi(__bss_end)
 800026c:	00c20134 	movhi	r3,2052
    ori r3, r3, %lo(__bss_end)
 8000270:	18e81814 	ori	r3,r3,41056

    beq r2, r3, 1f
 8000274:	10c00326 	beq	r2,r3,8000284 <_start+0x40>

0:
    stw zero, (r2)
 8000278:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 800027c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 8000280:	10fffd36 	bltu	r2,r3,8000278 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 8000284:	800a8780 	call	800a878 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8000288:	800aa0c0 	call	800aa0c <alt_main>

0800028c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 800028c:	003fff06 	br	800028c <alt_after_alt_main>

08000290 <measuringFrameRate>:
#include <sys/alt_alarm.h>
#include "myfile.h"

#define PI 3.141592

void measuringFrameRate() {
 8000290:	defffc04 	addi	sp,sp,-16
 8000294:	df000315 	stw	fp,12(sp)
 8000298:	df000304 	addi	fp,sp,12
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 800029c:	d0a76e17 	ldw	r2,-25160(gp)
  alt_u32 ticks_per_second = alt_ticks_per_second();
 80002a0:	e0bffd15 	stw	r2,-12(fp)
  alt_u32 current_tick = 0, prev_tick = alt_nticks();
 80002a4:	e03ffe15 	stw	zero,-8(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 80002a8:	d0a76f17 	ldw	r2,-25156(gp)
 80002ac:	e0bfff15 	stw	r2,-4(fp)
}
 80002b0:	0001883a 	nop
 80002b4:	e037883a 	mov	sp,fp
 80002b8:	df000017 	ldw	fp,0(sp)
 80002bc:	dec00104 	addi	sp,sp,4
 80002c0:	f800283a 	ret

080002c4 <displayFrameRate>:
void displayFrameRate(alt_up_char_buffer_dev *char_buf) {
 80002c4:	defffd04 	addi	sp,sp,-12
 80002c8:	dfc00215 	stw	ra,8(sp)
 80002cc:	df000115 	stw	fp,4(sp)
 80002d0:	df000104 	addi	fp,sp,4
 80002d4:	e13fff15 	stw	r4,-4(fp)
  char_buf = alt_up_char_buffer_open_dev("/dev/video_character_buffer_with_dma_0");
 80002d8:	01020074 	movhi	r4,2049
 80002dc:	21379304 	addi	r4,r4,-8628
 80002e0:	800bee80 	call	800bee8 <alt_up_char_buffer_open_dev>
 80002e4:	e0bfff15 	stw	r2,-4(fp)
  if (!char_buf) printf("error opening character buffer\n");
 80002e8:	e0bfff17 	ldw	r2,-4(fp)
 80002ec:	1000031e 	bne	r2,zero,80002fc <displayFrameRate+0x38>
 80002f0:	01020074 	movhi	r4,2049
 80002f4:	21379d04 	addi	r4,r4,-8588
 80002f8:	8005ed40 	call	8005ed4 <puts>
  alt_up_char_buffer_clear(char_buf);
 80002fc:	e13fff17 	ldw	r4,-4(fp)
 8000300:	800c0ec0 	call	800c0ec <alt_up_char_buffer_clear>
  alt_up_char_buffer_string(char_buf, "Video Works", 35, 50);
 8000304:	01c00c84 	movi	r7,50
 8000308:	018008c4 	movi	r6,35
 800030c:	01420074 	movhi	r5,2049
 8000310:	2977a504 	addi	r5,r5,-8556
 8000314:	e13fff17 	ldw	r4,-4(fp)
 8000318:	800bff00 	call	800bff0 <alt_up_char_buffer_string>
}
 800031c:	0001883a 	nop
 8000320:	e037883a 	mov	sp,fp
 8000324:	dfc00117 	ldw	ra,4(sp)
 8000328:	df000017 	ldw	fp,0(sp)
 800032c:	dec00204 	addi	sp,sp,8
 8000330:	f800283a 	ret

08000334 <displayImage>:

void displayImage (alt_u8 *image_array, int screen_width, int screen_height, float angle) {
 8000334:	defff004 	addi	sp,sp,-64
 8000338:	dfc00f15 	stw	ra,60(sp)
 800033c:	df000e15 	stw	fp,56(sp)
 8000340:	dd400d15 	stw	r21,52(sp)
 8000344:	dd000c15 	stw	r20,48(sp)
 8000348:	dcc00b15 	stw	r19,44(sp)
 800034c:	dc800a15 	stw	r18,40(sp)
 8000350:	dc400915 	stw	r17,36(sp)
 8000354:	dc000815 	stw	r16,32(sp)
 8000358:	df000e04 	addi	fp,sp,56
 800035c:	e13ff615 	stw	r4,-40(fp)
 8000360:	e17ff715 	stw	r5,-36(fp)
 8000364:	e1bff815 	stw	r6,-32(fp)
 8000368:	e1fff915 	stw	r7,-28(fp)
  alt_up_pixel_buffer_dma_dev *pix_buf;
  pix_buf = alt_up_pixel_buffer_dma_open_dev("/dev/video_pixel_buffer_dma_0");
 800036c:	01020074 	movhi	r4,2049
 8000370:	2137a804 	addi	r4,r4,-8544
 8000374:	800c1480 	call	800c148 <alt_up_pixel_buffer_dma_open_dev>
 8000378:	e0bff415 	stw	r2,-48(fp)
  alt_up_pixel_buffer_dma_clear_screen(pix_buf, 0);
 800037c:	000b883a 	mov	r5,zero
 8000380:	e13ff417 	ldw	r4,-48(fp)
 8000384:	800c4080 	call	800c408 <alt_up_pixel_buffer_dma_clear_screen>
  
  // Display the image at the angle given
  alt_u16 r;
  alt_u16 c;
  for (int i = 0; i < screen_height; i++) {
 8000388:	e03ff215 	stw	zero,-56(fp)
 800038c:	0000ca06 	br	80006b8 <displayImage+0x384>
    for (int j = 0; j < screen_width; j++) {
 8000390:	e03ff315 	stw	zero,-52(fp)
 8000394:	0000c206 	br	80006a0 <displayImage+0x36c>
      // Get the translated image by coordinates for row and colmn
      r = ((j-160)*sin(angle))+((i-120)*cos(angle));
 8000398:	e0bff317 	ldw	r2,-52(fp)
 800039c:	10bfd804 	addi	r2,r2,-160
 80003a0:	1009883a 	mov	r4,r2
 80003a4:	8005b6c0 	call	8005b6c <__floatsidf>
 80003a8:	1025883a 	mov	r18,r2
 80003ac:	1827883a 	mov	r19,r3
 80003b0:	e13ff917 	ldw	r4,-28(fp)
 80003b4:	8005c480 	call	8005c48 <__extendsfdf2>
 80003b8:	100b883a 	mov	r5,r2
 80003bc:	180d883a 	mov	r6,r3
 80003c0:	2809883a 	mov	r4,r5
 80003c4:	300b883a 	mov	r5,r6
 80003c8:	8000a2c0 	call	8000a2c <sin>
 80003cc:	1009883a 	mov	r4,r2
 80003d0:	180b883a 	mov	r5,r3
 80003d4:	200d883a 	mov	r6,r4
 80003d8:	280f883a 	mov	r7,r5
 80003dc:	9009883a 	mov	r4,r18
 80003e0:	980b883a 	mov	r5,r19
 80003e4:	8004ad80 	call	8004ad8 <__muldf3>
 80003e8:	1009883a 	mov	r4,r2
 80003ec:	180b883a 	mov	r5,r3
 80003f0:	2025883a 	mov	r18,r4
 80003f4:	2827883a 	mov	r19,r5
 80003f8:	e0bff217 	ldw	r2,-56(fp)
 80003fc:	10bfe204 	addi	r2,r2,-120
 8000400:	1009883a 	mov	r4,r2
 8000404:	8005b6c0 	call	8005b6c <__floatsidf>
 8000408:	1029883a 	mov	r20,r2
 800040c:	182b883a 	mov	r21,r3
 8000410:	e13ff917 	ldw	r4,-28(fp)
 8000414:	8005c480 	call	8005c48 <__extendsfdf2>
 8000418:	100b883a 	mov	r5,r2
 800041c:	180d883a 	mov	r6,r3
 8000420:	2809883a 	mov	r4,r5
 8000424:	300b883a 	mov	r5,r6
 8000428:	80008380 	call	8000838 <cos>
 800042c:	1009883a 	mov	r4,r2
 8000430:	180b883a 	mov	r5,r3
 8000434:	200d883a 	mov	r6,r4
 8000438:	280f883a 	mov	r7,r5
 800043c:	a009883a 	mov	r4,r20
 8000440:	a80b883a 	mov	r5,r21
 8000444:	8004ad80 	call	8004ad8 <__muldf3>
 8000448:	1009883a 	mov	r4,r2
 800044c:	180b883a 	mov	r5,r3
 8000450:	2005883a 	mov	r2,r4
 8000454:	2807883a 	mov	r3,r5
 8000458:	100d883a 	mov	r6,r2
 800045c:	180f883a 	mov	r7,r3
 8000460:	9009883a 	mov	r4,r18
 8000464:	980b883a 	mov	r5,r19
 8000468:	80040c80 	call	80040c8 <__adddf3>
 800046c:	1009883a 	mov	r4,r2
 8000470:	180b883a 	mov	r5,r3
 8000474:	2005883a 	mov	r2,r4
 8000478:	2807883a 	mov	r3,r5
 800047c:	1009883a 	mov	r4,r2
 8000480:	180b883a 	mov	r5,r3
 8000484:	8003ea00 	call	8003ea0 <__fixunsdfsi>
 8000488:	e0bff50d 	sth	r2,-44(fp)
      c = ((j-160)*cos(angle))+((i-120)*(-sin(angle)));
 800048c:	e0bff317 	ldw	r2,-52(fp)
 8000490:	10bfd804 	addi	r2,r2,-160
 8000494:	1009883a 	mov	r4,r2
 8000498:	8005b6c0 	call	8005b6c <__floatsidf>
 800049c:	1025883a 	mov	r18,r2
 80004a0:	1827883a 	mov	r19,r3
 80004a4:	e13ff917 	ldw	r4,-28(fp)
 80004a8:	8005c480 	call	8005c48 <__extendsfdf2>
 80004ac:	100b883a 	mov	r5,r2
 80004b0:	180d883a 	mov	r6,r3
 80004b4:	2809883a 	mov	r4,r5
 80004b8:	300b883a 	mov	r5,r6
 80004bc:	80008380 	call	8000838 <cos>
 80004c0:	1009883a 	mov	r4,r2
 80004c4:	180b883a 	mov	r5,r3
 80004c8:	200d883a 	mov	r6,r4
 80004cc:	280f883a 	mov	r7,r5
 80004d0:	9009883a 	mov	r4,r18
 80004d4:	980b883a 	mov	r5,r19
 80004d8:	8004ad80 	call	8004ad8 <__muldf3>
 80004dc:	1009883a 	mov	r4,r2
 80004e0:	180b883a 	mov	r5,r3
 80004e4:	2025883a 	mov	r18,r4
 80004e8:	2827883a 	mov	r19,r5
 80004ec:	e0bff217 	ldw	r2,-56(fp)
 80004f0:	10bfe204 	addi	r2,r2,-120
 80004f4:	1009883a 	mov	r4,r2
 80004f8:	8005b6c0 	call	8005b6c <__floatsidf>
 80004fc:	1029883a 	mov	r20,r2
 8000500:	182b883a 	mov	r21,r3
 8000504:	e13ff917 	ldw	r4,-28(fp)
 8000508:	8005c480 	call	8005c48 <__extendsfdf2>
 800050c:	100b883a 	mov	r5,r2
 8000510:	180d883a 	mov	r6,r3
 8000514:	2809883a 	mov	r4,r5
 8000518:	300b883a 	mov	r5,r6
 800051c:	8000a2c0 	call	8000a2c <sin>
 8000520:	1009883a 	mov	r4,r2
 8000524:	180b883a 	mov	r5,r3
 8000528:	2021883a 	mov	r16,r4
 800052c:	2c60003c 	xorhi	r17,r5,32768
 8000530:	800d883a 	mov	r6,r16
 8000534:	880f883a 	mov	r7,r17
 8000538:	a009883a 	mov	r4,r20
 800053c:	a80b883a 	mov	r5,r21
 8000540:	8004ad80 	call	8004ad8 <__muldf3>
 8000544:	1009883a 	mov	r4,r2
 8000548:	180b883a 	mov	r5,r3
 800054c:	2005883a 	mov	r2,r4
 8000550:	2807883a 	mov	r3,r5
 8000554:	100d883a 	mov	r6,r2
 8000558:	180f883a 	mov	r7,r3
 800055c:	9009883a 	mov	r4,r18
 8000560:	980b883a 	mov	r5,r19
 8000564:	80040c80 	call	80040c8 <__adddf3>
 8000568:	1009883a 	mov	r4,r2
 800056c:	180b883a 	mov	r5,r3
 8000570:	2005883a 	mov	r2,r4
 8000574:	2807883a 	mov	r3,r5
 8000578:	1009883a 	mov	r4,r2
 800057c:	180b883a 	mov	r5,r3
 8000580:	8003ea00 	call	8003ea0 <__fixunsdfsi>
 8000584:	e0bff58d 	sth	r2,-42(fp)
      // Get the coordinates back to top left of screen
      r += 120;
 8000588:	e0bff50b 	ldhu	r2,-44(fp)
 800058c:	10801e04 	addi	r2,r2,120
 8000590:	e0bff50d 	sth	r2,-44(fp)
      c += 160;
 8000594:	e0bff58b 	ldhu	r2,-42(fp)
 8000598:	10802804 	addi	r2,r2,160
 800059c:	e0bff58d 	sth	r2,-42(fp)
      r = roundf(r);
 80005a0:	e0bff50b 	ldhu	r2,-44(fp)
 80005a4:	1005feb2 	custom	250,r2,r2,zero
 80005a8:	1005fe72 	custom	249,r2,r2,zero
 80005ac:	e0bff50d 	sth	r2,-44(fp)
      c = roundf(c);
 80005b0:	e0bff58b 	ldhu	r2,-42(fp)
 80005b4:	1005feb2 	custom	250,r2,r2,zero
 80005b8:	1005fe72 	custom	249,r2,r2,zero
 80005bc:	e0bff58d 	sth	r2,-42(fp)
   
      // Draw the image
      alt_up_pixel_buffer_dma_draw(pix_buf,
       (myimage[(i*screen_height+j)*3+0] << 16) +
 80005c0:	e0fff217 	ldw	r3,-56(fp)
 80005c4:	e0bff817 	ldw	r2,-32(fp)
 80005c8:	1887383a 	mul	r3,r3,r2
 80005cc:	e0bff317 	ldw	r2,-52(fp)
 80005d0:	1887883a 	add	r3,r3,r2
 80005d4:	1805883a 	mov	r2,r3
 80005d8:	1085883a 	add	r2,r2,r2
 80005dc:	10c7883a 	add	r3,r2,r3
 80005e0:	00820074 	movhi	r2,2049
 80005e4:	10b7af84 	addi	r2,r2,-8514
 80005e8:	10c5883a 	add	r2,r2,r3
 80005ec:	10800003 	ldbu	r2,0(r2)
 80005f0:	10803fcc 	andi	r2,r2,255
 80005f4:	1008943a 	slli	r4,r2,16
       (myimage[(i*screen_height+j)*3+1] << 8) + 
 80005f8:	e0fff217 	ldw	r3,-56(fp)
 80005fc:	e0bff817 	ldw	r2,-32(fp)
 8000600:	1887383a 	mul	r3,r3,r2
 8000604:	e0bff317 	ldw	r2,-52(fp)
 8000608:	1887883a 	add	r3,r3,r2
 800060c:	1805883a 	mov	r2,r3
 8000610:	1085883a 	add	r2,r2,r2
 8000614:	10c5883a 	add	r2,r2,r3
 8000618:	10c00044 	addi	r3,r2,1
 800061c:	00820074 	movhi	r2,2049
 8000620:	10b7af84 	addi	r2,r2,-8514
 8000624:	10c5883a 	add	r2,r2,r3
 8000628:	10800003 	ldbu	r2,0(r2)
 800062c:	10803fcc 	andi	r2,r2,255
 8000630:	1004923a 	slli	r2,r2,8
      r = roundf(r);
      c = roundf(c);
   
      // Draw the image
      alt_up_pixel_buffer_dma_draw(pix_buf,
       (myimage[(i*screen_height+j)*3+0] << 16) +
 8000634:	2089883a 	add	r4,r4,r2
       (myimage[(i*screen_height+j)*3+1] << 8) + 
       (myimage[(i*screen_height+j)*3+2]), (int)c, (int)r);
 8000638:	e0fff217 	ldw	r3,-56(fp)
 800063c:	e0bff817 	ldw	r2,-32(fp)
 8000640:	1887383a 	mul	r3,r3,r2
 8000644:	e0bff317 	ldw	r2,-52(fp)
 8000648:	1887883a 	add	r3,r3,r2
 800064c:	1805883a 	mov	r2,r3
 8000650:	1085883a 	add	r2,r2,r2
 8000654:	10c5883a 	add	r2,r2,r3
 8000658:	10c00084 	addi	r3,r2,2
 800065c:	00820074 	movhi	r2,2049
 8000660:	10b7af84 	addi	r2,r2,-8514
 8000664:	10c5883a 	add	r2,r2,r3
 8000668:	10800003 	ldbu	r2,0(r2)
      c = roundf(c);
   
      // Draw the image
      alt_up_pixel_buffer_dma_draw(pix_buf,
       (myimage[(i*screen_height+j)*3+0] << 16) +
       (myimage[(i*screen_height+j)*3+1] << 8) + 
 800066c:	10803fcc 	andi	r2,r2,255
 8000670:	2085883a 	add	r2,r4,r2
      c += 160;
      r = roundf(r);
      c = roundf(c);
   
      // Draw the image
      alt_up_pixel_buffer_dma_draw(pix_buf,
 8000674:	1009883a 	mov	r4,r2
 8000678:	e0bff58b 	ldhu	r2,-42(fp)
 800067c:	e0fff50b 	ldhu	r3,-44(fp)
 8000680:	180f883a 	mov	r7,r3
 8000684:	100d883a 	mov	r6,r2
 8000688:	200b883a 	mov	r5,r4
 800068c:	e13ff417 	ldw	r4,-48(fp)
 8000690:	800c1840 	call	800c184 <alt_up_pixel_buffer_dma_draw>
  
  // Display the image at the angle given
  alt_u16 r;
  alt_u16 c;
  for (int i = 0; i < screen_height; i++) {
    for (int j = 0; j < screen_width; j++) {
 8000694:	e0bff317 	ldw	r2,-52(fp)
 8000698:	10800044 	addi	r2,r2,1
 800069c:	e0bff315 	stw	r2,-52(fp)
 80006a0:	e0fff317 	ldw	r3,-52(fp)
 80006a4:	e0bff717 	ldw	r2,-36(fp)
 80006a8:	18bf3b16 	blt	r3,r2,8000398 <displayImage+0x64>
  alt_up_pixel_buffer_dma_clear_screen(pix_buf, 0);
  
  // Display the image at the angle given
  alt_u16 r;
  alt_u16 c;
  for (int i = 0; i < screen_height; i++) {
 80006ac:	e0bff217 	ldw	r2,-56(fp)
 80006b0:	10800044 	addi	r2,r2,1
 80006b4:	e0bff215 	stw	r2,-56(fp)
 80006b8:	e0fff217 	ldw	r3,-56(fp)
 80006bc:	e0bff817 	ldw	r2,-32(fp)
 80006c0:	18bf3316 	blt	r3,r2,8000390 <displayImage+0x5c>
       (myimage[(i*screen_height+j)*3+0] << 16) +
       (myimage[(i*screen_height+j)*3+1] << 8) + 
       (myimage[(i*screen_height+j)*3+2]), (int)c, (int)r);
    }
  }  
}
 80006c4:	0001883a 	nop
 80006c8:	e6fffa04 	addi	sp,fp,-24
 80006cc:	dfc00717 	ldw	ra,28(sp)
 80006d0:	df000617 	ldw	fp,24(sp)
 80006d4:	dd400517 	ldw	r21,20(sp)
 80006d8:	dd000417 	ldw	r20,16(sp)
 80006dc:	dcc00317 	ldw	r19,12(sp)
 80006e0:	dc800217 	ldw	r18,8(sp)
 80006e4:	dc400117 	ldw	r17,4(sp)
 80006e8:	dc000017 	ldw	r16,0(sp)
 80006ec:	dec00804 	addi	sp,sp,32
 80006f0:	f800283a 	ret

080006f4 <main>:

int main() {  
 80006f4:	defff004 	addi	sp,sp,-64
 80006f8:	dfc00f15 	stw	ra,60(sp)
 80006fc:	df000e15 	stw	fp,56(sp)
 8000700:	df000e04 	addi	fp,sp,56
  myimage[230400];
  alt_up_char_buffer_dev *char_buf;
  float angles[12] = {0, PI/6, PI/3, PI/2, (2*PI)/3, (5*PI)/6, PI,
 8000704:	e03ff415 	stw	zero,-48(fp)
 8000708:	008fc1b4 	movhi	r2,16134
 800070c:	1082a404 	addi	r2,r2,2704
 8000710:	e0bff515 	stw	r2,-44(fp)
 8000714:	008fe1b4 	movhi	r2,16262
 8000718:	1082a404 	addi	r2,r2,2704
 800071c:	e0bff615 	stw	r2,-40(fp)
 8000720:	008ff274 	movhi	r2,16329
 8000724:	1083f604 	addi	r2,r2,4056
 8000728:	e0bff715 	stw	r2,-36(fp)
 800072c:	009001b4 	movhi	r2,16390
 8000730:	1082a404 	addi	r2,r2,2704
 8000734:	e0bff815 	stw	r2,-32(fp)
 8000738:	00900a34 	movhi	r2,16424
 800073c:	10a34d04 	addi	r2,r2,-29388
 8000740:	e0bff915 	stw	r2,-28(fp)
 8000744:	00901274 	movhi	r2,16457
 8000748:	1083f604 	addi	r2,r2,4056
 800074c:	e0bffa15 	stw	r2,-24(fp)
 8000750:	00901af4 	movhi	r2,16491
 8000754:	10a49f04 	addi	r2,r2,-28036
 8000758:	e0bffb15 	stw	r2,-20(fp)
 800075c:	009021b4 	movhi	r2,16518
 8000760:	1082a404 	addi	r2,r2,2704
 8000764:	e0bffc15 	stw	r2,-16(fp)
 8000768:	009025f4 	movhi	r2,16535
 800076c:	10b2f884 	addi	r2,r2,-13342
 8000770:	e0bffd15 	stw	r2,-12(fp)
 8000774:	00902a34 	movhi	r2,16552
 8000778:	10a34d04 	addi	r2,r2,-29388
 800077c:	e0bffe15 	stw	r2,-8(fp)
 8000780:	00902e34 	movhi	r2,16568
 8000784:	1093a184 	addi	r2,r2,20102
 8000788:	e0bfff15 	stw	r2,-4(fp)
                     (7*PI)/6, (4*PI)/3, (3*PI)/2, (5*PI)/3, (11*PI)/6, 2*PI};
  while(1) {
    for (int i = 0; i < 13; i++) {
 800078c:	e03ff215 	stw	zero,-56(fp)
 8000790:	00001006 	br	80007d4 <main+0xe0>
      displayImage(myimage, 480, 320, angles[i]);
 8000794:	e0bff217 	ldw	r2,-56(fp)
 8000798:	1085883a 	add	r2,r2,r2
 800079c:	1085883a 	add	r2,r2,r2
 80007a0:	e0fff204 	addi	r3,fp,-56
 80007a4:	1885883a 	add	r2,r3,r2
 80007a8:	10800204 	addi	r2,r2,8
 80007ac:	10c00017 	ldw	r3,0(r2)
 80007b0:	180f883a 	mov	r7,r3
 80007b4:	01805004 	movi	r6,320
 80007b8:	01407804 	movi	r5,480
 80007bc:	01020074 	movhi	r4,2049
 80007c0:	2137af84 	addi	r4,r4,-8514
 80007c4:	80003340 	call	8000334 <displayImage>
  myimage[230400];
  alt_up_char_buffer_dev *char_buf;
  float angles[12] = {0, PI/6, PI/3, PI/2, (2*PI)/3, (5*PI)/6, PI,
                     (7*PI)/6, (4*PI)/3, (3*PI)/2, (5*PI)/3, (11*PI)/6, 2*PI};
  while(1) {
    for (int i = 0; i < 13; i++) {
 80007c8:	e0bff217 	ldw	r2,-56(fp)
 80007cc:	10800044 	addi	r2,r2,1
 80007d0:	e0bff215 	stw	r2,-56(fp)
 80007d4:	e0bff217 	ldw	r2,-56(fp)
 80007d8:	10800350 	cmplti	r2,r2,13
 80007dc:	103fed1e 	bne	r2,zero,8000794 <main+0xa0>
      displayImage(myimage, 480, 320, angles[i]);
    }
    for (int i = 13; i != 0; i--) {
 80007e0:	00800344 	movi	r2,13
 80007e4:	e0bff315 	stw	r2,-52(fp)
 80007e8:	00001006 	br	800082c <main+0x138>
      displayImage(myimage, 480, 320, angles[i]);
 80007ec:	e0bff317 	ldw	r2,-52(fp)
 80007f0:	1085883a 	add	r2,r2,r2
 80007f4:	1085883a 	add	r2,r2,r2
 80007f8:	e0fff204 	addi	r3,fp,-56
 80007fc:	1885883a 	add	r2,r3,r2
 8000800:	10800204 	addi	r2,r2,8
 8000804:	10c00017 	ldw	r3,0(r2)
 8000808:	180f883a 	mov	r7,r3
 800080c:	01805004 	movi	r6,320
 8000810:	01407804 	movi	r5,480
 8000814:	01020074 	movhi	r4,2049
 8000818:	2137af84 	addi	r4,r4,-8514
 800081c:	80003340 	call	8000334 <displayImage>
                     (7*PI)/6, (4*PI)/3, (3*PI)/2, (5*PI)/3, (11*PI)/6, 2*PI};
  while(1) {
    for (int i = 0; i < 13; i++) {
      displayImage(myimage, 480, 320, angles[i]);
    }
    for (int i = 13; i != 0; i--) {
 8000820:	e0bff317 	ldw	r2,-52(fp)
 8000824:	10bfffc4 	addi	r2,r2,-1
 8000828:	e0bff315 	stw	r2,-52(fp)
 800082c:	e0bff317 	ldw	r2,-52(fp)
 8000830:	103fee1e 	bne	r2,zero,80007ec <main+0xf8>
      displayImage(myimage, 480, 320, angles[i]);
    }
  }
 8000834:	003fd506 	br	800078c <main+0x98>

08000838 <cos>:
	double cos(double x)
#else
	double cos(x)
	double x;
#endif
{
 8000838:	deffef04 	addi	sp,sp,-68
 800083c:	dfc01015 	stw	ra,64(sp)
 8000840:	df000f15 	stw	fp,60(sp)
 8000844:	dc400e15 	stw	r17,56(sp)
 8000848:	dc000d15 	stw	r16,52(sp)
 800084c:	df000f04 	addi	fp,sp,60
 8000850:	e13ffc15 	stw	r4,-16(fp)
 8000854:	e17ffd15 	stw	r5,-12(fp)
	double y[2],z=0.0;
 8000858:	e03ff215 	stw	zero,-56(fp)
 800085c:	e03ff315 	stw	zero,-52(fp)
	__int32_t n,ix;

    /* High word of x. */
	GET_HIGH_WORD(ix,x);
 8000860:	e0bffc17 	ldw	r2,-16(fp)
 8000864:	e0bffa15 	stw	r2,-24(fp)
 8000868:	e0bffd17 	ldw	r2,-12(fp)
 800086c:	e0bffb15 	stw	r2,-20(fp)
 8000870:	e0bffb17 	ldw	r2,-20(fp)
 8000874:	e0bff415 	stw	r2,-48(fp)

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
 8000878:	e0fff417 	ldw	r3,-48(fp)
 800087c:	00a00034 	movhi	r2,32768
 8000880:	10bfffc4 	addi	r2,r2,-1
 8000884:	1884703a 	and	r2,r3,r2
 8000888:	e0bff415 	stw	r2,-48(fp)
	if(ix <= 0x3fe921fb) return __kernel_cos(x,z);
 800088c:	e0fff417 	ldw	r3,-48(fp)
 8000890:	008ffa74 	movhi	r2,16361
 8000894:	10887ec4 	addi	r2,r2,8699
 8000898:	10c00816 	blt	r2,r3,80008bc <cos+0x84>
 800089c:	e1bff217 	ldw	r6,-56(fp)
 80008a0:	e1fff317 	ldw	r7,-52(fp)
 80008a4:	e13ffc17 	ldw	r4,-16(fp)
 80008a8:	e17ffd17 	ldw	r5,-12(fp)
 80008ac:	80019080 	call	8001908 <__kernel_cos>
 80008b0:	1021883a 	mov	r16,r2
 80008b4:	1823883a 	mov	r17,r3
 80008b8:	00005106 	br	8000a00 <cos+0x1c8>

    /* cos(Inf or NaN) is NaN */
	else if (ix>=0x7ff00000) return x-x;
 80008bc:	e0fff417 	ldw	r3,-48(fp)
 80008c0:	009ffc34 	movhi	r2,32752
 80008c4:	18800a16 	blt	r3,r2,80008f0 <cos+0xb8>
 80008c8:	e1bffc17 	ldw	r6,-16(fp)
 80008cc:	e1fffd17 	ldw	r7,-12(fp)
 80008d0:	e13ffc17 	ldw	r4,-16(fp)
 80008d4:	e17ffd17 	ldw	r5,-12(fp)
 80008d8:	80051f00 	call	80051f0 <__subdf3>
 80008dc:	1009883a 	mov	r4,r2
 80008e0:	180b883a 	mov	r5,r3
 80008e4:	2021883a 	mov	r16,r4
 80008e8:	2823883a 	mov	r17,r5
 80008ec:	00004406 	br	8000a00 <cos+0x1c8>

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2(x,y);
 80008f0:	e0bff604 	addi	r2,fp,-40
 80008f4:	100d883a 	mov	r6,r2
 80008f8:	e13ffc17 	ldw	r4,-16(fp)
 80008fc:	e17ffd17 	ldw	r5,-12(fp)
 8000900:	8000c240 	call	8000c24 <__ieee754_rem_pio2>
 8000904:	e0bff515 	stw	r2,-44(fp)
	    switch(n&3) {
 8000908:	e0bff517 	ldw	r2,-44(fp)
 800090c:	108000cc 	andi	r2,r2,3
 8000910:	10c00060 	cmpeqi	r3,r2,1
 8000914:	18000f1e 	bne	r3,zero,8000954 <cos+0x11c>
 8000918:	10c000a0 	cmpeqi	r3,r2,2
 800091c:	18001d1e 	bne	r3,zero,8000994 <cos+0x15c>
 8000920:	10002a1e 	bne	r2,zero,80009cc <cos+0x194>
		case 0: return  __kernel_cos(y[0],y[1]);
 8000924:	e0bff617 	ldw	r2,-40(fp)
 8000928:	e0fff717 	ldw	r3,-36(fp)
 800092c:	e13ff817 	ldw	r4,-32(fp)
 8000930:	e17ff917 	ldw	r5,-28(fp)
 8000934:	200d883a 	mov	r6,r4
 8000938:	280f883a 	mov	r7,r5
 800093c:	1009883a 	mov	r4,r2
 8000940:	180b883a 	mov	r5,r3
 8000944:	80019080 	call	8001908 <__kernel_cos>
 8000948:	1021883a 	mov	r16,r2
 800094c:	1823883a 	mov	r17,r3
 8000950:	00002b06 	br	8000a00 <cos+0x1c8>
		case 1: return -__kernel_sin(y[0],y[1],1);
 8000954:	e0bff617 	ldw	r2,-40(fp)
 8000958:	e0fff717 	ldw	r3,-36(fp)
 800095c:	e13ff817 	ldw	r4,-32(fp)
 8000960:	e17ff917 	ldw	r5,-28(fp)
 8000964:	01800044 	movi	r6,1
 8000968:	d9800015 	stw	r6,0(sp)
 800096c:	200d883a 	mov	r6,r4
 8000970:	280f883a 	mov	r7,r5
 8000974:	1009883a 	mov	r4,r2
 8000978:	180b883a 	mov	r5,r3
 800097c:	80032340 	call	8003234 <__kernel_sin>
 8000980:	1009883a 	mov	r4,r2
 8000984:	180b883a 	mov	r5,r3
 8000988:	2021883a 	mov	r16,r4
 800098c:	2c60003c 	xorhi	r17,r5,32768
 8000990:	00001b06 	br	8000a00 <cos+0x1c8>
		case 2: return -__kernel_cos(y[0],y[1]);
 8000994:	e0bff617 	ldw	r2,-40(fp)
 8000998:	e0fff717 	ldw	r3,-36(fp)
 800099c:	e13ff817 	ldw	r4,-32(fp)
 80009a0:	e17ff917 	ldw	r5,-28(fp)
 80009a4:	200d883a 	mov	r6,r4
 80009a8:	280f883a 	mov	r7,r5
 80009ac:	1009883a 	mov	r4,r2
 80009b0:	180b883a 	mov	r5,r3
 80009b4:	80019080 	call	8001908 <__kernel_cos>
 80009b8:	1009883a 	mov	r4,r2
 80009bc:	180b883a 	mov	r5,r3
 80009c0:	2021883a 	mov	r16,r4
 80009c4:	2c60003c 	xorhi	r17,r5,32768
 80009c8:	00000d06 	br	8000a00 <cos+0x1c8>
		default:
		        return  __kernel_sin(y[0],y[1],1);
 80009cc:	e0bff617 	ldw	r2,-40(fp)
 80009d0:	e0fff717 	ldw	r3,-36(fp)
 80009d4:	e13ff817 	ldw	r4,-32(fp)
 80009d8:	e17ff917 	ldw	r5,-28(fp)
 80009dc:	01800044 	movi	r6,1
 80009e0:	d9800015 	stw	r6,0(sp)
 80009e4:	200d883a 	mov	r6,r4
 80009e8:	280f883a 	mov	r7,r5
 80009ec:	1009883a 	mov	r4,r2
 80009f0:	180b883a 	mov	r5,r3
 80009f4:	80032340 	call	8003234 <__kernel_sin>
 80009f8:	1021883a 	mov	r16,r2
 80009fc:	1823883a 	mov	r17,r3
 8000a00:	8007883a 	mov	r3,r16
 8000a04:	8809883a 	mov	r4,r17
	    }
	}
}
 8000a08:	1805883a 	mov	r2,r3
 8000a0c:	2007883a 	mov	r3,r4
 8000a10:	e6fffe04 	addi	sp,fp,-8
 8000a14:	dfc00317 	ldw	ra,12(sp)
 8000a18:	df000217 	ldw	fp,8(sp)
 8000a1c:	dc400117 	ldw	r17,4(sp)
 8000a20:	dc000017 	ldw	r16,0(sp)
 8000a24:	dec00404 	addi	sp,sp,16
 8000a28:	f800283a 	ret

08000a2c <sin>:
	double sin(double x)
#else
	double sin(x)
	double x;
#endif
{
 8000a2c:	deffef04 	addi	sp,sp,-68
 8000a30:	dfc01015 	stw	ra,64(sp)
 8000a34:	df000f15 	stw	fp,60(sp)
 8000a38:	dc400e15 	stw	r17,56(sp)
 8000a3c:	dc000d15 	stw	r16,52(sp)
 8000a40:	df000f04 	addi	fp,sp,60
 8000a44:	e13ffc15 	stw	r4,-16(fp)
 8000a48:	e17ffd15 	stw	r5,-12(fp)
	double y[2],z=0.0;
 8000a4c:	e03ff215 	stw	zero,-56(fp)
 8000a50:	e03ff315 	stw	zero,-52(fp)
	__int32_t n,ix;

    /* High word of x. */
	GET_HIGH_WORD(ix,x);
 8000a54:	e0bffc17 	ldw	r2,-16(fp)
 8000a58:	e0bffa15 	stw	r2,-24(fp)
 8000a5c:	e0bffd17 	ldw	r2,-12(fp)
 8000a60:	e0bffb15 	stw	r2,-20(fp)
 8000a64:	e0bffb17 	ldw	r2,-20(fp)
 8000a68:	e0bff415 	stw	r2,-48(fp)

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
 8000a6c:	e0fff417 	ldw	r3,-48(fp)
 8000a70:	00a00034 	movhi	r2,32768
 8000a74:	10bfffc4 	addi	r2,r2,-1
 8000a78:	1884703a 	and	r2,r3,r2
 8000a7c:	e0bff415 	stw	r2,-48(fp)
	if(ix <= 0x3fe921fb) return __kernel_sin(x,z,0);
 8000a80:	e0fff417 	ldw	r3,-48(fp)
 8000a84:	008ffa74 	movhi	r2,16361
 8000a88:	10887ec4 	addi	r2,r2,8699
 8000a8c:	10c00916 	blt	r2,r3,8000ab4 <sin+0x88>
 8000a90:	d8000015 	stw	zero,0(sp)
 8000a94:	e1bff217 	ldw	r6,-56(fp)
 8000a98:	e1fff317 	ldw	r7,-52(fp)
 8000a9c:	e13ffc17 	ldw	r4,-16(fp)
 8000aa0:	e17ffd17 	ldw	r5,-12(fp)
 8000aa4:	80032340 	call	8003234 <__kernel_sin>
 8000aa8:	1021883a 	mov	r16,r2
 8000aac:	1823883a 	mov	r17,r3
 8000ab0:	00005106 	br	8000bf8 <sin+0x1cc>

    /* sin(Inf or NaN) is NaN */
	else if (ix>=0x7ff00000) return x-x;
 8000ab4:	e0fff417 	ldw	r3,-48(fp)
 8000ab8:	009ffc34 	movhi	r2,32752
 8000abc:	18800a16 	blt	r3,r2,8000ae8 <sin+0xbc>
 8000ac0:	e1bffc17 	ldw	r6,-16(fp)
 8000ac4:	e1fffd17 	ldw	r7,-12(fp)
 8000ac8:	e13ffc17 	ldw	r4,-16(fp)
 8000acc:	e17ffd17 	ldw	r5,-12(fp)
 8000ad0:	80051f00 	call	80051f0 <__subdf3>
 8000ad4:	1009883a 	mov	r4,r2
 8000ad8:	180b883a 	mov	r5,r3
 8000adc:	2021883a 	mov	r16,r4
 8000ae0:	2823883a 	mov	r17,r5
 8000ae4:	00004406 	br	8000bf8 <sin+0x1cc>

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2(x,y);
 8000ae8:	e0bff604 	addi	r2,fp,-40
 8000aec:	100d883a 	mov	r6,r2
 8000af0:	e13ffc17 	ldw	r4,-16(fp)
 8000af4:	e17ffd17 	ldw	r5,-12(fp)
 8000af8:	8000c240 	call	8000c24 <__ieee754_rem_pio2>
 8000afc:	e0bff515 	stw	r2,-44(fp)
	    switch(n&3) {
 8000b00:	e0bff517 	ldw	r2,-44(fp)
 8000b04:	108000cc 	andi	r2,r2,3
 8000b08:	10c00060 	cmpeqi	r3,r2,1
 8000b0c:	1800111e 	bne	r3,zero,8000b54 <sin+0x128>
 8000b10:	10c000a0 	cmpeqi	r3,r2,2
 8000b14:	18001b1e 	bne	r3,zero,8000b84 <sin+0x158>
 8000b18:	10002a1e 	bne	r2,zero,8000bc4 <sin+0x198>
		case 0: return  __kernel_sin(y[0],y[1],1);
 8000b1c:	e0bff617 	ldw	r2,-40(fp)
 8000b20:	e0fff717 	ldw	r3,-36(fp)
 8000b24:	e13ff817 	ldw	r4,-32(fp)
 8000b28:	e17ff917 	ldw	r5,-28(fp)
 8000b2c:	01800044 	movi	r6,1
 8000b30:	d9800015 	stw	r6,0(sp)
 8000b34:	200d883a 	mov	r6,r4
 8000b38:	280f883a 	mov	r7,r5
 8000b3c:	1009883a 	mov	r4,r2
 8000b40:	180b883a 	mov	r5,r3
 8000b44:	80032340 	call	8003234 <__kernel_sin>
 8000b48:	1021883a 	mov	r16,r2
 8000b4c:	1823883a 	mov	r17,r3
 8000b50:	00002906 	br	8000bf8 <sin+0x1cc>
		case 1: return  __kernel_cos(y[0],y[1]);
 8000b54:	e0bff617 	ldw	r2,-40(fp)
 8000b58:	e0fff717 	ldw	r3,-36(fp)
 8000b5c:	e13ff817 	ldw	r4,-32(fp)
 8000b60:	e17ff917 	ldw	r5,-28(fp)
 8000b64:	200d883a 	mov	r6,r4
 8000b68:	280f883a 	mov	r7,r5
 8000b6c:	1009883a 	mov	r4,r2
 8000b70:	180b883a 	mov	r5,r3
 8000b74:	80019080 	call	8001908 <__kernel_cos>
 8000b78:	1021883a 	mov	r16,r2
 8000b7c:	1823883a 	mov	r17,r3
 8000b80:	00001d06 	br	8000bf8 <sin+0x1cc>
		case 2: return -__kernel_sin(y[0],y[1],1);
 8000b84:	e0bff617 	ldw	r2,-40(fp)
 8000b88:	e0fff717 	ldw	r3,-36(fp)
 8000b8c:	e13ff817 	ldw	r4,-32(fp)
 8000b90:	e17ff917 	ldw	r5,-28(fp)
 8000b94:	01800044 	movi	r6,1
 8000b98:	d9800015 	stw	r6,0(sp)
 8000b9c:	200d883a 	mov	r6,r4
 8000ba0:	280f883a 	mov	r7,r5
 8000ba4:	1009883a 	mov	r4,r2
 8000ba8:	180b883a 	mov	r5,r3
 8000bac:	80032340 	call	8003234 <__kernel_sin>
 8000bb0:	1009883a 	mov	r4,r2
 8000bb4:	180b883a 	mov	r5,r3
 8000bb8:	2021883a 	mov	r16,r4
 8000bbc:	2c60003c 	xorhi	r17,r5,32768
 8000bc0:	00000d06 	br	8000bf8 <sin+0x1cc>
		default:
			return -__kernel_cos(y[0],y[1]);
 8000bc4:	e0bff617 	ldw	r2,-40(fp)
 8000bc8:	e0fff717 	ldw	r3,-36(fp)
 8000bcc:	e13ff817 	ldw	r4,-32(fp)
 8000bd0:	e17ff917 	ldw	r5,-28(fp)
 8000bd4:	200d883a 	mov	r6,r4
 8000bd8:	280f883a 	mov	r7,r5
 8000bdc:	1009883a 	mov	r4,r2
 8000be0:	180b883a 	mov	r5,r3
 8000be4:	80019080 	call	8001908 <__kernel_cos>
 8000be8:	1009883a 	mov	r4,r2
 8000bec:	180b883a 	mov	r5,r3
 8000bf0:	2021883a 	mov	r16,r4
 8000bf4:	2c60003c 	xorhi	r17,r5,32768
 8000bf8:	8007883a 	mov	r3,r16
 8000bfc:	8809883a 	mov	r4,r17
	    }
	}
}
 8000c00:	1805883a 	mov	r2,r3
 8000c04:	2007883a 	mov	r3,r4
 8000c08:	e6fffe04 	addi	sp,fp,-8
 8000c0c:	dfc00317 	ldw	ra,12(sp)
 8000c10:	df000217 	ldw	fp,8(sp)
 8000c14:	dc400117 	ldw	r17,4(sp)
 8000c18:	dc000017 	ldw	r16,0(sp)
 8000c1c:	dec00404 	addi	sp,sp,16
 8000c20:	f800283a 	ret

08000c24 <__ieee754_rem_pio2>:
	__int32_t __ieee754_rem_pio2(double x, double *y)
#else
	__int32_t __ieee754_rem_pio2(x,y)
	double x,y[];
#endif
{
 8000c24:	deffcc04 	addi	sp,sp,-208
 8000c28:	dfc03315 	stw	ra,204(sp)
 8000c2c:	df003215 	stw	fp,200(sp)
 8000c30:	ddc03115 	stw	r23,196(sp)
 8000c34:	dd803015 	stw	r22,192(sp)
 8000c38:	dd402f15 	stw	r21,188(sp)
 8000c3c:	dd002e15 	stw	r20,184(sp)
 8000c40:	dcc02d15 	stw	r19,180(sp)
 8000c44:	dc802c15 	stw	r18,176(sp)
 8000c48:	dc402b15 	stw	r17,172(sp)
 8000c4c:	dc002a15 	stw	r16,168(sp)
 8000c50:	df003204 	addi	fp,sp,200
 8000c54:	e13ff515 	stw	r4,-44(fp)
 8000c58:	e17ff615 	stw	r5,-40(fp)
 8000c5c:	e1bff715 	stw	r6,-36(fp)
	double z = 0.0,w,t,r,fn;
 8000c60:	e03fd015 	stw	zero,-192(fp)
 8000c64:	e03fd115 	stw	zero,-188(fp)
	double tx[3];
	__int32_t i,j,n,ix,hx;
	int e0,nx;
	__uint32_t low;

	GET_HIGH_WORD(hx,x);		/* high word of x */
 8000c68:	e0bff517 	ldw	r2,-44(fp)
 8000c6c:	e0bfe915 	stw	r2,-92(fp)
 8000c70:	e0bff617 	ldw	r2,-40(fp)
 8000c74:	e0bfea15 	stw	r2,-88(fp)
 8000c78:	e0bfea17 	ldw	r2,-88(fp)
 8000c7c:	e0bfd815 	stw	r2,-160(fp)
	ix = hx&0x7fffffff;
 8000c80:	e0ffd817 	ldw	r3,-160(fp)
 8000c84:	00a00034 	movhi	r2,32768
 8000c88:	10bfffc4 	addi	r2,r2,-1
 8000c8c:	1884703a 	and	r2,r3,r2
 8000c90:	e0bfd915 	stw	r2,-156(fp)
	if(ix<=0x3fe921fb)   /* |x| ~<= pi/4 , no need for reduction */
 8000c94:	e0ffd917 	ldw	r3,-156(fp)
 8000c98:	008ffa74 	movhi	r2,16361
 8000c9c:	10887ec4 	addi	r2,r2,8699
 8000ca0:	10c00b16 	blt	r2,r3,8000cd0 <__ieee754_rem_pio2+0xac>
	    {y[0] = x; y[1] = 0; return 0;}
 8000ca4:	e0bff717 	ldw	r2,-36(fp)
 8000ca8:	e0fff517 	ldw	r3,-44(fp)
 8000cac:	10c00015 	stw	r3,0(r2)
 8000cb0:	e0fff617 	ldw	r3,-40(fp)
 8000cb4:	10c00115 	stw	r3,4(r2)
 8000cb8:	e0bff717 	ldw	r2,-36(fp)
 8000cbc:	10800204 	addi	r2,r2,8
 8000cc0:	10000015 	stw	zero,0(r2)
 8000cc4:	10000115 	stw	zero,4(r2)
 8000cc8:	0005883a 	mov	r2,zero
 8000ccc:	00030106 	br	80018d4 <__ieee754_rem_pio2+0xcb0>
	if(ix<0x4002d97c) {  /* |x| < 3pi/4, special case with n=+-1 */
 8000cd0:	e0ffd917 	ldw	r3,-156(fp)
 8000cd4:	009000f4 	movhi	r2,16387
 8000cd8:	10b65ec4 	addi	r2,r2,-9861
 8000cdc:	10c0f416 	blt	r2,r3,80010b0 <__ieee754_rem_pio2+0x48c>
	    if(hx>0) { 
 8000ce0:	e0bfd817 	ldw	r2,-160(fp)
 8000ce4:	0080790e 	bge	zero,r2,8000ecc <__ieee754_rem_pio2+0x2a8>
		z = x - pio2_1;
 8000ce8:	00951034 	movhi	r2,21568
 8000cec:	00cffe74 	movhi	r3,16377
 8000cf0:	18c87ec4 	addi	r3,r3,8699
 8000cf4:	100d883a 	mov	r6,r2
 8000cf8:	180f883a 	mov	r7,r3
 8000cfc:	e13ff517 	ldw	r4,-44(fp)
 8000d00:	e17ff617 	ldw	r5,-40(fp)
 8000d04:	80051f00 	call	80051f0 <__subdf3>
 8000d08:	1009883a 	mov	r4,r2
 8000d0c:	180b883a 	mov	r5,r3
 8000d10:	e13fd015 	stw	r4,-192(fp)
 8000d14:	e17fd115 	stw	r5,-188(fp)
		if(ix!=0x3ff921fb) { 	/* 33+53 bit pi is good enough */
 8000d18:	e0ffd917 	ldw	r3,-156(fp)
 8000d1c:	008ffe74 	movhi	r2,16377
 8000d20:	10887ec4 	addi	r2,r2,8699
 8000d24:	18802e26 	beq	r3,r2,8000de0 <__ieee754_rem_pio2+0x1bc>
		    y[0] = z - pio2_1t;
 8000d28:	008698b4 	movhi	r2,6754
 8000d2c:	1098cc44 	addi	r2,r2,25393
 8000d30:	00cf7474 	movhi	r3,15825
 8000d34:	18ed1844 	addi	r3,r3,-19359
 8000d38:	100d883a 	mov	r6,r2
 8000d3c:	180f883a 	mov	r7,r3
 8000d40:	e13fd017 	ldw	r4,-192(fp)
 8000d44:	e17fd117 	ldw	r5,-188(fp)
 8000d48:	80051f00 	call	80051f0 <__subdf3>
 8000d4c:	1009883a 	mov	r4,r2
 8000d50:	180b883a 	mov	r5,r3
 8000d54:	2005883a 	mov	r2,r4
 8000d58:	2807883a 	mov	r3,r5
 8000d5c:	e13ff717 	ldw	r4,-36(fp)
 8000d60:	20800015 	stw	r2,0(r4)
 8000d64:	20c00115 	stw	r3,4(r4)
		    y[1] = (z-y[0])-pio2_1t;
 8000d68:	e0bff717 	ldw	r2,-36(fp)
 8000d6c:	14000204 	addi	r16,r2,8
 8000d70:	e13ff717 	ldw	r4,-36(fp)
 8000d74:	20800017 	ldw	r2,0(r4)
 8000d78:	20c00117 	ldw	r3,4(r4)
 8000d7c:	100d883a 	mov	r6,r2
 8000d80:	180f883a 	mov	r7,r3
 8000d84:	e13fd017 	ldw	r4,-192(fp)
 8000d88:	e17fd117 	ldw	r5,-188(fp)
 8000d8c:	80051f00 	call	80051f0 <__subdf3>
 8000d90:	1009883a 	mov	r4,r2
 8000d94:	180b883a 	mov	r5,r3
 8000d98:	2011883a 	mov	r8,r4
 8000d9c:	2813883a 	mov	r9,r5
 8000da0:	008698b4 	movhi	r2,6754
 8000da4:	1098cc44 	addi	r2,r2,25393
 8000da8:	00cf7474 	movhi	r3,15825
 8000dac:	18ed1844 	addi	r3,r3,-19359
 8000db0:	100d883a 	mov	r6,r2
 8000db4:	180f883a 	mov	r7,r3
 8000db8:	4009883a 	mov	r4,r8
 8000dbc:	480b883a 	mov	r5,r9
 8000dc0:	80051f00 	call	80051f0 <__subdf3>
 8000dc4:	1009883a 	mov	r4,r2
 8000dc8:	180b883a 	mov	r5,r3
 8000dcc:	2005883a 	mov	r2,r4
 8000dd0:	2807883a 	mov	r3,r5
 8000dd4:	80800015 	stw	r2,0(r16)
 8000dd8:	80c00115 	stw	r3,4(r16)
 8000ddc:	00003906 	br	8000ec4 <__ieee754_rem_pio2+0x2a0>
		} else {		/* near pi/2, use 33+33+53 bit pi */
		    z -= pio2_2;
 8000de0:	00869834 	movhi	r2,6752
 8000de4:	00cf7474 	movhi	r3,15825
 8000de8:	18ed1844 	addi	r3,r3,-19359
 8000dec:	100d883a 	mov	r6,r2
 8000df0:	180f883a 	mov	r7,r3
 8000df4:	e13fd017 	ldw	r4,-192(fp)
 8000df8:	e17fd117 	ldw	r5,-188(fp)
 8000dfc:	80051f00 	call	80051f0 <__subdf3>
 8000e00:	1009883a 	mov	r4,r2
 8000e04:	180b883a 	mov	r5,r3
 8000e08:	e13fd015 	stw	r4,-192(fp)
 8000e0c:	e17fd115 	stw	r5,-188(fp)
		    y[0] = z - pio2_2t;
 8000e10:	008b80f4 	movhi	r2,11779
 8000e14:	109c1cc4 	addi	r2,r2,28787
 8000e18:	00cee8f4 	movhi	r3,15267
 8000e1c:	18c66284 	addi	r3,r3,6538
 8000e20:	100d883a 	mov	r6,r2
 8000e24:	180f883a 	mov	r7,r3
 8000e28:	e13fd017 	ldw	r4,-192(fp)
 8000e2c:	e17fd117 	ldw	r5,-188(fp)
 8000e30:	80051f00 	call	80051f0 <__subdf3>
 8000e34:	1009883a 	mov	r4,r2
 8000e38:	180b883a 	mov	r5,r3
 8000e3c:	2005883a 	mov	r2,r4
 8000e40:	2807883a 	mov	r3,r5
 8000e44:	e13ff717 	ldw	r4,-36(fp)
 8000e48:	20800015 	stw	r2,0(r4)
 8000e4c:	20c00115 	stw	r3,4(r4)
		    y[1] = (z-y[0])-pio2_2t;
 8000e50:	e0bff717 	ldw	r2,-36(fp)
 8000e54:	14000204 	addi	r16,r2,8
 8000e58:	e13ff717 	ldw	r4,-36(fp)
 8000e5c:	20800017 	ldw	r2,0(r4)
 8000e60:	20c00117 	ldw	r3,4(r4)
 8000e64:	100d883a 	mov	r6,r2
 8000e68:	180f883a 	mov	r7,r3
 8000e6c:	e13fd017 	ldw	r4,-192(fp)
 8000e70:	e17fd117 	ldw	r5,-188(fp)
 8000e74:	80051f00 	call	80051f0 <__subdf3>
 8000e78:	1009883a 	mov	r4,r2
 8000e7c:	180b883a 	mov	r5,r3
 8000e80:	2011883a 	mov	r8,r4
 8000e84:	2813883a 	mov	r9,r5
 8000e88:	008b80f4 	movhi	r2,11779
 8000e8c:	109c1cc4 	addi	r2,r2,28787
 8000e90:	00cee8f4 	movhi	r3,15267
 8000e94:	18c66284 	addi	r3,r3,6538
 8000e98:	100d883a 	mov	r6,r2
 8000e9c:	180f883a 	mov	r7,r3
 8000ea0:	4009883a 	mov	r4,r8
 8000ea4:	480b883a 	mov	r5,r9
 8000ea8:	80051f00 	call	80051f0 <__subdf3>
 8000eac:	1009883a 	mov	r4,r2
 8000eb0:	180b883a 	mov	r5,r3
 8000eb4:	2005883a 	mov	r2,r4
 8000eb8:	2807883a 	mov	r3,r5
 8000ebc:	80800015 	stw	r2,0(r16)
 8000ec0:	80c00115 	stw	r3,4(r16)
		}
		return 1;
 8000ec4:	00800044 	movi	r2,1
 8000ec8:	00028206 	br	80018d4 <__ieee754_rem_pio2+0xcb0>
	    } else {	/* negative x */
		z = x + pio2_1;
 8000ecc:	00951034 	movhi	r2,21568
 8000ed0:	00cffe74 	movhi	r3,16377
 8000ed4:	18c87ec4 	addi	r3,r3,8699
 8000ed8:	100d883a 	mov	r6,r2
 8000edc:	180f883a 	mov	r7,r3
 8000ee0:	e13ff517 	ldw	r4,-44(fp)
 8000ee4:	e17ff617 	ldw	r5,-40(fp)
 8000ee8:	80040c80 	call	80040c8 <__adddf3>
 8000eec:	1009883a 	mov	r4,r2
 8000ef0:	180b883a 	mov	r5,r3
 8000ef4:	e13fd015 	stw	r4,-192(fp)
 8000ef8:	e17fd115 	stw	r5,-188(fp)
		if(ix!=0x3ff921fb) { 	/* 33+53 bit pi is good enough */
 8000efc:	e0ffd917 	ldw	r3,-156(fp)
 8000f00:	008ffe74 	movhi	r2,16377
 8000f04:	10887ec4 	addi	r2,r2,8699
 8000f08:	18802e26 	beq	r3,r2,8000fc4 <__ieee754_rem_pio2+0x3a0>
		    y[0] = z + pio2_1t;
 8000f0c:	008698b4 	movhi	r2,6754
 8000f10:	1098cc44 	addi	r2,r2,25393
 8000f14:	00cf7474 	movhi	r3,15825
 8000f18:	18ed1844 	addi	r3,r3,-19359
 8000f1c:	e1bfd017 	ldw	r6,-192(fp)
 8000f20:	e1ffd117 	ldw	r7,-188(fp)
 8000f24:	1009883a 	mov	r4,r2
 8000f28:	180b883a 	mov	r5,r3
 8000f2c:	80040c80 	call	80040c8 <__adddf3>
 8000f30:	1009883a 	mov	r4,r2
 8000f34:	180b883a 	mov	r5,r3
 8000f38:	2005883a 	mov	r2,r4
 8000f3c:	2807883a 	mov	r3,r5
 8000f40:	e13ff717 	ldw	r4,-36(fp)
 8000f44:	20800015 	stw	r2,0(r4)
 8000f48:	20c00115 	stw	r3,4(r4)
		    y[1] = (z-y[0])+pio2_1t;
 8000f4c:	e0bff717 	ldw	r2,-36(fp)
 8000f50:	14000204 	addi	r16,r2,8
 8000f54:	e13ff717 	ldw	r4,-36(fp)
 8000f58:	20800017 	ldw	r2,0(r4)
 8000f5c:	20c00117 	ldw	r3,4(r4)
 8000f60:	100d883a 	mov	r6,r2
 8000f64:	180f883a 	mov	r7,r3
 8000f68:	e13fd017 	ldw	r4,-192(fp)
 8000f6c:	e17fd117 	ldw	r5,-188(fp)
 8000f70:	80051f00 	call	80051f0 <__subdf3>
 8000f74:	1009883a 	mov	r4,r2
 8000f78:	180b883a 	mov	r5,r3
 8000f7c:	2011883a 	mov	r8,r4
 8000f80:	2813883a 	mov	r9,r5
 8000f84:	008698b4 	movhi	r2,6754
 8000f88:	1098cc44 	addi	r2,r2,25393
 8000f8c:	00cf7474 	movhi	r3,15825
 8000f90:	18ed1844 	addi	r3,r3,-19359
 8000f94:	100d883a 	mov	r6,r2
 8000f98:	180f883a 	mov	r7,r3
 8000f9c:	4009883a 	mov	r4,r8
 8000fa0:	480b883a 	mov	r5,r9
 8000fa4:	80040c80 	call	80040c8 <__adddf3>
 8000fa8:	1009883a 	mov	r4,r2
 8000fac:	180b883a 	mov	r5,r3
 8000fb0:	2005883a 	mov	r2,r4
 8000fb4:	2807883a 	mov	r3,r5
 8000fb8:	80800015 	stw	r2,0(r16)
 8000fbc:	80c00115 	stw	r3,4(r16)
 8000fc0:	00003906 	br	80010a8 <__ieee754_rem_pio2+0x484>
		} else {		/* near pi/2, use 33+33+53 bit pi */
		    z += pio2_2;
 8000fc4:	00869834 	movhi	r2,6752
 8000fc8:	00cf7474 	movhi	r3,15825
 8000fcc:	18ed1844 	addi	r3,r3,-19359
 8000fd0:	100d883a 	mov	r6,r2
 8000fd4:	180f883a 	mov	r7,r3
 8000fd8:	e13fd017 	ldw	r4,-192(fp)
 8000fdc:	e17fd117 	ldw	r5,-188(fp)
 8000fe0:	80040c80 	call	80040c8 <__adddf3>
 8000fe4:	1009883a 	mov	r4,r2
 8000fe8:	180b883a 	mov	r5,r3
 8000fec:	e13fd015 	stw	r4,-192(fp)
 8000ff0:	e17fd115 	stw	r5,-188(fp)
		    y[0] = z + pio2_2t;
 8000ff4:	008b80f4 	movhi	r2,11779
 8000ff8:	109c1cc4 	addi	r2,r2,28787
 8000ffc:	00cee8f4 	movhi	r3,15267
 8001000:	18c66284 	addi	r3,r3,6538
 8001004:	e1bfd017 	ldw	r6,-192(fp)
 8001008:	e1ffd117 	ldw	r7,-188(fp)
 800100c:	1009883a 	mov	r4,r2
 8001010:	180b883a 	mov	r5,r3
 8001014:	80040c80 	call	80040c8 <__adddf3>
 8001018:	1009883a 	mov	r4,r2
 800101c:	180b883a 	mov	r5,r3
 8001020:	2005883a 	mov	r2,r4
 8001024:	2807883a 	mov	r3,r5
 8001028:	e13ff717 	ldw	r4,-36(fp)
 800102c:	20800015 	stw	r2,0(r4)
 8001030:	20c00115 	stw	r3,4(r4)
		    y[1] = (z-y[0])+pio2_2t;
 8001034:	e0bff717 	ldw	r2,-36(fp)
 8001038:	14000204 	addi	r16,r2,8
 800103c:	e13ff717 	ldw	r4,-36(fp)
 8001040:	20800017 	ldw	r2,0(r4)
 8001044:	20c00117 	ldw	r3,4(r4)
 8001048:	100d883a 	mov	r6,r2
 800104c:	180f883a 	mov	r7,r3
 8001050:	e13fd017 	ldw	r4,-192(fp)
 8001054:	e17fd117 	ldw	r5,-188(fp)
 8001058:	80051f00 	call	80051f0 <__subdf3>
 800105c:	1009883a 	mov	r4,r2
 8001060:	180b883a 	mov	r5,r3
 8001064:	2011883a 	mov	r8,r4
 8001068:	2813883a 	mov	r9,r5
 800106c:	008b80f4 	movhi	r2,11779
 8001070:	109c1cc4 	addi	r2,r2,28787
 8001074:	00cee8f4 	movhi	r3,15267
 8001078:	18c66284 	addi	r3,r3,6538
 800107c:	100d883a 	mov	r6,r2
 8001080:	180f883a 	mov	r7,r3
 8001084:	4009883a 	mov	r4,r8
 8001088:	480b883a 	mov	r5,r9
 800108c:	80040c80 	call	80040c8 <__adddf3>
 8001090:	1009883a 	mov	r4,r2
 8001094:	180b883a 	mov	r5,r3
 8001098:	2005883a 	mov	r2,r4
 800109c:	2807883a 	mov	r3,r5
 80010a0:	80800015 	stw	r2,0(r16)
 80010a4:	80c00115 	stw	r3,4(r16)
		}
		return -1;
 80010a8:	00bfffc4 	movi	r2,-1
 80010ac:	00020906 	br	80018d4 <__ieee754_rem_pio2+0xcb0>
	    }
	}
	if(ix<=0x413921fb) { /* |x| ~<= 2^19*(pi/2), medium size */
 80010b0:	e0ffd917 	ldw	r3,-156(fp)
 80010b4:	00904e74 	movhi	r2,16697
 80010b8:	10887ec4 	addi	r2,r2,8699
 80010bc:	10c15e16 	blt	r2,r3,8001638 <__ieee754_rem_pio2+0xa14>
	    t  = fabs(x);
 80010c0:	e13ff517 	ldw	r4,-44(fp)
 80010c4:	e17ff617 	ldw	r5,-40(fp)
 80010c8:	80036780 	call	8003678 <fabs>
 80010cc:	e0bfda15 	stw	r2,-152(fp)
 80010d0:	e0ffdb15 	stw	r3,-148(fp)
	    n  = (__int32_t) (t*invpio2+half);
 80010d4:	009b72b4 	movhi	r2,28106
 80010d8:	10b220c4 	addi	r2,r2,-14205
 80010dc:	00cff934 	movhi	r3,16356
 80010e0:	18d7cc04 	addi	r3,r3,24368
 80010e4:	e1bfda17 	ldw	r6,-152(fp)
 80010e8:	e1ffdb17 	ldw	r7,-148(fp)
 80010ec:	1009883a 	mov	r4,r2
 80010f0:	180b883a 	mov	r5,r3
 80010f4:	8004ad80 	call	8004ad8 <__muldf3>
 80010f8:	1009883a 	mov	r4,r2
 80010fc:	180b883a 	mov	r5,r3
 8001100:	2011883a 	mov	r8,r4
 8001104:	2813883a 	mov	r9,r5
 8001108:	0005883a 	mov	r2,zero
 800110c:	00cff834 	movhi	r3,16352
 8001110:	100d883a 	mov	r6,r2
 8001114:	180f883a 	mov	r7,r3
 8001118:	4009883a 	mov	r4,r8
 800111c:	480b883a 	mov	r5,r9
 8001120:	80040c80 	call	80040c8 <__adddf3>
 8001124:	1009883a 	mov	r4,r2
 8001128:	180b883a 	mov	r5,r3
 800112c:	2005883a 	mov	r2,r4
 8001130:	2807883a 	mov	r3,r5
 8001134:	1009883a 	mov	r4,r2
 8001138:	180b883a 	mov	r5,r3
 800113c:	8005aec0 	call	8005aec <__fixdfsi>
 8001140:	e0bfdc15 	stw	r2,-144(fp)
	    fn = (double)n;
 8001144:	e13fdc17 	ldw	r4,-144(fp)
 8001148:	8005b6c0 	call	8005b6c <__floatsidf>
 800114c:	1009883a 	mov	r4,r2
 8001150:	180b883a 	mov	r5,r3
 8001154:	e13fdd15 	stw	r4,-140(fp)
 8001158:	e17fde15 	stw	r5,-136(fp)
	    r  = t-fn*pio2_1;
 800115c:	00951034 	movhi	r2,21568
 8001160:	00cffe74 	movhi	r3,16377
 8001164:	18c87ec4 	addi	r3,r3,8699
 8001168:	e1bfdd17 	ldw	r6,-140(fp)
 800116c:	e1ffde17 	ldw	r7,-136(fp)
 8001170:	1009883a 	mov	r4,r2
 8001174:	180b883a 	mov	r5,r3
 8001178:	8004ad80 	call	8004ad8 <__muldf3>
 800117c:	1009883a 	mov	r4,r2
 8001180:	180b883a 	mov	r5,r3
 8001184:	2005883a 	mov	r2,r4
 8001188:	2807883a 	mov	r3,r5
 800118c:	100d883a 	mov	r6,r2
 8001190:	180f883a 	mov	r7,r3
 8001194:	e13fda17 	ldw	r4,-152(fp)
 8001198:	e17fdb17 	ldw	r5,-148(fp)
 800119c:	80051f00 	call	80051f0 <__subdf3>
 80011a0:	1009883a 	mov	r4,r2
 80011a4:	180b883a 	mov	r5,r3
 80011a8:	e13fd415 	stw	r4,-176(fp)
 80011ac:	e17fd515 	stw	r5,-172(fp)
	    w  = fn*pio2_1t;	/* 1st round good to 85 bit */
 80011b0:	008698b4 	movhi	r2,6754
 80011b4:	1098cc44 	addi	r2,r2,25393
 80011b8:	00cf7474 	movhi	r3,15825
 80011bc:	18ed1844 	addi	r3,r3,-19359
 80011c0:	100d883a 	mov	r6,r2
 80011c4:	180f883a 	mov	r7,r3
 80011c8:	e13fdd17 	ldw	r4,-140(fp)
 80011cc:	e17fde17 	ldw	r5,-136(fp)
 80011d0:	8004ad80 	call	8004ad8 <__muldf3>
 80011d4:	1009883a 	mov	r4,r2
 80011d8:	180b883a 	mov	r5,r3
 80011dc:	e13fd215 	stw	r4,-184(fp)
 80011e0:	e17fd315 	stw	r5,-180(fp)
	    if(n<32&&ix!=npio2_hw[n-1]) {	
 80011e4:	e0bfdc17 	ldw	r2,-144(fp)
 80011e8:	10800808 	cmpgei	r2,r2,32
 80011ec:	1000171e 	bne	r2,zero,800124c <__ieee754_rem_pio2+0x628>
 80011f0:	e0bfdc17 	ldw	r2,-144(fp)
 80011f4:	10ffffc4 	addi	r3,r2,-1
 80011f8:	00820134 	movhi	r2,2052
 80011fc:	1098f204 	addi	r2,r2,25544
 8001200:	18c7883a 	add	r3,r3,r3
 8001204:	18c7883a 	add	r3,r3,r3
 8001208:	10c5883a 	add	r2,r2,r3
 800120c:	10c00017 	ldw	r3,0(r2)
 8001210:	e0bfd917 	ldw	r2,-156(fp)
 8001214:	18800d26 	beq	r3,r2,800124c <__ieee754_rem_pio2+0x628>
		y[0] = r-w;	/* quick check no cancellation */
 8001218:	e1bfd217 	ldw	r6,-184(fp)
 800121c:	e1ffd317 	ldw	r7,-180(fp)
 8001220:	e13fd417 	ldw	r4,-176(fp)
 8001224:	e17fd517 	ldw	r5,-172(fp)
 8001228:	80051f00 	call	80051f0 <__subdf3>
 800122c:	1009883a 	mov	r4,r2
 8001230:	180b883a 	mov	r5,r3
 8001234:	2005883a 	mov	r2,r4
 8001238:	2807883a 	mov	r3,r5
 800123c:	e13ff717 	ldw	r4,-36(fp)
 8001240:	20800015 	stw	r2,0(r4)
 8001244:	20c00115 	stw	r3,4(r4)
 8001248:	0000c906 	br	8001570 <__ieee754_rem_pio2+0x94c>
	    } else {
	        __uint32_t high;
	        j  = ix>>20;
 800124c:	e0bfd917 	ldw	r2,-156(fp)
 8001250:	1005d53a 	srai	r2,r2,20
 8001254:	e0bfdf15 	stw	r2,-132(fp)
	        y[0] = r-w; 
 8001258:	e1bfd217 	ldw	r6,-184(fp)
 800125c:	e1ffd317 	ldw	r7,-180(fp)
 8001260:	e13fd417 	ldw	r4,-176(fp)
 8001264:	e17fd517 	ldw	r5,-172(fp)
 8001268:	80051f00 	call	80051f0 <__subdf3>
 800126c:	1009883a 	mov	r4,r2
 8001270:	180b883a 	mov	r5,r3
 8001274:	2005883a 	mov	r2,r4
 8001278:	2807883a 	mov	r3,r5
 800127c:	e13ff717 	ldw	r4,-36(fp)
 8001280:	20800015 	stw	r2,0(r4)
 8001284:	20c00115 	stw	r3,4(r4)
		GET_HIGH_WORD(high,y[0]);
 8001288:	e13ff717 	ldw	r4,-36(fp)
 800128c:	20800017 	ldw	r2,0(r4)
 8001290:	20c00117 	ldw	r3,4(r4)
 8001294:	e0bfeb15 	stw	r2,-84(fp)
 8001298:	e0ffec15 	stw	r3,-80(fp)
 800129c:	e0bfec17 	ldw	r2,-80(fp)
 80012a0:	e0bfe015 	stw	r2,-128(fp)
	        i = j-((high>>20)&0x7ff);
 80012a4:	e0ffdf17 	ldw	r3,-132(fp)
 80012a8:	e0bfe017 	ldw	r2,-128(fp)
 80012ac:	1004d53a 	srli	r2,r2,20
 80012b0:	1081ffcc 	andi	r2,r2,2047
 80012b4:	1885c83a 	sub	r2,r3,r2
 80012b8:	e0bfd615 	stw	r2,-168(fp)
	        if(i>16) {  /* 2nd iteration needed, good to 118 */
 80012bc:	e0bfd617 	ldw	r2,-168(fp)
 80012c0:	10800450 	cmplti	r2,r2,17
 80012c4:	1000aa1e 	bne	r2,zero,8001570 <__ieee754_rem_pio2+0x94c>
		    t  = r;
 80012c8:	e0bfd417 	ldw	r2,-176(fp)
 80012cc:	e0bfda15 	stw	r2,-152(fp)
 80012d0:	e0bfd517 	ldw	r2,-172(fp)
 80012d4:	e0bfdb15 	stw	r2,-148(fp)
		    w  = fn*pio2_2;	
 80012d8:	00869834 	movhi	r2,6752
 80012dc:	00cf7474 	movhi	r3,15825
 80012e0:	18ed1844 	addi	r3,r3,-19359
 80012e4:	100d883a 	mov	r6,r2
 80012e8:	180f883a 	mov	r7,r3
 80012ec:	e13fdd17 	ldw	r4,-140(fp)
 80012f0:	e17fde17 	ldw	r5,-136(fp)
 80012f4:	8004ad80 	call	8004ad8 <__muldf3>
 80012f8:	1009883a 	mov	r4,r2
 80012fc:	180b883a 	mov	r5,r3
 8001300:	e13fd215 	stw	r4,-184(fp)
 8001304:	e17fd315 	stw	r5,-180(fp)
		    r  = t-w;
 8001308:	e1bfd217 	ldw	r6,-184(fp)
 800130c:	e1ffd317 	ldw	r7,-180(fp)
 8001310:	e13fda17 	ldw	r4,-152(fp)
 8001314:	e17fdb17 	ldw	r5,-148(fp)
 8001318:	80051f00 	call	80051f0 <__subdf3>
 800131c:	1009883a 	mov	r4,r2
 8001320:	180b883a 	mov	r5,r3
 8001324:	e13fd415 	stw	r4,-176(fp)
 8001328:	e17fd515 	stw	r5,-172(fp)
		    w  = fn*pio2_2t-((t-r)-w);	
 800132c:	008b80f4 	movhi	r2,11779
 8001330:	109c1cc4 	addi	r2,r2,28787
 8001334:	00cee8f4 	movhi	r3,15267
 8001338:	18c66284 	addi	r3,r3,6538
 800133c:	e1bfdd17 	ldw	r6,-140(fp)
 8001340:	e1ffde17 	ldw	r7,-136(fp)
 8001344:	1009883a 	mov	r4,r2
 8001348:	180b883a 	mov	r5,r3
 800134c:	8004ad80 	call	8004ad8 <__muldf3>
 8001350:	1009883a 	mov	r4,r2
 8001354:	180b883a 	mov	r5,r3
 8001358:	2021883a 	mov	r16,r4
 800135c:	2823883a 	mov	r17,r5
 8001360:	e1bfd417 	ldw	r6,-176(fp)
 8001364:	e1ffd517 	ldw	r7,-172(fp)
 8001368:	e13fda17 	ldw	r4,-152(fp)
 800136c:	e17fdb17 	ldw	r5,-148(fp)
 8001370:	80051f00 	call	80051f0 <__subdf3>
 8001374:	1009883a 	mov	r4,r2
 8001378:	180b883a 	mov	r5,r3
 800137c:	2005883a 	mov	r2,r4
 8001380:	2807883a 	mov	r3,r5
 8001384:	e1bfd217 	ldw	r6,-184(fp)
 8001388:	e1ffd317 	ldw	r7,-180(fp)
 800138c:	1009883a 	mov	r4,r2
 8001390:	180b883a 	mov	r5,r3
 8001394:	80051f00 	call	80051f0 <__subdf3>
 8001398:	1009883a 	mov	r4,r2
 800139c:	180b883a 	mov	r5,r3
 80013a0:	2005883a 	mov	r2,r4
 80013a4:	2807883a 	mov	r3,r5
 80013a8:	100d883a 	mov	r6,r2
 80013ac:	180f883a 	mov	r7,r3
 80013b0:	8009883a 	mov	r4,r16
 80013b4:	880b883a 	mov	r5,r17
 80013b8:	80051f00 	call	80051f0 <__subdf3>
 80013bc:	1009883a 	mov	r4,r2
 80013c0:	180b883a 	mov	r5,r3
 80013c4:	e13fd215 	stw	r4,-184(fp)
 80013c8:	e17fd315 	stw	r5,-180(fp)
		    y[0] = r-w;
 80013cc:	e1bfd217 	ldw	r6,-184(fp)
 80013d0:	e1ffd317 	ldw	r7,-180(fp)
 80013d4:	e13fd417 	ldw	r4,-176(fp)
 80013d8:	e17fd517 	ldw	r5,-172(fp)
 80013dc:	80051f00 	call	80051f0 <__subdf3>
 80013e0:	1009883a 	mov	r4,r2
 80013e4:	180b883a 	mov	r5,r3
 80013e8:	2005883a 	mov	r2,r4
 80013ec:	2807883a 	mov	r3,r5
 80013f0:	e13ff717 	ldw	r4,-36(fp)
 80013f4:	20800015 	stw	r2,0(r4)
 80013f8:	20c00115 	stw	r3,4(r4)
		    GET_HIGH_WORD(high,y[0]);
 80013fc:	e13ff717 	ldw	r4,-36(fp)
 8001400:	20800017 	ldw	r2,0(r4)
 8001404:	20c00117 	ldw	r3,4(r4)
 8001408:	e0bfed15 	stw	r2,-76(fp)
 800140c:	e0ffee15 	stw	r3,-72(fp)
 8001410:	e0bfee17 	ldw	r2,-72(fp)
 8001414:	e0bfe015 	stw	r2,-128(fp)
		    i = j-((high>>20)&0x7ff);
 8001418:	e0ffdf17 	ldw	r3,-132(fp)
 800141c:	e0bfe017 	ldw	r2,-128(fp)
 8001420:	1004d53a 	srli	r2,r2,20
 8001424:	1081ffcc 	andi	r2,r2,2047
 8001428:	1885c83a 	sub	r2,r3,r2
 800142c:	e0bfd615 	stw	r2,-168(fp)
		    if(i>49)  {	/* 3rd iteration need, 151 bits acc */
 8001430:	e0bfd617 	ldw	r2,-168(fp)
 8001434:	10800c90 	cmplti	r2,r2,50
 8001438:	10004d1e 	bne	r2,zero,8001570 <__ieee754_rem_pio2+0x94c>
		    	t  = r;	/* will cover all possible cases */
 800143c:	e0bfd417 	ldw	r2,-176(fp)
 8001440:	e0bfda15 	stw	r2,-152(fp)
 8001444:	e0bfd517 	ldw	r2,-172(fp)
 8001448:	e0bfdb15 	stw	r2,-148(fp)
		    	w  = fn*pio2_3;	
 800144c:	008b8034 	movhi	r2,11776
 8001450:	00cee8f4 	movhi	r3,15267
 8001454:	18c66284 	addi	r3,r3,6538
 8001458:	100d883a 	mov	r6,r2
 800145c:	180f883a 	mov	r7,r3
 8001460:	e13fdd17 	ldw	r4,-140(fp)
 8001464:	e17fde17 	ldw	r5,-136(fp)
 8001468:	8004ad80 	call	8004ad8 <__muldf3>
 800146c:	1009883a 	mov	r4,r2
 8001470:	180b883a 	mov	r5,r3
 8001474:	e13fd215 	stw	r4,-184(fp)
 8001478:	e17fd315 	stw	r5,-180(fp)
		    	r  = t-w;
 800147c:	e1bfd217 	ldw	r6,-184(fp)
 8001480:	e1ffd317 	ldw	r7,-180(fp)
 8001484:	e13fda17 	ldw	r4,-152(fp)
 8001488:	e17fdb17 	ldw	r5,-148(fp)
 800148c:	80051f00 	call	80051f0 <__subdf3>
 8001490:	1009883a 	mov	r4,r2
 8001494:	180b883a 	mov	r5,r3
 8001498:	e13fd415 	stw	r4,-176(fp)
 800149c:	e17fd515 	stw	r5,-172(fp)
		    	w  = fn*pio2_3t-((t-r)-w);	
 80014a0:	00894834 	movhi	r2,9504
 80014a4:	10927044 	addi	r2,r2,18881
 80014a8:	00ce5f34 	movhi	r3,14716
 80014ac:	18e0e684 	addi	r3,r3,-31846
 80014b0:	e1bfdd17 	ldw	r6,-140(fp)
 80014b4:	e1ffde17 	ldw	r7,-136(fp)
 80014b8:	1009883a 	mov	r4,r2
 80014bc:	180b883a 	mov	r5,r3
 80014c0:	8004ad80 	call	8004ad8 <__muldf3>
 80014c4:	1009883a 	mov	r4,r2
 80014c8:	180b883a 	mov	r5,r3
 80014cc:	2021883a 	mov	r16,r4
 80014d0:	2823883a 	mov	r17,r5
 80014d4:	e1bfd417 	ldw	r6,-176(fp)
 80014d8:	e1ffd517 	ldw	r7,-172(fp)
 80014dc:	e13fda17 	ldw	r4,-152(fp)
 80014e0:	e17fdb17 	ldw	r5,-148(fp)
 80014e4:	80051f00 	call	80051f0 <__subdf3>
 80014e8:	1009883a 	mov	r4,r2
 80014ec:	180b883a 	mov	r5,r3
 80014f0:	2005883a 	mov	r2,r4
 80014f4:	2807883a 	mov	r3,r5
 80014f8:	e1bfd217 	ldw	r6,-184(fp)
 80014fc:	e1ffd317 	ldw	r7,-180(fp)
 8001500:	1009883a 	mov	r4,r2
 8001504:	180b883a 	mov	r5,r3
 8001508:	80051f00 	call	80051f0 <__subdf3>
 800150c:	1009883a 	mov	r4,r2
 8001510:	180b883a 	mov	r5,r3
 8001514:	2005883a 	mov	r2,r4
 8001518:	2807883a 	mov	r3,r5
 800151c:	100d883a 	mov	r6,r2
 8001520:	180f883a 	mov	r7,r3
 8001524:	8009883a 	mov	r4,r16
 8001528:	880b883a 	mov	r5,r17
 800152c:	80051f00 	call	80051f0 <__subdf3>
 8001530:	1009883a 	mov	r4,r2
 8001534:	180b883a 	mov	r5,r3
 8001538:	e13fd215 	stw	r4,-184(fp)
 800153c:	e17fd315 	stw	r5,-180(fp)
		    	y[0] = r-w;
 8001540:	e1bfd217 	ldw	r6,-184(fp)
 8001544:	e1ffd317 	ldw	r7,-180(fp)
 8001548:	e13fd417 	ldw	r4,-176(fp)
 800154c:	e17fd517 	ldw	r5,-172(fp)
 8001550:	80051f00 	call	80051f0 <__subdf3>
 8001554:	1009883a 	mov	r4,r2
 8001558:	180b883a 	mov	r5,r3
 800155c:	2005883a 	mov	r2,r4
 8001560:	2807883a 	mov	r3,r5
 8001564:	e13ff717 	ldw	r4,-36(fp)
 8001568:	20800015 	stw	r2,0(r4)
 800156c:	20c00115 	stw	r3,4(r4)
		    }
		}
	    }
	    y[1] = (r-y[0])-w;
 8001570:	e0bff717 	ldw	r2,-36(fp)
 8001574:	14000204 	addi	r16,r2,8
 8001578:	e13ff717 	ldw	r4,-36(fp)
 800157c:	20800017 	ldw	r2,0(r4)
 8001580:	20c00117 	ldw	r3,4(r4)
 8001584:	100d883a 	mov	r6,r2
 8001588:	180f883a 	mov	r7,r3
 800158c:	e13fd417 	ldw	r4,-176(fp)
 8001590:	e17fd517 	ldw	r5,-172(fp)
 8001594:	80051f00 	call	80051f0 <__subdf3>
 8001598:	1009883a 	mov	r4,r2
 800159c:	180b883a 	mov	r5,r3
 80015a0:	2005883a 	mov	r2,r4
 80015a4:	2807883a 	mov	r3,r5
 80015a8:	e1bfd217 	ldw	r6,-184(fp)
 80015ac:	e1ffd317 	ldw	r7,-180(fp)
 80015b0:	1009883a 	mov	r4,r2
 80015b4:	180b883a 	mov	r5,r3
 80015b8:	80051f00 	call	80051f0 <__subdf3>
 80015bc:	1009883a 	mov	r4,r2
 80015c0:	180b883a 	mov	r5,r3
 80015c4:	2005883a 	mov	r2,r4
 80015c8:	2807883a 	mov	r3,r5
 80015cc:	80800015 	stw	r2,0(r16)
 80015d0:	80c00115 	stw	r3,4(r16)
	    if(hx<0) 	{y[0] = -y[0]; y[1] = -y[1]; return -n;}
 80015d4:	e0bfd817 	ldw	r2,-160(fp)
 80015d8:	1000150e 	bge	r2,zero,8001630 <__ieee754_rem_pio2+0xa0c>
 80015dc:	e13ff717 	ldw	r4,-36(fp)
 80015e0:	20800017 	ldw	r2,0(r4)
 80015e4:	20c00117 	ldw	r3,4(r4)
 80015e8:	102d883a 	mov	r22,r2
 80015ec:	1de0003c 	xorhi	r23,r3,32768
 80015f0:	e0bff717 	ldw	r2,-36(fp)
 80015f4:	15800015 	stw	r22,0(r2)
 80015f8:	15c00115 	stw	r23,4(r2)
 80015fc:	e0bff717 	ldw	r2,-36(fp)
 8001600:	11000204 	addi	r4,r2,8
 8001604:	e0bff717 	ldw	r2,-36(fp)
 8001608:	11400204 	addi	r5,r2,8
 800160c:	28800017 	ldw	r2,0(r5)
 8001610:	28c00117 	ldw	r3,4(r5)
 8001614:	1029883a 	mov	r20,r2
 8001618:	1d60003c 	xorhi	r21,r3,32768
 800161c:	25000015 	stw	r20,0(r4)
 8001620:	25400115 	stw	r21,4(r4)
 8001624:	e0bfdc17 	ldw	r2,-144(fp)
 8001628:	0085c83a 	sub	r2,zero,r2
 800162c:	0000a906 	br	80018d4 <__ieee754_rem_pio2+0xcb0>
	    else	 return n;
 8001630:	e0bfdc17 	ldw	r2,-144(fp)
 8001634:	0000a706 	br	80018d4 <__ieee754_rem_pio2+0xcb0>
	}
    /* 
     * all other (large) arguments
     */
	if(ix>=0x7ff00000) {		/* x is inf or NaN */
 8001638:	e0ffd917 	ldw	r3,-156(fp)
 800163c:	009ffc34 	movhi	r2,32752
 8001640:	18801416 	blt	r3,r2,8001694 <__ieee754_rem_pio2+0xa70>
	    y[0]=y[1]=x-x; return 0;
 8001644:	e0bff717 	ldw	r2,-36(fp)
 8001648:	14000204 	addi	r16,r2,8
 800164c:	e1bff517 	ldw	r6,-44(fp)
 8001650:	e1fff617 	ldw	r7,-40(fp)
 8001654:	e13ff517 	ldw	r4,-44(fp)
 8001658:	e17ff617 	ldw	r5,-40(fp)
 800165c:	80051f00 	call	80051f0 <__subdf3>
 8001660:	1009883a 	mov	r4,r2
 8001664:	180b883a 	mov	r5,r3
 8001668:	2005883a 	mov	r2,r4
 800166c:	2807883a 	mov	r3,r5
 8001670:	80800015 	stw	r2,0(r16)
 8001674:	80c00115 	stw	r3,4(r16)
 8001678:	80800017 	ldw	r2,0(r16)
 800167c:	80c00117 	ldw	r3,4(r16)
 8001680:	e13ff717 	ldw	r4,-36(fp)
 8001684:	20800015 	stw	r2,0(r4)
 8001688:	20c00115 	stw	r3,4(r4)
 800168c:	0005883a 	mov	r2,zero
 8001690:	00009006 	br	80018d4 <__ieee754_rem_pio2+0xcb0>
	}
    /* set z = scalbn(|x|,ilogb(x)-23) */
	GET_LOW_WORD(low,x);
 8001694:	e0bff517 	ldw	r2,-44(fp)
 8001698:	e0bfef15 	stw	r2,-68(fp)
 800169c:	e0bff617 	ldw	r2,-40(fp)
 80016a0:	e0bff015 	stw	r2,-64(fp)
 80016a4:	e0bfef17 	ldw	r2,-68(fp)
 80016a8:	e0bfe115 	stw	r2,-124(fp)
	SET_LOW_WORD(z,low);
 80016ac:	e0bfd017 	ldw	r2,-192(fp)
 80016b0:	e0bff115 	stw	r2,-60(fp)
 80016b4:	e0bfd117 	ldw	r2,-188(fp)
 80016b8:	e0bff215 	stw	r2,-56(fp)
 80016bc:	e0bfe117 	ldw	r2,-124(fp)
 80016c0:	e0bff115 	stw	r2,-60(fp)
 80016c4:	e0bff117 	ldw	r2,-60(fp)
 80016c8:	e0bfd015 	stw	r2,-192(fp)
 80016cc:	e0bff217 	ldw	r2,-56(fp)
 80016d0:	e0bfd115 	stw	r2,-188(fp)
	e0 	= (int)((ix>>20)-1046);	/* e0 = ilogb(z)-23; */
 80016d4:	e0bfd917 	ldw	r2,-156(fp)
 80016d8:	1005d53a 	srai	r2,r2,20
 80016dc:	10befa84 	addi	r2,r2,-1046
 80016e0:	e0bfe215 	stw	r2,-120(fp)
	SET_HIGH_WORD(z, ix - ((__int32_t)e0<<20));
 80016e4:	e0bfd017 	ldw	r2,-192(fp)
 80016e8:	e0bff315 	stw	r2,-52(fp)
 80016ec:	e0bfd117 	ldw	r2,-188(fp)
 80016f0:	e0bff415 	stw	r2,-48(fp)
 80016f4:	e0bfe217 	ldw	r2,-120(fp)
 80016f8:	1004953a 	slli	r2,r2,20
 80016fc:	e0ffd917 	ldw	r3,-156(fp)
 8001700:	1885c83a 	sub	r2,r3,r2
 8001704:	e0bff415 	stw	r2,-48(fp)
 8001708:	e0bff317 	ldw	r2,-52(fp)
 800170c:	e0bfd015 	stw	r2,-192(fp)
 8001710:	e0bff417 	ldw	r2,-48(fp)
 8001714:	e0bfd115 	stw	r2,-188(fp)
	for(i=0;i<2;i++) {
 8001718:	e03fd615 	stw	zero,-168(fp)
 800171c:	00002c06 	br	80017d0 <__ieee754_rem_pio2+0xbac>
		tx[i] = (double)((__int32_t)(z));
 8001720:	e13fd017 	ldw	r4,-192(fp)
 8001724:	e17fd117 	ldw	r5,-188(fp)
 8001728:	8005aec0 	call	8005aec <__fixdfsi>
 800172c:	1009883a 	mov	r4,r2
 8001730:	8005b6c0 	call	8005b6c <__floatsidf>
 8001734:	1009883a 	mov	r4,r2
 8001738:	180b883a 	mov	r5,r3
 800173c:	e0bfd617 	ldw	r2,-168(fp)
 8001740:	100490fa 	slli	r2,r2,3
 8001744:	e0ffd004 	addi	r3,fp,-192
 8001748:	1885883a 	add	r2,r3,r2
 800174c:	10801304 	addi	r2,r2,76
 8001750:	11000015 	stw	r4,0(r2)
 8001754:	11400115 	stw	r5,4(r2)
		z     = (z-tx[i])*two24;
 8001758:	e0bfd617 	ldw	r2,-168(fp)
 800175c:	100490fa 	slli	r2,r2,3
 8001760:	e0ffd004 	addi	r3,fp,-192
 8001764:	1885883a 	add	r2,r3,r2
 8001768:	11001304 	addi	r4,r2,76
 800176c:	20800017 	ldw	r2,0(r4)
 8001770:	20c00117 	ldw	r3,4(r4)
 8001774:	100d883a 	mov	r6,r2
 8001778:	180f883a 	mov	r7,r3
 800177c:	e13fd017 	ldw	r4,-192(fp)
 8001780:	e17fd117 	ldw	r5,-188(fp)
 8001784:	80051f00 	call	80051f0 <__subdf3>
 8001788:	1009883a 	mov	r4,r2
 800178c:	180b883a 	mov	r5,r3
 8001790:	2011883a 	mov	r8,r4
 8001794:	2813883a 	mov	r9,r5
 8001798:	0005883a 	mov	r2,zero
 800179c:	00d05c34 	movhi	r3,16752
 80017a0:	100d883a 	mov	r6,r2
 80017a4:	180f883a 	mov	r7,r3
 80017a8:	4009883a 	mov	r4,r8
 80017ac:	480b883a 	mov	r5,r9
 80017b0:	8004ad80 	call	8004ad8 <__muldf3>
 80017b4:	1009883a 	mov	r4,r2
 80017b8:	180b883a 	mov	r5,r3
 80017bc:	e13fd015 	stw	r4,-192(fp)
 80017c0:	e17fd115 	stw	r5,-188(fp)
    /* set z = scalbn(|x|,ilogb(x)-23) */
	GET_LOW_WORD(low,x);
	SET_LOW_WORD(z,low);
	e0 	= (int)((ix>>20)-1046);	/* e0 = ilogb(z)-23; */
	SET_HIGH_WORD(z, ix - ((__int32_t)e0<<20));
	for(i=0;i<2;i++) {
 80017c4:	e0bfd617 	ldw	r2,-168(fp)
 80017c8:	10800044 	addi	r2,r2,1
 80017cc:	e0bfd615 	stw	r2,-168(fp)
 80017d0:	e0bfd617 	ldw	r2,-168(fp)
 80017d4:	10800090 	cmplti	r2,r2,2
 80017d8:	103fd11e 	bne	r2,zero,8001720 <__ieee754_rem_pio2+0xafc>
		tx[i] = (double)((__int32_t)(z));
		z     = (z-tx[i])*two24;
	}
	tx[2] = z;
 80017dc:	e0bfd017 	ldw	r2,-192(fp)
 80017e0:	e0bfe715 	stw	r2,-100(fp)
 80017e4:	e0bfd117 	ldw	r2,-188(fp)
 80017e8:	e0bfe815 	stw	r2,-96(fp)
	nx = 3;
 80017ec:	008000c4 	movi	r2,3
 80017f0:	e0bfd715 	stw	r2,-164(fp)
	while(tx[nx-1]==zero) nx--;	/* skip zero term */
 80017f4:	00000306 	br	8001804 <__ieee754_rem_pio2+0xbe0>
 80017f8:	e0bfd717 	ldw	r2,-164(fp)
 80017fc:	10bfffc4 	addi	r2,r2,-1
 8001800:	e0bfd715 	stw	r2,-164(fp)
 8001804:	e0bfd717 	ldw	r2,-164(fp)
 8001808:	10bfffc4 	addi	r2,r2,-1
 800180c:	100490fa 	slli	r2,r2,3
 8001810:	e0ffd004 	addi	r3,fp,-192
 8001814:	1885883a 	add	r2,r3,r2
 8001818:	11001304 	addi	r4,r2,76
 800181c:	20800017 	ldw	r2,0(r4)
 8001820:	20c00117 	ldw	r3,4(r4)
 8001824:	0009883a 	mov	r4,zero
 8001828:	000b883a 	mov	r5,zero
 800182c:	200d883a 	mov	r6,r4
 8001830:	280f883a 	mov	r7,r5
 8001834:	1009883a 	mov	r4,r2
 8001838:	180b883a 	mov	r5,r3
 800183c:	80049740 	call	8004974 <__eqdf2>
 8001840:	103fed26 	beq	r2,zero,80017f8 <__ieee754_rem_pio2+0xbd4>
	n  =  __kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);
 8001844:	e0ffe304 	addi	r3,fp,-116
 8001848:	00820134 	movhi	r2,2052
 800184c:	1098b004 	addi	r2,r2,25280
 8001850:	d8800115 	stw	r2,4(sp)
 8001854:	00800084 	movi	r2,2
 8001858:	d8800015 	stw	r2,0(sp)
 800185c:	e1ffd717 	ldw	r7,-164(fp)
 8001860:	e1bfe217 	ldw	r6,-120(fp)
 8001864:	e17ff717 	ldw	r5,-36(fp)
 8001868:	1809883a 	mov	r4,r3
 800186c:	8001e3c0 	call	8001e3c <__kernel_rem_pio2>
 8001870:	e0bfdc15 	stw	r2,-144(fp)
	if(hx<0) {y[0] = -y[0]; y[1] = -y[1]; return -n;}
 8001874:	e0bfd817 	ldw	r2,-160(fp)
 8001878:	1000150e 	bge	r2,zero,80018d0 <__ieee754_rem_pio2+0xcac>
 800187c:	e13ff717 	ldw	r4,-36(fp)
 8001880:	20800017 	ldw	r2,0(r4)
 8001884:	20c00117 	ldw	r3,4(r4)
 8001888:	1025883a 	mov	r18,r2
 800188c:	1ce0003c 	xorhi	r19,r3,32768
 8001890:	e0bff717 	ldw	r2,-36(fp)
 8001894:	14800015 	stw	r18,0(r2)
 8001898:	14c00115 	stw	r19,4(r2)
 800189c:	e0bff717 	ldw	r2,-36(fp)
 80018a0:	11000204 	addi	r4,r2,8
 80018a4:	e0bff717 	ldw	r2,-36(fp)
 80018a8:	11400204 	addi	r5,r2,8
 80018ac:	28800017 	ldw	r2,0(r5)
 80018b0:	28c00117 	ldw	r3,4(r5)
 80018b4:	1021883a 	mov	r16,r2
 80018b8:	1c60003c 	xorhi	r17,r3,32768
 80018bc:	24000015 	stw	r16,0(r4)
 80018c0:	24400115 	stw	r17,4(r4)
 80018c4:	e0bfdc17 	ldw	r2,-144(fp)
 80018c8:	0085c83a 	sub	r2,zero,r2
 80018cc:	00000106 	br	80018d4 <__ieee754_rem_pio2+0xcb0>
	return n;
 80018d0:	e0bfdc17 	ldw	r2,-144(fp)
}
 80018d4:	e6fff804 	addi	sp,fp,-32
 80018d8:	dfc00917 	ldw	ra,36(sp)
 80018dc:	df000817 	ldw	fp,32(sp)
 80018e0:	ddc00717 	ldw	r23,28(sp)
 80018e4:	dd800617 	ldw	r22,24(sp)
 80018e8:	dd400517 	ldw	r21,20(sp)
 80018ec:	dd000417 	ldw	r20,16(sp)
 80018f0:	dcc00317 	ldw	r19,12(sp)
 80018f4:	dc800217 	ldw	r18,8(sp)
 80018f8:	dc400117 	ldw	r17,4(sp)
 80018fc:	dc000017 	ldw	r16,0(sp)
 8001900:	dec00a04 	addi	sp,sp,40
 8001904:	f800283a 	ret

08001908 <__kernel_cos>:
	double __kernel_cos(double x, double y)
#else
	double __kernel_cos(x, y)
	double x,y;
#endif
{
 8001908:	deffe504 	addi	sp,sp,-108
 800190c:	dfc01a15 	stw	ra,104(sp)
 8001910:	df001915 	stw	fp,100(sp)
 8001914:	dd401815 	stw	r21,96(sp)
 8001918:	dd001715 	stw	r20,92(sp)
 800191c:	dcc01615 	stw	r19,88(sp)
 8001920:	dc801515 	stw	r18,84(sp)
 8001924:	dc401415 	stw	r17,80(sp)
 8001928:	dc001315 	stw	r16,76(sp)
 800192c:	df001904 	addi	fp,sp,100
 8001930:	e13ff615 	stw	r4,-40(fp)
 8001934:	e17ff715 	stw	r5,-36(fp)
 8001938:	e1bff815 	stw	r6,-32(fp)
 800193c:	e1fff915 	stw	r7,-28(fp)
	double a,hz,z,r,qx;
	__int32_t ix;
	GET_HIGH_WORD(ix,x);
 8001940:	e0bff617 	ldw	r2,-40(fp)
 8001944:	e0bff215 	stw	r2,-56(fp)
 8001948:	e0bff717 	ldw	r2,-36(fp)
 800194c:	e0bff315 	stw	r2,-52(fp)
 8001950:	e0bff317 	ldw	r2,-52(fp)
 8001954:	e0bfe915 	stw	r2,-92(fp)
	ix &= 0x7fffffff;			/* ix = |x|'s high word*/
 8001958:	e0ffe917 	ldw	r3,-92(fp)
 800195c:	00a00034 	movhi	r2,32768
 8001960:	10bfffc4 	addi	r2,r2,-1
 8001964:	1884703a 	and	r2,r3,r2
 8001968:	e0bfe915 	stw	r2,-92(fp)
	if(ix<0x3e400000) {			/* if x < 2**27 */
 800196c:	e0ffe917 	ldw	r3,-92(fp)
 8001970:	008f9034 	movhi	r2,15936
 8001974:	1880070e 	bge	r3,r2,8001994 <__kernel_cos+0x8c>
	    if(((int)x)==0) return one;		/* generate inexact */
 8001978:	e13ff617 	ldw	r4,-40(fp)
 800197c:	e17ff717 	ldw	r5,-36(fp)
 8001980:	8005aec0 	call	8005aec <__fixdfsi>
 8001984:	1000031e 	bne	r2,zero,8001994 <__kernel_cos+0x8c>
 8001988:	0005883a 	mov	r2,zero
 800198c:	00cffc34 	movhi	r3,16368
 8001990:	00011b06 	br	8001e00 <__kernel_cos+0x4f8>
	}
	z  = x*x;
 8001994:	e1bff617 	ldw	r6,-40(fp)
 8001998:	e1fff717 	ldw	r7,-36(fp)
 800199c:	e13ff617 	ldw	r4,-40(fp)
 80019a0:	e17ff717 	ldw	r5,-36(fp)
 80019a4:	8004ad80 	call	8004ad8 <__muldf3>
 80019a8:	1009883a 	mov	r4,r2
 80019ac:	180b883a 	mov	r5,r3
 80019b0:	e13fea15 	stw	r4,-88(fp)
 80019b4:	e17feb15 	stw	r5,-84(fp)
	r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
 80019b8:	00afa234 	movhi	r2,48776
 80019bc:	108e3504 	addi	r2,r2,14548
 80019c0:	00ef6a74 	movhi	r3,48553
 80019c4:	18feba44 	addi	r3,r3,-1303
 80019c8:	e1bfea17 	ldw	r6,-88(fp)
 80019cc:	e1ffeb17 	ldw	r7,-84(fp)
 80019d0:	1009883a 	mov	r4,r2
 80019d4:	180b883a 	mov	r5,r3
 80019d8:	8004ad80 	call	8004ad8 <__muldf3>
 80019dc:	1009883a 	mov	r4,r2
 80019e0:	180b883a 	mov	r5,r3
 80019e4:	2011883a 	mov	r8,r4
 80019e8:	2813883a 	mov	r9,r5
 80019ec:	00af6d74 	movhi	r2,48565
 80019f0:	10ac7104 	addi	r2,r2,-20028
 80019f4:	00cf88b4 	movhi	r3,15906
 80019f8:	18fba784 	addi	r3,r3,-4450
 80019fc:	100d883a 	mov	r6,r2
 8001a00:	180f883a 	mov	r7,r3
 8001a04:	4009883a 	mov	r4,r8
 8001a08:	480b883a 	mov	r5,r9
 8001a0c:	80040c80 	call	80040c8 <__adddf3>
 8001a10:	1009883a 	mov	r4,r2
 8001a14:	180b883a 	mov	r5,r3
 8001a18:	2005883a 	mov	r2,r4
 8001a1c:	2807883a 	mov	r3,r5
 8001a20:	e1bfea17 	ldw	r6,-88(fp)
 8001a24:	e1ffeb17 	ldw	r7,-84(fp)
 8001a28:	1009883a 	mov	r4,r2
 8001a2c:	180b883a 	mov	r5,r3
 8001a30:	8004ad80 	call	8004ad8 <__muldf3>
 8001a34:	1009883a 	mov	r4,r2
 8001a38:	180b883a 	mov	r5,r3
 8001a3c:	2011883a 	mov	r8,r4
 8001a40:	2813883a 	mov	r9,r5
 8001a44:	00a02734 	movhi	r2,32924
 8001a48:	1094ab44 	addi	r2,r2,21165
 8001a4c:	00efa4b4 	movhi	r3,48786
 8001a50:	18df93c4 	addi	r3,r3,32335
 8001a54:	100d883a 	mov	r6,r2
 8001a58:	180f883a 	mov	r7,r3
 8001a5c:	4009883a 	mov	r4,r8
 8001a60:	480b883a 	mov	r5,r9
 8001a64:	80040c80 	call	80040c8 <__adddf3>
 8001a68:	1009883a 	mov	r4,r2
 8001a6c:	180b883a 	mov	r5,r3
 8001a70:	2005883a 	mov	r2,r4
 8001a74:	2807883a 	mov	r3,r5
 8001a78:	e1bfea17 	ldw	r6,-88(fp)
 8001a7c:	e1ffeb17 	ldw	r7,-84(fp)
 8001a80:	1009883a 	mov	r4,r2
 8001a84:	180b883a 	mov	r5,r3
 8001a88:	8004ad80 	call	8004ad8 <__muldf3>
 8001a8c:	1009883a 	mov	r4,r2
 8001a90:	180b883a 	mov	r5,r3
 8001a94:	2011883a 	mov	r8,r4
 8001a98:	2813883a 	mov	r9,r5
 8001a9c:	008672f4 	movhi	r2,6603
 8001aa0:	10856404 	addi	r2,r2,5520
 8001aa4:	00cfbeb4 	movhi	r3,16122
 8001aa8:	18c06804 	addi	r3,r3,416
 8001aac:	100d883a 	mov	r6,r2
 8001ab0:	180f883a 	mov	r7,r3
 8001ab4:	4009883a 	mov	r4,r8
 8001ab8:	480b883a 	mov	r5,r9
 8001abc:	80040c80 	call	80040c8 <__adddf3>
 8001ac0:	1009883a 	mov	r4,r2
 8001ac4:	180b883a 	mov	r5,r3
 8001ac8:	2005883a 	mov	r2,r4
 8001acc:	2807883a 	mov	r3,r5
 8001ad0:	e1bfea17 	ldw	r6,-88(fp)
 8001ad4:	e1ffeb17 	ldw	r7,-84(fp)
 8001ad8:	1009883a 	mov	r4,r2
 8001adc:	180b883a 	mov	r5,r3
 8001ae0:	8004ad80 	call	8004ad8 <__muldf3>
 8001ae4:	1009883a 	mov	r4,r2
 8001ae8:	180b883a 	mov	r5,r3
 8001aec:	2011883a 	mov	r8,r4
 8001af0:	2813883a 	mov	r9,r5
 8001af4:	0085b074 	movhi	r2,5825
 8001af8:	10945dc4 	addi	r2,r2,20855
 8001afc:	00efd5f4 	movhi	r3,48983
 8001b00:	18f05b04 	addi	r3,r3,-16020
 8001b04:	100d883a 	mov	r6,r2
 8001b08:	180f883a 	mov	r7,r3
 8001b0c:	4009883a 	mov	r4,r8
 8001b10:	480b883a 	mov	r5,r9
 8001b14:	80040c80 	call	80040c8 <__adddf3>
 8001b18:	1009883a 	mov	r4,r2
 8001b1c:	180b883a 	mov	r5,r3
 8001b20:	2005883a 	mov	r2,r4
 8001b24:	2807883a 	mov	r3,r5
 8001b28:	e1bfea17 	ldw	r6,-88(fp)
 8001b2c:	e1ffeb17 	ldw	r7,-84(fp)
 8001b30:	1009883a 	mov	r4,r2
 8001b34:	180b883a 	mov	r5,r3
 8001b38:	8004ad80 	call	8004ad8 <__muldf3>
 8001b3c:	1009883a 	mov	r4,r2
 8001b40:	180b883a 	mov	r5,r3
 8001b44:	2011883a 	mov	r8,r4
 8001b48:	2813883a 	mov	r9,r5
 8001b4c:	00955574 	movhi	r2,21845
 8001b50:	10955304 	addi	r2,r2,21836
 8001b54:	00cfe974 	movhi	r3,16293
 8001b58:	18d55544 	addi	r3,r3,21845
 8001b5c:	100d883a 	mov	r6,r2
 8001b60:	180f883a 	mov	r7,r3
 8001b64:	4009883a 	mov	r4,r8
 8001b68:	480b883a 	mov	r5,r9
 8001b6c:	80040c80 	call	80040c8 <__adddf3>
 8001b70:	1009883a 	mov	r4,r2
 8001b74:	180b883a 	mov	r5,r3
 8001b78:	2005883a 	mov	r2,r4
 8001b7c:	2807883a 	mov	r3,r5
 8001b80:	e1bfea17 	ldw	r6,-88(fp)
 8001b84:	e1ffeb17 	ldw	r7,-84(fp)
 8001b88:	1009883a 	mov	r4,r2
 8001b8c:	180b883a 	mov	r5,r3
 8001b90:	8004ad80 	call	8004ad8 <__muldf3>
 8001b94:	1009883a 	mov	r4,r2
 8001b98:	180b883a 	mov	r5,r3
 8001b9c:	e13fec15 	stw	r4,-80(fp)
 8001ba0:	e17fed15 	stw	r5,-76(fp)
	if(ix < 0x3FD33333) 			/* if |x| < 0.3 */ 
 8001ba4:	e0ffe917 	ldw	r3,-92(fp)
 8001ba8:	008ff4f4 	movhi	r2,16339
 8001bac:	108ccc84 	addi	r2,r2,13106
 8001bb0:	10c03916 	blt	r2,r3,8001c98 <__kernel_cos+0x390>
	    return one - (0.5*z - (z*r - x*y));
 8001bb4:	0021883a 	mov	r16,zero
 8001bb8:	044ffc34 	movhi	r17,16368
 8001bbc:	000d883a 	mov	r6,zero
 8001bc0:	01cff834 	movhi	r7,16352
 8001bc4:	e13fea17 	ldw	r4,-88(fp)
 8001bc8:	e17feb17 	ldw	r5,-84(fp)
 8001bcc:	8004ad80 	call	8004ad8 <__muldf3>
 8001bd0:	1009883a 	mov	r4,r2
 8001bd4:	180b883a 	mov	r5,r3
 8001bd8:	2025883a 	mov	r18,r4
 8001bdc:	2827883a 	mov	r19,r5
 8001be0:	e1bfec17 	ldw	r6,-80(fp)
 8001be4:	e1ffed17 	ldw	r7,-76(fp)
 8001be8:	e13fea17 	ldw	r4,-88(fp)
 8001bec:	e17feb17 	ldw	r5,-84(fp)
 8001bf0:	8004ad80 	call	8004ad8 <__muldf3>
 8001bf4:	1009883a 	mov	r4,r2
 8001bf8:	180b883a 	mov	r5,r3
 8001bfc:	2029883a 	mov	r20,r4
 8001c00:	282b883a 	mov	r21,r5
 8001c04:	e1bff817 	ldw	r6,-32(fp)
 8001c08:	e1fff917 	ldw	r7,-28(fp)
 8001c0c:	e13ff617 	ldw	r4,-40(fp)
 8001c10:	e17ff717 	ldw	r5,-36(fp)
 8001c14:	8004ad80 	call	8004ad8 <__muldf3>
 8001c18:	1009883a 	mov	r4,r2
 8001c1c:	180b883a 	mov	r5,r3
 8001c20:	2005883a 	mov	r2,r4
 8001c24:	2807883a 	mov	r3,r5
 8001c28:	100d883a 	mov	r6,r2
 8001c2c:	180f883a 	mov	r7,r3
 8001c30:	a009883a 	mov	r4,r20
 8001c34:	a80b883a 	mov	r5,r21
 8001c38:	80051f00 	call	80051f0 <__subdf3>
 8001c3c:	1009883a 	mov	r4,r2
 8001c40:	180b883a 	mov	r5,r3
 8001c44:	2005883a 	mov	r2,r4
 8001c48:	2807883a 	mov	r3,r5
 8001c4c:	100d883a 	mov	r6,r2
 8001c50:	180f883a 	mov	r7,r3
 8001c54:	9009883a 	mov	r4,r18
 8001c58:	980b883a 	mov	r5,r19
 8001c5c:	80051f00 	call	80051f0 <__subdf3>
 8001c60:	1009883a 	mov	r4,r2
 8001c64:	180b883a 	mov	r5,r3
 8001c68:	2005883a 	mov	r2,r4
 8001c6c:	2807883a 	mov	r3,r5
 8001c70:	100d883a 	mov	r6,r2
 8001c74:	180f883a 	mov	r7,r3
 8001c78:	8009883a 	mov	r4,r16
 8001c7c:	880b883a 	mov	r5,r17
 8001c80:	80051f00 	call	80051f0 <__subdf3>
 8001c84:	1009883a 	mov	r4,r2
 8001c88:	180b883a 	mov	r5,r3
 8001c8c:	2005883a 	mov	r2,r4
 8001c90:	2807883a 	mov	r3,r5
 8001c94:	00005a06 	br	8001e00 <__kernel_cos+0x4f8>
	else {
	    if(ix > 0x3fe90000) {		/* x > 0.78125 */
 8001c98:	e0bfe917 	ldw	r2,-92(fp)
 8001c9c:	00cffa74 	movhi	r3,16361
 8001ca0:	1880040e 	bge	r3,r2,8001cb4 <__kernel_cos+0x3ac>
		qx = 0.28125;
 8001ca4:	e03fe715 	stw	zero,-100(fp)
 8001ca8:	008ff4b4 	movhi	r2,16338
 8001cac:	e0bfe815 	stw	r2,-96(fp)
 8001cb0:	00000906 	br	8001cd8 <__kernel_cos+0x3d0>
	    } else {
	        INSERT_WORDS(qx,ix-0x00200000,0);	/* x/4 */
 8001cb4:	e0ffe917 	ldw	r3,-92(fp)
 8001cb8:	00bff834 	movhi	r2,65504
 8001cbc:	1885883a 	add	r2,r3,r2
 8001cc0:	e0bff515 	stw	r2,-44(fp)
 8001cc4:	e03ff415 	stw	zero,-48(fp)
 8001cc8:	e0bff417 	ldw	r2,-48(fp)
 8001ccc:	e0bfe715 	stw	r2,-100(fp)
 8001cd0:	e0bff517 	ldw	r2,-44(fp)
 8001cd4:	e0bfe815 	stw	r2,-96(fp)
	    }
	    hz = 0.5*z-qx;
 8001cd8:	000d883a 	mov	r6,zero
 8001cdc:	01cff834 	movhi	r7,16352
 8001ce0:	e13fea17 	ldw	r4,-88(fp)
 8001ce4:	e17feb17 	ldw	r5,-84(fp)
 8001ce8:	8004ad80 	call	8004ad8 <__muldf3>
 8001cec:	1009883a 	mov	r4,r2
 8001cf0:	180b883a 	mov	r5,r3
 8001cf4:	2005883a 	mov	r2,r4
 8001cf8:	2807883a 	mov	r3,r5
 8001cfc:	e1bfe717 	ldw	r6,-100(fp)
 8001d00:	e1ffe817 	ldw	r7,-96(fp)
 8001d04:	1009883a 	mov	r4,r2
 8001d08:	180b883a 	mov	r5,r3
 8001d0c:	80051f00 	call	80051f0 <__subdf3>
 8001d10:	1009883a 	mov	r4,r2
 8001d14:	180b883a 	mov	r5,r3
 8001d18:	e13fee15 	stw	r4,-72(fp)
 8001d1c:	e17fef15 	stw	r5,-68(fp)
	    a  = one-qx;
 8001d20:	0005883a 	mov	r2,zero
 8001d24:	00cffc34 	movhi	r3,16368
 8001d28:	e1bfe717 	ldw	r6,-100(fp)
 8001d2c:	e1ffe817 	ldw	r7,-96(fp)
 8001d30:	1009883a 	mov	r4,r2
 8001d34:	180b883a 	mov	r5,r3
 8001d38:	80051f00 	call	80051f0 <__subdf3>
 8001d3c:	1009883a 	mov	r4,r2
 8001d40:	180b883a 	mov	r5,r3
 8001d44:	e13ff015 	stw	r4,-64(fp)
 8001d48:	e17ff115 	stw	r5,-60(fp)
	    return a - (hz - (z*r-x*y));
 8001d4c:	e1bfec17 	ldw	r6,-80(fp)
 8001d50:	e1ffed17 	ldw	r7,-76(fp)
 8001d54:	e13fea17 	ldw	r4,-88(fp)
 8001d58:	e17feb17 	ldw	r5,-84(fp)
 8001d5c:	8004ad80 	call	8004ad8 <__muldf3>
 8001d60:	1009883a 	mov	r4,r2
 8001d64:	180b883a 	mov	r5,r3
 8001d68:	2021883a 	mov	r16,r4
 8001d6c:	2823883a 	mov	r17,r5
 8001d70:	e1bff817 	ldw	r6,-32(fp)
 8001d74:	e1fff917 	ldw	r7,-28(fp)
 8001d78:	e13ff617 	ldw	r4,-40(fp)
 8001d7c:	e17ff717 	ldw	r5,-36(fp)
 8001d80:	8004ad80 	call	8004ad8 <__muldf3>
 8001d84:	1009883a 	mov	r4,r2
 8001d88:	180b883a 	mov	r5,r3
 8001d8c:	2005883a 	mov	r2,r4
 8001d90:	2807883a 	mov	r3,r5
 8001d94:	100d883a 	mov	r6,r2
 8001d98:	180f883a 	mov	r7,r3
 8001d9c:	8009883a 	mov	r4,r16
 8001da0:	880b883a 	mov	r5,r17
 8001da4:	80051f00 	call	80051f0 <__subdf3>
 8001da8:	1009883a 	mov	r4,r2
 8001dac:	180b883a 	mov	r5,r3
 8001db0:	2005883a 	mov	r2,r4
 8001db4:	2807883a 	mov	r3,r5
 8001db8:	100d883a 	mov	r6,r2
 8001dbc:	180f883a 	mov	r7,r3
 8001dc0:	e13fee17 	ldw	r4,-72(fp)
 8001dc4:	e17fef17 	ldw	r5,-68(fp)
 8001dc8:	80051f00 	call	80051f0 <__subdf3>
 8001dcc:	1009883a 	mov	r4,r2
 8001dd0:	180b883a 	mov	r5,r3
 8001dd4:	2005883a 	mov	r2,r4
 8001dd8:	2807883a 	mov	r3,r5
 8001ddc:	100d883a 	mov	r6,r2
 8001de0:	180f883a 	mov	r7,r3
 8001de4:	e13ff017 	ldw	r4,-64(fp)
 8001de8:	e17ff117 	ldw	r5,-60(fp)
 8001dec:	80051f00 	call	80051f0 <__subdf3>
 8001df0:	1009883a 	mov	r4,r2
 8001df4:	180b883a 	mov	r5,r3
 8001df8:	2005883a 	mov	r2,r4
 8001dfc:	2807883a 	mov	r3,r5
 8001e00:	1009883a 	mov	r4,r2
 8001e04:	180b883a 	mov	r5,r3
	}
}
 8001e08:	2005883a 	mov	r2,r4
 8001e0c:	2807883a 	mov	r3,r5
 8001e10:	e6fffa04 	addi	sp,fp,-24
 8001e14:	dfc00717 	ldw	ra,28(sp)
 8001e18:	df000617 	ldw	fp,24(sp)
 8001e1c:	dd400517 	ldw	r21,20(sp)
 8001e20:	dd000417 	ldw	r20,16(sp)
 8001e24:	dcc00317 	ldw	r19,12(sp)
 8001e28:	dc800217 	ldw	r18,8(sp)
 8001e2c:	dc400117 	ldw	r17,4(sp)
 8001e30:	dc000017 	ldw	r16,0(sp)
 8001e34:	dec00804 	addi	sp,sp,32
 8001e38:	f800283a 	ret

08001e3c <__kernel_rem_pio2>:
	int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const __int32_t *ipio2) 
#else
	int __kernel_rem_pio2(x,y,e0,nx,prec,ipio2) 	
	double x[], y[]; int e0,nx,prec; __int32_t ipio2[];
#endif
{
 8001e3c:	deff5004 	addi	sp,sp,-704
 8001e40:	dfc0af15 	stw	ra,700(sp)
 8001e44:	df00ae15 	stw	fp,696(sp)
 8001e48:	ddc0ad15 	stw	r23,692(sp)
 8001e4c:	dd80ac15 	stw	r22,688(sp)
 8001e50:	dd40ab15 	stw	r21,684(sp)
 8001e54:	dd00aa15 	stw	r20,680(sp)
 8001e58:	dcc0a915 	stw	r19,676(sp)
 8001e5c:	dc80a815 	stw	r18,672(sp)
 8001e60:	dc40a715 	stw	r17,668(sp)
 8001e64:	dc00a615 	stw	r16,664(sp)
 8001e68:	df00ae04 	addi	fp,sp,696
 8001e6c:	e13fef15 	stw	r4,-68(fp)
 8001e70:	e17ff015 	stw	r5,-64(fp)
 8001e74:	e1bff115 	stw	r6,-60(fp)
 8001e78:	e1fff215 	stw	r7,-56(fp)
	__int32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
	double z,fw,f[20],fq[20],q[20];

    /* initialize jk*/
	jk = init_jk[prec];
 8001e7c:	00820134 	movhi	r2,2052
 8001e80:	10991204 	addi	r2,r2,25672
 8001e84:	e0c00217 	ldw	r3,8(fp)
 8001e88:	18c7883a 	add	r3,r3,r3
 8001e8c:	18c7883a 	add	r3,r3,r3
 8001e90:	10c5883a 	add	r2,r2,r3
 8001e94:	10800017 	ldw	r2,0(r2)
 8001e98:	e0bf5f15 	stw	r2,-644(fp)
	jp = jk;
 8001e9c:	e0bf5f17 	ldw	r2,-644(fp)
 8001ea0:	e0bf6015 	stw	r2,-640(fp)

    /* determine jx,jv,q0, note that 3>q0 */
	jx =  nx-1;
 8001ea4:	e0bff217 	ldw	r2,-56(fp)
 8001ea8:	10bfffc4 	addi	r2,r2,-1
 8001eac:	e0bf6115 	stw	r2,-636(fp)
	jv = (e0-3)/24; if(jv<0) jv=0;
 8001eb0:	e0bff117 	ldw	r2,-60(fp)
 8001eb4:	10bfff44 	addi	r2,r2,-3
 8001eb8:	01400604 	movi	r5,24
 8001ebc:	1009883a 	mov	r4,r2
 8001ec0:	8003f140 	call	8003f14 <__divsi3>
 8001ec4:	e0bf5315 	stw	r2,-692(fp)
 8001ec8:	e0bf5317 	ldw	r2,-692(fp)
 8001ecc:	1000010e 	bge	r2,zero,8001ed4 <__kernel_rem_pio2+0x98>
 8001ed0:	e03f5315 	stw	zero,-692(fp)
	q0 =  e0-24*(jv+1);
 8001ed4:	e0bf5317 	ldw	r2,-692(fp)
 8001ed8:	10800044 	addi	r2,r2,1
 8001edc:	10fffa24 	muli	r3,r2,-24
 8001ee0:	e0bff117 	ldw	r2,-60(fp)
 8001ee4:	1885883a 	add	r2,r3,r2
 8001ee8:	e0bf5915 	stw	r2,-668(fp)

    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
 8001eec:	e0ff5317 	ldw	r3,-692(fp)
 8001ef0:	e0bf6117 	ldw	r2,-636(fp)
 8001ef4:	1885c83a 	sub	r2,r3,r2
 8001ef8:	e0bf5715 	stw	r2,-676(fp)
 8001efc:	e0ff6117 	ldw	r3,-636(fp)
 8001f00:	e0bf5f17 	ldw	r2,-644(fp)
 8001f04:	1885883a 	add	r2,r3,r2
 8001f08:	e0bf6215 	stw	r2,-632(fp)
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];
 8001f0c:	e03f5615 	stw	zero,-680(fp)
 8001f10:	00001d06 	br	8001f88 <__kernel_rem_pio2+0x14c>
 8001f14:	e0bf5717 	ldw	r2,-676(fp)
 8001f18:	10000c16 	blt	r2,zero,8001f4c <__kernel_rem_pio2+0x110>
 8001f1c:	e0bf5717 	ldw	r2,-676(fp)
 8001f20:	1085883a 	add	r2,r2,r2
 8001f24:	1085883a 	add	r2,r2,r2
 8001f28:	1007883a 	mov	r3,r2
 8001f2c:	e0800317 	ldw	r2,12(fp)
 8001f30:	10c5883a 	add	r2,r2,r3
 8001f34:	10800017 	ldw	r2,0(r2)
 8001f38:	1009883a 	mov	r4,r2
 8001f3c:	8005b6c0 	call	8005b6c <__floatsidf>
 8001f40:	1009883a 	mov	r4,r2
 8001f44:	180b883a 	mov	r5,r3
 8001f48:	00000206 	br	8001f54 <__kernel_rem_pio2+0x118>
 8001f4c:	0009883a 	mov	r4,zero
 8001f50:	000b883a 	mov	r5,zero
 8001f54:	e0bf5617 	ldw	r2,-680(fp)
 8001f58:	100490fa 	slli	r2,r2,3
 8001f5c:	e0ff5204 	addi	r3,fp,-696
 8001f60:	1885883a 	add	r2,r3,r2
 8001f64:	10802504 	addi	r2,r2,148
 8001f68:	11000015 	stw	r4,0(r2)
 8001f6c:	11400115 	stw	r5,4(r2)
 8001f70:	e0bf5617 	ldw	r2,-680(fp)
 8001f74:	10800044 	addi	r2,r2,1
 8001f78:	e0bf5615 	stw	r2,-680(fp)
 8001f7c:	e0bf5717 	ldw	r2,-676(fp)
 8001f80:	10800044 	addi	r2,r2,1
 8001f84:	e0bf5715 	stw	r2,-676(fp)
 8001f88:	e0bf5617 	ldw	r2,-680(fp)
 8001f8c:	e0ff6217 	ldw	r3,-632(fp)
 8001f90:	18bfe00e 	bge	r3,r2,8001f14 <__kernel_rem_pio2+0xd8>

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
 8001f94:	e03f5615 	stw	zero,-680(fp)
 8001f98:	00003906 	br	8002080 <__kernel_rem_pio2+0x244>
	    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
 8001f9c:	e03f5715 	stw	zero,-676(fp)
 8001fa0:	e03f5d15 	stw	zero,-652(fp)
 8001fa4:	e03f5e15 	stw	zero,-648(fp)
 8001fa8:	00002606 	br	8002044 <__kernel_rem_pio2+0x208>
 8001fac:	e0bf5717 	ldw	r2,-676(fp)
 8001fb0:	100490fa 	slli	r2,r2,3
 8001fb4:	e0ffef17 	ldw	r3,-68(fp)
 8001fb8:	1889883a 	add	r4,r3,r2
 8001fbc:	20800017 	ldw	r2,0(r4)
 8001fc0:	20c00117 	ldw	r3,4(r4)
 8001fc4:	e17f6117 	ldw	r5,-636(fp)
 8001fc8:	e13f5617 	ldw	r4,-680(fp)
 8001fcc:	290b883a 	add	r5,r5,r4
 8001fd0:	e13f5717 	ldw	r4,-676(fp)
 8001fd4:	2909c83a 	sub	r4,r5,r4
 8001fd8:	200890fa 	slli	r4,r4,3
 8001fdc:	e17f5204 	addi	r5,fp,-696
 8001fe0:	2909883a 	add	r4,r5,r4
 8001fe4:	21802504 	addi	r6,r4,148
 8001fe8:	31000017 	ldw	r4,0(r6)
 8001fec:	31400117 	ldw	r5,4(r6)
 8001ff0:	200d883a 	mov	r6,r4
 8001ff4:	280f883a 	mov	r7,r5
 8001ff8:	1009883a 	mov	r4,r2
 8001ffc:	180b883a 	mov	r5,r3
 8002000:	8004ad80 	call	8004ad8 <__muldf3>
 8002004:	1009883a 	mov	r4,r2
 8002008:	180b883a 	mov	r5,r3
 800200c:	2005883a 	mov	r2,r4
 8002010:	2807883a 	mov	r3,r5
 8002014:	100d883a 	mov	r6,r2
 8002018:	180f883a 	mov	r7,r3
 800201c:	e13f5d17 	ldw	r4,-652(fp)
 8002020:	e17f5e17 	ldw	r5,-648(fp)
 8002024:	80040c80 	call	80040c8 <__adddf3>
 8002028:	1009883a 	mov	r4,r2
 800202c:	180b883a 	mov	r5,r3
 8002030:	e13f5d15 	stw	r4,-652(fp)
 8002034:	e17f5e15 	stw	r5,-648(fp)
 8002038:	e0bf5717 	ldw	r2,-676(fp)
 800203c:	10800044 	addi	r2,r2,1
 8002040:	e0bf5715 	stw	r2,-676(fp)
 8002044:	e0bf5717 	ldw	r2,-676(fp)
 8002048:	e0ff6117 	ldw	r3,-636(fp)
 800204c:	18bfd70e 	bge	r3,r2,8001fac <__kernel_rem_pio2+0x170>
 8002050:	e0bf5617 	ldw	r2,-680(fp)
 8002054:	100490fa 	slli	r2,r2,3
 8002058:	e0ff5204 	addi	r3,fp,-696
 800205c:	1885883a 	add	r2,r3,r2
 8002060:	10807504 	addi	r2,r2,468
 8002064:	e0ff5d17 	ldw	r3,-652(fp)
 8002068:	10c00015 	stw	r3,0(r2)
 800206c:	e0ff5e17 	ldw	r3,-648(fp)
 8002070:	10c00115 	stw	r3,4(r2)
    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
 8002074:	e0bf5617 	ldw	r2,-680(fp)
 8002078:	10800044 	addi	r2,r2,1
 800207c:	e0bf5615 	stw	r2,-680(fp)
 8002080:	e0bf5617 	ldw	r2,-680(fp)
 8002084:	e0ff5f17 	ldw	r3,-644(fp)
 8002088:	18bfc40e 	bge	r3,r2,8001f9c <__kernel_rem_pio2+0x160>
	    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
	}

	jz = jk;
 800208c:	e0bf5f17 	ldw	r2,-644(fp)
 8002090:	e0bf5215 	stw	r2,-696(fp)
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
 8002094:	e03f5615 	stw	zero,-680(fp)
 8002098:	e0bf5217 	ldw	r2,-696(fp)
 800209c:	e0bf5715 	stw	r2,-676(fp)
 80020a0:	e0bf5217 	ldw	r2,-696(fp)
 80020a4:	100490fa 	slli	r2,r2,3
 80020a8:	e13f5204 	addi	r4,fp,-696
 80020ac:	2085883a 	add	r2,r4,r2
 80020b0:	10807504 	addi	r2,r2,468
 80020b4:	10c00017 	ldw	r3,0(r2)
 80020b8:	e0ff5b15 	stw	r3,-660(fp)
 80020bc:	10800117 	ldw	r2,4(r2)
 80020c0:	e0bf5c15 	stw	r2,-656(fp)
 80020c4:	00004a06 	br	80021f0 <__kernel_rem_pio2+0x3b4>
	    fw    =  (double)((__int32_t)(twon24* z));
 80020c8:	0005883a 	mov	r2,zero
 80020cc:	00cf9c34 	movhi	r3,15984
 80020d0:	e1bf5b17 	ldw	r6,-660(fp)
 80020d4:	e1ff5c17 	ldw	r7,-656(fp)
 80020d8:	1009883a 	mov	r4,r2
 80020dc:	180b883a 	mov	r5,r3
 80020e0:	8004ad80 	call	8004ad8 <__muldf3>
 80020e4:	1009883a 	mov	r4,r2
 80020e8:	180b883a 	mov	r5,r3
 80020ec:	2005883a 	mov	r2,r4
 80020f0:	2807883a 	mov	r3,r5
 80020f4:	1009883a 	mov	r4,r2
 80020f8:	180b883a 	mov	r5,r3
 80020fc:	8005aec0 	call	8005aec <__fixdfsi>
 8002100:	1009883a 	mov	r4,r2
 8002104:	8005b6c0 	call	8005b6c <__floatsidf>
 8002108:	1009883a 	mov	r4,r2
 800210c:	180b883a 	mov	r5,r3
 8002110:	e13f5d15 	stw	r4,-652(fp)
 8002114:	e17f5e15 	stw	r5,-648(fp)
	    iq[i] =  (__int32_t)(z-two24*fw);
 8002118:	0005883a 	mov	r2,zero
 800211c:	00d05c34 	movhi	r3,16752
 8002120:	e1bf5d17 	ldw	r6,-652(fp)
 8002124:	e1ff5e17 	ldw	r7,-648(fp)
 8002128:	1009883a 	mov	r4,r2
 800212c:	180b883a 	mov	r5,r3
 8002130:	8004ad80 	call	8004ad8 <__muldf3>
 8002134:	1009883a 	mov	r4,r2
 8002138:	180b883a 	mov	r5,r3
 800213c:	2005883a 	mov	r2,r4
 8002140:	2807883a 	mov	r3,r5
 8002144:	100d883a 	mov	r6,r2
 8002148:	180f883a 	mov	r7,r3
 800214c:	e13f5b17 	ldw	r4,-660(fp)
 8002150:	e17f5c17 	ldw	r5,-656(fp)
 8002154:	80051f00 	call	80051f0 <__subdf3>
 8002158:	1009883a 	mov	r4,r2
 800215c:	180b883a 	mov	r5,r3
 8002160:	2005883a 	mov	r2,r4
 8002164:	2807883a 	mov	r3,r5
 8002168:	1009883a 	mov	r4,r2
 800216c:	180b883a 	mov	r5,r3
 8002170:	8005aec0 	call	8005aec <__fixdfsi>
 8002174:	1007883a 	mov	r3,r2
 8002178:	e0bf5617 	ldw	r2,-680(fp)
 800217c:	1085883a 	add	r2,r2,r2
 8002180:	1085883a 	add	r2,r2,r2
 8002184:	e17f5204 	addi	r5,fp,-696
 8002188:	2885883a 	add	r2,r5,r2
 800218c:	10801104 	addi	r2,r2,68
 8002190:	10c00015 	stw	r3,0(r2)
	    z     =  q[j-1]+fw;
 8002194:	e0bf5717 	ldw	r2,-676(fp)
 8002198:	10bfffc4 	addi	r2,r2,-1
 800219c:	100490fa 	slli	r2,r2,3
 80021a0:	e0ff5204 	addi	r3,fp,-696
 80021a4:	1885883a 	add	r2,r3,r2
 80021a8:	11007504 	addi	r4,r2,468
 80021ac:	20800017 	ldw	r2,0(r4)
 80021b0:	20c00117 	ldw	r3,4(r4)
 80021b4:	e1bf5d17 	ldw	r6,-652(fp)
 80021b8:	e1ff5e17 	ldw	r7,-648(fp)
 80021bc:	1009883a 	mov	r4,r2
 80021c0:	180b883a 	mov	r5,r3
 80021c4:	80040c80 	call	80040c8 <__adddf3>
 80021c8:	1009883a 	mov	r4,r2
 80021cc:	180b883a 	mov	r5,r3
 80021d0:	e13f5b15 	stw	r4,-660(fp)
 80021d4:	e17f5c15 	stw	r5,-656(fp)
	}

	jz = jk;
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
 80021d8:	e0bf5617 	ldw	r2,-680(fp)
 80021dc:	10800044 	addi	r2,r2,1
 80021e0:	e0bf5615 	stw	r2,-680(fp)
 80021e4:	e0bf5717 	ldw	r2,-676(fp)
 80021e8:	10bfffc4 	addi	r2,r2,-1
 80021ec:	e0bf5715 	stw	r2,-676(fp)
 80021f0:	e0bf5717 	ldw	r2,-676(fp)
 80021f4:	00bfb416 	blt	zero,r2,80020c8 <__kernel_rem_pio2+0x28c>
	    iq[i] =  (__int32_t)(z-two24*fw);
	    z     =  q[j-1]+fw;
	}

    /* compute n */
	z  = scalbn(z,(int)q0);		/* actual value of z */
 80021f8:	e1bf5917 	ldw	r6,-668(fp)
 80021fc:	e13f5b17 	ldw	r4,-660(fp)
 8002200:	e17f5c17 	ldw	r5,-656(fp)
 8002204:	8003a440 	call	8003a44 <scalbn>
 8002208:	e0bf5b15 	stw	r2,-660(fp)
 800220c:	e0ff5c15 	stw	r3,-656(fp)
	z -= 8.0*floor(z*0.125);		/* trim off integer >= 8 */
 8002210:	000d883a 	mov	r6,zero
 8002214:	01cff034 	movhi	r7,16320
 8002218:	e13f5b17 	ldw	r4,-660(fp)
 800221c:	e17f5c17 	ldw	r5,-656(fp)
 8002220:	8004ad80 	call	8004ad8 <__muldf3>
 8002224:	1009883a 	mov	r4,r2
 8002228:	180b883a 	mov	r5,r3
 800222c:	2005883a 	mov	r2,r4
 8002230:	2807883a 	mov	r3,r5
 8002234:	1009883a 	mov	r4,r2
 8002238:	180b883a 	mov	r5,r3
 800223c:	80037000 	call	8003700 <floor>
 8002240:	1011883a 	mov	r8,r2
 8002244:	1813883a 	mov	r9,r3
 8002248:	000d883a 	mov	r6,zero
 800224c:	01d00834 	movhi	r7,16416
 8002250:	4009883a 	mov	r4,r8
 8002254:	480b883a 	mov	r5,r9
 8002258:	8004ad80 	call	8004ad8 <__muldf3>
 800225c:	1009883a 	mov	r4,r2
 8002260:	180b883a 	mov	r5,r3
 8002264:	2005883a 	mov	r2,r4
 8002268:	2807883a 	mov	r3,r5
 800226c:	100d883a 	mov	r6,r2
 8002270:	180f883a 	mov	r7,r3
 8002274:	e13f5b17 	ldw	r4,-660(fp)
 8002278:	e17f5c17 	ldw	r5,-656(fp)
 800227c:	80051f00 	call	80051f0 <__subdf3>
 8002280:	1009883a 	mov	r4,r2
 8002284:	180b883a 	mov	r5,r3
 8002288:	e13f5b15 	stw	r4,-660(fp)
 800228c:	e17f5c15 	stw	r5,-656(fp)
	n  = (__int32_t) z;
 8002290:	e13f5b17 	ldw	r4,-660(fp)
 8002294:	e17f5c17 	ldw	r5,-656(fp)
 8002298:	8005aec0 	call	8005aec <__fixdfsi>
 800229c:	e0bf5515 	stw	r2,-684(fp)
	z -= (double)n;
 80022a0:	e13f5517 	ldw	r4,-684(fp)
 80022a4:	8005b6c0 	call	8005b6c <__floatsidf>
 80022a8:	1009883a 	mov	r4,r2
 80022ac:	180b883a 	mov	r5,r3
 80022b0:	200d883a 	mov	r6,r4
 80022b4:	280f883a 	mov	r7,r5
 80022b8:	e13f5b17 	ldw	r4,-660(fp)
 80022bc:	e17f5c17 	ldw	r5,-656(fp)
 80022c0:	80051f00 	call	80051f0 <__subdf3>
 80022c4:	1009883a 	mov	r4,r2
 80022c8:	180b883a 	mov	r5,r3
 80022cc:	e13f5b15 	stw	r4,-660(fp)
 80022d0:	e17f5c15 	stw	r5,-656(fp)
	ih = 0;
 80022d4:	e03f5a15 	stw	zero,-664(fp)
	if(q0>0) {	/* need iq[jz-1] to determine n */
 80022d8:	e0bf5917 	ldw	r2,-668(fp)
 80022dc:	0080350e 	bge	zero,r2,80023b4 <__kernel_rem_pio2+0x578>
	    i  = (iq[jz-1]>>(24-q0)); n += i;
 80022e0:	e0bf5217 	ldw	r2,-696(fp)
 80022e4:	10bfffc4 	addi	r2,r2,-1
 80022e8:	1085883a 	add	r2,r2,r2
 80022ec:	1085883a 	add	r2,r2,r2
 80022f0:	e13f5204 	addi	r4,fp,-696
 80022f4:	2085883a 	add	r2,r4,r2
 80022f8:	10801104 	addi	r2,r2,68
 80022fc:	10c00017 	ldw	r3,0(r2)
 8002300:	01000604 	movi	r4,24
 8002304:	e0bf5917 	ldw	r2,-668(fp)
 8002308:	2085c83a 	sub	r2,r4,r2
 800230c:	1885d83a 	sra	r2,r3,r2
 8002310:	e0bf5615 	stw	r2,-680(fp)
 8002314:	e0ff5517 	ldw	r3,-684(fp)
 8002318:	e0bf5617 	ldw	r2,-680(fp)
 800231c:	1885883a 	add	r2,r3,r2
 8002320:	e0bf5515 	stw	r2,-684(fp)
	    iq[jz-1] -= i<<(24-q0);
 8002324:	e0bf5217 	ldw	r2,-696(fp)
 8002328:	10bfffc4 	addi	r2,r2,-1
 800232c:	e0ff5217 	ldw	r3,-696(fp)
 8002330:	18ffffc4 	addi	r3,r3,-1
 8002334:	18c7883a 	add	r3,r3,r3
 8002338:	18c7883a 	add	r3,r3,r3
 800233c:	e17f5204 	addi	r5,fp,-696
 8002340:	28c7883a 	add	r3,r5,r3
 8002344:	18c01104 	addi	r3,r3,68
 8002348:	19000017 	ldw	r4,0(r3)
 800234c:	01400604 	movi	r5,24
 8002350:	e0ff5917 	ldw	r3,-668(fp)
 8002354:	28c7c83a 	sub	r3,r5,r3
 8002358:	e17f5617 	ldw	r5,-680(fp)
 800235c:	28c6983a 	sll	r3,r5,r3
 8002360:	20c7c83a 	sub	r3,r4,r3
 8002364:	1085883a 	add	r2,r2,r2
 8002368:	1085883a 	add	r2,r2,r2
 800236c:	e13f5204 	addi	r4,fp,-696
 8002370:	2085883a 	add	r2,r4,r2
 8002374:	10801104 	addi	r2,r2,68
 8002378:	10c00015 	stw	r3,0(r2)
	    ih = iq[jz-1]>>(23-q0);
 800237c:	e0bf5217 	ldw	r2,-696(fp)
 8002380:	10bfffc4 	addi	r2,r2,-1
 8002384:	1085883a 	add	r2,r2,r2
 8002388:	1085883a 	add	r2,r2,r2
 800238c:	e17f5204 	addi	r5,fp,-696
 8002390:	2885883a 	add	r2,r5,r2
 8002394:	10801104 	addi	r2,r2,68
 8002398:	10c00017 	ldw	r3,0(r2)
 800239c:	010005c4 	movi	r4,23
 80023a0:	e0bf5917 	ldw	r2,-668(fp)
 80023a4:	2085c83a 	sub	r2,r4,r2
 80023a8:	1885d83a 	sra	r2,r3,r2
 80023ac:	e0bf5a15 	stw	r2,-664(fp)
 80023b0:	00001506 	br	8002408 <__kernel_rem_pio2+0x5cc>
	} 
	else if(q0==0) ih = iq[jz-1]>>23;
 80023b4:	e0bf5917 	ldw	r2,-668(fp)
 80023b8:	10000b1e 	bne	r2,zero,80023e8 <__kernel_rem_pio2+0x5ac>
 80023bc:	e0bf5217 	ldw	r2,-696(fp)
 80023c0:	10bfffc4 	addi	r2,r2,-1
 80023c4:	1085883a 	add	r2,r2,r2
 80023c8:	1085883a 	add	r2,r2,r2
 80023cc:	e0ff5204 	addi	r3,fp,-696
 80023d0:	1885883a 	add	r2,r3,r2
 80023d4:	10801104 	addi	r2,r2,68
 80023d8:	10800017 	ldw	r2,0(r2)
 80023dc:	1005d5fa 	srai	r2,r2,23
 80023e0:	e0bf5a15 	stw	r2,-664(fp)
 80023e4:	00000806 	br	8002408 <__kernel_rem_pio2+0x5cc>
	else if(z>=0.5) ih=2;
 80023e8:	000d883a 	mov	r6,zero
 80023ec:	01cff834 	movhi	r7,16352
 80023f0:	e13f5b17 	ldw	r4,-660(fp)
 80023f4:	e17f5c17 	ldw	r5,-656(fp)
 80023f8:	80049fc0 	call	80049fc <__gedf2>
 80023fc:	10000216 	blt	r2,zero,8002408 <__kernel_rem_pio2+0x5cc>
 8002400:	00800084 	movi	r2,2
 8002404:	e0bf5a15 	stw	r2,-664(fp)

	if(ih>0) {	/* q > 0.5 */
 8002408:	e0bf5a17 	ldw	r2,-664(fp)
 800240c:	0080810e 	bge	zero,r2,8002614 <__kernel_rem_pio2+0x7d8>
	    n += 1; carry = 0;
 8002410:	e0bf5517 	ldw	r2,-684(fp)
 8002414:	10800044 	addi	r2,r2,1
 8002418:	e0bf5515 	stw	r2,-684(fp)
 800241c:	e03f5415 	stw	zero,-688(fp)
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
 8002420:	e03f5615 	stw	zero,-680(fp)
 8002424:	00002706 	br	80024c4 <__kernel_rem_pio2+0x688>
		j = iq[i];
 8002428:	e0bf5617 	ldw	r2,-680(fp)
 800242c:	1085883a 	add	r2,r2,r2
 8002430:	1085883a 	add	r2,r2,r2
 8002434:	e13f5204 	addi	r4,fp,-696
 8002438:	2085883a 	add	r2,r4,r2
 800243c:	10801104 	addi	r2,r2,68
 8002440:	10800017 	ldw	r2,0(r2)
 8002444:	e0bf5715 	stw	r2,-676(fp)
		if(carry==0) {
 8002448:	e0bf5417 	ldw	r2,-688(fp)
 800244c:	10000f1e 	bne	r2,zero,800248c <__kernel_rem_pio2+0x650>
		    if(j!=0) {
 8002450:	e0bf5717 	ldw	r2,-676(fp)
 8002454:	10001826 	beq	r2,zero,80024b8 <__kernel_rem_pio2+0x67c>
			carry = 1; iq[i] = 0x1000000- j;
 8002458:	00800044 	movi	r2,1
 800245c:	e0bf5415 	stw	r2,-688(fp)
 8002460:	00c04034 	movhi	r3,256
 8002464:	e0bf5717 	ldw	r2,-676(fp)
 8002468:	1887c83a 	sub	r3,r3,r2
 800246c:	e0bf5617 	ldw	r2,-680(fp)
 8002470:	1085883a 	add	r2,r2,r2
 8002474:	1085883a 	add	r2,r2,r2
 8002478:	e17f5204 	addi	r5,fp,-696
 800247c:	2885883a 	add	r2,r5,r2
 8002480:	10801104 	addi	r2,r2,68
 8002484:	10c00015 	stw	r3,0(r2)
 8002488:	00000b06 	br	80024b8 <__kernel_rem_pio2+0x67c>
		    }
		} else  iq[i] = 0xffffff - j;
 800248c:	00804034 	movhi	r2,256
 8002490:	10bfffc4 	addi	r2,r2,-1
 8002494:	e0ff5717 	ldw	r3,-676(fp)
 8002498:	10c7c83a 	sub	r3,r2,r3
 800249c:	e0bf5617 	ldw	r2,-680(fp)
 80024a0:	1085883a 	add	r2,r2,r2
 80024a4:	1085883a 	add	r2,r2,r2
 80024a8:	e13f5204 	addi	r4,fp,-696
 80024ac:	2085883a 	add	r2,r4,r2
 80024b0:	10801104 	addi	r2,r2,68
 80024b4:	10c00015 	stw	r3,0(r2)
	else if(q0==0) ih = iq[jz-1]>>23;
	else if(z>=0.5) ih=2;

	if(ih>0) {	/* q > 0.5 */
	    n += 1; carry = 0;
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
 80024b8:	e0bf5617 	ldw	r2,-680(fp)
 80024bc:	10800044 	addi	r2,r2,1
 80024c0:	e0bf5615 	stw	r2,-680(fp)
 80024c4:	e0ff5617 	ldw	r3,-680(fp)
 80024c8:	e0bf5217 	ldw	r2,-696(fp)
 80024cc:	18bfd616 	blt	r3,r2,8002428 <__kernel_rem_pio2+0x5ec>
		    if(j!=0) {
			carry = 1; iq[i] = 0x1000000- j;
		    }
		} else  iq[i] = 0xffffff - j;
	    }
	    if(q0>0) {		/* rare case: chance is 1 in 12 */
 80024d0:	e0bf5917 	ldw	r2,-668(fp)
 80024d4:	00802e0e 	bge	zero,r2,8002590 <__kernel_rem_pio2+0x754>
	        switch(q0) {
 80024d8:	e0bf5917 	ldw	r2,-668(fp)
 80024dc:	10c00060 	cmpeqi	r3,r2,1
 80024e0:	1800031e 	bne	r3,zero,80024f0 <__kernel_rem_pio2+0x6b4>
 80024e4:	108000a0 	cmpeqi	r2,r2,2
 80024e8:	1000151e 	bne	r2,zero,8002540 <__kernel_rem_pio2+0x704>
 80024ec:	00002806 	br	8002590 <__kernel_rem_pio2+0x754>
	        case 1:
	    	   iq[jz-1] &= 0x7fffff; break;
 80024f0:	e0bf5217 	ldw	r2,-696(fp)
 80024f4:	10ffffc4 	addi	r3,r2,-1
 80024f8:	e0bf5217 	ldw	r2,-696(fp)
 80024fc:	10bfffc4 	addi	r2,r2,-1
 8002500:	1085883a 	add	r2,r2,r2
 8002504:	1085883a 	add	r2,r2,r2
 8002508:	e17f5204 	addi	r5,fp,-696
 800250c:	2885883a 	add	r2,r5,r2
 8002510:	10801104 	addi	r2,r2,68
 8002514:	11000017 	ldw	r4,0(r2)
 8002518:	00802034 	movhi	r2,128
 800251c:	10bfffc4 	addi	r2,r2,-1
 8002520:	2088703a 	and	r4,r4,r2
 8002524:	18c5883a 	add	r2,r3,r3
 8002528:	1085883a 	add	r2,r2,r2
 800252c:	e0ff5204 	addi	r3,fp,-696
 8002530:	1885883a 	add	r2,r3,r2
 8002534:	10801104 	addi	r2,r2,68
 8002538:	11000015 	stw	r4,0(r2)
 800253c:	00001406 	br	8002590 <__kernel_rem_pio2+0x754>
	    	case 2:
	    	   iq[jz-1] &= 0x3fffff; break;
 8002540:	e0bf5217 	ldw	r2,-696(fp)
 8002544:	10ffffc4 	addi	r3,r2,-1
 8002548:	e0bf5217 	ldw	r2,-696(fp)
 800254c:	10bfffc4 	addi	r2,r2,-1
 8002550:	1085883a 	add	r2,r2,r2
 8002554:	1085883a 	add	r2,r2,r2
 8002558:	e13f5204 	addi	r4,fp,-696
 800255c:	2085883a 	add	r2,r4,r2
 8002560:	10801104 	addi	r2,r2,68
 8002564:	11000017 	ldw	r4,0(r2)
 8002568:	00801034 	movhi	r2,64
 800256c:	10bfffc4 	addi	r2,r2,-1
 8002570:	2088703a 	and	r4,r4,r2
 8002574:	18c5883a 	add	r2,r3,r3
 8002578:	1085883a 	add	r2,r2,r2
 800257c:	e17f5204 	addi	r5,fp,-696
 8002580:	2885883a 	add	r2,r5,r2
 8002584:	10801104 	addi	r2,r2,68
 8002588:	11000015 	stw	r4,0(r2)
 800258c:	0001883a 	nop
	        }
	    }
	    if(ih==2) {
 8002590:	e0bf5a17 	ldw	r2,-664(fp)
 8002594:	10800098 	cmpnei	r2,r2,2
 8002598:	10001e1e 	bne	r2,zero,8002614 <__kernel_rem_pio2+0x7d8>
		z = one - z;
 800259c:	0005883a 	mov	r2,zero
 80025a0:	00cffc34 	movhi	r3,16368
 80025a4:	e1bf5b17 	ldw	r6,-660(fp)
 80025a8:	e1ff5c17 	ldw	r7,-656(fp)
 80025ac:	1009883a 	mov	r4,r2
 80025b0:	180b883a 	mov	r5,r3
 80025b4:	80051f00 	call	80051f0 <__subdf3>
 80025b8:	1009883a 	mov	r4,r2
 80025bc:	180b883a 	mov	r5,r3
 80025c0:	e13f5b15 	stw	r4,-660(fp)
 80025c4:	e17f5c15 	stw	r5,-656(fp)
		if(carry!=0) z -= scalbn(one,(int)q0);
 80025c8:	e0bf5417 	ldw	r2,-688(fp)
 80025cc:	10001126 	beq	r2,zero,8002614 <__kernel_rem_pio2+0x7d8>
 80025d0:	0005883a 	mov	r2,zero
 80025d4:	00cffc34 	movhi	r3,16368
 80025d8:	e1bf5917 	ldw	r6,-668(fp)
 80025dc:	1009883a 	mov	r4,r2
 80025e0:	180b883a 	mov	r5,r3
 80025e4:	8003a440 	call	8003a44 <scalbn>
 80025e8:	1009883a 	mov	r4,r2
 80025ec:	180b883a 	mov	r5,r3
 80025f0:	200d883a 	mov	r6,r4
 80025f4:	280f883a 	mov	r7,r5
 80025f8:	e13f5b17 	ldw	r4,-660(fp)
 80025fc:	e17f5c17 	ldw	r5,-656(fp)
 8002600:	80051f00 	call	80051f0 <__subdf3>
 8002604:	1009883a 	mov	r4,r2
 8002608:	180b883a 	mov	r5,r3
 800260c:	e13f5b15 	stw	r4,-660(fp)
 8002610:	e17f5c15 	stw	r5,-656(fp)
	    }
	}

    /* check if recomputation is needed */
	if(z==zero) {
 8002614:	0005883a 	mov	r2,zero
 8002618:	0007883a 	mov	r3,zero
 800261c:	100d883a 	mov	r6,r2
 8002620:	180f883a 	mov	r7,r3
 8002624:	e13f5b17 	ldw	r4,-660(fp)
 8002628:	e17f5c17 	ldw	r5,-656(fp)
 800262c:	80049740 	call	8004974 <__eqdf2>
 8002630:	1000861e 	bne	r2,zero,800284c <__kernel_rem_pio2+0xa10>
	    j = 0;
 8002634:	e03f5715 	stw	zero,-676(fp)
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
 8002638:	e0bf5217 	ldw	r2,-696(fp)
 800263c:	10bfffc4 	addi	r2,r2,-1
 8002640:	e0bf5615 	stw	r2,-680(fp)
 8002644:	00000d06 	br	800267c <__kernel_rem_pio2+0x840>
 8002648:	e0bf5617 	ldw	r2,-680(fp)
 800264c:	1085883a 	add	r2,r2,r2
 8002650:	1085883a 	add	r2,r2,r2
 8002654:	e0ff5204 	addi	r3,fp,-696
 8002658:	1885883a 	add	r2,r3,r2
 800265c:	10801104 	addi	r2,r2,68
 8002660:	10800017 	ldw	r2,0(r2)
 8002664:	e0ff5717 	ldw	r3,-676(fp)
 8002668:	1884b03a 	or	r2,r3,r2
 800266c:	e0bf5715 	stw	r2,-676(fp)
 8002670:	e0bf5617 	ldw	r2,-680(fp)
 8002674:	10bfffc4 	addi	r2,r2,-1
 8002678:	e0bf5615 	stw	r2,-680(fp)
 800267c:	e0ff5617 	ldw	r3,-680(fp)
 8002680:	e0bf5f17 	ldw	r2,-644(fp)
 8002684:	18bff00e 	bge	r3,r2,8002648 <__kernel_rem_pio2+0x80c>
	    if(j==0) { /* need recomputation */
 8002688:	e0bf5717 	ldw	r2,-676(fp)
 800268c:	10006f1e 	bne	r2,zero,800284c <__kernel_rem_pio2+0xa10>
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */
 8002690:	00800044 	movi	r2,1
 8002694:	e0bf5815 	stw	r2,-672(fp)
 8002698:	00000306 	br	80026a8 <__kernel_rem_pio2+0x86c>
 800269c:	e0bf5817 	ldw	r2,-672(fp)
 80026a0:	10800044 	addi	r2,r2,1
 80026a4:	e0bf5815 	stw	r2,-672(fp)
 80026a8:	e0ff5f17 	ldw	r3,-644(fp)
 80026ac:	e0bf5817 	ldw	r2,-672(fp)
 80026b0:	1885c83a 	sub	r2,r3,r2
 80026b4:	1085883a 	add	r2,r2,r2
 80026b8:	1085883a 	add	r2,r2,r2
 80026bc:	e13f5204 	addi	r4,fp,-696
 80026c0:	2085883a 	add	r2,r4,r2
 80026c4:	10801104 	addi	r2,r2,68
 80026c8:	10800017 	ldw	r2,0(r2)
 80026cc:	103ff326 	beq	r2,zero,800269c <__kernel_rem_pio2+0x860>

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
 80026d0:	e0bf5217 	ldw	r2,-696(fp)
 80026d4:	10800044 	addi	r2,r2,1
 80026d8:	e0bf5615 	stw	r2,-680(fp)
 80026dc:	00005106 	br	8002824 <__kernel_rem_pio2+0x9e8>
		    f[jx+i] = (double) ipio2[jv+i];
 80026e0:	e0ff6117 	ldw	r3,-636(fp)
 80026e4:	e0bf5617 	ldw	r2,-680(fp)
 80026e8:	1885883a 	add	r2,r3,r2
 80026ec:	e0bff315 	stw	r2,-52(fp)
 80026f0:	e0ff5317 	ldw	r3,-692(fp)
 80026f4:	e0bf5617 	ldw	r2,-680(fp)
 80026f8:	1885883a 	add	r2,r3,r2
 80026fc:	1085883a 	add	r2,r2,r2
 8002700:	1085883a 	add	r2,r2,r2
 8002704:	1007883a 	mov	r3,r2
 8002708:	e0800317 	ldw	r2,12(fp)
 800270c:	10c5883a 	add	r2,r2,r3
 8002710:	10800017 	ldw	r2,0(r2)
 8002714:	1009883a 	mov	r4,r2
 8002718:	8005b6c0 	call	8005b6c <__floatsidf>
 800271c:	1009883a 	mov	r4,r2
 8002720:	180b883a 	mov	r5,r3
 8002724:	e0fff317 	ldw	r3,-52(fp)
 8002728:	180490fa 	slli	r2,r3,3
 800272c:	e0ff5204 	addi	r3,fp,-696
 8002730:	1885883a 	add	r2,r3,r2
 8002734:	10802504 	addi	r2,r2,148
 8002738:	11000015 	stw	r4,0(r2)
 800273c:	11400115 	stw	r5,4(r2)
		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
 8002740:	e03f5715 	stw	zero,-676(fp)
 8002744:	e03f5d15 	stw	zero,-652(fp)
 8002748:	e03f5e15 	stw	zero,-648(fp)
 800274c:	00002606 	br	80027e8 <__kernel_rem_pio2+0x9ac>
 8002750:	e0bf5717 	ldw	r2,-676(fp)
 8002754:	100490fa 	slli	r2,r2,3
 8002758:	e0ffef17 	ldw	r3,-68(fp)
 800275c:	1889883a 	add	r4,r3,r2
 8002760:	20800017 	ldw	r2,0(r4)
 8002764:	20c00117 	ldw	r3,4(r4)
 8002768:	e17f6117 	ldw	r5,-636(fp)
 800276c:	e13f5617 	ldw	r4,-680(fp)
 8002770:	290b883a 	add	r5,r5,r4
 8002774:	e13f5717 	ldw	r4,-676(fp)
 8002778:	2909c83a 	sub	r4,r5,r4
 800277c:	200890fa 	slli	r4,r4,3
 8002780:	e17f5204 	addi	r5,fp,-696
 8002784:	2909883a 	add	r4,r5,r4
 8002788:	21802504 	addi	r6,r4,148
 800278c:	31000017 	ldw	r4,0(r6)
 8002790:	31400117 	ldw	r5,4(r6)
 8002794:	200d883a 	mov	r6,r4
 8002798:	280f883a 	mov	r7,r5
 800279c:	1009883a 	mov	r4,r2
 80027a0:	180b883a 	mov	r5,r3
 80027a4:	8004ad80 	call	8004ad8 <__muldf3>
 80027a8:	1009883a 	mov	r4,r2
 80027ac:	180b883a 	mov	r5,r3
 80027b0:	2005883a 	mov	r2,r4
 80027b4:	2807883a 	mov	r3,r5
 80027b8:	100d883a 	mov	r6,r2
 80027bc:	180f883a 	mov	r7,r3
 80027c0:	e13f5d17 	ldw	r4,-652(fp)
 80027c4:	e17f5e17 	ldw	r5,-648(fp)
 80027c8:	80040c80 	call	80040c8 <__adddf3>
 80027cc:	1009883a 	mov	r4,r2
 80027d0:	180b883a 	mov	r5,r3
 80027d4:	e13f5d15 	stw	r4,-652(fp)
 80027d8:	e17f5e15 	stw	r5,-648(fp)
 80027dc:	e0bf5717 	ldw	r2,-676(fp)
 80027e0:	10800044 	addi	r2,r2,1
 80027e4:	e0bf5715 	stw	r2,-676(fp)
 80027e8:	e0bf5717 	ldw	r2,-676(fp)
 80027ec:	e0ff6117 	ldw	r3,-636(fp)
 80027f0:	18bfd70e 	bge	r3,r2,8002750 <__kernel_rem_pio2+0x914>
		    q[i] = fw;
 80027f4:	e0bf5617 	ldw	r2,-680(fp)
 80027f8:	100490fa 	slli	r2,r2,3
 80027fc:	e0ff5204 	addi	r3,fp,-696
 8002800:	1885883a 	add	r2,r3,r2
 8002804:	10807504 	addi	r2,r2,468
 8002808:	e0ff5d17 	ldw	r3,-652(fp)
 800280c:	10c00015 	stw	r3,0(r2)
 8002810:	e0ff5e17 	ldw	r3,-648(fp)
 8002814:	10c00115 	stw	r3,4(r2)
	    j = 0;
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
	    if(j==0) { /* need recomputation */
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
 8002818:	e0bf5617 	ldw	r2,-680(fp)
 800281c:	10800044 	addi	r2,r2,1
 8002820:	e0bf5615 	stw	r2,-680(fp)
 8002824:	e0ff5217 	ldw	r3,-696(fp)
 8002828:	e0bf5817 	ldw	r2,-672(fp)
 800282c:	1887883a 	add	r3,r3,r2
 8002830:	e0bf5617 	ldw	r2,-680(fp)
 8002834:	18bfaa0e 	bge	r3,r2,80026e0 <__kernel_rem_pio2+0x8a4>
		    f[jx+i] = (double) ipio2[jv+i];
		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
		    q[i] = fw;
		}
		jz += k;
 8002838:	e0ff5217 	ldw	r3,-696(fp)
 800283c:	e0bf5817 	ldw	r2,-672(fp)
 8002840:	1885883a 	add	r2,r3,r2
 8002844:	e0bf5215 	stw	r2,-696(fp)
		goto recompute;
 8002848:	003e1206 	br	8002094 <__kernel_rem_pio2+0x258>
	    }
	}

    /* chop off zero terms */
	if(z==0.0) {
 800284c:	000d883a 	mov	r6,zero
 8002850:	000f883a 	mov	r7,zero
 8002854:	e13f5b17 	ldw	r4,-660(fp)
 8002858:	e17f5c17 	ldw	r5,-656(fp)
 800285c:	80049740 	call	8004974 <__eqdf2>
 8002860:	1000161e 	bne	r2,zero,80028bc <__kernel_rem_pio2+0xa80>
	    jz -= 1; q0 -= 24;
 8002864:	e0bf5217 	ldw	r2,-696(fp)
 8002868:	10bfffc4 	addi	r2,r2,-1
 800286c:	e0bf5215 	stw	r2,-696(fp)
 8002870:	e0bf5917 	ldw	r2,-668(fp)
 8002874:	10bffa04 	addi	r2,r2,-24
 8002878:	e0bf5915 	stw	r2,-668(fp)
	    while(iq[jz]==0) { jz--; q0-=24;}
 800287c:	00000606 	br	8002898 <__kernel_rem_pio2+0xa5c>
 8002880:	e0bf5217 	ldw	r2,-696(fp)
 8002884:	10bfffc4 	addi	r2,r2,-1
 8002888:	e0bf5215 	stw	r2,-696(fp)
 800288c:	e0bf5917 	ldw	r2,-668(fp)
 8002890:	10bffa04 	addi	r2,r2,-24
 8002894:	e0bf5915 	stw	r2,-668(fp)
 8002898:	e0bf5217 	ldw	r2,-696(fp)
 800289c:	1085883a 	add	r2,r2,r2
 80028a0:	1085883a 	add	r2,r2,r2
 80028a4:	e13f5204 	addi	r4,fp,-696
 80028a8:	2085883a 	add	r2,r4,r2
 80028ac:	10801104 	addi	r2,r2,68
 80028b0:	10800017 	ldw	r2,0(r2)
 80028b4:	103ff226 	beq	r2,zero,8002880 <__kernel_rem_pio2+0xa44>
 80028b8:	00006006 	br	8002a3c <__kernel_rem_pio2+0xc00>
	} else { /* break z into 24-bit if necessary */
	    z = scalbn(z,-(int)q0);
 80028bc:	e0bf5917 	ldw	r2,-668(fp)
 80028c0:	0085c83a 	sub	r2,zero,r2
 80028c4:	100d883a 	mov	r6,r2
 80028c8:	e13f5b17 	ldw	r4,-660(fp)
 80028cc:	e17f5c17 	ldw	r5,-656(fp)
 80028d0:	8003a440 	call	8003a44 <scalbn>
 80028d4:	e0bf5b15 	stw	r2,-660(fp)
 80028d8:	e0ff5c15 	stw	r3,-656(fp)
	    if(z>=two24) { 
 80028dc:	0005883a 	mov	r2,zero
 80028e0:	00d05c34 	movhi	r3,16752
 80028e4:	100d883a 	mov	r6,r2
 80028e8:	180f883a 	mov	r7,r3
 80028ec:	e13f5b17 	ldw	r4,-660(fp)
 80028f0:	e17f5c17 	ldw	r5,-656(fp)
 80028f4:	80049fc0 	call	80049fc <__gedf2>
 80028f8:	10004516 	blt	r2,zero,8002a10 <__kernel_rem_pio2+0xbd4>
		fw = (double)((__int32_t)(twon24*z));
 80028fc:	0005883a 	mov	r2,zero
 8002900:	00cf9c34 	movhi	r3,15984
 8002904:	e1bf5b17 	ldw	r6,-660(fp)
 8002908:	e1ff5c17 	ldw	r7,-656(fp)
 800290c:	1009883a 	mov	r4,r2
 8002910:	180b883a 	mov	r5,r3
 8002914:	8004ad80 	call	8004ad8 <__muldf3>
 8002918:	1009883a 	mov	r4,r2
 800291c:	180b883a 	mov	r5,r3
 8002920:	2005883a 	mov	r2,r4
 8002924:	2807883a 	mov	r3,r5
 8002928:	1009883a 	mov	r4,r2
 800292c:	180b883a 	mov	r5,r3
 8002930:	8005aec0 	call	8005aec <__fixdfsi>
 8002934:	1009883a 	mov	r4,r2
 8002938:	8005b6c0 	call	8005b6c <__floatsidf>
 800293c:	1009883a 	mov	r4,r2
 8002940:	180b883a 	mov	r5,r3
 8002944:	e13f5d15 	stw	r4,-652(fp)
 8002948:	e17f5e15 	stw	r5,-648(fp)
		iq[jz] = (__int32_t)(z-two24*fw);
 800294c:	0005883a 	mov	r2,zero
 8002950:	00d05c34 	movhi	r3,16752
 8002954:	e1bf5d17 	ldw	r6,-652(fp)
 8002958:	e1ff5e17 	ldw	r7,-648(fp)
 800295c:	1009883a 	mov	r4,r2
 8002960:	180b883a 	mov	r5,r3
 8002964:	8004ad80 	call	8004ad8 <__muldf3>
 8002968:	1009883a 	mov	r4,r2
 800296c:	180b883a 	mov	r5,r3
 8002970:	2005883a 	mov	r2,r4
 8002974:	2807883a 	mov	r3,r5
 8002978:	100d883a 	mov	r6,r2
 800297c:	180f883a 	mov	r7,r3
 8002980:	e13f5b17 	ldw	r4,-660(fp)
 8002984:	e17f5c17 	ldw	r5,-656(fp)
 8002988:	80051f00 	call	80051f0 <__subdf3>
 800298c:	1009883a 	mov	r4,r2
 8002990:	180b883a 	mov	r5,r3
 8002994:	2005883a 	mov	r2,r4
 8002998:	2807883a 	mov	r3,r5
 800299c:	1009883a 	mov	r4,r2
 80029a0:	180b883a 	mov	r5,r3
 80029a4:	8005aec0 	call	8005aec <__fixdfsi>
 80029a8:	1007883a 	mov	r3,r2
 80029ac:	e0bf5217 	ldw	r2,-696(fp)
 80029b0:	1085883a 	add	r2,r2,r2
 80029b4:	1085883a 	add	r2,r2,r2
 80029b8:	e17f5204 	addi	r5,fp,-696
 80029bc:	2885883a 	add	r2,r5,r2
 80029c0:	10801104 	addi	r2,r2,68
 80029c4:	10c00015 	stw	r3,0(r2)
		jz += 1; q0 += 24;
 80029c8:	e0bf5217 	ldw	r2,-696(fp)
 80029cc:	10800044 	addi	r2,r2,1
 80029d0:	e0bf5215 	stw	r2,-696(fp)
 80029d4:	e0bf5917 	ldw	r2,-668(fp)
 80029d8:	10800604 	addi	r2,r2,24
 80029dc:	e0bf5915 	stw	r2,-668(fp)
		iq[jz] = (__int32_t) fw;
 80029e0:	e13f5d17 	ldw	r4,-652(fp)
 80029e4:	e17f5e17 	ldw	r5,-648(fp)
 80029e8:	8005aec0 	call	8005aec <__fixdfsi>
 80029ec:	1007883a 	mov	r3,r2
 80029f0:	e0bf5217 	ldw	r2,-696(fp)
 80029f4:	1085883a 	add	r2,r2,r2
 80029f8:	1085883a 	add	r2,r2,r2
 80029fc:	e13f5204 	addi	r4,fp,-696
 8002a00:	2085883a 	add	r2,r4,r2
 8002a04:	10801104 	addi	r2,r2,68
 8002a08:	10c00015 	stw	r3,0(r2)
 8002a0c:	00000b06 	br	8002a3c <__kernel_rem_pio2+0xc00>
	    } else iq[jz] = (__int32_t) z ;
 8002a10:	e13f5b17 	ldw	r4,-660(fp)
 8002a14:	e17f5c17 	ldw	r5,-656(fp)
 8002a18:	8005aec0 	call	8005aec <__fixdfsi>
 8002a1c:	1007883a 	mov	r3,r2
 8002a20:	e0bf5217 	ldw	r2,-696(fp)
 8002a24:	1085883a 	add	r2,r2,r2
 8002a28:	1085883a 	add	r2,r2,r2
 8002a2c:	e17f5204 	addi	r5,fp,-696
 8002a30:	2885883a 	add	r2,r5,r2
 8002a34:	10801104 	addi	r2,r2,68
 8002a38:	10c00015 	stw	r3,0(r2)
	}

    /* convert integer "bit" chunk to floating-point value */
	fw = scalbn(one,(int)q0);
 8002a3c:	0005883a 	mov	r2,zero
 8002a40:	00cffc34 	movhi	r3,16368
 8002a44:	e1bf5917 	ldw	r6,-668(fp)
 8002a48:	1009883a 	mov	r4,r2
 8002a4c:	180b883a 	mov	r5,r3
 8002a50:	8003a440 	call	8003a44 <scalbn>
 8002a54:	e0bf5d15 	stw	r2,-652(fp)
 8002a58:	e0ff5e15 	stw	r3,-648(fp)
	for(i=jz;i>=0;i--) {
 8002a5c:	e0bf5217 	ldw	r2,-696(fp)
 8002a60:	e0bf5615 	stw	r2,-680(fp)
 8002a64:	00002906 	br	8002b0c <__kernel_rem_pio2+0xcd0>
	    q[i] = fw*(double)iq[i]; fw*=twon24;
 8002a68:	e0bf5617 	ldw	r2,-680(fp)
 8002a6c:	1085883a 	add	r2,r2,r2
 8002a70:	1085883a 	add	r2,r2,r2
 8002a74:	e0ff5204 	addi	r3,fp,-696
 8002a78:	1885883a 	add	r2,r3,r2
 8002a7c:	10801104 	addi	r2,r2,68
 8002a80:	10800017 	ldw	r2,0(r2)
 8002a84:	1009883a 	mov	r4,r2
 8002a88:	8005b6c0 	call	8005b6c <__floatsidf>
 8002a8c:	1011883a 	mov	r8,r2
 8002a90:	1813883a 	mov	r9,r3
 8002a94:	e1bf5d17 	ldw	r6,-652(fp)
 8002a98:	e1ff5e17 	ldw	r7,-648(fp)
 8002a9c:	4009883a 	mov	r4,r8
 8002aa0:	480b883a 	mov	r5,r9
 8002aa4:	8004ad80 	call	8004ad8 <__muldf3>
 8002aa8:	1009883a 	mov	r4,r2
 8002aac:	180b883a 	mov	r5,r3
 8002ab0:	2005883a 	mov	r2,r4
 8002ab4:	2807883a 	mov	r3,r5
 8002ab8:	e13f5617 	ldw	r4,-680(fp)
 8002abc:	200890fa 	slli	r4,r4,3
 8002ac0:	e17f5204 	addi	r5,fp,-696
 8002ac4:	2909883a 	add	r4,r5,r4
 8002ac8:	21007504 	addi	r4,r4,468
 8002acc:	20800015 	stw	r2,0(r4)
 8002ad0:	20c00115 	stw	r3,4(r4)
 8002ad4:	0005883a 	mov	r2,zero
 8002ad8:	00cf9c34 	movhi	r3,15984
 8002adc:	100d883a 	mov	r6,r2
 8002ae0:	180f883a 	mov	r7,r3
 8002ae4:	e13f5d17 	ldw	r4,-652(fp)
 8002ae8:	e17f5e17 	ldw	r5,-648(fp)
 8002aec:	8004ad80 	call	8004ad8 <__muldf3>
 8002af0:	1009883a 	mov	r4,r2
 8002af4:	180b883a 	mov	r5,r3
 8002af8:	e13f5d15 	stw	r4,-652(fp)
 8002afc:	e17f5e15 	stw	r5,-648(fp)
	    } else iq[jz] = (__int32_t) z ;
	}

    /* convert integer "bit" chunk to floating-point value */
	fw = scalbn(one,(int)q0);
	for(i=jz;i>=0;i--) {
 8002b00:	e0bf5617 	ldw	r2,-680(fp)
 8002b04:	10bfffc4 	addi	r2,r2,-1
 8002b08:	e0bf5615 	stw	r2,-680(fp)
 8002b0c:	e0bf5617 	ldw	r2,-680(fp)
 8002b10:	103fd50e 	bge	r2,zero,8002a68 <__kernel_rem_pio2+0xc2c>
	    q[i] = fw*(double)iq[i]; fw*=twon24;
	}

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
	for(i=jz;i>=0;i--) {
 8002b14:	e0bf5217 	ldw	r2,-696(fp)
 8002b18:	e0bf5615 	stw	r2,-680(fp)
 8002b1c:	00003f06 	br	8002c1c <__kernel_rem_pio2+0xde0>
	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
 8002b20:	e03f5d15 	stw	zero,-652(fp)
 8002b24:	e03f5e15 	stw	zero,-648(fp)
 8002b28:	e03f5815 	stw	zero,-672(fp)
 8002b2c:	00002506 	br	8002bc4 <__kernel_rem_pio2+0xd88>
 8002b30:	00820134 	movhi	r2,2052
 8002b34:	10991604 	addi	r2,r2,25688
 8002b38:	e0ff5817 	ldw	r3,-672(fp)
 8002b3c:	180690fa 	slli	r3,r3,3
 8002b40:	10c9883a 	add	r4,r2,r3
 8002b44:	20800017 	ldw	r2,0(r4)
 8002b48:	20c00117 	ldw	r3,4(r4)
 8002b4c:	e17f5617 	ldw	r5,-680(fp)
 8002b50:	e13f5817 	ldw	r4,-672(fp)
 8002b54:	2909883a 	add	r4,r5,r4
 8002b58:	200890fa 	slli	r4,r4,3
 8002b5c:	e17f5204 	addi	r5,fp,-696
 8002b60:	2909883a 	add	r4,r5,r4
 8002b64:	21807504 	addi	r6,r4,468
 8002b68:	31000017 	ldw	r4,0(r6)
 8002b6c:	31400117 	ldw	r5,4(r6)
 8002b70:	200d883a 	mov	r6,r4
 8002b74:	280f883a 	mov	r7,r5
 8002b78:	1009883a 	mov	r4,r2
 8002b7c:	180b883a 	mov	r5,r3
 8002b80:	8004ad80 	call	8004ad8 <__muldf3>
 8002b84:	1009883a 	mov	r4,r2
 8002b88:	180b883a 	mov	r5,r3
 8002b8c:	2005883a 	mov	r2,r4
 8002b90:	2807883a 	mov	r3,r5
 8002b94:	100d883a 	mov	r6,r2
 8002b98:	180f883a 	mov	r7,r3
 8002b9c:	e13f5d17 	ldw	r4,-652(fp)
 8002ba0:	e17f5e17 	ldw	r5,-648(fp)
 8002ba4:	80040c80 	call	80040c8 <__adddf3>
 8002ba8:	1009883a 	mov	r4,r2
 8002bac:	180b883a 	mov	r5,r3
 8002bb0:	e13f5d15 	stw	r4,-652(fp)
 8002bb4:	e17f5e15 	stw	r5,-648(fp)
 8002bb8:	e0bf5817 	ldw	r2,-672(fp)
 8002bbc:	10800044 	addi	r2,r2,1
 8002bc0:	e0bf5815 	stw	r2,-672(fp)
 8002bc4:	e0bf5817 	ldw	r2,-672(fp)
 8002bc8:	e0ff6017 	ldw	r3,-640(fp)
 8002bcc:	18800516 	blt	r3,r2,8002be4 <__kernel_rem_pio2+0xda8>
 8002bd0:	e0ff5217 	ldw	r3,-696(fp)
 8002bd4:	e0bf5617 	ldw	r2,-680(fp)
 8002bd8:	1887c83a 	sub	r3,r3,r2
 8002bdc:	e0bf5817 	ldw	r2,-672(fp)
 8002be0:	18bfd30e 	bge	r3,r2,8002b30 <__kernel_rem_pio2+0xcf4>
	    fq[jz-i] = fw;
 8002be4:	e0ff5217 	ldw	r3,-696(fp)
 8002be8:	e0bf5617 	ldw	r2,-680(fp)
 8002bec:	1885c83a 	sub	r2,r3,r2
 8002bf0:	100490fa 	slli	r2,r2,3
 8002bf4:	e0ff5204 	addi	r3,fp,-696
 8002bf8:	1885883a 	add	r2,r3,r2
 8002bfc:	10804d04 	addi	r2,r2,308
 8002c00:	e0ff5d17 	ldw	r3,-652(fp)
 8002c04:	10c00015 	stw	r3,0(r2)
 8002c08:	e0ff5e17 	ldw	r3,-648(fp)
 8002c0c:	10c00115 	stw	r3,4(r2)
	for(i=jz;i>=0;i--) {
	    q[i] = fw*(double)iq[i]; fw*=twon24;
	}

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
	for(i=jz;i>=0;i--) {
 8002c10:	e0bf5617 	ldw	r2,-680(fp)
 8002c14:	10bfffc4 	addi	r2,r2,-1
 8002c18:	e0bf5615 	stw	r2,-680(fp)
 8002c1c:	e0bf5617 	ldw	r2,-680(fp)
 8002c20:	103fbf0e 	bge	r2,zero,8002b20 <__kernel_rem_pio2+0xce4>
	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
	    fq[jz-i] = fw;
	}

    /* compress fq[] into y[] */
	switch(prec) {
 8002c24:	e0800217 	ldw	r2,8(fp)
 8002c28:	10c000c8 	cmpgei	r3,r2,3
 8002c2c:	1800031e 	bne	r3,zero,8002c3c <__kernel_rem_pio2+0xe00>
 8002c30:	00802b16 	blt	zero,r2,8002ce0 <__kernel_rem_pio2+0xea4>
 8002c34:	10000426 	beq	r2,zero,8002c48 <__kernel_rem_pio2+0xe0c>
 8002c38:	00016f06 	br	80031f8 <__kernel_rem_pio2+0x13bc>
 8002c3c:	108000e0 	cmpeqi	r2,r2,3
 8002c40:	10007d1e 	bne	r2,zero,8002e38 <__kernel_rem_pio2+0xffc>
 8002c44:	00016c06 	br	80031f8 <__kernel_rem_pio2+0x13bc>
	    case 0:
		fw = 0.0;
 8002c48:	e03f5d15 	stw	zero,-652(fp)
 8002c4c:	e03f5e15 	stw	zero,-648(fp)
		for (i=jz;i>=0;i--) fw += fq[i];
 8002c50:	e0bf5217 	ldw	r2,-696(fp)
 8002c54:	e0bf5615 	stw	r2,-680(fp)
 8002c58:	00001306 	br	8002ca8 <__kernel_rem_pio2+0xe6c>
 8002c5c:	e0bf5617 	ldw	r2,-680(fp)
 8002c60:	100490fa 	slli	r2,r2,3
 8002c64:	e13f5204 	addi	r4,fp,-696
 8002c68:	2085883a 	add	r2,r4,r2
 8002c6c:	11004d04 	addi	r4,r2,308
 8002c70:	20800017 	ldw	r2,0(r4)
 8002c74:	20c00117 	ldw	r3,4(r4)
 8002c78:	100d883a 	mov	r6,r2
 8002c7c:	180f883a 	mov	r7,r3
 8002c80:	e13f5d17 	ldw	r4,-652(fp)
 8002c84:	e17f5e17 	ldw	r5,-648(fp)
 8002c88:	80040c80 	call	80040c8 <__adddf3>
 8002c8c:	1009883a 	mov	r4,r2
 8002c90:	180b883a 	mov	r5,r3
 8002c94:	e13f5d15 	stw	r4,-652(fp)
 8002c98:	e17f5e15 	stw	r5,-648(fp)
 8002c9c:	e0bf5617 	ldw	r2,-680(fp)
 8002ca0:	10bfffc4 	addi	r2,r2,-1
 8002ca4:	e0bf5615 	stw	r2,-680(fp)
 8002ca8:	e0bf5617 	ldw	r2,-680(fp)
 8002cac:	103feb0e 	bge	r2,zero,8002c5c <__kernel_rem_pio2+0xe20>
		y[0] = (ih==0)? fw: -fw; 
 8002cb0:	e0bf5a17 	ldw	r2,-664(fp)
 8002cb4:	10000426 	beq	r2,zero,8002cc8 <__kernel_rem_pio2+0xe8c>
 8002cb8:	e53f5d17 	ldw	r20,-652(fp)
 8002cbc:	e0bf5e17 	ldw	r2,-648(fp)
 8002cc0:	1560003c 	xorhi	r21,r2,32768
 8002cc4:	00000206 	br	8002cd0 <__kernel_rem_pio2+0xe94>
 8002cc8:	e53f5d17 	ldw	r20,-652(fp)
 8002ccc:	e57f5e17 	ldw	r21,-648(fp)
 8002cd0:	e0bff017 	ldw	r2,-64(fp)
 8002cd4:	15000015 	stw	r20,0(r2)
 8002cd8:	15400115 	stw	r21,4(r2)
		break;
 8002cdc:	00014606 	br	80031f8 <__kernel_rem_pio2+0x13bc>
	    case 1:
	    case 2:
		fw = 0.0;
 8002ce0:	e03f5d15 	stw	zero,-652(fp)
 8002ce4:	e03f5e15 	stw	zero,-648(fp)
		for (i=jz;i>=0;i--) fw += fq[i]; 
 8002ce8:	e0bf5217 	ldw	r2,-696(fp)
 8002cec:	e0bf5615 	stw	r2,-680(fp)
 8002cf0:	00001306 	br	8002d40 <__kernel_rem_pio2+0xf04>
 8002cf4:	e0bf5617 	ldw	r2,-680(fp)
 8002cf8:	100490fa 	slli	r2,r2,3
 8002cfc:	e17f5204 	addi	r5,fp,-696
 8002d00:	2885883a 	add	r2,r5,r2
 8002d04:	11004d04 	addi	r4,r2,308
 8002d08:	20800017 	ldw	r2,0(r4)
 8002d0c:	20c00117 	ldw	r3,4(r4)
 8002d10:	100d883a 	mov	r6,r2
 8002d14:	180f883a 	mov	r7,r3
 8002d18:	e13f5d17 	ldw	r4,-652(fp)
 8002d1c:	e17f5e17 	ldw	r5,-648(fp)
 8002d20:	80040c80 	call	80040c8 <__adddf3>
 8002d24:	1009883a 	mov	r4,r2
 8002d28:	180b883a 	mov	r5,r3
 8002d2c:	e13f5d15 	stw	r4,-652(fp)
 8002d30:	e17f5e15 	stw	r5,-648(fp)
 8002d34:	e0bf5617 	ldw	r2,-680(fp)
 8002d38:	10bfffc4 	addi	r2,r2,-1
 8002d3c:	e0bf5615 	stw	r2,-680(fp)
 8002d40:	e0bf5617 	ldw	r2,-680(fp)
 8002d44:	103feb0e 	bge	r2,zero,8002cf4 <__kernel_rem_pio2+0xeb8>
		y[0] = (ih==0)? fw: -fw; 
 8002d48:	e0bf5a17 	ldw	r2,-664(fp)
 8002d4c:	10000426 	beq	r2,zero,8002d60 <__kernel_rem_pio2+0xf24>
 8002d50:	e4bf5d17 	ldw	r18,-652(fp)
 8002d54:	e0bf5e17 	ldw	r2,-648(fp)
 8002d58:	14e0003c 	xorhi	r19,r2,32768
 8002d5c:	00000206 	br	8002d68 <__kernel_rem_pio2+0xf2c>
 8002d60:	e4bf5d17 	ldw	r18,-652(fp)
 8002d64:	e4ff5e17 	ldw	r19,-648(fp)
 8002d68:	e0bff017 	ldw	r2,-64(fp)
 8002d6c:	14800015 	stw	r18,0(r2)
 8002d70:	14c00115 	stw	r19,4(r2)
		fw = fq[0]-fw;
 8002d74:	e0bf9f17 	ldw	r2,-388(fp)
 8002d78:	e0ffa017 	ldw	r3,-384(fp)
 8002d7c:	e1bf5d17 	ldw	r6,-652(fp)
 8002d80:	e1ff5e17 	ldw	r7,-648(fp)
 8002d84:	1009883a 	mov	r4,r2
 8002d88:	180b883a 	mov	r5,r3
 8002d8c:	80051f00 	call	80051f0 <__subdf3>
 8002d90:	1009883a 	mov	r4,r2
 8002d94:	180b883a 	mov	r5,r3
 8002d98:	e13f5d15 	stw	r4,-652(fp)
 8002d9c:	e17f5e15 	stw	r5,-648(fp)
		for (i=1;i<=jz;i++) fw += fq[i];
 8002da0:	00800044 	movi	r2,1
 8002da4:	e0bf5615 	stw	r2,-680(fp)
 8002da8:	00001306 	br	8002df8 <__kernel_rem_pio2+0xfbc>
 8002dac:	e0bf5617 	ldw	r2,-680(fp)
 8002db0:	100490fa 	slli	r2,r2,3
 8002db4:	e0ff5204 	addi	r3,fp,-696
 8002db8:	1885883a 	add	r2,r3,r2
 8002dbc:	11004d04 	addi	r4,r2,308
 8002dc0:	20800017 	ldw	r2,0(r4)
 8002dc4:	20c00117 	ldw	r3,4(r4)
 8002dc8:	100d883a 	mov	r6,r2
 8002dcc:	180f883a 	mov	r7,r3
 8002dd0:	e13f5d17 	ldw	r4,-652(fp)
 8002dd4:	e17f5e17 	ldw	r5,-648(fp)
 8002dd8:	80040c80 	call	80040c8 <__adddf3>
 8002ddc:	1009883a 	mov	r4,r2
 8002de0:	180b883a 	mov	r5,r3
 8002de4:	e13f5d15 	stw	r4,-652(fp)
 8002de8:	e17f5e15 	stw	r5,-648(fp)
 8002dec:	e0bf5617 	ldw	r2,-680(fp)
 8002df0:	10800044 	addi	r2,r2,1
 8002df4:	e0bf5615 	stw	r2,-680(fp)
 8002df8:	e0bf5617 	ldw	r2,-680(fp)
 8002dfc:	e0ff5217 	ldw	r3,-696(fp)
 8002e00:	18bfea0e 	bge	r3,r2,8002dac <__kernel_rem_pio2+0xf70>
		y[1] = (ih==0)? fw: -fw; 
 8002e04:	e0bff017 	ldw	r2,-64(fp)
 8002e08:	10800204 	addi	r2,r2,8
 8002e0c:	e0ff5a17 	ldw	r3,-664(fp)
 8002e10:	18000426 	beq	r3,zero,8002e24 <__kernel_rem_pio2+0xfe8>
 8002e14:	e43f5d17 	ldw	r16,-652(fp)
 8002e18:	e0ff5e17 	ldw	r3,-648(fp)
 8002e1c:	1c60003c 	xorhi	r17,r3,32768
 8002e20:	00000206 	br	8002e2c <__kernel_rem_pio2+0xff0>
 8002e24:	e43f5d17 	ldw	r16,-652(fp)
 8002e28:	e47f5e17 	ldw	r17,-648(fp)
 8002e2c:	14000015 	stw	r16,0(r2)
 8002e30:	14400115 	stw	r17,4(r2)
		break;
 8002e34:	0000f006 	br	80031f8 <__kernel_rem_pio2+0x13bc>
	    case 3:	/* painful */
		for (i=jz;i>0;i--) {
 8002e38:	e0bf5217 	ldw	r2,-696(fp)
 8002e3c:	e0bf5615 	stw	r2,-680(fp)
 8002e40:	00004d06 	br	8002f78 <__kernel_rem_pio2+0x113c>
		    fw      = fq[i-1]+fq[i]; 
 8002e44:	e0bf5617 	ldw	r2,-680(fp)
 8002e48:	10bfffc4 	addi	r2,r2,-1
 8002e4c:	100490fa 	slli	r2,r2,3
 8002e50:	e13f5204 	addi	r4,fp,-696
 8002e54:	2085883a 	add	r2,r4,r2
 8002e58:	11004d04 	addi	r4,r2,308
 8002e5c:	20800017 	ldw	r2,0(r4)
 8002e60:	20c00117 	ldw	r3,4(r4)
 8002e64:	e13f5617 	ldw	r4,-680(fp)
 8002e68:	200890fa 	slli	r4,r4,3
 8002e6c:	e17f5204 	addi	r5,fp,-696
 8002e70:	2909883a 	add	r4,r5,r4
 8002e74:	21804d04 	addi	r6,r4,308
 8002e78:	31000017 	ldw	r4,0(r6)
 8002e7c:	31400117 	ldw	r5,4(r6)
 8002e80:	200d883a 	mov	r6,r4
 8002e84:	280f883a 	mov	r7,r5
 8002e88:	1009883a 	mov	r4,r2
 8002e8c:	180b883a 	mov	r5,r3
 8002e90:	80040c80 	call	80040c8 <__adddf3>
 8002e94:	1009883a 	mov	r4,r2
 8002e98:	180b883a 	mov	r5,r3
 8002e9c:	e13f5d15 	stw	r4,-652(fp)
 8002ea0:	e17f5e15 	stw	r5,-648(fp)
		    fq[i]  += fq[i-1]-fw;
 8002ea4:	e0bf5617 	ldw	r2,-680(fp)
 8002ea8:	100490fa 	slli	r2,r2,3
 8002eac:	e0ff5204 	addi	r3,fp,-696
 8002eb0:	1885883a 	add	r2,r3,r2
 8002eb4:	10804d04 	addi	r2,r2,308
 8002eb8:	14000017 	ldw	r16,0(r2)
 8002ebc:	14400117 	ldw	r17,4(r2)
 8002ec0:	e0bf5617 	ldw	r2,-680(fp)
 8002ec4:	10bfffc4 	addi	r2,r2,-1
 8002ec8:	100490fa 	slli	r2,r2,3
 8002ecc:	e13f5204 	addi	r4,fp,-696
 8002ed0:	2085883a 	add	r2,r4,r2
 8002ed4:	11004d04 	addi	r4,r2,308
 8002ed8:	20800017 	ldw	r2,0(r4)
 8002edc:	20c00117 	ldw	r3,4(r4)
 8002ee0:	e1bf5d17 	ldw	r6,-652(fp)
 8002ee4:	e1ff5e17 	ldw	r7,-648(fp)
 8002ee8:	1009883a 	mov	r4,r2
 8002eec:	180b883a 	mov	r5,r3
 8002ef0:	80051f00 	call	80051f0 <__subdf3>
 8002ef4:	1009883a 	mov	r4,r2
 8002ef8:	180b883a 	mov	r5,r3
 8002efc:	2005883a 	mov	r2,r4
 8002f00:	2807883a 	mov	r3,r5
 8002f04:	100d883a 	mov	r6,r2
 8002f08:	180f883a 	mov	r7,r3
 8002f0c:	8009883a 	mov	r4,r16
 8002f10:	880b883a 	mov	r5,r17
 8002f14:	80040c80 	call	80040c8 <__adddf3>
 8002f18:	1009883a 	mov	r4,r2
 8002f1c:	180b883a 	mov	r5,r3
 8002f20:	2005883a 	mov	r2,r4
 8002f24:	2807883a 	mov	r3,r5
 8002f28:	e13f5617 	ldw	r4,-680(fp)
 8002f2c:	200890fa 	slli	r4,r4,3
 8002f30:	e17f5204 	addi	r5,fp,-696
 8002f34:	2909883a 	add	r4,r5,r4
 8002f38:	21004d04 	addi	r4,r4,308
 8002f3c:	20800015 	stw	r2,0(r4)
 8002f40:	20c00115 	stw	r3,4(r4)
		    fq[i-1] = fw;
 8002f44:	e0bf5617 	ldw	r2,-680(fp)
 8002f48:	10bfffc4 	addi	r2,r2,-1
 8002f4c:	100490fa 	slli	r2,r2,3
 8002f50:	e0ff5204 	addi	r3,fp,-696
 8002f54:	1885883a 	add	r2,r3,r2
 8002f58:	10804d04 	addi	r2,r2,308
 8002f5c:	e0ff5d17 	ldw	r3,-652(fp)
 8002f60:	10c00015 	stw	r3,0(r2)
 8002f64:	e0ff5e17 	ldw	r3,-648(fp)
 8002f68:	10c00115 	stw	r3,4(r2)
		fw = fq[0]-fw;
		for (i=1;i<=jz;i++) fw += fq[i];
		y[1] = (ih==0)? fw: -fw; 
		break;
	    case 3:	/* painful */
		for (i=jz;i>0;i--) {
 8002f6c:	e0bf5617 	ldw	r2,-680(fp)
 8002f70:	10bfffc4 	addi	r2,r2,-1
 8002f74:	e0bf5615 	stw	r2,-680(fp)
 8002f78:	e0bf5617 	ldw	r2,-680(fp)
 8002f7c:	00bfb116 	blt	zero,r2,8002e44 <__kernel_rem_pio2+0x1008>
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (i=jz;i>1;i--) {
 8002f80:	e0bf5217 	ldw	r2,-696(fp)
 8002f84:	e0bf5615 	stw	r2,-680(fp)
 8002f88:	00004d06 	br	80030c0 <__kernel_rem_pio2+0x1284>
		    fw      = fq[i-1]+fq[i]; 
 8002f8c:	e0bf5617 	ldw	r2,-680(fp)
 8002f90:	10bfffc4 	addi	r2,r2,-1
 8002f94:	100490fa 	slli	r2,r2,3
 8002f98:	e13f5204 	addi	r4,fp,-696
 8002f9c:	2085883a 	add	r2,r4,r2
 8002fa0:	11004d04 	addi	r4,r2,308
 8002fa4:	20800017 	ldw	r2,0(r4)
 8002fa8:	20c00117 	ldw	r3,4(r4)
 8002fac:	e13f5617 	ldw	r4,-680(fp)
 8002fb0:	200890fa 	slli	r4,r4,3
 8002fb4:	e17f5204 	addi	r5,fp,-696
 8002fb8:	2909883a 	add	r4,r5,r4
 8002fbc:	21804d04 	addi	r6,r4,308
 8002fc0:	31000017 	ldw	r4,0(r6)
 8002fc4:	31400117 	ldw	r5,4(r6)
 8002fc8:	200d883a 	mov	r6,r4
 8002fcc:	280f883a 	mov	r7,r5
 8002fd0:	1009883a 	mov	r4,r2
 8002fd4:	180b883a 	mov	r5,r3
 8002fd8:	80040c80 	call	80040c8 <__adddf3>
 8002fdc:	1009883a 	mov	r4,r2
 8002fe0:	180b883a 	mov	r5,r3
 8002fe4:	e13f5d15 	stw	r4,-652(fp)
 8002fe8:	e17f5e15 	stw	r5,-648(fp)
		    fq[i]  += fq[i-1]-fw;
 8002fec:	e0bf5617 	ldw	r2,-680(fp)
 8002ff0:	100490fa 	slli	r2,r2,3
 8002ff4:	e0ff5204 	addi	r3,fp,-696
 8002ff8:	1885883a 	add	r2,r3,r2
 8002ffc:	10804d04 	addi	r2,r2,308
 8003000:	14000017 	ldw	r16,0(r2)
 8003004:	14400117 	ldw	r17,4(r2)
 8003008:	e0bf5617 	ldw	r2,-680(fp)
 800300c:	10bfffc4 	addi	r2,r2,-1
 8003010:	100490fa 	slli	r2,r2,3
 8003014:	e13f5204 	addi	r4,fp,-696
 8003018:	2085883a 	add	r2,r4,r2
 800301c:	11004d04 	addi	r4,r2,308
 8003020:	20800017 	ldw	r2,0(r4)
 8003024:	20c00117 	ldw	r3,4(r4)
 8003028:	e1bf5d17 	ldw	r6,-652(fp)
 800302c:	e1ff5e17 	ldw	r7,-648(fp)
 8003030:	1009883a 	mov	r4,r2
 8003034:	180b883a 	mov	r5,r3
 8003038:	80051f00 	call	80051f0 <__subdf3>
 800303c:	1009883a 	mov	r4,r2
 8003040:	180b883a 	mov	r5,r3
 8003044:	2005883a 	mov	r2,r4
 8003048:	2807883a 	mov	r3,r5
 800304c:	100d883a 	mov	r6,r2
 8003050:	180f883a 	mov	r7,r3
 8003054:	8009883a 	mov	r4,r16
 8003058:	880b883a 	mov	r5,r17
 800305c:	80040c80 	call	80040c8 <__adddf3>
 8003060:	1009883a 	mov	r4,r2
 8003064:	180b883a 	mov	r5,r3
 8003068:	2005883a 	mov	r2,r4
 800306c:	2807883a 	mov	r3,r5
 8003070:	e13f5617 	ldw	r4,-680(fp)
 8003074:	200890fa 	slli	r4,r4,3
 8003078:	e17f5204 	addi	r5,fp,-696
 800307c:	2909883a 	add	r4,r5,r4
 8003080:	21004d04 	addi	r4,r4,308
 8003084:	20800015 	stw	r2,0(r4)
 8003088:	20c00115 	stw	r3,4(r4)
		    fq[i-1] = fw;
 800308c:	e0bf5617 	ldw	r2,-680(fp)
 8003090:	10bfffc4 	addi	r2,r2,-1
 8003094:	100490fa 	slli	r2,r2,3
 8003098:	e0ff5204 	addi	r3,fp,-696
 800309c:	1885883a 	add	r2,r3,r2
 80030a0:	10804d04 	addi	r2,r2,308
 80030a4:	e0ff5d17 	ldw	r3,-652(fp)
 80030a8:	10c00015 	stw	r3,0(r2)
 80030ac:	e0ff5e17 	ldw	r3,-648(fp)
 80030b0:	10c00115 	stw	r3,4(r2)
		for (i=jz;i>0;i--) {
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (i=jz;i>1;i--) {
 80030b4:	e0bf5617 	ldw	r2,-680(fp)
 80030b8:	10bfffc4 	addi	r2,r2,-1
 80030bc:	e0bf5615 	stw	r2,-680(fp)
 80030c0:	e0bf5617 	ldw	r2,-680(fp)
 80030c4:	10800088 	cmpgei	r2,r2,2
 80030c8:	103fb01e 	bne	r2,zero,8002f8c <__kernel_rem_pio2+0x1150>
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (fw=0.0,i=jz;i>=2;i--) fw += fq[i]; 
 80030cc:	e03f5d15 	stw	zero,-652(fp)
 80030d0:	e03f5e15 	stw	zero,-648(fp)
 80030d4:	e0bf5217 	ldw	r2,-696(fp)
 80030d8:	e0bf5615 	stw	r2,-680(fp)
 80030dc:	00001306 	br	800312c <__kernel_rem_pio2+0x12f0>
 80030e0:	e0bf5617 	ldw	r2,-680(fp)
 80030e4:	100490fa 	slli	r2,r2,3
 80030e8:	e13f5204 	addi	r4,fp,-696
 80030ec:	2085883a 	add	r2,r4,r2
 80030f0:	11004d04 	addi	r4,r2,308
 80030f4:	20800017 	ldw	r2,0(r4)
 80030f8:	20c00117 	ldw	r3,4(r4)
 80030fc:	100d883a 	mov	r6,r2
 8003100:	180f883a 	mov	r7,r3
 8003104:	e13f5d17 	ldw	r4,-652(fp)
 8003108:	e17f5e17 	ldw	r5,-648(fp)
 800310c:	80040c80 	call	80040c8 <__adddf3>
 8003110:	1009883a 	mov	r4,r2
 8003114:	180b883a 	mov	r5,r3
 8003118:	e13f5d15 	stw	r4,-652(fp)
 800311c:	e17f5e15 	stw	r5,-648(fp)
 8003120:	e0bf5617 	ldw	r2,-680(fp)
 8003124:	10bfffc4 	addi	r2,r2,-1
 8003128:	e0bf5615 	stw	r2,-680(fp)
 800312c:	e0bf5617 	ldw	r2,-680(fp)
 8003130:	10800088 	cmpgei	r2,r2,2
 8003134:	103fea1e 	bne	r2,zero,80030e0 <__kernel_rem_pio2+0x12a4>
		if(ih==0) {
 8003138:	e0bf5a17 	ldw	r2,-664(fp)
 800313c:	1000121e 	bne	r2,zero,8003188 <__kernel_rem_pio2+0x134c>
		    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;
 8003140:	e0bf9f17 	ldw	r2,-388(fp)
 8003144:	e0ffa017 	ldw	r3,-384(fp)
 8003148:	e13ff017 	ldw	r4,-64(fp)
 800314c:	20800015 	stw	r2,0(r4)
 8003150:	20c00115 	stw	r3,4(r4)
 8003154:	e0bff017 	ldw	r2,-64(fp)
 8003158:	11000204 	addi	r4,r2,8
 800315c:	e0bfa117 	ldw	r2,-380(fp)
 8003160:	e0ffa217 	ldw	r3,-376(fp)
 8003164:	20800015 	stw	r2,0(r4)
 8003168:	20c00115 	stw	r3,4(r4)
 800316c:	e0bff017 	ldw	r2,-64(fp)
 8003170:	10800404 	addi	r2,r2,16
 8003174:	e0ff5d17 	ldw	r3,-652(fp)
 8003178:	10c00015 	stw	r3,0(r2)
 800317c:	e0ff5e17 	ldw	r3,-648(fp)
 8003180:	10c00115 	stw	r3,4(r2)
 8003184:	00001c06 	br	80031f8 <__kernel_rem_pio2+0x13bc>
		} else {
		    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
 8003188:	e0bf9f17 	ldw	r2,-388(fp)
 800318c:	e0ffa017 	ldw	r3,-384(fp)
 8003190:	e0bff415 	stw	r2,-48(fp)
 8003194:	1960003c 	xorhi	r5,r3,32768
 8003198:	e17ff515 	stw	r5,-44(fp)
 800319c:	e0bff017 	ldw	r2,-64(fp)
 80031a0:	e0fff417 	ldw	r3,-48(fp)
 80031a4:	10c00015 	stw	r3,0(r2)
 80031a8:	e13ff517 	ldw	r4,-44(fp)
 80031ac:	11000115 	stw	r4,4(r2)
 80031b0:	e0bff017 	ldw	r2,-64(fp)
 80031b4:	11000204 	addi	r4,r2,8
 80031b8:	e0bfa117 	ldw	r2,-380(fp)
 80031bc:	e0ffa217 	ldw	r3,-376(fp)
 80031c0:	e0bff615 	stw	r2,-40(fp)
 80031c4:	1960003c 	xorhi	r5,r3,32768
 80031c8:	e17ff715 	stw	r5,-36(fp)
 80031cc:	e0bff617 	ldw	r2,-40(fp)
 80031d0:	20800015 	stw	r2,0(r4)
 80031d4:	e0fff717 	ldw	r3,-36(fp)
 80031d8:	20c00115 	stw	r3,4(r4)
 80031dc:	e0bff017 	ldw	r2,-64(fp)
 80031e0:	10800404 	addi	r2,r2,16
 80031e4:	e5bf5d17 	ldw	r22,-652(fp)
 80031e8:	e0ff5e17 	ldw	r3,-648(fp)
 80031ec:	1de0003c 	xorhi	r23,r3,32768
 80031f0:	15800015 	stw	r22,0(r2)
 80031f4:	15c00115 	stw	r23,4(r2)
		}
	}
	return n&7;
 80031f8:	e0bf5517 	ldw	r2,-684(fp)
 80031fc:	108001cc 	andi	r2,r2,7
}
 8003200:	e6fff804 	addi	sp,fp,-32
 8003204:	dfc00917 	ldw	ra,36(sp)
 8003208:	df000817 	ldw	fp,32(sp)
 800320c:	ddc00717 	ldw	r23,28(sp)
 8003210:	dd800617 	ldw	r22,24(sp)
 8003214:	dd400517 	ldw	r21,20(sp)
 8003218:	dd000417 	ldw	r20,16(sp)
 800321c:	dcc00317 	ldw	r19,12(sp)
 8003220:	dc800217 	ldw	r18,8(sp)
 8003224:	dc400117 	ldw	r17,4(sp)
 8003228:	dc000017 	ldw	r16,0(sp)
 800322c:	dec00a04 	addi	sp,sp,40
 8003230:	f800283a 	ret

08003234 <__kernel_sin>:
	double __kernel_sin(double x, double y, int iy)
#else
	double __kernel_sin(x, y, iy)
	double x,y; int iy;		/* iy=0 if y is zero */
#endif
{
 8003234:	deffef04 	addi	sp,sp,-68
 8003238:	dfc01015 	stw	ra,64(sp)
 800323c:	df000f15 	stw	fp,60(sp)
 8003240:	dc400e15 	stw	r17,56(sp)
 8003244:	dc000d15 	stw	r16,52(sp)
 8003248:	df000f04 	addi	fp,sp,60
 800324c:	e13ffa15 	stw	r4,-24(fp)
 8003250:	e17ffb15 	stw	r5,-20(fp)
 8003254:	e1bffc15 	stw	r6,-16(fp)
 8003258:	e1fffd15 	stw	r7,-12(fp)
	double z,r,v;
	__int32_t ix;
	GET_HIGH_WORD(ix,x);
 800325c:	e0bffa17 	ldw	r2,-24(fp)
 8003260:	e0bff815 	stw	r2,-32(fp)
 8003264:	e0bffb17 	ldw	r2,-20(fp)
 8003268:	e0bff915 	stw	r2,-28(fp)
 800326c:	e0bff917 	ldw	r2,-28(fp)
 8003270:	e0bff115 	stw	r2,-60(fp)
	ix &= 0x7fffffff;			/* high word of x */
 8003274:	e0fff117 	ldw	r3,-60(fp)
 8003278:	00a00034 	movhi	r2,32768
 800327c:	10bfffc4 	addi	r2,r2,-1
 8003280:	1884703a 	and	r2,r3,r2
 8003284:	e0bff115 	stw	r2,-60(fp)
	if(ix<0x3e400000)			/* |x| < 2**-27 */
 8003288:	e0fff117 	ldw	r3,-60(fp)
 800328c:	008f9034 	movhi	r2,15936
 8003290:	1880070e 	bge	r3,r2,80032b0 <__kernel_sin+0x7c>
	   {if((int)x==0) return x;}		/* generate inexact */
 8003294:	e13ffa17 	ldw	r4,-24(fp)
 8003298:	e17ffb17 	ldw	r5,-20(fp)
 800329c:	8005aec0 	call	8005aec <__fixdfsi>
 80032a0:	1000031e 	bne	r2,zero,80032b0 <__kernel_sin+0x7c>
 80032a4:	e0bffa17 	ldw	r2,-24(fp)
 80032a8:	e0fffb17 	ldw	r3,-20(fp)
 80032ac:	0000e706 	br	800364c <__kernel_sin+0x418>
	z	=  x*x;
 80032b0:	e1bffa17 	ldw	r6,-24(fp)
 80032b4:	e1fffb17 	ldw	r7,-20(fp)
 80032b8:	e13ffa17 	ldw	r4,-24(fp)
 80032bc:	e17ffb17 	ldw	r5,-20(fp)
 80032c0:	8004ad80 	call	8004ad8 <__muldf3>
 80032c4:	1009883a 	mov	r4,r2
 80032c8:	180b883a 	mov	r5,r3
 80032cc:	e13ff215 	stw	r4,-56(fp)
 80032d0:	e17ff315 	stw	r5,-52(fp)
	v	=  z*x;
 80032d4:	e1bffa17 	ldw	r6,-24(fp)
 80032d8:	e1fffb17 	ldw	r7,-20(fp)
 80032dc:	e13ff217 	ldw	r4,-56(fp)
 80032e0:	e17ff317 	ldw	r5,-52(fp)
 80032e4:	8004ad80 	call	8004ad8 <__muldf3>
 80032e8:	1009883a 	mov	r4,r2
 80032ec:	180b883a 	mov	r5,r3
 80032f0:	e13ff415 	stw	r4,-48(fp)
 80032f4:	e17ff515 	stw	r5,-44(fp)
	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
 80032f8:	0096b434 	movhi	r2,23248
 80032fc:	10b55f04 	addi	r2,r2,-10884
 8003300:	00cf79b4 	movhi	r3,15846
 8003304:	18f64e84 	addi	r3,r3,-9926
 8003308:	e1bff217 	ldw	r6,-56(fp)
 800330c:	e1fff317 	ldw	r7,-52(fp)
 8003310:	1009883a 	mov	r4,r2
 8003314:	180b883a 	mov	r5,r3
 8003318:	8004ad80 	call	8004ad8 <__muldf3>
 800331c:	1009883a 	mov	r4,r2
 8003320:	180b883a 	mov	r5,r3
 8003324:	2011883a 	mov	r8,r4
 8003328:	2813883a 	mov	r9,r5
 800332c:	00a28b34 	movhi	r2,35372
 8003330:	10a73ac4 	addi	r2,r2,-25365
 8003334:	00ef96f4 	movhi	r3,48731
 8003338:	18f97984 	addi	r3,r3,-6682
 800333c:	100d883a 	mov	r6,r2
 8003340:	180f883a 	mov	r7,r3
 8003344:	4009883a 	mov	r4,r8
 8003348:	480b883a 	mov	r5,r9
 800334c:	80040c80 	call	80040c8 <__adddf3>
 8003350:	1009883a 	mov	r4,r2
 8003354:	180b883a 	mov	r5,r3
 8003358:	2005883a 	mov	r2,r4
 800335c:	2807883a 	mov	r3,r5
 8003360:	e1bff217 	ldw	r6,-56(fp)
 8003364:	e1fff317 	ldw	r7,-52(fp)
 8003368:	1009883a 	mov	r4,r2
 800336c:	180b883a 	mov	r5,r3
 8003370:	8004ad80 	call	8004ad8 <__muldf3>
 8003374:	1009883a 	mov	r4,r2
 8003378:	180b883a 	mov	r5,r3
 800337c:	2011883a 	mov	r8,r4
 8003380:	2813883a 	mov	r9,r5
 8003384:	0095ecb4 	movhi	r2,22450
 8003388:	10bf9f44 	addi	r2,r2,-387
 800338c:	00cfb1f4 	movhi	r3,16071
 8003390:	18c778c4 	addi	r3,r3,7651
 8003394:	100d883a 	mov	r6,r2
 8003398:	180f883a 	mov	r7,r3
 800339c:	4009883a 	mov	r4,r8
 80033a0:	480b883a 	mov	r5,r9
 80033a4:	80040c80 	call	80040c8 <__adddf3>
 80033a8:	1009883a 	mov	r4,r2
 80033ac:	180b883a 	mov	r5,r3
 80033b0:	2005883a 	mov	r2,r4
 80033b4:	2807883a 	mov	r3,r5
 80033b8:	e1bff217 	ldw	r6,-56(fp)
 80033bc:	e1fff317 	ldw	r7,-52(fp)
 80033c0:	1009883a 	mov	r4,r2
 80033c4:	180b883a 	mov	r5,r3
 80033c8:	8004ad80 	call	8004ad8 <__muldf3>
 80033cc:	1009883a 	mov	r4,r2
 80033d0:	180b883a 	mov	r5,r3
 80033d4:	2011883a 	mov	r8,r4
 80033d8:	2813883a 	mov	r9,r5
 80033dc:	00867074 	movhi	r2,6593
 80033e0:	10987544 	addi	r2,r2,25045
 80033e4:	00efcab4 	movhi	r3,48938
 80033e8:	18c06804 	addi	r3,r3,416
 80033ec:	100d883a 	mov	r6,r2
 80033f0:	180f883a 	mov	r7,r3
 80033f4:	4009883a 	mov	r4,r8
 80033f8:	480b883a 	mov	r5,r9
 80033fc:	80040c80 	call	80040c8 <__adddf3>
 8003400:	1009883a 	mov	r4,r2
 8003404:	180b883a 	mov	r5,r3
 8003408:	2005883a 	mov	r2,r4
 800340c:	2807883a 	mov	r3,r5
 8003410:	e1bff217 	ldw	r6,-56(fp)
 8003414:	e1fff317 	ldw	r7,-52(fp)
 8003418:	1009883a 	mov	r4,r2
 800341c:	180b883a 	mov	r5,r3
 8003420:	8004ad80 	call	8004ad8 <__muldf3>
 8003424:	1009883a 	mov	r4,r2
 8003428:	180b883a 	mov	r5,r3
 800342c:	2011883a 	mov	r8,r4
 8003430:	2813883a 	mov	r9,r5
 8003434:	00844474 	movhi	r2,4369
 8003438:	10be2984 	addi	r2,r2,-1882
 800343c:	00cfe074 	movhi	r3,16257
 8003440:	18c44444 	addi	r3,r3,4369
 8003444:	100d883a 	mov	r6,r2
 8003448:	180f883a 	mov	r7,r3
 800344c:	4009883a 	mov	r4,r8
 8003450:	480b883a 	mov	r5,r9
 8003454:	80040c80 	call	80040c8 <__adddf3>
 8003458:	1009883a 	mov	r4,r2
 800345c:	180b883a 	mov	r5,r3
 8003460:	e13ff615 	stw	r4,-40(fp)
 8003464:	e17ff715 	stw	r5,-36(fp)
	if(iy==0) return x+v*(S1+z*r);
 8003468:	e0800217 	ldw	r2,8(fp)
 800346c:	1000291e 	bne	r2,zero,8003514 <__kernel_sin+0x2e0>
 8003470:	e1bff617 	ldw	r6,-40(fp)
 8003474:	e1fff717 	ldw	r7,-36(fp)
 8003478:	e13ff217 	ldw	r4,-56(fp)
 800347c:	e17ff317 	ldw	r5,-52(fp)
 8003480:	8004ad80 	call	8004ad8 <__muldf3>
 8003484:	1009883a 	mov	r4,r2
 8003488:	180b883a 	mov	r5,r3
 800348c:	2011883a 	mov	r8,r4
 8003490:	2813883a 	mov	r9,r5
 8003494:	00955574 	movhi	r2,21845
 8003498:	10955244 	addi	r2,r2,21833
 800349c:	00eff174 	movhi	r3,49093
 80034a0:	18d55544 	addi	r3,r3,21845
 80034a4:	100d883a 	mov	r6,r2
 80034a8:	180f883a 	mov	r7,r3
 80034ac:	4009883a 	mov	r4,r8
 80034b0:	480b883a 	mov	r5,r9
 80034b4:	80040c80 	call	80040c8 <__adddf3>
 80034b8:	1009883a 	mov	r4,r2
 80034bc:	180b883a 	mov	r5,r3
 80034c0:	2005883a 	mov	r2,r4
 80034c4:	2807883a 	mov	r3,r5
 80034c8:	e1bff417 	ldw	r6,-48(fp)
 80034cc:	e1fff517 	ldw	r7,-44(fp)
 80034d0:	1009883a 	mov	r4,r2
 80034d4:	180b883a 	mov	r5,r3
 80034d8:	8004ad80 	call	8004ad8 <__muldf3>
 80034dc:	1009883a 	mov	r4,r2
 80034e0:	180b883a 	mov	r5,r3
 80034e4:	2005883a 	mov	r2,r4
 80034e8:	2807883a 	mov	r3,r5
 80034ec:	e1bffa17 	ldw	r6,-24(fp)
 80034f0:	e1fffb17 	ldw	r7,-20(fp)
 80034f4:	1009883a 	mov	r4,r2
 80034f8:	180b883a 	mov	r5,r3
 80034fc:	80040c80 	call	80040c8 <__adddf3>
 8003500:	1009883a 	mov	r4,r2
 8003504:	180b883a 	mov	r5,r3
 8003508:	2005883a 	mov	r2,r4
 800350c:	2807883a 	mov	r3,r5
 8003510:	00004e06 	br	800364c <__kernel_sin+0x418>
	else      return x-((z*(half*y-v*r)-y)-v*S1);
 8003514:	0005883a 	mov	r2,zero
 8003518:	00cff834 	movhi	r3,16352
 800351c:	e1bffc17 	ldw	r6,-16(fp)
 8003520:	e1fffd17 	ldw	r7,-12(fp)
 8003524:	1009883a 	mov	r4,r2
 8003528:	180b883a 	mov	r5,r3
 800352c:	8004ad80 	call	8004ad8 <__muldf3>
 8003530:	1009883a 	mov	r4,r2
 8003534:	180b883a 	mov	r5,r3
 8003538:	2021883a 	mov	r16,r4
 800353c:	2823883a 	mov	r17,r5
 8003540:	e1bff617 	ldw	r6,-40(fp)
 8003544:	e1fff717 	ldw	r7,-36(fp)
 8003548:	e13ff417 	ldw	r4,-48(fp)
 800354c:	e17ff517 	ldw	r5,-44(fp)
 8003550:	8004ad80 	call	8004ad8 <__muldf3>
 8003554:	1009883a 	mov	r4,r2
 8003558:	180b883a 	mov	r5,r3
 800355c:	2005883a 	mov	r2,r4
 8003560:	2807883a 	mov	r3,r5
 8003564:	100d883a 	mov	r6,r2
 8003568:	180f883a 	mov	r7,r3
 800356c:	8009883a 	mov	r4,r16
 8003570:	880b883a 	mov	r5,r17
 8003574:	80051f00 	call	80051f0 <__subdf3>
 8003578:	1009883a 	mov	r4,r2
 800357c:	180b883a 	mov	r5,r3
 8003580:	2005883a 	mov	r2,r4
 8003584:	2807883a 	mov	r3,r5
 8003588:	e1bff217 	ldw	r6,-56(fp)
 800358c:	e1fff317 	ldw	r7,-52(fp)
 8003590:	1009883a 	mov	r4,r2
 8003594:	180b883a 	mov	r5,r3
 8003598:	8004ad80 	call	8004ad8 <__muldf3>
 800359c:	1009883a 	mov	r4,r2
 80035a0:	180b883a 	mov	r5,r3
 80035a4:	2005883a 	mov	r2,r4
 80035a8:	2807883a 	mov	r3,r5
 80035ac:	e1bffc17 	ldw	r6,-16(fp)
 80035b0:	e1fffd17 	ldw	r7,-12(fp)
 80035b4:	1009883a 	mov	r4,r2
 80035b8:	180b883a 	mov	r5,r3
 80035bc:	80051f00 	call	80051f0 <__subdf3>
 80035c0:	1009883a 	mov	r4,r2
 80035c4:	180b883a 	mov	r5,r3
 80035c8:	2021883a 	mov	r16,r4
 80035cc:	2823883a 	mov	r17,r5
 80035d0:	00955574 	movhi	r2,21845
 80035d4:	10955244 	addi	r2,r2,21833
 80035d8:	00eff174 	movhi	r3,49093
 80035dc:	18d55544 	addi	r3,r3,21845
 80035e0:	e1bff417 	ldw	r6,-48(fp)
 80035e4:	e1fff517 	ldw	r7,-44(fp)
 80035e8:	1009883a 	mov	r4,r2
 80035ec:	180b883a 	mov	r5,r3
 80035f0:	8004ad80 	call	8004ad8 <__muldf3>
 80035f4:	1009883a 	mov	r4,r2
 80035f8:	180b883a 	mov	r5,r3
 80035fc:	2005883a 	mov	r2,r4
 8003600:	2807883a 	mov	r3,r5
 8003604:	100d883a 	mov	r6,r2
 8003608:	180f883a 	mov	r7,r3
 800360c:	8009883a 	mov	r4,r16
 8003610:	880b883a 	mov	r5,r17
 8003614:	80051f00 	call	80051f0 <__subdf3>
 8003618:	1009883a 	mov	r4,r2
 800361c:	180b883a 	mov	r5,r3
 8003620:	2005883a 	mov	r2,r4
 8003624:	2807883a 	mov	r3,r5
 8003628:	100d883a 	mov	r6,r2
 800362c:	180f883a 	mov	r7,r3
 8003630:	e13ffa17 	ldw	r4,-24(fp)
 8003634:	e17ffb17 	ldw	r5,-20(fp)
 8003638:	80051f00 	call	80051f0 <__subdf3>
 800363c:	1009883a 	mov	r4,r2
 8003640:	180b883a 	mov	r5,r3
 8003644:	2005883a 	mov	r2,r4
 8003648:	2807883a 	mov	r3,r5
 800364c:	1009883a 	mov	r4,r2
 8003650:	180b883a 	mov	r5,r3
}
 8003654:	2005883a 	mov	r2,r4
 8003658:	2807883a 	mov	r3,r5
 800365c:	e6fffe04 	addi	sp,fp,-8
 8003660:	dfc00317 	ldw	ra,12(sp)
 8003664:	df000217 	ldw	fp,8(sp)
 8003668:	dc400117 	ldw	r17,4(sp)
 800366c:	dc000017 	ldw	r16,0(sp)
 8003670:	dec00404 	addi	sp,sp,16
 8003674:	f800283a 	ret

08003678 <fabs>:
	double fabs(double x)
#else
	double fabs(x)
	double x;
#endif
{
 8003678:	defff804 	addi	sp,sp,-32
 800367c:	df000715 	stw	fp,28(sp)
 8003680:	df000704 	addi	fp,sp,28
 8003684:	e13ffe15 	stw	r4,-8(fp)
 8003688:	e17fff15 	stw	r5,-4(fp)
	__uint32_t high;
	GET_HIGH_WORD(high,x);
 800368c:	e0bffe17 	ldw	r2,-8(fp)
 8003690:	e0bffa15 	stw	r2,-24(fp)
 8003694:	e0bfff17 	ldw	r2,-4(fp)
 8003698:	e0bffb15 	stw	r2,-20(fp)
 800369c:	e0bffb17 	ldw	r2,-20(fp)
 80036a0:	e0bff915 	stw	r2,-28(fp)
	SET_HIGH_WORD(x,high&0x7fffffff);
 80036a4:	e0bffe17 	ldw	r2,-8(fp)
 80036a8:	e0bffc15 	stw	r2,-16(fp)
 80036ac:	e0bfff17 	ldw	r2,-4(fp)
 80036b0:	e0bffd15 	stw	r2,-12(fp)
 80036b4:	e0fff917 	ldw	r3,-28(fp)
 80036b8:	00a00034 	movhi	r2,32768
 80036bc:	10bfffc4 	addi	r2,r2,-1
 80036c0:	1884703a 	and	r2,r3,r2
 80036c4:	e0bffd15 	stw	r2,-12(fp)
 80036c8:	e0bffc17 	ldw	r2,-16(fp)
 80036cc:	e0bffe15 	stw	r2,-8(fp)
 80036d0:	e0bffd17 	ldw	r2,-12(fp)
 80036d4:	e0bfff15 	stw	r2,-4(fp)
        return x;
 80036d8:	e0bffe17 	ldw	r2,-8(fp)
 80036dc:	e0ffff17 	ldw	r3,-4(fp)
 80036e0:	1009883a 	mov	r4,r2
 80036e4:	180b883a 	mov	r5,r3
}
 80036e8:	2005883a 	mov	r2,r4
 80036ec:	2807883a 	mov	r3,r5
 80036f0:	e037883a 	mov	sp,fp
 80036f4:	df000017 	ldw	fp,0(sp)
 80036f8:	dec00104 	addi	sp,sp,4
 80036fc:	f800283a 	ret

08003700 <floor>:
	double floor(double x)
#else
	double floor(x)
	double x;
#endif
{
 8003700:	defff304 	addi	sp,sp,-52
 8003704:	dfc00c15 	stw	ra,48(sp)
 8003708:	df000b15 	stw	fp,44(sp)
 800370c:	df000b04 	addi	fp,sp,44
 8003710:	e13ffe15 	stw	r4,-8(fp)
 8003714:	e17fff15 	stw	r5,-4(fp)
	__int32_t i0,i1,j0;
	__uint32_t i,j;
	EXTRACT_WORDS(i0,i1,x);
 8003718:	e0bffe17 	ldw	r2,-8(fp)
 800371c:	e0bffa15 	stw	r2,-24(fp)
 8003720:	e0bfff17 	ldw	r2,-4(fp)
 8003724:	e0bffb15 	stw	r2,-20(fp)
 8003728:	e0bffb17 	ldw	r2,-20(fp)
 800372c:	e0bff515 	stw	r2,-44(fp)
 8003730:	e0bffa17 	ldw	r2,-24(fp)
 8003734:	e0bff615 	stw	r2,-40(fp)
	j0 = ((i0>>20)&0x7ff)-0x3ff;
 8003738:	e0bff517 	ldw	r2,-44(fp)
 800373c:	1005d53a 	srai	r2,r2,20
 8003740:	1081ffcc 	andi	r2,r2,2047
 8003744:	10bf0044 	addi	r2,r2,-1023
 8003748:	e0bff715 	stw	r2,-36(fp)
	if(j0<20) {
 800374c:	e0bff717 	ldw	r2,-36(fp)
 8003750:	10800508 	cmpgei	r2,r2,20
 8003754:	1000561e 	bne	r2,zero,80038b0 <floor+0x1b0>
	    if(j0<0) { 	/* raise inexact if x != 0 */
 8003758:	e0bff717 	ldw	r2,-36(fp)
 800375c:	1000240e 	bge	r2,zero,80037f0 <floor+0xf0>
		if(huge+x>0.0) {/* return 0*sign(x) if |x|<1 */
 8003760:	00a20034 	movhi	r2,34816
 8003764:	109d6704 	addi	r2,r2,30108
 8003768:	00df8e34 	movhi	r3,32312
 800376c:	18f90f04 	addi	r3,r3,-7108
 8003770:	e1bffe17 	ldw	r6,-8(fp)
 8003774:	e1ffff17 	ldw	r7,-4(fp)
 8003778:	1009883a 	mov	r4,r2
 800377c:	180b883a 	mov	r5,r3
 8003780:	80040c80 	call	80040c8 <__adddf3>
 8003784:	1009883a 	mov	r4,r2
 8003788:	180b883a 	mov	r5,r3
 800378c:	2005883a 	mov	r2,r4
 8003790:	2807883a 	mov	r3,r5
 8003794:	000d883a 	mov	r6,zero
 8003798:	000f883a 	mov	r7,zero
 800379c:	1009883a 	mov	r4,r2
 80037a0:	180b883a 	mov	r5,r3
 80037a4:	80049fc0 	call	80049fc <__gedf2>
 80037a8:	0080930e 	bge	zero,r2,80039f8 <floor+0x2f8>
		    if(i0>=0) {i0=i1=0;} 
 80037ac:	e0bff517 	ldw	r2,-44(fp)
 80037b0:	10000416 	blt	r2,zero,80037c4 <floor+0xc4>
 80037b4:	e03ff615 	stw	zero,-40(fp)
 80037b8:	e0bff617 	ldw	r2,-40(fp)
 80037bc:	e0bff515 	stw	r2,-44(fp)
 80037c0:	00008d06 	br	80039f8 <floor+0x2f8>
		    else if(((i0&0x7fffffff)|i1)!=0)
 80037c4:	e0fff517 	ldw	r3,-44(fp)
 80037c8:	00a00034 	movhi	r2,32768
 80037cc:	10bfffc4 	addi	r2,r2,-1
 80037d0:	1886703a 	and	r3,r3,r2
 80037d4:	e0bff617 	ldw	r2,-40(fp)
 80037d8:	1884b03a 	or	r2,r3,r2
 80037dc:	10008626 	beq	r2,zero,80039f8 <floor+0x2f8>
			{ i0=0xbff00000;i1=0;}
 80037e0:	00affc34 	movhi	r2,49136
 80037e4:	e0bff515 	stw	r2,-44(fp)
 80037e8:	e03ff615 	stw	zero,-40(fp)
 80037ec:	00008206 	br	80039f8 <floor+0x2f8>
		}
	    } else {
		i = (0x000fffff)>>j0;
 80037f0:	00800434 	movhi	r2,16
 80037f4:	10bfffc4 	addi	r2,r2,-1
 80037f8:	e0fff717 	ldw	r3,-36(fp)
 80037fc:	10c5d83a 	sra	r2,r2,r3
 8003800:	e0bff815 	stw	r2,-32(fp)
		if(((i0&i)|i1)==0) return x; /* x is integral */
 8003804:	e0fff517 	ldw	r3,-44(fp)
 8003808:	e0bff817 	ldw	r2,-32(fp)
 800380c:	1886703a 	and	r3,r3,r2
 8003810:	e0bff617 	ldw	r2,-40(fp)
 8003814:	1884b03a 	or	r2,r3,r2
 8003818:	1000031e 	bne	r2,zero,8003828 <floor+0x128>
 800381c:	e0bffe17 	ldw	r2,-8(fp)
 8003820:	e0ffff17 	ldw	r3,-4(fp)
 8003824:	00007e06 	br	8003a20 <floor+0x320>
		if(huge+x>0.0) {	/* raise inexact flag */
 8003828:	00a20034 	movhi	r2,34816
 800382c:	109d6704 	addi	r2,r2,30108
 8003830:	00df8e34 	movhi	r3,32312
 8003834:	18f90f04 	addi	r3,r3,-7108
 8003838:	e1bffe17 	ldw	r6,-8(fp)
 800383c:	e1ffff17 	ldw	r7,-4(fp)
 8003840:	1009883a 	mov	r4,r2
 8003844:	180b883a 	mov	r5,r3
 8003848:	80040c80 	call	80040c8 <__adddf3>
 800384c:	1009883a 	mov	r4,r2
 8003850:	180b883a 	mov	r5,r3
 8003854:	2005883a 	mov	r2,r4
 8003858:	2807883a 	mov	r3,r5
 800385c:	000d883a 	mov	r6,zero
 8003860:	000f883a 	mov	r7,zero
 8003864:	1009883a 	mov	r4,r2
 8003868:	180b883a 	mov	r5,r3
 800386c:	80049fc0 	call	80049fc <__gedf2>
 8003870:	0080610e 	bge	zero,r2,80039f8 <floor+0x2f8>
		    if(i0<0) i0 += (0x00100000)>>j0;
 8003874:	e0bff517 	ldw	r2,-44(fp)
 8003878:	1000060e 	bge	r2,zero,8003894 <floor+0x194>
 800387c:	00c00434 	movhi	r3,16
 8003880:	e0bff717 	ldw	r2,-36(fp)
 8003884:	1885d83a 	sra	r2,r3,r2
 8003888:	e0fff517 	ldw	r3,-44(fp)
 800388c:	1885883a 	add	r2,r3,r2
 8003890:	e0bff515 	stw	r2,-44(fp)
		    i0 &= (~i); i1=0;
 8003894:	e0bff817 	ldw	r2,-32(fp)
 8003898:	0086303a 	nor	r3,zero,r2
 800389c:	e0bff517 	ldw	r2,-44(fp)
 80038a0:	1884703a 	and	r2,r3,r2
 80038a4:	e0bff515 	stw	r2,-44(fp)
 80038a8:	e03ff615 	stw	zero,-40(fp)
 80038ac:	00005206 	br	80039f8 <floor+0x2f8>
		}
	    }
	} else if (j0>51) {
 80038b0:	e0bff717 	ldw	r2,-36(fp)
 80038b4:	10800d10 	cmplti	r2,r2,52
 80038b8:	1000121e 	bne	r2,zero,8003904 <floor+0x204>
	    if(j0==0x400) return x+x;	/* inf or NaN */
 80038bc:	e0bff717 	ldw	r2,-36(fp)
 80038c0:	10810018 	cmpnei	r2,r2,1024
 80038c4:	10000c1e 	bne	r2,zero,80038f8 <floor+0x1f8>
 80038c8:	e0bffe17 	ldw	r2,-8(fp)
 80038cc:	e0ffff17 	ldw	r3,-4(fp)
 80038d0:	100d883a 	mov	r6,r2
 80038d4:	180f883a 	mov	r7,r3
 80038d8:	1009883a 	mov	r4,r2
 80038dc:	180b883a 	mov	r5,r3
 80038e0:	80040c80 	call	80040c8 <__adddf3>
 80038e4:	1009883a 	mov	r4,r2
 80038e8:	180b883a 	mov	r5,r3
 80038ec:	2005883a 	mov	r2,r4
 80038f0:	2807883a 	mov	r3,r5
 80038f4:	00004a06 	br	8003a20 <floor+0x320>
	    else return x;		/* x is integral */
 80038f8:	e0bffe17 	ldw	r2,-8(fp)
 80038fc:	e0ffff17 	ldw	r3,-4(fp)
 8003900:	00004706 	br	8003a20 <floor+0x320>
	} else {
	    i = ((__uint32_t)(0xffffffff))>>(j0-20);
 8003904:	e0bff717 	ldw	r2,-36(fp)
 8003908:	10bffb04 	addi	r2,r2,-20
 800390c:	00ffffc4 	movi	r3,-1
 8003910:	1884d83a 	srl	r2,r3,r2
 8003914:	e0bff815 	stw	r2,-32(fp)
	    if((i1&i)==0) return x;	/* x is integral */
 8003918:	e0fff617 	ldw	r3,-40(fp)
 800391c:	e0bff817 	ldw	r2,-32(fp)
 8003920:	1884703a 	and	r2,r3,r2
 8003924:	1000031e 	bne	r2,zero,8003934 <floor+0x234>
 8003928:	e0bffe17 	ldw	r2,-8(fp)
 800392c:	e0ffff17 	ldw	r3,-4(fp)
 8003930:	00003b06 	br	8003a20 <floor+0x320>
	    if(huge+x>0.0) { 		/* raise inexact flag */
 8003934:	00a20034 	movhi	r2,34816
 8003938:	109d6704 	addi	r2,r2,30108
 800393c:	00df8e34 	movhi	r3,32312
 8003940:	18f90f04 	addi	r3,r3,-7108
 8003944:	e1bffe17 	ldw	r6,-8(fp)
 8003948:	e1ffff17 	ldw	r7,-4(fp)
 800394c:	1009883a 	mov	r4,r2
 8003950:	180b883a 	mov	r5,r3
 8003954:	80040c80 	call	80040c8 <__adddf3>
 8003958:	1009883a 	mov	r4,r2
 800395c:	180b883a 	mov	r5,r3
 8003960:	2005883a 	mov	r2,r4
 8003964:	2807883a 	mov	r3,r5
 8003968:	000d883a 	mov	r6,zero
 800396c:	000f883a 	mov	r7,zero
 8003970:	1009883a 	mov	r4,r2
 8003974:	180b883a 	mov	r5,r3
 8003978:	80049fc0 	call	80049fc <__gedf2>
 800397c:	00801e0e 	bge	zero,r2,80039f8 <floor+0x2f8>
		if(i0<0) {
 8003980:	e0bff517 	ldw	r2,-44(fp)
 8003984:	1000170e 	bge	r2,zero,80039e4 <floor+0x2e4>
		    if(j0==20) i0+=1; 
 8003988:	e0bff717 	ldw	r2,-36(fp)
 800398c:	10800518 	cmpnei	r2,r2,20
 8003990:	1000041e 	bne	r2,zero,80039a4 <floor+0x2a4>
 8003994:	e0bff517 	ldw	r2,-44(fp)
 8003998:	10800044 	addi	r2,r2,1
 800399c:	e0bff515 	stw	r2,-44(fp)
 80039a0:	00001006 	br	80039e4 <floor+0x2e4>
		    else {
			j = i1+(1<<(52-j0));
 80039a4:	00c00d04 	movi	r3,52
 80039a8:	e0bff717 	ldw	r2,-36(fp)
 80039ac:	1885c83a 	sub	r2,r3,r2
 80039b0:	00c00044 	movi	r3,1
 80039b4:	1886983a 	sll	r3,r3,r2
 80039b8:	e0bff617 	ldw	r2,-40(fp)
 80039bc:	1885883a 	add	r2,r3,r2
 80039c0:	e0bff915 	stw	r2,-28(fp)
			if(j<i1) i0 +=1 ; 	/* got a carry */
 80039c4:	e0bff617 	ldw	r2,-40(fp)
 80039c8:	e0fff917 	ldw	r3,-28(fp)
 80039cc:	1880032e 	bgeu	r3,r2,80039dc <floor+0x2dc>
 80039d0:	e0bff517 	ldw	r2,-44(fp)
 80039d4:	10800044 	addi	r2,r2,1
 80039d8:	e0bff515 	stw	r2,-44(fp)
			i1=j;
 80039dc:	e0bff917 	ldw	r2,-28(fp)
 80039e0:	e0bff615 	stw	r2,-40(fp)
		    }
		}
		i1 &= (~i);
 80039e4:	e0bff817 	ldw	r2,-32(fp)
 80039e8:	0086303a 	nor	r3,zero,r2
 80039ec:	e0bff617 	ldw	r2,-40(fp)
 80039f0:	1884703a 	and	r2,r3,r2
 80039f4:	e0bff615 	stw	r2,-40(fp)
	    }
	}
	INSERT_WORDS(x,i0,i1);
 80039f8:	e0bff517 	ldw	r2,-44(fp)
 80039fc:	e0bffd15 	stw	r2,-12(fp)
 8003a00:	e0bff617 	ldw	r2,-40(fp)
 8003a04:	e0bffc15 	stw	r2,-16(fp)
 8003a08:	e0bffc17 	ldw	r2,-16(fp)
 8003a0c:	e0bffe15 	stw	r2,-8(fp)
 8003a10:	e0bffd17 	ldw	r2,-12(fp)
 8003a14:	e0bfff15 	stw	r2,-4(fp)
	return x;
 8003a18:	e0bffe17 	ldw	r2,-8(fp)
 8003a1c:	e0ffff17 	ldw	r3,-4(fp)
 8003a20:	1009883a 	mov	r4,r2
 8003a24:	180b883a 	mov	r5,r3
}
 8003a28:	2005883a 	mov	r2,r4
 8003a2c:	2807883a 	mov	r3,r5
 8003a30:	e037883a 	mov	sp,fp
 8003a34:	dfc00117 	ldw	ra,4(sp)
 8003a38:	df000017 	ldw	fp,0(sp)
 8003a3c:	dec00204 	addi	sp,sp,8
 8003a40:	f800283a 	ret

08003a44 <scalbn>:
	double scalbn (double x, int n)
#else
	double scalbn (x,n)
	double x; int n;
#endif
{
 8003a44:	defff004 	addi	sp,sp,-64
 8003a48:	dfc00f15 	stw	ra,60(sp)
 8003a4c:	df000e15 	stw	fp,56(sp)
 8003a50:	df000e04 	addi	fp,sp,56
 8003a54:	e13ffd15 	stw	r4,-12(fp)
 8003a58:	e17ffe15 	stw	r5,-8(fp)
 8003a5c:	e1bfff15 	stw	r6,-4(fp)
	__int32_t  k,hx,lx;
	EXTRACT_WORDS(hx,lx,x);
 8003a60:	e0bffd17 	ldw	r2,-12(fp)
 8003a64:	e0bff515 	stw	r2,-44(fp)
 8003a68:	e0bffe17 	ldw	r2,-8(fp)
 8003a6c:	e0bff615 	stw	r2,-40(fp)
 8003a70:	e0bff617 	ldw	r2,-40(fp)
 8003a74:	e0bff315 	stw	r2,-52(fp)
 8003a78:	e0bff517 	ldw	r2,-44(fp)
 8003a7c:	e0bff415 	stw	r2,-48(fp)
        k = (hx&0x7ff00000)>>20;		/* extract exponent */
 8003a80:	e0bff317 	ldw	r2,-52(fp)
 8003a84:	109ffc2c 	andhi	r2,r2,32752
 8003a88:	1005d53a 	srai	r2,r2,20
 8003a8c:	e0bff215 	stw	r2,-56(fp)
        if (k==0) {				/* 0 or subnormal x */
 8003a90:	e0bff217 	ldw	r2,-56(fp)
 8003a94:	1000321e 	bne	r2,zero,8003b60 <scalbn+0x11c>
            if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */
 8003a98:	e0fff317 	ldw	r3,-52(fp)
 8003a9c:	00a00034 	movhi	r2,32768
 8003aa0:	10bfffc4 	addi	r2,r2,-1
 8003aa4:	1886703a 	and	r3,r3,r2
 8003aa8:	e0bff417 	ldw	r2,-48(fp)
 8003aac:	1884b03a 	or	r2,r3,r2
 8003ab0:	1000031e 	bne	r2,zero,8003ac0 <scalbn+0x7c>
 8003ab4:	e0bffd17 	ldw	r2,-12(fp)
 8003ab8:	e0fffe17 	ldw	r3,-8(fp)
 8003abc:	0000c206 	br	8003dc8 <scalbn+0x384>
	    x *= two54; 
 8003ac0:	0005883a 	mov	r2,zero
 8003ac4:	00d0d434 	movhi	r3,17232
 8003ac8:	100d883a 	mov	r6,r2
 8003acc:	180f883a 	mov	r7,r3
 8003ad0:	e13ffd17 	ldw	r4,-12(fp)
 8003ad4:	e17ffe17 	ldw	r5,-8(fp)
 8003ad8:	8004ad80 	call	8004ad8 <__muldf3>
 8003adc:	1009883a 	mov	r4,r2
 8003ae0:	180b883a 	mov	r5,r3
 8003ae4:	e13ffd15 	stw	r4,-12(fp)
 8003ae8:	e17ffe15 	stw	r5,-8(fp)
	    GET_HIGH_WORD(hx,x);
 8003aec:	e0bffd17 	ldw	r2,-12(fp)
 8003af0:	e0bff715 	stw	r2,-36(fp)
 8003af4:	e0bffe17 	ldw	r2,-8(fp)
 8003af8:	e0bff815 	stw	r2,-32(fp)
 8003afc:	e0bff817 	ldw	r2,-32(fp)
 8003b00:	e0bff315 	stw	r2,-52(fp)
	    k = ((hx&0x7ff00000)>>20) - 54; 
 8003b04:	e0bff317 	ldw	r2,-52(fp)
 8003b08:	109ffc2c 	andhi	r2,r2,32752
 8003b0c:	1005d53a 	srai	r2,r2,20
 8003b10:	10bff284 	addi	r2,r2,-54
 8003b14:	e0bff215 	stw	r2,-56(fp)
            if (n< -50000) return tiny*x; 	/*underflow*/
 8003b18:	e0ffff17 	ldw	r3,-4(fp)
 8003b1c:	00bffff4 	movhi	r2,65535
 8003b20:	108f2c04 	addi	r2,r2,15536
 8003b24:	18800e0e 	bge	r3,r2,8003b60 <scalbn+0x11c>
 8003b28:	00b0be74 	movhi	r2,49913
 8003b2c:	10bcd644 	addi	r2,r2,-3239
 8003b30:	00c06974 	movhi	r3,421
 8003b34:	18db87c4 	addi	r3,r3,28191
 8003b38:	e1bffd17 	ldw	r6,-12(fp)
 8003b3c:	e1fffe17 	ldw	r7,-8(fp)
 8003b40:	1009883a 	mov	r4,r2
 8003b44:	180b883a 	mov	r5,r3
 8003b48:	8004ad80 	call	8004ad8 <__muldf3>
 8003b4c:	1009883a 	mov	r4,r2
 8003b50:	180b883a 	mov	r5,r3
 8003b54:	2005883a 	mov	r2,r4
 8003b58:	2807883a 	mov	r3,r5
 8003b5c:	00009a06 	br	8003dc8 <scalbn+0x384>
	    }
        if (k==0x7ff) return x+x;		/* NaN or Inf */
 8003b60:	e0bff217 	ldw	r2,-56(fp)
 8003b64:	1081ffd8 	cmpnei	r2,r2,2047
 8003b68:	10000c1e 	bne	r2,zero,8003b9c <scalbn+0x158>
 8003b6c:	e0bffd17 	ldw	r2,-12(fp)
 8003b70:	e0fffe17 	ldw	r3,-8(fp)
 8003b74:	100d883a 	mov	r6,r2
 8003b78:	180f883a 	mov	r7,r3
 8003b7c:	1009883a 	mov	r4,r2
 8003b80:	180b883a 	mov	r5,r3
 8003b84:	80040c80 	call	80040c8 <__adddf3>
 8003b88:	1009883a 	mov	r4,r2
 8003b8c:	180b883a 	mov	r5,r3
 8003b90:	2005883a 	mov	r2,r4
 8003b94:	2807883a 	mov	r3,r5
 8003b98:	00008b06 	br	8003dc8 <scalbn+0x384>
        k = k+n; 
 8003b9c:	e0fff217 	ldw	r3,-56(fp)
 8003ba0:	e0bfff17 	ldw	r2,-4(fp)
 8003ba4:	1885883a 	add	r2,r3,r2
 8003ba8:	e0bff215 	stw	r2,-56(fp)
        if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */
 8003bac:	e0bff217 	ldw	r2,-56(fp)
 8003bb0:	1081ffd0 	cmplti	r2,r2,2047
 8003bb4:	1000191e 	bne	r2,zero,8003c1c <scalbn+0x1d8>
 8003bb8:	00a20034 	movhi	r2,34816
 8003bbc:	109d6704 	addi	r2,r2,30108
 8003bc0:	00df8e34 	movhi	r3,32312
 8003bc4:	18f90f04 	addi	r3,r3,-7108
 8003bc8:	e1bffd17 	ldw	r6,-12(fp)
 8003bcc:	e1fffe17 	ldw	r7,-8(fp)
 8003bd0:	1009883a 	mov	r4,r2
 8003bd4:	180b883a 	mov	r5,r3
 8003bd8:	8003dec0 	call	8003dec <copysign>
 8003bdc:	1011883a 	mov	r8,r2
 8003be0:	1813883a 	mov	r9,r3
 8003be4:	00a20034 	movhi	r2,34816
 8003be8:	109d6704 	addi	r2,r2,30108
 8003bec:	00df8e34 	movhi	r3,32312
 8003bf0:	18f90f04 	addi	r3,r3,-7108
 8003bf4:	100d883a 	mov	r6,r2
 8003bf8:	180f883a 	mov	r7,r3
 8003bfc:	4009883a 	mov	r4,r8
 8003c00:	480b883a 	mov	r5,r9
 8003c04:	8004ad80 	call	8004ad8 <__muldf3>
 8003c08:	1009883a 	mov	r4,r2
 8003c0c:	180b883a 	mov	r5,r3
 8003c10:	2005883a 	mov	r2,r4
 8003c14:	2807883a 	mov	r3,r5
 8003c18:	00006b06 	br	8003dc8 <scalbn+0x384>
        if (k > 0) 				/* normal result */
 8003c1c:	e0bff217 	ldw	r2,-56(fp)
 8003c20:	0080130e 	bge	zero,r2,8003c70 <scalbn+0x22c>
	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}
 8003c24:	e0bffd17 	ldw	r2,-12(fp)
 8003c28:	e0bff915 	stw	r2,-28(fp)
 8003c2c:	e0bffe17 	ldw	r2,-8(fp)
 8003c30:	e0bffa15 	stw	r2,-24(fp)
 8003c34:	e0fff317 	ldw	r3,-52(fp)
 8003c38:	00a00434 	movhi	r2,32784
 8003c3c:	10bfffc4 	addi	r2,r2,-1
 8003c40:	1884703a 	and	r2,r3,r2
 8003c44:	e0fff217 	ldw	r3,-56(fp)
 8003c48:	1806953a 	slli	r3,r3,20
 8003c4c:	10c4b03a 	or	r2,r2,r3
 8003c50:	e0bffa15 	stw	r2,-24(fp)
 8003c54:	e0bff917 	ldw	r2,-28(fp)
 8003c58:	e0bffd15 	stw	r2,-12(fp)
 8003c5c:	e0bffa17 	ldw	r2,-24(fp)
 8003c60:	e0bffe15 	stw	r2,-8(fp)
 8003c64:	e0bffd17 	ldw	r2,-12(fp)
 8003c68:	e0fffe17 	ldw	r3,-8(fp)
 8003c6c:	00005606 	br	8003dc8 <scalbn+0x384>
        if (k <= -54) {
 8003c70:	e0bff217 	ldw	r2,-56(fp)
 8003c74:	10bff2c8 	cmpgei	r2,r2,-53
 8003c78:	1000351e 	bne	r2,zero,8003d50 <scalbn+0x30c>
            if (n > 50000) 	/* in case integer overflow in n+k */
 8003c7c:	e0bfff17 	ldw	r2,-4(fp)
 8003c80:	00f0d414 	movui	r3,50000
 8003c84:	1880190e 	bge	r3,r2,8003cec <scalbn+0x2a8>
		return huge*copysign(huge,x);	/*overflow*/
 8003c88:	00a20034 	movhi	r2,34816
 8003c8c:	109d6704 	addi	r2,r2,30108
 8003c90:	00df8e34 	movhi	r3,32312
 8003c94:	18f90f04 	addi	r3,r3,-7108
 8003c98:	e1bffd17 	ldw	r6,-12(fp)
 8003c9c:	e1fffe17 	ldw	r7,-8(fp)
 8003ca0:	1009883a 	mov	r4,r2
 8003ca4:	180b883a 	mov	r5,r3
 8003ca8:	8003dec0 	call	8003dec <copysign>
 8003cac:	1011883a 	mov	r8,r2
 8003cb0:	1813883a 	mov	r9,r3
 8003cb4:	00a20034 	movhi	r2,34816
 8003cb8:	109d6704 	addi	r2,r2,30108
 8003cbc:	00df8e34 	movhi	r3,32312
 8003cc0:	18f90f04 	addi	r3,r3,-7108
 8003cc4:	100d883a 	mov	r6,r2
 8003cc8:	180f883a 	mov	r7,r3
 8003ccc:	4009883a 	mov	r4,r8
 8003cd0:	480b883a 	mov	r5,r9
 8003cd4:	8004ad80 	call	8004ad8 <__muldf3>
 8003cd8:	1009883a 	mov	r4,r2
 8003cdc:	180b883a 	mov	r5,r3
 8003ce0:	2005883a 	mov	r2,r4
 8003ce4:	2807883a 	mov	r3,r5
 8003ce8:	00003706 	br	8003dc8 <scalbn+0x384>
	    else return tiny*copysign(tiny,x); 	/*underflow*/
 8003cec:	00b0be74 	movhi	r2,49913
 8003cf0:	10bcd644 	addi	r2,r2,-3239
 8003cf4:	00c06974 	movhi	r3,421
 8003cf8:	18db87c4 	addi	r3,r3,28191
 8003cfc:	e1bffd17 	ldw	r6,-12(fp)
 8003d00:	e1fffe17 	ldw	r7,-8(fp)
 8003d04:	1009883a 	mov	r4,r2
 8003d08:	180b883a 	mov	r5,r3
 8003d0c:	8003dec0 	call	8003dec <copysign>
 8003d10:	1011883a 	mov	r8,r2
 8003d14:	1813883a 	mov	r9,r3
 8003d18:	00b0be74 	movhi	r2,49913
 8003d1c:	10bcd644 	addi	r2,r2,-3239
 8003d20:	00c06974 	movhi	r3,421
 8003d24:	18db87c4 	addi	r3,r3,28191
 8003d28:	100d883a 	mov	r6,r2
 8003d2c:	180f883a 	mov	r7,r3
 8003d30:	4009883a 	mov	r4,r8
 8003d34:	480b883a 	mov	r5,r9
 8003d38:	8004ad80 	call	8004ad8 <__muldf3>
 8003d3c:	1009883a 	mov	r4,r2
 8003d40:	180b883a 	mov	r5,r3
 8003d44:	2005883a 	mov	r2,r4
 8003d48:	2807883a 	mov	r3,r5
 8003d4c:	00001e06 	br	8003dc8 <scalbn+0x384>
      }
        k += 54;				/* subnormal result */
 8003d50:	e0bff217 	ldw	r2,-56(fp)
 8003d54:	10800d84 	addi	r2,r2,54
 8003d58:	e0bff215 	stw	r2,-56(fp)
	SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
 8003d5c:	e0bffd17 	ldw	r2,-12(fp)
 8003d60:	e0bffb15 	stw	r2,-20(fp)
 8003d64:	e0bffe17 	ldw	r2,-8(fp)
 8003d68:	e0bffc15 	stw	r2,-16(fp)
 8003d6c:	e0fff317 	ldw	r3,-52(fp)
 8003d70:	00a00434 	movhi	r2,32784
 8003d74:	10bfffc4 	addi	r2,r2,-1
 8003d78:	1884703a 	and	r2,r3,r2
 8003d7c:	e0fff217 	ldw	r3,-56(fp)
 8003d80:	1806953a 	slli	r3,r3,20
 8003d84:	10c4b03a 	or	r2,r2,r3
 8003d88:	e0bffc15 	stw	r2,-16(fp)
 8003d8c:	e0bffb17 	ldw	r2,-20(fp)
 8003d90:	e0bffd15 	stw	r2,-12(fp)
 8003d94:	e0bffc17 	ldw	r2,-16(fp)
 8003d98:	e0bffe15 	stw	r2,-8(fp)
        return x*twom54;
 8003d9c:	0005883a 	mov	r2,zero
 8003da0:	00cf2434 	movhi	r3,15504
 8003da4:	e1bffd17 	ldw	r6,-12(fp)
 8003da8:	e1fffe17 	ldw	r7,-8(fp)
 8003dac:	1009883a 	mov	r4,r2
 8003db0:	180b883a 	mov	r5,r3
 8003db4:	8004ad80 	call	8004ad8 <__muldf3>
 8003db8:	1009883a 	mov	r4,r2
 8003dbc:	180b883a 	mov	r5,r3
 8003dc0:	2005883a 	mov	r2,r4
 8003dc4:	2807883a 	mov	r3,r5
 8003dc8:	1009883a 	mov	r4,r2
 8003dcc:	180b883a 	mov	r5,r3
}
 8003dd0:	2005883a 	mov	r2,r4
 8003dd4:	2807883a 	mov	r3,r5
 8003dd8:	e037883a 	mov	sp,fp
 8003ddc:	dfc00117 	ldw	ra,4(sp)
 8003de0:	df000017 	ldw	fp,0(sp)
 8003de4:	dec00204 	addi	sp,sp,8
 8003de8:	f800283a 	ret

08003dec <copysign>:
	double copysign(double x, double y)
#else
	double copysign(x,y)
	double x,y;
#endif
{
 8003dec:	defff304 	addi	sp,sp,-52
 8003df0:	df000c15 	stw	fp,48(sp)
 8003df4:	df000c04 	addi	fp,sp,48
 8003df8:	e13ffc15 	stw	r4,-16(fp)
 8003dfc:	e17ffd15 	stw	r5,-12(fp)
 8003e00:	e1bffe15 	stw	r6,-8(fp)
 8003e04:	e1ffff15 	stw	r7,-4(fp)
	__uint32_t hx,hy;
	GET_HIGH_WORD(hx,x);
 8003e08:	e0bffc17 	ldw	r2,-16(fp)
 8003e0c:	e0bff615 	stw	r2,-40(fp)
 8003e10:	e0bffd17 	ldw	r2,-12(fp)
 8003e14:	e0bff715 	stw	r2,-36(fp)
 8003e18:	e0bff717 	ldw	r2,-36(fp)
 8003e1c:	e0bff415 	stw	r2,-48(fp)
	GET_HIGH_WORD(hy,y);
 8003e20:	e0bffe17 	ldw	r2,-8(fp)
 8003e24:	e0bff815 	stw	r2,-32(fp)
 8003e28:	e0bfff17 	ldw	r2,-4(fp)
 8003e2c:	e0bff915 	stw	r2,-28(fp)
 8003e30:	e0bff917 	ldw	r2,-28(fp)
 8003e34:	e0bff515 	stw	r2,-44(fp)
	SET_HIGH_WORD(x,(hx&0x7fffffff)|(hy&0x80000000));
 8003e38:	e0bffc17 	ldw	r2,-16(fp)
 8003e3c:	e0bffa15 	stw	r2,-24(fp)
 8003e40:	e0bffd17 	ldw	r2,-12(fp)
 8003e44:	e0bffb15 	stw	r2,-20(fp)
 8003e48:	e0fff417 	ldw	r3,-48(fp)
 8003e4c:	00a00034 	movhi	r2,32768
 8003e50:	10bfffc4 	addi	r2,r2,-1
 8003e54:	1886703a 	and	r3,r3,r2
 8003e58:	e0bff517 	ldw	r2,-44(fp)
 8003e5c:	10a0002c 	andhi	r2,r2,32768
 8003e60:	1884b03a 	or	r2,r3,r2
 8003e64:	e0bffb15 	stw	r2,-20(fp)
 8003e68:	e0bffa17 	ldw	r2,-24(fp)
 8003e6c:	e0bffc15 	stw	r2,-16(fp)
 8003e70:	e0bffb17 	ldw	r2,-20(fp)
 8003e74:	e0bffd15 	stw	r2,-12(fp)
        return x;
 8003e78:	e0bffc17 	ldw	r2,-16(fp)
 8003e7c:	e0fffd17 	ldw	r3,-12(fp)
 8003e80:	1009883a 	mov	r4,r2
 8003e84:	180b883a 	mov	r5,r3
}
 8003e88:	2005883a 	mov	r2,r4
 8003e8c:	2807883a 	mov	r3,r5
 8003e90:	e037883a 	mov	sp,fp
 8003e94:	df000017 	ldw	fp,0(sp)
 8003e98:	dec00104 	addi	sp,sp,4
 8003e9c:	f800283a 	ret

08003ea0 <__fixunsdfsi>:
 8003ea0:	defffd04 	addi	sp,sp,-12
 8003ea4:	000d883a 	mov	r6,zero
 8003ea8:	01d07834 	movhi	r7,16864
 8003eac:	dc400115 	stw	r17,4(sp)
 8003eb0:	dc000015 	stw	r16,0(sp)
 8003eb4:	dfc00215 	stw	ra,8(sp)
 8003eb8:	2023883a 	mov	r17,r4
 8003ebc:	2821883a 	mov	r16,r5
 8003ec0:	80049fc0 	call	80049fc <__gedf2>
 8003ec4:	1000080e 	bge	r2,zero,8003ee8 <__fixunsdfsi+0x48>
 8003ec8:	8809883a 	mov	r4,r17
 8003ecc:	800b883a 	mov	r5,r16
 8003ed0:	8005aec0 	call	8005aec <__fixdfsi>
 8003ed4:	dfc00217 	ldw	ra,8(sp)
 8003ed8:	dc400117 	ldw	r17,4(sp)
 8003edc:	dc000017 	ldw	r16,0(sp)
 8003ee0:	dec00304 	addi	sp,sp,12
 8003ee4:	f800283a 	ret
 8003ee8:	000d883a 	mov	r6,zero
 8003eec:	01d07834 	movhi	r7,16864
 8003ef0:	8809883a 	mov	r4,r17
 8003ef4:	800b883a 	mov	r5,r16
 8003ef8:	80051f00 	call	80051f0 <__subdf3>
 8003efc:	180b883a 	mov	r5,r3
 8003f00:	1009883a 	mov	r4,r2
 8003f04:	8005aec0 	call	8005aec <__fixdfsi>
 8003f08:	00e00034 	movhi	r3,32768
 8003f0c:	10c5883a 	add	r2,r2,r3
 8003f10:	003ff006 	br	8003ed4 <__fixunsdfsi+0x34>

08003f14 <__divsi3>:
 8003f14:	20001b16 	blt	r4,zero,8003f84 <__divsi3+0x70>
 8003f18:	000f883a 	mov	r7,zero
 8003f1c:	28001616 	blt	r5,zero,8003f78 <__divsi3+0x64>
 8003f20:	200d883a 	mov	r6,r4
 8003f24:	29001a2e 	bgeu	r5,r4,8003f90 <__divsi3+0x7c>
 8003f28:	00800804 	movi	r2,32
 8003f2c:	00c00044 	movi	r3,1
 8003f30:	00000106 	br	8003f38 <__divsi3+0x24>
 8003f34:	10000d26 	beq	r2,zero,8003f6c <__divsi3+0x58>
 8003f38:	294b883a 	add	r5,r5,r5
 8003f3c:	10bfffc4 	addi	r2,r2,-1
 8003f40:	18c7883a 	add	r3,r3,r3
 8003f44:	293ffb36 	bltu	r5,r4,8003f34 <__divsi3+0x20>
 8003f48:	0005883a 	mov	r2,zero
 8003f4c:	18000726 	beq	r3,zero,8003f6c <__divsi3+0x58>
 8003f50:	0005883a 	mov	r2,zero
 8003f54:	31400236 	bltu	r6,r5,8003f60 <__divsi3+0x4c>
 8003f58:	314dc83a 	sub	r6,r6,r5
 8003f5c:	10c4b03a 	or	r2,r2,r3
 8003f60:	1806d07a 	srli	r3,r3,1
 8003f64:	280ad07a 	srli	r5,r5,1
 8003f68:	183ffa1e 	bne	r3,zero,8003f54 <__divsi3+0x40>
 8003f6c:	38000126 	beq	r7,zero,8003f74 <__divsi3+0x60>
 8003f70:	0085c83a 	sub	r2,zero,r2
 8003f74:	f800283a 	ret
 8003f78:	014bc83a 	sub	r5,zero,r5
 8003f7c:	39c0005c 	xori	r7,r7,1
 8003f80:	003fe706 	br	8003f20 <__divsi3+0xc>
 8003f84:	0109c83a 	sub	r4,zero,r4
 8003f88:	01c00044 	movi	r7,1
 8003f8c:	003fe306 	br	8003f1c <__divsi3+0x8>
 8003f90:	00c00044 	movi	r3,1
 8003f94:	003fee06 	br	8003f50 <__divsi3+0x3c>

08003f98 <__modsi3>:
 8003f98:	20001716 	blt	r4,zero,8003ff8 <__modsi3+0x60>
 8003f9c:	000f883a 	mov	r7,zero
 8003fa0:	2005883a 	mov	r2,r4
 8003fa4:	28001216 	blt	r5,zero,8003ff0 <__modsi3+0x58>
 8003fa8:	2900162e 	bgeu	r5,r4,8004004 <__modsi3+0x6c>
 8003fac:	01800804 	movi	r6,32
 8003fb0:	00c00044 	movi	r3,1
 8003fb4:	00000106 	br	8003fbc <__modsi3+0x24>
 8003fb8:	30000a26 	beq	r6,zero,8003fe4 <__modsi3+0x4c>
 8003fbc:	294b883a 	add	r5,r5,r5
 8003fc0:	31bfffc4 	addi	r6,r6,-1
 8003fc4:	18c7883a 	add	r3,r3,r3
 8003fc8:	293ffb36 	bltu	r5,r4,8003fb8 <__modsi3+0x20>
 8003fcc:	18000526 	beq	r3,zero,8003fe4 <__modsi3+0x4c>
 8003fd0:	1806d07a 	srli	r3,r3,1
 8003fd4:	11400136 	bltu	r2,r5,8003fdc <__modsi3+0x44>
 8003fd8:	1145c83a 	sub	r2,r2,r5
 8003fdc:	280ad07a 	srli	r5,r5,1
 8003fe0:	183ffb1e 	bne	r3,zero,8003fd0 <__modsi3+0x38>
 8003fe4:	38000126 	beq	r7,zero,8003fec <__modsi3+0x54>
 8003fe8:	0085c83a 	sub	r2,zero,r2
 8003fec:	f800283a 	ret
 8003ff0:	014bc83a 	sub	r5,zero,r5
 8003ff4:	003fec06 	br	8003fa8 <__modsi3+0x10>
 8003ff8:	0109c83a 	sub	r4,zero,r4
 8003ffc:	01c00044 	movi	r7,1
 8004000:	003fe706 	br	8003fa0 <__modsi3+0x8>
 8004004:	00c00044 	movi	r3,1
 8004008:	003ff106 	br	8003fd0 <__modsi3+0x38>

0800400c <__udivsi3>:
 800400c:	200d883a 	mov	r6,r4
 8004010:	2900152e 	bgeu	r5,r4,8004068 <__udivsi3+0x5c>
 8004014:	28001416 	blt	r5,zero,8004068 <__udivsi3+0x5c>
 8004018:	00800804 	movi	r2,32
 800401c:	00c00044 	movi	r3,1
 8004020:	00000206 	br	800402c <__udivsi3+0x20>
 8004024:	10000e26 	beq	r2,zero,8004060 <__udivsi3+0x54>
 8004028:	28000516 	blt	r5,zero,8004040 <__udivsi3+0x34>
 800402c:	294b883a 	add	r5,r5,r5
 8004030:	10bfffc4 	addi	r2,r2,-1
 8004034:	18c7883a 	add	r3,r3,r3
 8004038:	293ffa36 	bltu	r5,r4,8004024 <__udivsi3+0x18>
 800403c:	18000826 	beq	r3,zero,8004060 <__udivsi3+0x54>
 8004040:	0005883a 	mov	r2,zero
 8004044:	31400236 	bltu	r6,r5,8004050 <__udivsi3+0x44>
 8004048:	314dc83a 	sub	r6,r6,r5
 800404c:	10c4b03a 	or	r2,r2,r3
 8004050:	1806d07a 	srli	r3,r3,1
 8004054:	280ad07a 	srli	r5,r5,1
 8004058:	183ffa1e 	bne	r3,zero,8004044 <__udivsi3+0x38>
 800405c:	f800283a 	ret
 8004060:	0005883a 	mov	r2,zero
 8004064:	f800283a 	ret
 8004068:	00c00044 	movi	r3,1
 800406c:	003ff406 	br	8004040 <__udivsi3+0x34>

08004070 <__umodsi3>:
 8004070:	2005883a 	mov	r2,r4
 8004074:	2900122e 	bgeu	r5,r4,80040c0 <__umodsi3+0x50>
 8004078:	28001116 	blt	r5,zero,80040c0 <__umodsi3+0x50>
 800407c:	01800804 	movi	r6,32
 8004080:	00c00044 	movi	r3,1
 8004084:	00000206 	br	8004090 <__umodsi3+0x20>
 8004088:	30000c26 	beq	r6,zero,80040bc <__umodsi3+0x4c>
 800408c:	28000516 	blt	r5,zero,80040a4 <__umodsi3+0x34>
 8004090:	294b883a 	add	r5,r5,r5
 8004094:	31bfffc4 	addi	r6,r6,-1
 8004098:	18c7883a 	add	r3,r3,r3
 800409c:	293ffa36 	bltu	r5,r4,8004088 <__umodsi3+0x18>
 80040a0:	18000626 	beq	r3,zero,80040bc <__umodsi3+0x4c>
 80040a4:	1806d07a 	srli	r3,r3,1
 80040a8:	11400136 	bltu	r2,r5,80040b0 <__umodsi3+0x40>
 80040ac:	1145c83a 	sub	r2,r2,r5
 80040b0:	280ad07a 	srli	r5,r5,1
 80040b4:	183ffb1e 	bne	r3,zero,80040a4 <__umodsi3+0x34>
 80040b8:	f800283a 	ret
 80040bc:	f800283a 	ret
 80040c0:	00c00044 	movi	r3,1
 80040c4:	003ff706 	br	80040a4 <__umodsi3+0x34>

080040c8 <__adddf3>:
 80040c8:	02c00434 	movhi	r11,16
 80040cc:	5affffc4 	addi	r11,r11,-1
 80040d0:	2806d7fa 	srli	r3,r5,31
 80040d4:	2ad4703a 	and	r10,r5,r11
 80040d8:	3ad2703a 	and	r9,r7,r11
 80040dc:	3804d53a 	srli	r2,r7,20
 80040e0:	3018d77a 	srli	r12,r6,29
 80040e4:	280ad53a 	srli	r5,r5,20
 80040e8:	501490fa 	slli	r10,r10,3
 80040ec:	2010d77a 	srli	r8,r4,29
 80040f0:	481290fa 	slli	r9,r9,3
 80040f4:	380ed7fa 	srli	r7,r7,31
 80040f8:	defffb04 	addi	sp,sp,-20
 80040fc:	dc800215 	stw	r18,8(sp)
 8004100:	dc400115 	stw	r17,4(sp)
 8004104:	dc000015 	stw	r16,0(sp)
 8004108:	dfc00415 	stw	ra,16(sp)
 800410c:	dcc00315 	stw	r19,12(sp)
 8004110:	1c803fcc 	andi	r18,r3,255
 8004114:	2c01ffcc 	andi	r16,r5,2047
 8004118:	5210b03a 	or	r8,r10,r8
 800411c:	202290fa 	slli	r17,r4,3
 8004120:	1081ffcc 	andi	r2,r2,2047
 8004124:	4b12b03a 	or	r9,r9,r12
 8004128:	300c90fa 	slli	r6,r6,3
 800412c:	91c07526 	beq	r18,r7,8004304 <__adddf3+0x23c>
 8004130:	8087c83a 	sub	r3,r16,r2
 8004134:	00c0ab0e 	bge	zero,r3,80043e4 <__adddf3+0x31c>
 8004138:	10002a1e 	bne	r2,zero,80041e4 <__adddf3+0x11c>
 800413c:	4984b03a 	or	r2,r9,r6
 8004140:	1000961e 	bne	r2,zero,800439c <__adddf3+0x2d4>
 8004144:	888001cc 	andi	r2,r17,7
 8004148:	10000726 	beq	r2,zero,8004168 <__adddf3+0xa0>
 800414c:	888003cc 	andi	r2,r17,15
 8004150:	00c00104 	movi	r3,4
 8004154:	10c00426 	beq	r2,r3,8004168 <__adddf3+0xa0>
 8004158:	88c7883a 	add	r3,r17,r3
 800415c:	1c63803a 	cmpltu	r17,r3,r17
 8004160:	4451883a 	add	r8,r8,r17
 8004164:	1823883a 	mov	r17,r3
 8004168:	4080202c 	andhi	r2,r8,128
 800416c:	10005926 	beq	r2,zero,80042d4 <__adddf3+0x20c>
 8004170:	84000044 	addi	r16,r16,1
 8004174:	0081ffc4 	movi	r2,2047
 8004178:	8080ba26 	beq	r16,r2,8004464 <__adddf3+0x39c>
 800417c:	00bfe034 	movhi	r2,65408
 8004180:	10bfffc4 	addi	r2,r2,-1
 8004184:	4090703a 	and	r8,r8,r2
 8004188:	4004977a 	slli	r2,r8,29
 800418c:	4010927a 	slli	r8,r8,9
 8004190:	8822d0fa 	srli	r17,r17,3
 8004194:	8401ffcc 	andi	r16,r16,2047
 8004198:	4010d33a 	srli	r8,r8,12
 800419c:	9007883a 	mov	r3,r18
 80041a0:	1444b03a 	or	r2,r2,r17
 80041a4:	8401ffcc 	andi	r16,r16,2047
 80041a8:	8020953a 	slli	r16,r16,20
 80041ac:	18c03fcc 	andi	r3,r3,255
 80041b0:	01000434 	movhi	r4,16
 80041b4:	213fffc4 	addi	r4,r4,-1
 80041b8:	180697fa 	slli	r3,r3,31
 80041bc:	4110703a 	and	r8,r8,r4
 80041c0:	4410b03a 	or	r8,r8,r16
 80041c4:	40c6b03a 	or	r3,r8,r3
 80041c8:	dfc00417 	ldw	ra,16(sp)
 80041cc:	dcc00317 	ldw	r19,12(sp)
 80041d0:	dc800217 	ldw	r18,8(sp)
 80041d4:	dc400117 	ldw	r17,4(sp)
 80041d8:	dc000017 	ldw	r16,0(sp)
 80041dc:	dec00504 	addi	sp,sp,20
 80041e0:	f800283a 	ret
 80041e4:	0081ffc4 	movi	r2,2047
 80041e8:	80bfd626 	beq	r16,r2,8004144 <__adddf3+0x7c>
 80041ec:	4a402034 	orhi	r9,r9,128
 80041f0:	00800e04 	movi	r2,56
 80041f4:	10c09f16 	blt	r2,r3,8004474 <__adddf3+0x3ac>
 80041f8:	008007c4 	movi	r2,31
 80041fc:	10c0c216 	blt	r2,r3,8004508 <__adddf3+0x440>
 8004200:	00800804 	movi	r2,32
 8004204:	10c5c83a 	sub	r2,r2,r3
 8004208:	488a983a 	sll	r5,r9,r2
 800420c:	30c8d83a 	srl	r4,r6,r3
 8004210:	3084983a 	sll	r2,r6,r2
 8004214:	48c6d83a 	srl	r3,r9,r3
 8004218:	290cb03a 	or	r6,r5,r4
 800421c:	1004c03a 	cmpne	r2,r2,zero
 8004220:	308cb03a 	or	r6,r6,r2
 8004224:	898dc83a 	sub	r6,r17,r6
 8004228:	89a3803a 	cmpltu	r17,r17,r6
 800422c:	40d1c83a 	sub	r8,r8,r3
 8004230:	4451c83a 	sub	r8,r8,r17
 8004234:	3023883a 	mov	r17,r6
 8004238:	4080202c 	andhi	r2,r8,128
 800423c:	10002326 	beq	r2,zero,80042cc <__adddf3+0x204>
 8004240:	04c02034 	movhi	r19,128
 8004244:	9cffffc4 	addi	r19,r19,-1
 8004248:	44e6703a 	and	r19,r8,r19
 800424c:	98007626 	beq	r19,zero,8004428 <__adddf3+0x360>
 8004250:	9809883a 	mov	r4,r19
 8004254:	8005d580 	call	8005d58 <__clzsi2>
 8004258:	10fffe04 	addi	r3,r2,-8
 800425c:	010007c4 	movi	r4,31
 8004260:	20c07716 	blt	r4,r3,8004440 <__adddf3+0x378>
 8004264:	00800804 	movi	r2,32
 8004268:	10c5c83a 	sub	r2,r2,r3
 800426c:	8884d83a 	srl	r2,r17,r2
 8004270:	98d0983a 	sll	r8,r19,r3
 8004274:	88e2983a 	sll	r17,r17,r3
 8004278:	1204b03a 	or	r2,r2,r8
 800427c:	1c007416 	blt	r3,r16,8004450 <__adddf3+0x388>
 8004280:	1c21c83a 	sub	r16,r3,r16
 8004284:	82000044 	addi	r8,r16,1
 8004288:	00c007c4 	movi	r3,31
 800428c:	1a009116 	blt	r3,r8,80044d4 <__adddf3+0x40c>
 8004290:	00c00804 	movi	r3,32
 8004294:	1a07c83a 	sub	r3,r3,r8
 8004298:	8a08d83a 	srl	r4,r17,r8
 800429c:	88e2983a 	sll	r17,r17,r3
 80042a0:	10c6983a 	sll	r3,r2,r3
 80042a4:	1210d83a 	srl	r8,r2,r8
 80042a8:	8804c03a 	cmpne	r2,r17,zero
 80042ac:	1906b03a 	or	r3,r3,r4
 80042b0:	18a2b03a 	or	r17,r3,r2
 80042b4:	0021883a 	mov	r16,zero
 80042b8:	003fa206 	br	8004144 <__adddf3+0x7c>
 80042bc:	1890b03a 	or	r8,r3,r2
 80042c0:	40017d26 	beq	r8,zero,80048b8 <__adddf3+0x7f0>
 80042c4:	1011883a 	mov	r8,r2
 80042c8:	1823883a 	mov	r17,r3
 80042cc:	888001cc 	andi	r2,r17,7
 80042d0:	103f9e1e 	bne	r2,zero,800414c <__adddf3+0x84>
 80042d4:	4004977a 	slli	r2,r8,29
 80042d8:	8822d0fa 	srli	r17,r17,3
 80042dc:	4010d0fa 	srli	r8,r8,3
 80042e0:	9007883a 	mov	r3,r18
 80042e4:	1444b03a 	or	r2,r2,r17
 80042e8:	0101ffc4 	movi	r4,2047
 80042ec:	81002426 	beq	r16,r4,8004380 <__adddf3+0x2b8>
 80042f0:	8120703a 	and	r16,r16,r4
 80042f4:	01000434 	movhi	r4,16
 80042f8:	213fffc4 	addi	r4,r4,-1
 80042fc:	4110703a 	and	r8,r8,r4
 8004300:	003fa806 	br	80041a4 <__adddf3+0xdc>
 8004304:	8089c83a 	sub	r4,r16,r2
 8004308:	01005e0e 	bge	zero,r4,8004484 <__adddf3+0x3bc>
 800430c:	10002b26 	beq	r2,zero,80043bc <__adddf3+0x2f4>
 8004310:	0081ffc4 	movi	r2,2047
 8004314:	80bf8b26 	beq	r16,r2,8004144 <__adddf3+0x7c>
 8004318:	4a402034 	orhi	r9,r9,128
 800431c:	00800e04 	movi	r2,56
 8004320:	1100a40e 	bge	r2,r4,80045b4 <__adddf3+0x4ec>
 8004324:	498cb03a 	or	r6,r9,r6
 8004328:	300ac03a 	cmpne	r5,r6,zero
 800432c:	0013883a 	mov	r9,zero
 8004330:	2c4b883a 	add	r5,r5,r17
 8004334:	2c63803a 	cmpltu	r17,r5,r17
 8004338:	4a11883a 	add	r8,r9,r8
 800433c:	8a11883a 	add	r8,r17,r8
 8004340:	2823883a 	mov	r17,r5
 8004344:	4080202c 	andhi	r2,r8,128
 8004348:	103fe026 	beq	r2,zero,80042cc <__adddf3+0x204>
 800434c:	84000044 	addi	r16,r16,1
 8004350:	0081ffc4 	movi	r2,2047
 8004354:	8080d226 	beq	r16,r2,80046a0 <__adddf3+0x5d8>
 8004358:	00bfe034 	movhi	r2,65408
 800435c:	10bfffc4 	addi	r2,r2,-1
 8004360:	4090703a 	and	r8,r8,r2
 8004364:	880ad07a 	srli	r5,r17,1
 8004368:	400897fa 	slli	r4,r8,31
 800436c:	88c0004c 	andi	r3,r17,1
 8004370:	28e2b03a 	or	r17,r5,r3
 8004374:	4010d07a 	srli	r8,r8,1
 8004378:	2462b03a 	or	r17,r4,r17
 800437c:	003f7106 	br	8004144 <__adddf3+0x7c>
 8004380:	4088b03a 	or	r4,r8,r2
 8004384:	20014526 	beq	r4,zero,800489c <__adddf3+0x7d4>
 8004388:	01000434 	movhi	r4,16
 800438c:	42000234 	orhi	r8,r8,8
 8004390:	213fffc4 	addi	r4,r4,-1
 8004394:	4110703a 	and	r8,r8,r4
 8004398:	003f8206 	br	80041a4 <__adddf3+0xdc>
 800439c:	18ffffc4 	addi	r3,r3,-1
 80043a0:	1800491e 	bne	r3,zero,80044c8 <__adddf3+0x400>
 80043a4:	898bc83a 	sub	r5,r17,r6
 80043a8:	8963803a 	cmpltu	r17,r17,r5
 80043ac:	4251c83a 	sub	r8,r8,r9
 80043b0:	4451c83a 	sub	r8,r8,r17
 80043b4:	2823883a 	mov	r17,r5
 80043b8:	003f9f06 	br	8004238 <__adddf3+0x170>
 80043bc:	4984b03a 	or	r2,r9,r6
 80043c0:	103f6026 	beq	r2,zero,8004144 <__adddf3+0x7c>
 80043c4:	213fffc4 	addi	r4,r4,-1
 80043c8:	2000931e 	bne	r4,zero,8004618 <__adddf3+0x550>
 80043cc:	898d883a 	add	r6,r17,r6
 80043d0:	3463803a 	cmpltu	r17,r6,r17
 80043d4:	4251883a 	add	r8,r8,r9
 80043d8:	8a11883a 	add	r8,r17,r8
 80043dc:	3023883a 	mov	r17,r6
 80043e0:	003fd806 	br	8004344 <__adddf3+0x27c>
 80043e4:	1800541e 	bne	r3,zero,8004538 <__adddf3+0x470>
 80043e8:	80800044 	addi	r2,r16,1
 80043ec:	1081ffcc 	andi	r2,r2,2047
 80043f0:	00c00044 	movi	r3,1
 80043f4:	1880a00e 	bge	r3,r2,8004678 <__adddf3+0x5b0>
 80043f8:	8989c83a 	sub	r4,r17,r6
 80043fc:	8905803a 	cmpltu	r2,r17,r4
 8004400:	4267c83a 	sub	r19,r8,r9
 8004404:	98a7c83a 	sub	r19,r19,r2
 8004408:	9880202c 	andhi	r2,r19,128
 800440c:	10006326 	beq	r2,zero,800459c <__adddf3+0x4d4>
 8004410:	3463c83a 	sub	r17,r6,r17
 8004414:	4a07c83a 	sub	r3,r9,r8
 8004418:	344d803a 	cmpltu	r6,r6,r17
 800441c:	19a7c83a 	sub	r19,r3,r6
 8004420:	3825883a 	mov	r18,r7
 8004424:	983f8a1e 	bne	r19,zero,8004250 <__adddf3+0x188>
 8004428:	8809883a 	mov	r4,r17
 800442c:	8005d580 	call	8005d58 <__clzsi2>
 8004430:	10800804 	addi	r2,r2,32
 8004434:	10fffe04 	addi	r3,r2,-8
 8004438:	010007c4 	movi	r4,31
 800443c:	20ff890e 	bge	r4,r3,8004264 <__adddf3+0x19c>
 8004440:	10bff604 	addi	r2,r2,-40
 8004444:	8884983a 	sll	r2,r17,r2
 8004448:	0023883a 	mov	r17,zero
 800444c:	1c3f8c0e 	bge	r3,r16,8004280 <__adddf3+0x1b8>
 8004450:	023fe034 	movhi	r8,65408
 8004454:	423fffc4 	addi	r8,r8,-1
 8004458:	80e1c83a 	sub	r16,r16,r3
 800445c:	1210703a 	and	r8,r2,r8
 8004460:	003f3806 	br	8004144 <__adddf3+0x7c>
 8004464:	9007883a 	mov	r3,r18
 8004468:	0011883a 	mov	r8,zero
 800446c:	0005883a 	mov	r2,zero
 8004470:	003f4c06 	br	80041a4 <__adddf3+0xdc>
 8004474:	498cb03a 	or	r6,r9,r6
 8004478:	300cc03a 	cmpne	r6,r6,zero
 800447c:	0007883a 	mov	r3,zero
 8004480:	003f6806 	br	8004224 <__adddf3+0x15c>
 8004484:	20009c1e 	bne	r4,zero,80046f8 <__adddf3+0x630>
 8004488:	80800044 	addi	r2,r16,1
 800448c:	1141ffcc 	andi	r5,r2,2047
 8004490:	01000044 	movi	r4,1
 8004494:	2140670e 	bge	r4,r5,8004634 <__adddf3+0x56c>
 8004498:	0101ffc4 	movi	r4,2047
 800449c:	11007f26 	beq	r2,r4,800469c <__adddf3+0x5d4>
 80044a0:	898d883a 	add	r6,r17,r6
 80044a4:	4247883a 	add	r3,r8,r9
 80044a8:	3451803a 	cmpltu	r8,r6,r17
 80044ac:	40d1883a 	add	r8,r8,r3
 80044b0:	402297fa 	slli	r17,r8,31
 80044b4:	300cd07a 	srli	r6,r6,1
 80044b8:	4010d07a 	srli	r8,r8,1
 80044bc:	1021883a 	mov	r16,r2
 80044c0:	89a2b03a 	or	r17,r17,r6
 80044c4:	003f1f06 	br	8004144 <__adddf3+0x7c>
 80044c8:	0081ffc4 	movi	r2,2047
 80044cc:	80bf481e 	bne	r16,r2,80041f0 <__adddf3+0x128>
 80044d0:	003f1c06 	br	8004144 <__adddf3+0x7c>
 80044d4:	843ff844 	addi	r16,r16,-31
 80044d8:	01000804 	movi	r4,32
 80044dc:	1406d83a 	srl	r3,r2,r16
 80044e0:	41005026 	beq	r8,r4,8004624 <__adddf3+0x55c>
 80044e4:	01001004 	movi	r4,64
 80044e8:	2211c83a 	sub	r8,r4,r8
 80044ec:	1204983a 	sll	r2,r2,r8
 80044f0:	88a2b03a 	or	r17,r17,r2
 80044f4:	8822c03a 	cmpne	r17,r17,zero
 80044f8:	1c62b03a 	or	r17,r3,r17
 80044fc:	0011883a 	mov	r8,zero
 8004500:	0021883a 	mov	r16,zero
 8004504:	003f7106 	br	80042cc <__adddf3+0x204>
 8004508:	193ff804 	addi	r4,r3,-32
 800450c:	00800804 	movi	r2,32
 8004510:	4908d83a 	srl	r4,r9,r4
 8004514:	18804526 	beq	r3,r2,800462c <__adddf3+0x564>
 8004518:	00801004 	movi	r2,64
 800451c:	10c5c83a 	sub	r2,r2,r3
 8004520:	4886983a 	sll	r3,r9,r2
 8004524:	198cb03a 	or	r6,r3,r6
 8004528:	300cc03a 	cmpne	r6,r6,zero
 800452c:	218cb03a 	or	r6,r4,r6
 8004530:	0007883a 	mov	r3,zero
 8004534:	003f3b06 	br	8004224 <__adddf3+0x15c>
 8004538:	80002a26 	beq	r16,zero,80045e4 <__adddf3+0x51c>
 800453c:	0101ffc4 	movi	r4,2047
 8004540:	11006826 	beq	r2,r4,80046e4 <__adddf3+0x61c>
 8004544:	00c7c83a 	sub	r3,zero,r3
 8004548:	42002034 	orhi	r8,r8,128
 800454c:	01000e04 	movi	r4,56
 8004550:	20c07c16 	blt	r4,r3,8004744 <__adddf3+0x67c>
 8004554:	010007c4 	movi	r4,31
 8004558:	20c0da16 	blt	r4,r3,80048c4 <__adddf3+0x7fc>
 800455c:	01000804 	movi	r4,32
 8004560:	20c9c83a 	sub	r4,r4,r3
 8004564:	4114983a 	sll	r10,r8,r4
 8004568:	88cad83a 	srl	r5,r17,r3
 800456c:	8908983a 	sll	r4,r17,r4
 8004570:	40c6d83a 	srl	r3,r8,r3
 8004574:	5162b03a 	or	r17,r10,r5
 8004578:	2008c03a 	cmpne	r4,r4,zero
 800457c:	8922b03a 	or	r17,r17,r4
 8004580:	3463c83a 	sub	r17,r6,r17
 8004584:	48c7c83a 	sub	r3,r9,r3
 8004588:	344d803a 	cmpltu	r6,r6,r17
 800458c:	1991c83a 	sub	r8,r3,r6
 8004590:	1021883a 	mov	r16,r2
 8004594:	3825883a 	mov	r18,r7
 8004598:	003f2706 	br	8004238 <__adddf3+0x170>
 800459c:	24d0b03a 	or	r8,r4,r19
 80045a0:	40001b1e 	bne	r8,zero,8004610 <__adddf3+0x548>
 80045a4:	0005883a 	mov	r2,zero
 80045a8:	0007883a 	mov	r3,zero
 80045ac:	0021883a 	mov	r16,zero
 80045b0:	003f4d06 	br	80042e8 <__adddf3+0x220>
 80045b4:	008007c4 	movi	r2,31
 80045b8:	11003c16 	blt	r2,r4,80046ac <__adddf3+0x5e4>
 80045bc:	00800804 	movi	r2,32
 80045c0:	1105c83a 	sub	r2,r2,r4
 80045c4:	488e983a 	sll	r7,r9,r2
 80045c8:	310ad83a 	srl	r5,r6,r4
 80045cc:	3084983a 	sll	r2,r6,r2
 80045d0:	4912d83a 	srl	r9,r9,r4
 80045d4:	394ab03a 	or	r5,r7,r5
 80045d8:	1004c03a 	cmpne	r2,r2,zero
 80045dc:	288ab03a 	or	r5,r5,r2
 80045e0:	003f5306 	br	8004330 <__adddf3+0x268>
 80045e4:	4448b03a 	or	r4,r8,r17
 80045e8:	20003e26 	beq	r4,zero,80046e4 <__adddf3+0x61c>
 80045ec:	00c6303a 	nor	r3,zero,r3
 80045f0:	18003a1e 	bne	r3,zero,80046dc <__adddf3+0x614>
 80045f4:	3463c83a 	sub	r17,r6,r17
 80045f8:	4a07c83a 	sub	r3,r9,r8
 80045fc:	344d803a 	cmpltu	r6,r6,r17
 8004600:	1991c83a 	sub	r8,r3,r6
 8004604:	1021883a 	mov	r16,r2
 8004608:	3825883a 	mov	r18,r7
 800460c:	003f0a06 	br	8004238 <__adddf3+0x170>
 8004610:	2023883a 	mov	r17,r4
 8004614:	003f0d06 	br	800424c <__adddf3+0x184>
 8004618:	0081ffc4 	movi	r2,2047
 800461c:	80bf3f1e 	bne	r16,r2,800431c <__adddf3+0x254>
 8004620:	003ec806 	br	8004144 <__adddf3+0x7c>
 8004624:	0005883a 	mov	r2,zero
 8004628:	003fb106 	br	80044f0 <__adddf3+0x428>
 800462c:	0007883a 	mov	r3,zero
 8004630:	003fbc06 	br	8004524 <__adddf3+0x45c>
 8004634:	4444b03a 	or	r2,r8,r17
 8004638:	8000871e 	bne	r16,zero,8004858 <__adddf3+0x790>
 800463c:	1000ba26 	beq	r2,zero,8004928 <__adddf3+0x860>
 8004640:	4984b03a 	or	r2,r9,r6
 8004644:	103ebf26 	beq	r2,zero,8004144 <__adddf3+0x7c>
 8004648:	8985883a 	add	r2,r17,r6
 800464c:	4247883a 	add	r3,r8,r9
 8004650:	1451803a 	cmpltu	r8,r2,r17
 8004654:	40d1883a 	add	r8,r8,r3
 8004658:	40c0202c 	andhi	r3,r8,128
 800465c:	1023883a 	mov	r17,r2
 8004660:	183f1a26 	beq	r3,zero,80042cc <__adddf3+0x204>
 8004664:	00bfe034 	movhi	r2,65408
 8004668:	10bfffc4 	addi	r2,r2,-1
 800466c:	2021883a 	mov	r16,r4
 8004670:	4090703a 	and	r8,r8,r2
 8004674:	003eb306 	br	8004144 <__adddf3+0x7c>
 8004678:	4444b03a 	or	r2,r8,r17
 800467c:	8000291e 	bne	r16,zero,8004724 <__adddf3+0x65c>
 8004680:	10004b1e 	bne	r2,zero,80047b0 <__adddf3+0x6e8>
 8004684:	4990b03a 	or	r8,r9,r6
 8004688:	40008b26 	beq	r8,zero,80048b8 <__adddf3+0x7f0>
 800468c:	4811883a 	mov	r8,r9
 8004690:	3023883a 	mov	r17,r6
 8004694:	3825883a 	mov	r18,r7
 8004698:	003eaa06 	br	8004144 <__adddf3+0x7c>
 800469c:	1021883a 	mov	r16,r2
 80046a0:	0011883a 	mov	r8,zero
 80046a4:	0005883a 	mov	r2,zero
 80046a8:	003f0f06 	br	80042e8 <__adddf3+0x220>
 80046ac:	217ff804 	addi	r5,r4,-32
 80046b0:	00800804 	movi	r2,32
 80046b4:	494ad83a 	srl	r5,r9,r5
 80046b8:	20807d26 	beq	r4,r2,80048b0 <__adddf3+0x7e8>
 80046bc:	00801004 	movi	r2,64
 80046c0:	1109c83a 	sub	r4,r2,r4
 80046c4:	4912983a 	sll	r9,r9,r4
 80046c8:	498cb03a 	or	r6,r9,r6
 80046cc:	300cc03a 	cmpne	r6,r6,zero
 80046d0:	298ab03a 	or	r5,r5,r6
 80046d4:	0013883a 	mov	r9,zero
 80046d8:	003f1506 	br	8004330 <__adddf3+0x268>
 80046dc:	0101ffc4 	movi	r4,2047
 80046e0:	113f9a1e 	bne	r2,r4,800454c <__adddf3+0x484>
 80046e4:	4811883a 	mov	r8,r9
 80046e8:	3023883a 	mov	r17,r6
 80046ec:	1021883a 	mov	r16,r2
 80046f0:	3825883a 	mov	r18,r7
 80046f4:	003e9306 	br	8004144 <__adddf3+0x7c>
 80046f8:	8000161e 	bne	r16,zero,8004754 <__adddf3+0x68c>
 80046fc:	444ab03a 	or	r5,r8,r17
 8004700:	28005126 	beq	r5,zero,8004848 <__adddf3+0x780>
 8004704:	0108303a 	nor	r4,zero,r4
 8004708:	20004d1e 	bne	r4,zero,8004840 <__adddf3+0x778>
 800470c:	89a3883a 	add	r17,r17,r6
 8004710:	4253883a 	add	r9,r8,r9
 8004714:	898d803a 	cmpltu	r6,r17,r6
 8004718:	3251883a 	add	r8,r6,r9
 800471c:	1021883a 	mov	r16,r2
 8004720:	003f0806 	br	8004344 <__adddf3+0x27c>
 8004724:	1000301e 	bne	r2,zero,80047e8 <__adddf3+0x720>
 8004728:	4984b03a 	or	r2,r9,r6
 800472c:	10007126 	beq	r2,zero,80048f4 <__adddf3+0x82c>
 8004730:	4811883a 	mov	r8,r9
 8004734:	3023883a 	mov	r17,r6
 8004738:	3825883a 	mov	r18,r7
 800473c:	0401ffc4 	movi	r16,2047
 8004740:	003e8006 	br	8004144 <__adddf3+0x7c>
 8004744:	4462b03a 	or	r17,r8,r17
 8004748:	8822c03a 	cmpne	r17,r17,zero
 800474c:	0007883a 	mov	r3,zero
 8004750:	003f8b06 	br	8004580 <__adddf3+0x4b8>
 8004754:	0141ffc4 	movi	r5,2047
 8004758:	11403b26 	beq	r2,r5,8004848 <__adddf3+0x780>
 800475c:	0109c83a 	sub	r4,zero,r4
 8004760:	42002034 	orhi	r8,r8,128
 8004764:	01400e04 	movi	r5,56
 8004768:	29006716 	blt	r5,r4,8004908 <__adddf3+0x840>
 800476c:	014007c4 	movi	r5,31
 8004770:	29007016 	blt	r5,r4,8004934 <__adddf3+0x86c>
 8004774:	01400804 	movi	r5,32
 8004778:	290bc83a 	sub	r5,r5,r4
 800477c:	4154983a 	sll	r10,r8,r5
 8004780:	890ed83a 	srl	r7,r17,r4
 8004784:	894a983a 	sll	r5,r17,r5
 8004788:	4108d83a 	srl	r4,r8,r4
 800478c:	51e2b03a 	or	r17,r10,r7
 8004790:	280ac03a 	cmpne	r5,r5,zero
 8004794:	8962b03a 	or	r17,r17,r5
 8004798:	89a3883a 	add	r17,r17,r6
 800479c:	2253883a 	add	r9,r4,r9
 80047a0:	898d803a 	cmpltu	r6,r17,r6
 80047a4:	3251883a 	add	r8,r6,r9
 80047a8:	1021883a 	mov	r16,r2
 80047ac:	003ee506 	br	8004344 <__adddf3+0x27c>
 80047b0:	4984b03a 	or	r2,r9,r6
 80047b4:	103e6326 	beq	r2,zero,8004144 <__adddf3+0x7c>
 80047b8:	8987c83a 	sub	r3,r17,r6
 80047bc:	88c9803a 	cmpltu	r4,r17,r3
 80047c0:	4245c83a 	sub	r2,r8,r9
 80047c4:	1105c83a 	sub	r2,r2,r4
 80047c8:	1100202c 	andhi	r4,r2,128
 80047cc:	203ebb26 	beq	r4,zero,80042bc <__adddf3+0x1f4>
 80047d0:	3463c83a 	sub	r17,r6,r17
 80047d4:	4a07c83a 	sub	r3,r9,r8
 80047d8:	344d803a 	cmpltu	r6,r6,r17
 80047dc:	1991c83a 	sub	r8,r3,r6
 80047e0:	3825883a 	mov	r18,r7
 80047e4:	003e5706 	br	8004144 <__adddf3+0x7c>
 80047e8:	4984b03a 	or	r2,r9,r6
 80047ec:	10002e26 	beq	r2,zero,80048a8 <__adddf3+0x7e0>
 80047f0:	4004d0fa 	srli	r2,r8,3
 80047f4:	8822d0fa 	srli	r17,r17,3
 80047f8:	4010977a 	slli	r8,r8,29
 80047fc:	10c0022c 	andhi	r3,r2,8
 8004800:	4462b03a 	or	r17,r8,r17
 8004804:	18000826 	beq	r3,zero,8004828 <__adddf3+0x760>
 8004808:	4808d0fa 	srli	r4,r9,3
 800480c:	20c0022c 	andhi	r3,r4,8
 8004810:	1800051e 	bne	r3,zero,8004828 <__adddf3+0x760>
 8004814:	300cd0fa 	srli	r6,r6,3
 8004818:	4806977a 	slli	r3,r9,29
 800481c:	2005883a 	mov	r2,r4
 8004820:	3825883a 	mov	r18,r7
 8004824:	19a2b03a 	or	r17,r3,r6
 8004828:	8810d77a 	srli	r8,r17,29
 800482c:	100490fa 	slli	r2,r2,3
 8004830:	882290fa 	slli	r17,r17,3
 8004834:	0401ffc4 	movi	r16,2047
 8004838:	4090b03a 	or	r8,r8,r2
 800483c:	003e4106 	br	8004144 <__adddf3+0x7c>
 8004840:	0141ffc4 	movi	r5,2047
 8004844:	117fc71e 	bne	r2,r5,8004764 <__adddf3+0x69c>
 8004848:	4811883a 	mov	r8,r9
 800484c:	3023883a 	mov	r17,r6
 8004850:	1021883a 	mov	r16,r2
 8004854:	003e3b06 	br	8004144 <__adddf3+0x7c>
 8004858:	10002f26 	beq	r2,zero,8004918 <__adddf3+0x850>
 800485c:	4984b03a 	or	r2,r9,r6
 8004860:	10001126 	beq	r2,zero,80048a8 <__adddf3+0x7e0>
 8004864:	4004d0fa 	srli	r2,r8,3
 8004868:	8822d0fa 	srli	r17,r17,3
 800486c:	4010977a 	slli	r8,r8,29
 8004870:	10c0022c 	andhi	r3,r2,8
 8004874:	4462b03a 	or	r17,r8,r17
 8004878:	183feb26 	beq	r3,zero,8004828 <__adddf3+0x760>
 800487c:	4808d0fa 	srli	r4,r9,3
 8004880:	20c0022c 	andhi	r3,r4,8
 8004884:	183fe81e 	bne	r3,zero,8004828 <__adddf3+0x760>
 8004888:	300cd0fa 	srli	r6,r6,3
 800488c:	4806977a 	slli	r3,r9,29
 8004890:	2005883a 	mov	r2,r4
 8004894:	19a2b03a 	or	r17,r3,r6
 8004898:	003fe306 	br	8004828 <__adddf3+0x760>
 800489c:	0011883a 	mov	r8,zero
 80048a0:	0005883a 	mov	r2,zero
 80048a4:	003e3f06 	br	80041a4 <__adddf3+0xdc>
 80048a8:	0401ffc4 	movi	r16,2047
 80048ac:	003e2506 	br	8004144 <__adddf3+0x7c>
 80048b0:	0013883a 	mov	r9,zero
 80048b4:	003f8406 	br	80046c8 <__adddf3+0x600>
 80048b8:	0005883a 	mov	r2,zero
 80048bc:	0007883a 	mov	r3,zero
 80048c0:	003e8906 	br	80042e8 <__adddf3+0x220>
 80048c4:	197ff804 	addi	r5,r3,-32
 80048c8:	01000804 	movi	r4,32
 80048cc:	414ad83a 	srl	r5,r8,r5
 80048d0:	19002426 	beq	r3,r4,8004964 <__adddf3+0x89c>
 80048d4:	01001004 	movi	r4,64
 80048d8:	20c7c83a 	sub	r3,r4,r3
 80048dc:	40c6983a 	sll	r3,r8,r3
 80048e0:	1c46b03a 	or	r3,r3,r17
 80048e4:	1806c03a 	cmpne	r3,r3,zero
 80048e8:	28e2b03a 	or	r17,r5,r3
 80048ec:	0007883a 	mov	r3,zero
 80048f0:	003f2306 	br	8004580 <__adddf3+0x4b8>
 80048f4:	0007883a 	mov	r3,zero
 80048f8:	5811883a 	mov	r8,r11
 80048fc:	00bfffc4 	movi	r2,-1
 8004900:	0401ffc4 	movi	r16,2047
 8004904:	003e7806 	br	80042e8 <__adddf3+0x220>
 8004908:	4462b03a 	or	r17,r8,r17
 800490c:	8822c03a 	cmpne	r17,r17,zero
 8004910:	0009883a 	mov	r4,zero
 8004914:	003fa006 	br	8004798 <__adddf3+0x6d0>
 8004918:	4811883a 	mov	r8,r9
 800491c:	3023883a 	mov	r17,r6
 8004920:	0401ffc4 	movi	r16,2047
 8004924:	003e0706 	br	8004144 <__adddf3+0x7c>
 8004928:	4811883a 	mov	r8,r9
 800492c:	3023883a 	mov	r17,r6
 8004930:	003e0406 	br	8004144 <__adddf3+0x7c>
 8004934:	21fff804 	addi	r7,r4,-32
 8004938:	01400804 	movi	r5,32
 800493c:	41ced83a 	srl	r7,r8,r7
 8004940:	21400a26 	beq	r4,r5,800496c <__adddf3+0x8a4>
 8004944:	01401004 	movi	r5,64
 8004948:	2909c83a 	sub	r4,r5,r4
 800494c:	4108983a 	sll	r4,r8,r4
 8004950:	2448b03a 	or	r4,r4,r17
 8004954:	2008c03a 	cmpne	r4,r4,zero
 8004958:	3922b03a 	or	r17,r7,r4
 800495c:	0009883a 	mov	r4,zero
 8004960:	003f8d06 	br	8004798 <__adddf3+0x6d0>
 8004964:	0007883a 	mov	r3,zero
 8004968:	003fdd06 	br	80048e0 <__adddf3+0x818>
 800496c:	0009883a 	mov	r4,zero
 8004970:	003ff706 	br	8004950 <__adddf3+0x888>

08004974 <__eqdf2>:
 8004974:	2804d53a 	srli	r2,r5,20
 8004978:	3806d53a 	srli	r3,r7,20
 800497c:	02000434 	movhi	r8,16
 8004980:	423fffc4 	addi	r8,r8,-1
 8004984:	1081ffcc 	andi	r2,r2,2047
 8004988:	0281ffc4 	movi	r10,2047
 800498c:	2a12703a 	and	r9,r5,r8
 8004990:	18c1ffcc 	andi	r3,r3,2047
 8004994:	3a10703a 	and	r8,r7,r8
 8004998:	280ad7fa 	srli	r5,r5,31
 800499c:	380ed7fa 	srli	r7,r7,31
 80049a0:	12801026 	beq	r2,r10,80049e4 <__eqdf2+0x70>
 80049a4:	0281ffc4 	movi	r10,2047
 80049a8:	1a800a26 	beq	r3,r10,80049d4 <__eqdf2+0x60>
 80049ac:	10c00226 	beq	r2,r3,80049b8 <__eqdf2+0x44>
 80049b0:	00800044 	movi	r2,1
 80049b4:	f800283a 	ret
 80049b8:	4a3ffd1e 	bne	r9,r8,80049b0 <__eqdf2+0x3c>
 80049bc:	21bffc1e 	bne	r4,r6,80049b0 <__eqdf2+0x3c>
 80049c0:	29c00c26 	beq	r5,r7,80049f4 <__eqdf2+0x80>
 80049c4:	103ffa1e 	bne	r2,zero,80049b0 <__eqdf2+0x3c>
 80049c8:	2244b03a 	or	r2,r4,r9
 80049cc:	1004c03a 	cmpne	r2,r2,zero
 80049d0:	f800283a 	ret
 80049d4:	3214b03a 	or	r10,r6,r8
 80049d8:	503ff426 	beq	r10,zero,80049ac <__eqdf2+0x38>
 80049dc:	00800044 	movi	r2,1
 80049e0:	f800283a 	ret
 80049e4:	2254b03a 	or	r10,r4,r9
 80049e8:	503fee26 	beq	r10,zero,80049a4 <__eqdf2+0x30>
 80049ec:	00800044 	movi	r2,1
 80049f0:	f800283a 	ret
 80049f4:	0005883a 	mov	r2,zero
 80049f8:	f800283a 	ret

080049fc <__gedf2>:
 80049fc:	2804d53a 	srli	r2,r5,20
 8004a00:	3806d53a 	srli	r3,r7,20
 8004a04:	02000434 	movhi	r8,16
 8004a08:	423fffc4 	addi	r8,r8,-1
 8004a0c:	1081ffcc 	andi	r2,r2,2047
 8004a10:	0241ffc4 	movi	r9,2047
 8004a14:	2a14703a 	and	r10,r5,r8
 8004a18:	18c1ffcc 	andi	r3,r3,2047
 8004a1c:	3a10703a 	and	r8,r7,r8
 8004a20:	280ad7fa 	srli	r5,r5,31
 8004a24:	380ed7fa 	srli	r7,r7,31
 8004a28:	12401d26 	beq	r2,r9,8004aa0 <__gedf2+0xa4>
 8004a2c:	0241ffc4 	movi	r9,2047
 8004a30:	1a401226 	beq	r3,r9,8004a7c <__gedf2+0x80>
 8004a34:	1000081e 	bne	r2,zero,8004a58 <__gedf2+0x5c>
 8004a38:	2296b03a 	or	r11,r4,r10
 8004a3c:	5813003a 	cmpeq	r9,r11,zero
 8004a40:	1800091e 	bne	r3,zero,8004a68 <__gedf2+0x6c>
 8004a44:	3218b03a 	or	r12,r6,r8
 8004a48:	6000071e 	bne	r12,zero,8004a68 <__gedf2+0x6c>
 8004a4c:	0005883a 	mov	r2,zero
 8004a50:	5800101e 	bne	r11,zero,8004a94 <__gedf2+0x98>
 8004a54:	f800283a 	ret
 8004a58:	18000c1e 	bne	r3,zero,8004a8c <__gedf2+0x90>
 8004a5c:	3212b03a 	or	r9,r6,r8
 8004a60:	48000c26 	beq	r9,zero,8004a94 <__gedf2+0x98>
 8004a64:	0013883a 	mov	r9,zero
 8004a68:	39c03fcc 	andi	r7,r7,255
 8004a6c:	48000826 	beq	r9,zero,8004a90 <__gedf2+0x94>
 8004a70:	38000926 	beq	r7,zero,8004a98 <__gedf2+0x9c>
 8004a74:	00800044 	movi	r2,1
 8004a78:	f800283a 	ret
 8004a7c:	3212b03a 	or	r9,r6,r8
 8004a80:	483fec26 	beq	r9,zero,8004a34 <__gedf2+0x38>
 8004a84:	00bfff84 	movi	r2,-2
 8004a88:	f800283a 	ret
 8004a8c:	39c03fcc 	andi	r7,r7,255
 8004a90:	29c00626 	beq	r5,r7,8004aac <__gedf2+0xb0>
 8004a94:	283ff726 	beq	r5,zero,8004a74 <__gedf2+0x78>
 8004a98:	00bfffc4 	movi	r2,-1
 8004a9c:	f800283a 	ret
 8004aa0:	2292b03a 	or	r9,r4,r10
 8004aa4:	483fe126 	beq	r9,zero,8004a2c <__gedf2+0x30>
 8004aa8:	003ff606 	br	8004a84 <__gedf2+0x88>
 8004aac:	18bff916 	blt	r3,r2,8004a94 <__gedf2+0x98>
 8004ab0:	10c00316 	blt	r2,r3,8004ac0 <__gedf2+0xc4>
 8004ab4:	42bff736 	bltu	r8,r10,8004a94 <__gedf2+0x98>
 8004ab8:	52000326 	beq	r10,r8,8004ac8 <__gedf2+0xcc>
 8004abc:	5200042e 	bgeu	r10,r8,8004ad0 <__gedf2+0xd4>
 8004ac0:	283fec1e 	bne	r5,zero,8004a74 <__gedf2+0x78>
 8004ac4:	003ff406 	br	8004a98 <__gedf2+0x9c>
 8004ac8:	313ff236 	bltu	r6,r4,8004a94 <__gedf2+0x98>
 8004acc:	21bffc36 	bltu	r4,r6,8004ac0 <__gedf2+0xc4>
 8004ad0:	0005883a 	mov	r2,zero
 8004ad4:	f800283a 	ret

08004ad8 <__muldf3>:
 8004ad8:	defff304 	addi	sp,sp,-52
 8004adc:	2804d53a 	srli	r2,r5,20
 8004ae0:	dd800915 	stw	r22,36(sp)
 8004ae4:	282cd7fa 	srli	r22,r5,31
 8004ae8:	dc000315 	stw	r16,12(sp)
 8004aec:	04000434 	movhi	r16,16
 8004af0:	dd400815 	stw	r21,32(sp)
 8004af4:	dc800515 	stw	r18,20(sp)
 8004af8:	843fffc4 	addi	r16,r16,-1
 8004afc:	dfc00c15 	stw	ra,48(sp)
 8004b00:	df000b15 	stw	fp,44(sp)
 8004b04:	ddc00a15 	stw	r23,40(sp)
 8004b08:	dd000715 	stw	r20,28(sp)
 8004b0c:	dcc00615 	stw	r19,24(sp)
 8004b10:	dc400415 	stw	r17,16(sp)
 8004b14:	1481ffcc 	andi	r18,r2,2047
 8004b18:	2c20703a 	and	r16,r5,r16
 8004b1c:	b02b883a 	mov	r21,r22
 8004b20:	b2403fcc 	andi	r9,r22,255
 8004b24:	90006026 	beq	r18,zero,8004ca8 <__muldf3+0x1d0>
 8004b28:	0081ffc4 	movi	r2,2047
 8004b2c:	2029883a 	mov	r20,r4
 8004b30:	90803626 	beq	r18,r2,8004c0c <__muldf3+0x134>
 8004b34:	80800434 	orhi	r2,r16,16
 8004b38:	100490fa 	slli	r2,r2,3
 8004b3c:	2020d77a 	srli	r16,r4,29
 8004b40:	202890fa 	slli	r20,r4,3
 8004b44:	94bf0044 	addi	r18,r18,-1023
 8004b48:	80a0b03a 	or	r16,r16,r2
 8004b4c:	0027883a 	mov	r19,zero
 8004b50:	0039883a 	mov	fp,zero
 8004b54:	3804d53a 	srli	r2,r7,20
 8004b58:	382ed7fa 	srli	r23,r7,31
 8004b5c:	04400434 	movhi	r17,16
 8004b60:	8c7fffc4 	addi	r17,r17,-1
 8004b64:	1081ffcc 	andi	r2,r2,2047
 8004b68:	3011883a 	mov	r8,r6
 8004b6c:	3c62703a 	and	r17,r7,r17
 8004b70:	ba803fcc 	andi	r10,r23,255
 8004b74:	10006d26 	beq	r2,zero,8004d2c <__muldf3+0x254>
 8004b78:	00c1ffc4 	movi	r3,2047
 8004b7c:	10c06526 	beq	r2,r3,8004d14 <__muldf3+0x23c>
 8004b80:	88c00434 	orhi	r3,r17,16
 8004b84:	180690fa 	slli	r3,r3,3
 8004b88:	3022d77a 	srli	r17,r6,29
 8004b8c:	301090fa 	slli	r8,r6,3
 8004b90:	10bf0044 	addi	r2,r2,-1023
 8004b94:	88e2b03a 	or	r17,r17,r3
 8004b98:	000b883a 	mov	r5,zero
 8004b9c:	9085883a 	add	r2,r18,r2
 8004ba0:	2cc8b03a 	or	r4,r5,r19
 8004ba4:	00c003c4 	movi	r3,15
 8004ba8:	bdacf03a 	xor	r22,r23,r22
 8004bac:	12c00044 	addi	r11,r2,1
 8004bb0:	19009936 	bltu	r3,r4,8004e18 <__muldf3+0x340>
 8004bb4:	200890ba 	slli	r4,r4,2
 8004bb8:	00c20034 	movhi	r3,2048
 8004bbc:	18d2f304 	addi	r3,r3,19404
 8004bc0:	20c9883a 	add	r4,r4,r3
 8004bc4:	20c00017 	ldw	r3,0(r4)
 8004bc8:	1800683a 	jmp	r3
 8004bcc:	08004e18 	cmpnei	zero,at,312
 8004bd0:	08004c2c 	andhi	zero,at,304
 8004bd4:	08004c2c 	andhi	zero,at,304
 8004bd8:	08004c28 	cmpgeui	zero,at,304
 8004bdc:	08004df4 	orhi	zero,at,311
 8004be0:	08004df4 	orhi	zero,at,311
 8004be4:	08004ddc 	xori	zero,at,311
 8004be8:	08004c28 	cmpgeui	zero,at,304
 8004bec:	08004df4 	orhi	zero,at,311
 8004bf0:	08004ddc 	xori	zero,at,311
 8004bf4:	08004df4 	orhi	zero,at,311
 8004bf8:	08004c28 	cmpgeui	zero,at,304
 8004bfc:	08004e04 	addi	zero,at,312
 8004c00:	08004e04 	addi	zero,at,312
 8004c04:	08004e04 	addi	zero,at,312
 8004c08:	08005020 	cmpeqi	zero,at,320
 8004c0c:	2404b03a 	or	r2,r4,r16
 8004c10:	10006f1e 	bne	r2,zero,8004dd0 <__muldf3+0x2f8>
 8004c14:	04c00204 	movi	r19,8
 8004c18:	0021883a 	mov	r16,zero
 8004c1c:	0029883a 	mov	r20,zero
 8004c20:	07000084 	movi	fp,2
 8004c24:	003fcb06 	br	8004b54 <__muldf3+0x7c>
 8004c28:	502d883a 	mov	r22,r10
 8004c2c:	00800084 	movi	r2,2
 8004c30:	28805726 	beq	r5,r2,8004d90 <__muldf3+0x2b8>
 8004c34:	008000c4 	movi	r2,3
 8004c38:	28816626 	beq	r5,r2,80051d4 <__muldf3+0x6fc>
 8004c3c:	00800044 	movi	r2,1
 8004c40:	2881411e 	bne	r5,r2,8005148 <__muldf3+0x670>
 8004c44:	b02b883a 	mov	r21,r22
 8004c48:	0005883a 	mov	r2,zero
 8004c4c:	000b883a 	mov	r5,zero
 8004c50:	0029883a 	mov	r20,zero
 8004c54:	1004953a 	slli	r2,r2,20
 8004c58:	a8c03fcc 	andi	r3,r21,255
 8004c5c:	04400434 	movhi	r17,16
 8004c60:	8c7fffc4 	addi	r17,r17,-1
 8004c64:	180697fa 	slli	r3,r3,31
 8004c68:	2c4a703a 	and	r5,r5,r17
 8004c6c:	288ab03a 	or	r5,r5,r2
 8004c70:	28c6b03a 	or	r3,r5,r3
 8004c74:	a005883a 	mov	r2,r20
 8004c78:	dfc00c17 	ldw	ra,48(sp)
 8004c7c:	df000b17 	ldw	fp,44(sp)
 8004c80:	ddc00a17 	ldw	r23,40(sp)
 8004c84:	dd800917 	ldw	r22,36(sp)
 8004c88:	dd400817 	ldw	r21,32(sp)
 8004c8c:	dd000717 	ldw	r20,28(sp)
 8004c90:	dcc00617 	ldw	r19,24(sp)
 8004c94:	dc800517 	ldw	r18,20(sp)
 8004c98:	dc400417 	ldw	r17,16(sp)
 8004c9c:	dc000317 	ldw	r16,12(sp)
 8004ca0:	dec00d04 	addi	sp,sp,52
 8004ca4:	f800283a 	ret
 8004ca8:	2404b03a 	or	r2,r4,r16
 8004cac:	2027883a 	mov	r19,r4
 8004cb0:	10004226 	beq	r2,zero,8004dbc <__muldf3+0x2e4>
 8004cb4:	8000fc26 	beq	r16,zero,80050a8 <__muldf3+0x5d0>
 8004cb8:	8009883a 	mov	r4,r16
 8004cbc:	d9800215 	stw	r6,8(sp)
 8004cc0:	d9c00015 	stw	r7,0(sp)
 8004cc4:	da400115 	stw	r9,4(sp)
 8004cc8:	8005d580 	call	8005d58 <__clzsi2>
 8004ccc:	d9800217 	ldw	r6,8(sp)
 8004cd0:	d9c00017 	ldw	r7,0(sp)
 8004cd4:	da400117 	ldw	r9,4(sp)
 8004cd8:	113ffd44 	addi	r4,r2,-11
 8004cdc:	00c00704 	movi	r3,28
 8004ce0:	1900ed16 	blt	r3,r4,8005098 <__muldf3+0x5c0>
 8004ce4:	00c00744 	movi	r3,29
 8004ce8:	147ffe04 	addi	r17,r2,-8
 8004cec:	1907c83a 	sub	r3,r3,r4
 8004cf0:	8460983a 	sll	r16,r16,r17
 8004cf4:	98c6d83a 	srl	r3,r19,r3
 8004cf8:	9c68983a 	sll	r20,r19,r17
 8004cfc:	1c20b03a 	or	r16,r3,r16
 8004d00:	1080fcc4 	addi	r2,r2,1011
 8004d04:	00a5c83a 	sub	r18,zero,r2
 8004d08:	0027883a 	mov	r19,zero
 8004d0c:	0039883a 	mov	fp,zero
 8004d10:	003f9006 	br	8004b54 <__muldf3+0x7c>
 8004d14:	3446b03a 	or	r3,r6,r17
 8004d18:	1800261e 	bne	r3,zero,8004db4 <__muldf3+0x2dc>
 8004d1c:	0023883a 	mov	r17,zero
 8004d20:	0011883a 	mov	r8,zero
 8004d24:	01400084 	movi	r5,2
 8004d28:	003f9c06 	br	8004b9c <__muldf3+0xc4>
 8004d2c:	3446b03a 	or	r3,r6,r17
 8004d30:	18001c26 	beq	r3,zero,8004da4 <__muldf3+0x2cc>
 8004d34:	8800ce26 	beq	r17,zero,8005070 <__muldf3+0x598>
 8004d38:	8809883a 	mov	r4,r17
 8004d3c:	d9800215 	stw	r6,8(sp)
 8004d40:	da400115 	stw	r9,4(sp)
 8004d44:	da800015 	stw	r10,0(sp)
 8004d48:	8005d580 	call	8005d58 <__clzsi2>
 8004d4c:	d9800217 	ldw	r6,8(sp)
 8004d50:	da400117 	ldw	r9,4(sp)
 8004d54:	da800017 	ldw	r10,0(sp)
 8004d58:	113ffd44 	addi	r4,r2,-11
 8004d5c:	00c00704 	movi	r3,28
 8004d60:	1900bf16 	blt	r3,r4,8005060 <__muldf3+0x588>
 8004d64:	00c00744 	movi	r3,29
 8004d68:	123ffe04 	addi	r8,r2,-8
 8004d6c:	1907c83a 	sub	r3,r3,r4
 8004d70:	8a22983a 	sll	r17,r17,r8
 8004d74:	30c6d83a 	srl	r3,r6,r3
 8004d78:	3210983a 	sll	r8,r6,r8
 8004d7c:	1c62b03a 	or	r17,r3,r17
 8004d80:	1080fcc4 	addi	r2,r2,1011
 8004d84:	0085c83a 	sub	r2,zero,r2
 8004d88:	000b883a 	mov	r5,zero
 8004d8c:	003f8306 	br	8004b9c <__muldf3+0xc4>
 8004d90:	b02b883a 	mov	r21,r22
 8004d94:	0081ffc4 	movi	r2,2047
 8004d98:	000b883a 	mov	r5,zero
 8004d9c:	0029883a 	mov	r20,zero
 8004da0:	003fac06 	br	8004c54 <__muldf3+0x17c>
 8004da4:	0023883a 	mov	r17,zero
 8004da8:	0011883a 	mov	r8,zero
 8004dac:	01400044 	movi	r5,1
 8004db0:	003f7a06 	br	8004b9c <__muldf3+0xc4>
 8004db4:	014000c4 	movi	r5,3
 8004db8:	003f7806 	br	8004b9c <__muldf3+0xc4>
 8004dbc:	04c00104 	movi	r19,4
 8004dc0:	0021883a 	mov	r16,zero
 8004dc4:	0029883a 	mov	r20,zero
 8004dc8:	07000044 	movi	fp,1
 8004dcc:	003f6106 	br	8004b54 <__muldf3+0x7c>
 8004dd0:	04c00304 	movi	r19,12
 8004dd4:	070000c4 	movi	fp,3
 8004dd8:	003f5e06 	br	8004b54 <__muldf3+0x7c>
 8004ddc:	01400434 	movhi	r5,16
 8004de0:	002b883a 	mov	r21,zero
 8004de4:	297fffc4 	addi	r5,r5,-1
 8004de8:	053fffc4 	movi	r20,-1
 8004dec:	0081ffc4 	movi	r2,2047
 8004df0:	003f9806 	br	8004c54 <__muldf3+0x17c>
 8004df4:	8023883a 	mov	r17,r16
 8004df8:	a011883a 	mov	r8,r20
 8004dfc:	e00b883a 	mov	r5,fp
 8004e00:	003f8a06 	br	8004c2c <__muldf3+0x154>
 8004e04:	8023883a 	mov	r17,r16
 8004e08:	a011883a 	mov	r8,r20
 8004e0c:	482d883a 	mov	r22,r9
 8004e10:	e00b883a 	mov	r5,fp
 8004e14:	003f8506 	br	8004c2c <__muldf3+0x154>
 8004e18:	a00ad43a 	srli	r5,r20,16
 8004e1c:	401ad43a 	srli	r13,r8,16
 8004e20:	a53fffcc 	andi	r20,r20,65535
 8004e24:	423fffcc 	andi	r8,r8,65535
 8004e28:	4519383a 	mul	r12,r8,r20
 8004e2c:	4147383a 	mul	r3,r8,r5
 8004e30:	6d09383a 	mul	r4,r13,r20
 8004e34:	600cd43a 	srli	r6,r12,16
 8004e38:	2b5d383a 	mul	r14,r5,r13
 8004e3c:	20c9883a 	add	r4,r4,r3
 8004e40:	310d883a 	add	r6,r6,r4
 8004e44:	30c0022e 	bgeu	r6,r3,8004e50 <__muldf3+0x378>
 8004e48:	00c00074 	movhi	r3,1
 8004e4c:	70dd883a 	add	r14,r14,r3
 8004e50:	8826d43a 	srli	r19,r17,16
 8004e54:	8bffffcc 	andi	r15,r17,65535
 8004e58:	7d23383a 	mul	r17,r15,r20
 8004e5c:	7949383a 	mul	r4,r15,r5
 8004e60:	9d29383a 	mul	r20,r19,r20
 8004e64:	8814d43a 	srli	r10,r17,16
 8004e68:	3012943a 	slli	r9,r6,16
 8004e6c:	a129883a 	add	r20,r20,r4
 8004e70:	633fffcc 	andi	r12,r12,65535
 8004e74:	5515883a 	add	r10,r10,r20
 8004e78:	3006d43a 	srli	r3,r6,16
 8004e7c:	4b13883a 	add	r9,r9,r12
 8004e80:	2ccb383a 	mul	r5,r5,r19
 8004e84:	5100022e 	bgeu	r10,r4,8004e90 <__muldf3+0x3b8>
 8004e88:	01000074 	movhi	r4,1
 8004e8c:	290b883a 	add	r5,r5,r4
 8004e90:	802ad43a 	srli	r21,r16,16
 8004e94:	843fffcc 	andi	r16,r16,65535
 8004e98:	440d383a 	mul	r6,r8,r16
 8004e9c:	4565383a 	mul	r18,r8,r21
 8004ea0:	8349383a 	mul	r4,r16,r13
 8004ea4:	500e943a 	slli	r7,r10,16
 8004ea8:	3010d43a 	srli	r8,r6,16
 8004eac:	5028d43a 	srli	r20,r10,16
 8004eb0:	2489883a 	add	r4,r4,r18
 8004eb4:	8abfffcc 	andi	r10,r17,65535
 8004eb8:	3a95883a 	add	r10,r7,r10
 8004ebc:	4119883a 	add	r12,r8,r4
 8004ec0:	a169883a 	add	r20,r20,r5
 8004ec4:	1a87883a 	add	r3,r3,r10
 8004ec8:	6d5b383a 	mul	r13,r13,r21
 8004ecc:	6480022e 	bgeu	r12,r18,8004ed8 <__muldf3+0x400>
 8004ed0:	01000074 	movhi	r4,1
 8004ed4:	691b883a 	add	r13,r13,r4
 8004ed8:	7c25383a 	mul	r18,r15,r16
 8004edc:	7d4b383a 	mul	r5,r15,r21
 8004ee0:	84cf383a 	mul	r7,r16,r19
 8004ee4:	901ed43a 	srli	r15,r18,16
 8004ee8:	6008d43a 	srli	r4,r12,16
 8004eec:	6010943a 	slli	r8,r12,16
 8004ef0:	394f883a 	add	r7,r7,r5
 8004ef4:	333fffcc 	andi	r12,r6,65535
 8004ef8:	79df883a 	add	r15,r15,r7
 8004efc:	235b883a 	add	r13,r4,r13
 8004f00:	9d63383a 	mul	r17,r19,r21
 8004f04:	4309883a 	add	r4,r8,r12
 8004f08:	7940022e 	bgeu	r15,r5,8004f14 <__muldf3+0x43c>
 8004f0c:	01400074 	movhi	r5,1
 8004f10:	8963883a 	add	r17,r17,r5
 8004f14:	780a943a 	slli	r5,r15,16
 8004f18:	91bfffcc 	andi	r6,r18,65535
 8004f1c:	70c7883a 	add	r3,r14,r3
 8004f20:	298d883a 	add	r6,r5,r6
 8004f24:	1a8f803a 	cmpltu	r7,r3,r10
 8004f28:	350b883a 	add	r5,r6,r20
 8004f2c:	20c7883a 	add	r3,r4,r3
 8004f30:	3955883a 	add	r10,r7,r5
 8004f34:	1909803a 	cmpltu	r4,r3,r4
 8004f38:	6a91883a 	add	r8,r13,r10
 8004f3c:	780cd43a 	srli	r6,r15,16
 8004f40:	2219883a 	add	r12,r4,r8
 8004f44:	2d0b803a 	cmpltu	r5,r5,r20
 8004f48:	51cf803a 	cmpltu	r7,r10,r7
 8004f4c:	29ceb03a 	or	r7,r5,r7
 8004f50:	4351803a 	cmpltu	r8,r8,r13
 8004f54:	610b803a 	cmpltu	r5,r12,r4
 8004f58:	4148b03a 	or	r4,r8,r5
 8004f5c:	398f883a 	add	r7,r7,r6
 8004f60:	3909883a 	add	r4,r7,r4
 8004f64:	1810927a 	slli	r8,r3,9
 8004f68:	2449883a 	add	r4,r4,r17
 8004f6c:	2008927a 	slli	r4,r4,9
 8004f70:	6022d5fa 	srli	r17,r12,23
 8004f74:	1806d5fa 	srli	r3,r3,23
 8004f78:	4252b03a 	or	r9,r8,r9
 8004f7c:	600a927a 	slli	r5,r12,9
 8004f80:	4810c03a 	cmpne	r8,r9,zero
 8004f84:	2462b03a 	or	r17,r4,r17
 8004f88:	40c6b03a 	or	r3,r8,r3
 8004f8c:	8900402c 	andhi	r4,r17,256
 8004f90:	1950b03a 	or	r8,r3,r5
 8004f94:	20000726 	beq	r4,zero,8004fb4 <__muldf3+0x4dc>
 8004f98:	4006d07a 	srli	r3,r8,1
 8004f9c:	880497fa 	slli	r2,r17,31
 8004fa0:	4200004c 	andi	r8,r8,1
 8004fa4:	8822d07a 	srli	r17,r17,1
 8004fa8:	1a10b03a 	or	r8,r3,r8
 8004fac:	1210b03a 	or	r8,r2,r8
 8004fb0:	5805883a 	mov	r2,r11
 8004fb4:	1140ffc4 	addi	r5,r2,1023
 8004fb8:	0140440e 	bge	zero,r5,80050cc <__muldf3+0x5f4>
 8004fbc:	40c001cc 	andi	r3,r8,7
 8004fc0:	18000726 	beq	r3,zero,8004fe0 <__muldf3+0x508>
 8004fc4:	40c003cc 	andi	r3,r8,15
 8004fc8:	01000104 	movi	r4,4
 8004fcc:	19000426 	beq	r3,r4,8004fe0 <__muldf3+0x508>
 8004fd0:	4107883a 	add	r3,r8,r4
 8004fd4:	1a11803a 	cmpltu	r8,r3,r8
 8004fd8:	8a23883a 	add	r17,r17,r8
 8004fdc:	1811883a 	mov	r8,r3
 8004fe0:	88c0402c 	andhi	r3,r17,256
 8004fe4:	18000426 	beq	r3,zero,8004ff8 <__muldf3+0x520>
 8004fe8:	11410004 	addi	r5,r2,1024
 8004fec:	00bfc034 	movhi	r2,65280
 8004ff0:	10bfffc4 	addi	r2,r2,-1
 8004ff4:	88a2703a 	and	r17,r17,r2
 8004ff8:	0081ff84 	movi	r2,2046
 8004ffc:	117f6416 	blt	r2,r5,8004d90 <__muldf3+0x2b8>
 8005000:	8828977a 	slli	r20,r17,29
 8005004:	4010d0fa 	srli	r8,r8,3
 8005008:	8822927a 	slli	r17,r17,9
 800500c:	2881ffcc 	andi	r2,r5,2047
 8005010:	a228b03a 	or	r20,r20,r8
 8005014:	880ad33a 	srli	r5,r17,12
 8005018:	b02b883a 	mov	r21,r22
 800501c:	003f0d06 	br	8004c54 <__muldf3+0x17c>
 8005020:	8080022c 	andhi	r2,r16,8
 8005024:	10000926 	beq	r2,zero,800504c <__muldf3+0x574>
 8005028:	8880022c 	andhi	r2,r17,8
 800502c:	1000071e 	bne	r2,zero,800504c <__muldf3+0x574>
 8005030:	00800434 	movhi	r2,16
 8005034:	89400234 	orhi	r5,r17,8
 8005038:	10bfffc4 	addi	r2,r2,-1
 800503c:	b82b883a 	mov	r21,r23
 8005040:	288a703a 	and	r5,r5,r2
 8005044:	4029883a 	mov	r20,r8
 8005048:	003f6806 	br	8004dec <__muldf3+0x314>
 800504c:	00800434 	movhi	r2,16
 8005050:	81400234 	orhi	r5,r16,8
 8005054:	10bfffc4 	addi	r2,r2,-1
 8005058:	288a703a 	and	r5,r5,r2
 800505c:	003f6306 	br	8004dec <__muldf3+0x314>
 8005060:	147ff604 	addi	r17,r2,-40
 8005064:	3462983a 	sll	r17,r6,r17
 8005068:	0011883a 	mov	r8,zero
 800506c:	003f4406 	br	8004d80 <__muldf3+0x2a8>
 8005070:	3009883a 	mov	r4,r6
 8005074:	d9800215 	stw	r6,8(sp)
 8005078:	da400115 	stw	r9,4(sp)
 800507c:	da800015 	stw	r10,0(sp)
 8005080:	8005d580 	call	8005d58 <__clzsi2>
 8005084:	10800804 	addi	r2,r2,32
 8005088:	da800017 	ldw	r10,0(sp)
 800508c:	da400117 	ldw	r9,4(sp)
 8005090:	d9800217 	ldw	r6,8(sp)
 8005094:	003f3006 	br	8004d58 <__muldf3+0x280>
 8005098:	143ff604 	addi	r16,r2,-40
 800509c:	9c20983a 	sll	r16,r19,r16
 80050a0:	0029883a 	mov	r20,zero
 80050a4:	003f1606 	br	8004d00 <__muldf3+0x228>
 80050a8:	d9800215 	stw	r6,8(sp)
 80050ac:	d9c00015 	stw	r7,0(sp)
 80050b0:	da400115 	stw	r9,4(sp)
 80050b4:	8005d580 	call	8005d58 <__clzsi2>
 80050b8:	10800804 	addi	r2,r2,32
 80050bc:	da400117 	ldw	r9,4(sp)
 80050c0:	d9c00017 	ldw	r7,0(sp)
 80050c4:	d9800217 	ldw	r6,8(sp)
 80050c8:	003f0306 	br	8004cd8 <__muldf3+0x200>
 80050cc:	00c00044 	movi	r3,1
 80050d0:	1947c83a 	sub	r3,r3,r5
 80050d4:	00800e04 	movi	r2,56
 80050d8:	10feda16 	blt	r2,r3,8004c44 <__muldf3+0x16c>
 80050dc:	008007c4 	movi	r2,31
 80050e0:	10c01b16 	blt	r2,r3,8005150 <__muldf3+0x678>
 80050e4:	00800804 	movi	r2,32
 80050e8:	10c5c83a 	sub	r2,r2,r3
 80050ec:	888a983a 	sll	r5,r17,r2
 80050f0:	40c8d83a 	srl	r4,r8,r3
 80050f4:	4084983a 	sll	r2,r8,r2
 80050f8:	88e2d83a 	srl	r17,r17,r3
 80050fc:	2906b03a 	or	r3,r5,r4
 8005100:	1004c03a 	cmpne	r2,r2,zero
 8005104:	1886b03a 	or	r3,r3,r2
 8005108:	188001cc 	andi	r2,r3,7
 800510c:	10000726 	beq	r2,zero,800512c <__muldf3+0x654>
 8005110:	188003cc 	andi	r2,r3,15
 8005114:	01000104 	movi	r4,4
 8005118:	11000426 	beq	r2,r4,800512c <__muldf3+0x654>
 800511c:	1805883a 	mov	r2,r3
 8005120:	10c00104 	addi	r3,r2,4
 8005124:	1885803a 	cmpltu	r2,r3,r2
 8005128:	88a3883a 	add	r17,r17,r2
 800512c:	8880202c 	andhi	r2,r17,128
 8005130:	10001c26 	beq	r2,zero,80051a4 <__muldf3+0x6cc>
 8005134:	b02b883a 	mov	r21,r22
 8005138:	00800044 	movi	r2,1
 800513c:	000b883a 	mov	r5,zero
 8005140:	0029883a 	mov	r20,zero
 8005144:	003ec306 	br	8004c54 <__muldf3+0x17c>
 8005148:	5805883a 	mov	r2,r11
 800514c:	003f9906 	br	8004fb4 <__muldf3+0x4dc>
 8005150:	00bff844 	movi	r2,-31
 8005154:	1145c83a 	sub	r2,r2,r5
 8005158:	8888d83a 	srl	r4,r17,r2
 800515c:	00800804 	movi	r2,32
 8005160:	18801a26 	beq	r3,r2,80051cc <__muldf3+0x6f4>
 8005164:	00801004 	movi	r2,64
 8005168:	10c5c83a 	sub	r2,r2,r3
 800516c:	8884983a 	sll	r2,r17,r2
 8005170:	1204b03a 	or	r2,r2,r8
 8005174:	1004c03a 	cmpne	r2,r2,zero
 8005178:	2084b03a 	or	r2,r4,r2
 800517c:	144001cc 	andi	r17,r2,7
 8005180:	88000d1e 	bne	r17,zero,80051b8 <__muldf3+0x6e0>
 8005184:	000b883a 	mov	r5,zero
 8005188:	1028d0fa 	srli	r20,r2,3
 800518c:	b02b883a 	mov	r21,r22
 8005190:	0005883a 	mov	r2,zero
 8005194:	a468b03a 	or	r20,r20,r17
 8005198:	003eae06 	br	8004c54 <__muldf3+0x17c>
 800519c:	1007883a 	mov	r3,r2
 80051a0:	0023883a 	mov	r17,zero
 80051a4:	880a927a 	slli	r5,r17,9
 80051a8:	1805883a 	mov	r2,r3
 80051ac:	8822977a 	slli	r17,r17,29
 80051b0:	280ad33a 	srli	r5,r5,12
 80051b4:	003ff406 	br	8005188 <__muldf3+0x6b0>
 80051b8:	10c003cc 	andi	r3,r2,15
 80051bc:	01000104 	movi	r4,4
 80051c0:	193ff626 	beq	r3,r4,800519c <__muldf3+0x6c4>
 80051c4:	0023883a 	mov	r17,zero
 80051c8:	003fd506 	br	8005120 <__muldf3+0x648>
 80051cc:	0005883a 	mov	r2,zero
 80051d0:	003fe706 	br	8005170 <__muldf3+0x698>
 80051d4:	00800434 	movhi	r2,16
 80051d8:	89400234 	orhi	r5,r17,8
 80051dc:	10bfffc4 	addi	r2,r2,-1
 80051e0:	b02b883a 	mov	r21,r22
 80051e4:	288a703a 	and	r5,r5,r2
 80051e8:	4029883a 	mov	r20,r8
 80051ec:	003eff06 	br	8004dec <__muldf3+0x314>

080051f0 <__subdf3>:
 80051f0:	02000434 	movhi	r8,16
 80051f4:	423fffc4 	addi	r8,r8,-1
 80051f8:	defffb04 	addi	sp,sp,-20
 80051fc:	2a14703a 	and	r10,r5,r8
 8005200:	3812d53a 	srli	r9,r7,20
 8005204:	3a10703a 	and	r8,r7,r8
 8005208:	2006d77a 	srli	r3,r4,29
 800520c:	3004d77a 	srli	r2,r6,29
 8005210:	dc000015 	stw	r16,0(sp)
 8005214:	501490fa 	slli	r10,r10,3
 8005218:	2820d53a 	srli	r16,r5,20
 800521c:	401090fa 	slli	r8,r8,3
 8005220:	dc800215 	stw	r18,8(sp)
 8005224:	dc400115 	stw	r17,4(sp)
 8005228:	dfc00415 	stw	ra,16(sp)
 800522c:	202290fa 	slli	r17,r4,3
 8005230:	dcc00315 	stw	r19,12(sp)
 8005234:	4a41ffcc 	andi	r9,r9,2047
 8005238:	0101ffc4 	movi	r4,2047
 800523c:	2824d7fa 	srli	r18,r5,31
 8005240:	8401ffcc 	andi	r16,r16,2047
 8005244:	50c6b03a 	or	r3,r10,r3
 8005248:	380ed7fa 	srli	r7,r7,31
 800524c:	408ab03a 	or	r5,r8,r2
 8005250:	300c90fa 	slli	r6,r6,3
 8005254:	49009626 	beq	r9,r4,80054b0 <__subdf3+0x2c0>
 8005258:	39c0005c 	xori	r7,r7,1
 800525c:	8245c83a 	sub	r2,r16,r9
 8005260:	3c807426 	beq	r7,r18,8005434 <__subdf3+0x244>
 8005264:	0080af0e 	bge	zero,r2,8005524 <__subdf3+0x334>
 8005268:	48002a1e 	bne	r9,zero,8005314 <__subdf3+0x124>
 800526c:	2988b03a 	or	r4,r5,r6
 8005270:	20009a1e 	bne	r4,zero,80054dc <__subdf3+0x2ec>
 8005274:	888001cc 	andi	r2,r17,7
 8005278:	10000726 	beq	r2,zero,8005298 <__subdf3+0xa8>
 800527c:	888003cc 	andi	r2,r17,15
 8005280:	01000104 	movi	r4,4
 8005284:	11000426 	beq	r2,r4,8005298 <__subdf3+0xa8>
 8005288:	890b883a 	add	r5,r17,r4
 800528c:	2c63803a 	cmpltu	r17,r5,r17
 8005290:	1c47883a 	add	r3,r3,r17
 8005294:	2823883a 	mov	r17,r5
 8005298:	1880202c 	andhi	r2,r3,128
 800529c:	10005926 	beq	r2,zero,8005404 <__subdf3+0x214>
 80052a0:	84000044 	addi	r16,r16,1
 80052a4:	0081ffc4 	movi	r2,2047
 80052a8:	8080be26 	beq	r16,r2,80055a4 <__subdf3+0x3b4>
 80052ac:	017fe034 	movhi	r5,65408
 80052b0:	297fffc4 	addi	r5,r5,-1
 80052b4:	1946703a 	and	r3,r3,r5
 80052b8:	1804977a 	slli	r2,r3,29
 80052bc:	1806927a 	slli	r3,r3,9
 80052c0:	8822d0fa 	srli	r17,r17,3
 80052c4:	8401ffcc 	andi	r16,r16,2047
 80052c8:	180ad33a 	srli	r5,r3,12
 80052cc:	9100004c 	andi	r4,r18,1
 80052d0:	1444b03a 	or	r2,r2,r17
 80052d4:	80c1ffcc 	andi	r3,r16,2047
 80052d8:	1820953a 	slli	r16,r3,20
 80052dc:	20c03fcc 	andi	r3,r4,255
 80052e0:	180897fa 	slli	r4,r3,31
 80052e4:	00c00434 	movhi	r3,16
 80052e8:	18ffffc4 	addi	r3,r3,-1
 80052ec:	28c6703a 	and	r3,r5,r3
 80052f0:	1c06b03a 	or	r3,r3,r16
 80052f4:	1906b03a 	or	r3,r3,r4
 80052f8:	dfc00417 	ldw	ra,16(sp)
 80052fc:	dcc00317 	ldw	r19,12(sp)
 8005300:	dc800217 	ldw	r18,8(sp)
 8005304:	dc400117 	ldw	r17,4(sp)
 8005308:	dc000017 	ldw	r16,0(sp)
 800530c:	dec00504 	addi	sp,sp,20
 8005310:	f800283a 	ret
 8005314:	0101ffc4 	movi	r4,2047
 8005318:	813fd626 	beq	r16,r4,8005274 <__subdf3+0x84>
 800531c:	29402034 	orhi	r5,r5,128
 8005320:	01000e04 	movi	r4,56
 8005324:	2080a316 	blt	r4,r2,80055b4 <__subdf3+0x3c4>
 8005328:	010007c4 	movi	r4,31
 800532c:	2080c616 	blt	r4,r2,8005648 <__subdf3+0x458>
 8005330:	01000804 	movi	r4,32
 8005334:	2089c83a 	sub	r4,r4,r2
 8005338:	2910983a 	sll	r8,r5,r4
 800533c:	308ed83a 	srl	r7,r6,r2
 8005340:	3108983a 	sll	r4,r6,r4
 8005344:	2884d83a 	srl	r2,r5,r2
 8005348:	41ccb03a 	or	r6,r8,r7
 800534c:	2008c03a 	cmpne	r4,r4,zero
 8005350:	310cb03a 	or	r6,r6,r4
 8005354:	898dc83a 	sub	r6,r17,r6
 8005358:	89a3803a 	cmpltu	r17,r17,r6
 800535c:	1887c83a 	sub	r3,r3,r2
 8005360:	1c47c83a 	sub	r3,r3,r17
 8005364:	3023883a 	mov	r17,r6
 8005368:	1880202c 	andhi	r2,r3,128
 800536c:	10002326 	beq	r2,zero,80053fc <__subdf3+0x20c>
 8005370:	04c02034 	movhi	r19,128
 8005374:	9cffffc4 	addi	r19,r19,-1
 8005378:	1ce6703a 	and	r19,r3,r19
 800537c:	98007a26 	beq	r19,zero,8005568 <__subdf3+0x378>
 8005380:	9809883a 	mov	r4,r19
 8005384:	8005d580 	call	8005d58 <__clzsi2>
 8005388:	113ffe04 	addi	r4,r2,-8
 800538c:	00c007c4 	movi	r3,31
 8005390:	19007b16 	blt	r3,r4,8005580 <__subdf3+0x390>
 8005394:	00800804 	movi	r2,32
 8005398:	1105c83a 	sub	r2,r2,r4
 800539c:	8884d83a 	srl	r2,r17,r2
 80053a0:	9906983a 	sll	r3,r19,r4
 80053a4:	8922983a 	sll	r17,r17,r4
 80053a8:	10c4b03a 	or	r2,r2,r3
 80053ac:	24007816 	blt	r4,r16,8005590 <__subdf3+0x3a0>
 80053b0:	2421c83a 	sub	r16,r4,r16
 80053b4:	80c00044 	addi	r3,r16,1
 80053b8:	010007c4 	movi	r4,31
 80053bc:	20c09516 	blt	r4,r3,8005614 <__subdf3+0x424>
 80053c0:	01400804 	movi	r5,32
 80053c4:	28cbc83a 	sub	r5,r5,r3
 80053c8:	88c8d83a 	srl	r4,r17,r3
 80053cc:	8962983a 	sll	r17,r17,r5
 80053d0:	114a983a 	sll	r5,r2,r5
 80053d4:	10c6d83a 	srl	r3,r2,r3
 80053d8:	8804c03a 	cmpne	r2,r17,zero
 80053dc:	290ab03a 	or	r5,r5,r4
 80053e0:	28a2b03a 	or	r17,r5,r2
 80053e4:	0021883a 	mov	r16,zero
 80053e8:	003fa206 	br	8005274 <__subdf3+0x84>
 80053ec:	2090b03a 	or	r8,r4,r2
 80053f0:	40018e26 	beq	r8,zero,8005a2c <__subdf3+0x83c>
 80053f4:	1007883a 	mov	r3,r2
 80053f8:	2023883a 	mov	r17,r4
 80053fc:	888001cc 	andi	r2,r17,7
 8005400:	103f9e1e 	bne	r2,zero,800527c <__subdf3+0x8c>
 8005404:	1804977a 	slli	r2,r3,29
 8005408:	8822d0fa 	srli	r17,r17,3
 800540c:	1810d0fa 	srli	r8,r3,3
 8005410:	9100004c 	andi	r4,r18,1
 8005414:	1444b03a 	or	r2,r2,r17
 8005418:	00c1ffc4 	movi	r3,2047
 800541c:	80c02826 	beq	r16,r3,80054c0 <__subdf3+0x2d0>
 8005420:	01400434 	movhi	r5,16
 8005424:	297fffc4 	addi	r5,r5,-1
 8005428:	80e0703a 	and	r16,r16,r3
 800542c:	414a703a 	and	r5,r8,r5
 8005430:	003fa806 	br	80052d4 <__subdf3+0xe4>
 8005434:	0080630e 	bge	zero,r2,80055c4 <__subdf3+0x3d4>
 8005438:	48003026 	beq	r9,zero,80054fc <__subdf3+0x30c>
 800543c:	0101ffc4 	movi	r4,2047
 8005440:	813f8c26 	beq	r16,r4,8005274 <__subdf3+0x84>
 8005444:	29402034 	orhi	r5,r5,128
 8005448:	01000e04 	movi	r4,56
 800544c:	2080a90e 	bge	r4,r2,80056f4 <__subdf3+0x504>
 8005450:	298cb03a 	or	r6,r5,r6
 8005454:	3012c03a 	cmpne	r9,r6,zero
 8005458:	0005883a 	mov	r2,zero
 800545c:	4c53883a 	add	r9,r9,r17
 8005460:	4c63803a 	cmpltu	r17,r9,r17
 8005464:	10c7883a 	add	r3,r2,r3
 8005468:	88c7883a 	add	r3,r17,r3
 800546c:	4823883a 	mov	r17,r9
 8005470:	1880202c 	andhi	r2,r3,128
 8005474:	1000d026 	beq	r2,zero,80057b8 <__subdf3+0x5c8>
 8005478:	84000044 	addi	r16,r16,1
 800547c:	0081ffc4 	movi	r2,2047
 8005480:	8080fe26 	beq	r16,r2,800587c <__subdf3+0x68c>
 8005484:	00bfe034 	movhi	r2,65408
 8005488:	10bfffc4 	addi	r2,r2,-1
 800548c:	1886703a 	and	r3,r3,r2
 8005490:	880ad07a 	srli	r5,r17,1
 8005494:	180497fa 	slli	r2,r3,31
 8005498:	8900004c 	andi	r4,r17,1
 800549c:	2922b03a 	or	r17,r5,r4
 80054a0:	1806d07a 	srli	r3,r3,1
 80054a4:	1462b03a 	or	r17,r2,r17
 80054a8:	3825883a 	mov	r18,r7
 80054ac:	003f7106 	br	8005274 <__subdf3+0x84>
 80054b0:	2984b03a 	or	r2,r5,r6
 80054b4:	103f6826 	beq	r2,zero,8005258 <__subdf3+0x68>
 80054b8:	39c03fcc 	andi	r7,r7,255
 80054bc:	003f6706 	br	800525c <__subdf3+0x6c>
 80054c0:	4086b03a 	or	r3,r8,r2
 80054c4:	18015226 	beq	r3,zero,8005a10 <__subdf3+0x820>
 80054c8:	00c00434 	movhi	r3,16
 80054cc:	41400234 	orhi	r5,r8,8
 80054d0:	18ffffc4 	addi	r3,r3,-1
 80054d4:	28ca703a 	and	r5,r5,r3
 80054d8:	003f7e06 	br	80052d4 <__subdf3+0xe4>
 80054dc:	10bfffc4 	addi	r2,r2,-1
 80054e0:	1000491e 	bne	r2,zero,8005608 <__subdf3+0x418>
 80054e4:	898fc83a 	sub	r7,r17,r6
 80054e8:	89e3803a 	cmpltu	r17,r17,r7
 80054ec:	1947c83a 	sub	r3,r3,r5
 80054f0:	1c47c83a 	sub	r3,r3,r17
 80054f4:	3823883a 	mov	r17,r7
 80054f8:	003f9b06 	br	8005368 <__subdf3+0x178>
 80054fc:	2988b03a 	or	r4,r5,r6
 8005500:	203f5c26 	beq	r4,zero,8005274 <__subdf3+0x84>
 8005504:	10bfffc4 	addi	r2,r2,-1
 8005508:	1000931e 	bne	r2,zero,8005758 <__subdf3+0x568>
 800550c:	898d883a 	add	r6,r17,r6
 8005510:	3463803a 	cmpltu	r17,r6,r17
 8005514:	1947883a 	add	r3,r3,r5
 8005518:	88c7883a 	add	r3,r17,r3
 800551c:	3023883a 	mov	r17,r6
 8005520:	003fd306 	br	8005470 <__subdf3+0x280>
 8005524:	1000541e 	bne	r2,zero,8005678 <__subdf3+0x488>
 8005528:	80800044 	addi	r2,r16,1
 800552c:	1081ffcc 	andi	r2,r2,2047
 8005530:	01000044 	movi	r4,1
 8005534:	2080a20e 	bge	r4,r2,80057c0 <__subdf3+0x5d0>
 8005538:	8989c83a 	sub	r4,r17,r6
 800553c:	8905803a 	cmpltu	r2,r17,r4
 8005540:	1967c83a 	sub	r19,r3,r5
 8005544:	98a7c83a 	sub	r19,r19,r2
 8005548:	9880202c 	andhi	r2,r19,128
 800554c:	10006326 	beq	r2,zero,80056dc <__subdf3+0x4ec>
 8005550:	3463c83a 	sub	r17,r6,r17
 8005554:	28c7c83a 	sub	r3,r5,r3
 8005558:	344d803a 	cmpltu	r6,r6,r17
 800555c:	19a7c83a 	sub	r19,r3,r6
 8005560:	3825883a 	mov	r18,r7
 8005564:	983f861e 	bne	r19,zero,8005380 <__subdf3+0x190>
 8005568:	8809883a 	mov	r4,r17
 800556c:	8005d580 	call	8005d58 <__clzsi2>
 8005570:	10800804 	addi	r2,r2,32
 8005574:	113ffe04 	addi	r4,r2,-8
 8005578:	00c007c4 	movi	r3,31
 800557c:	193f850e 	bge	r3,r4,8005394 <__subdf3+0x1a4>
 8005580:	10bff604 	addi	r2,r2,-40
 8005584:	8884983a 	sll	r2,r17,r2
 8005588:	0023883a 	mov	r17,zero
 800558c:	243f880e 	bge	r4,r16,80053b0 <__subdf3+0x1c0>
 8005590:	00ffe034 	movhi	r3,65408
 8005594:	18ffffc4 	addi	r3,r3,-1
 8005598:	8121c83a 	sub	r16,r16,r4
 800559c:	10c6703a 	and	r3,r2,r3
 80055a0:	003f3406 	br	8005274 <__subdf3+0x84>
 80055a4:	9100004c 	andi	r4,r18,1
 80055a8:	000b883a 	mov	r5,zero
 80055ac:	0005883a 	mov	r2,zero
 80055b0:	003f4806 	br	80052d4 <__subdf3+0xe4>
 80055b4:	298cb03a 	or	r6,r5,r6
 80055b8:	300cc03a 	cmpne	r6,r6,zero
 80055bc:	0005883a 	mov	r2,zero
 80055c0:	003f6406 	br	8005354 <__subdf3+0x164>
 80055c4:	10009a1e 	bne	r2,zero,8005830 <__subdf3+0x640>
 80055c8:	82400044 	addi	r9,r16,1
 80055cc:	4881ffcc 	andi	r2,r9,2047
 80055d0:	02800044 	movi	r10,1
 80055d4:	5080670e 	bge	r10,r2,8005774 <__subdf3+0x584>
 80055d8:	0081ffc4 	movi	r2,2047
 80055dc:	4880af26 	beq	r9,r2,800589c <__subdf3+0x6ac>
 80055e0:	898d883a 	add	r6,r17,r6
 80055e4:	1945883a 	add	r2,r3,r5
 80055e8:	3447803a 	cmpltu	r3,r6,r17
 80055ec:	1887883a 	add	r3,r3,r2
 80055f0:	182297fa 	slli	r17,r3,31
 80055f4:	300cd07a 	srli	r6,r6,1
 80055f8:	1806d07a 	srli	r3,r3,1
 80055fc:	4821883a 	mov	r16,r9
 8005600:	89a2b03a 	or	r17,r17,r6
 8005604:	003f1b06 	br	8005274 <__subdf3+0x84>
 8005608:	0101ffc4 	movi	r4,2047
 800560c:	813f441e 	bne	r16,r4,8005320 <__subdf3+0x130>
 8005610:	003f1806 	br	8005274 <__subdf3+0x84>
 8005614:	843ff844 	addi	r16,r16,-31
 8005618:	01400804 	movi	r5,32
 800561c:	1408d83a 	srl	r4,r2,r16
 8005620:	19405026 	beq	r3,r5,8005764 <__subdf3+0x574>
 8005624:	01401004 	movi	r5,64
 8005628:	28c7c83a 	sub	r3,r5,r3
 800562c:	10c4983a 	sll	r2,r2,r3
 8005630:	88a2b03a 	or	r17,r17,r2
 8005634:	8822c03a 	cmpne	r17,r17,zero
 8005638:	2462b03a 	or	r17,r4,r17
 800563c:	0007883a 	mov	r3,zero
 8005640:	0021883a 	mov	r16,zero
 8005644:	003f6d06 	br	80053fc <__subdf3+0x20c>
 8005648:	11fff804 	addi	r7,r2,-32
 800564c:	01000804 	movi	r4,32
 8005650:	29ced83a 	srl	r7,r5,r7
 8005654:	11004526 	beq	r2,r4,800576c <__subdf3+0x57c>
 8005658:	01001004 	movi	r4,64
 800565c:	2089c83a 	sub	r4,r4,r2
 8005660:	2904983a 	sll	r2,r5,r4
 8005664:	118cb03a 	or	r6,r2,r6
 8005668:	300cc03a 	cmpne	r6,r6,zero
 800566c:	398cb03a 	or	r6,r7,r6
 8005670:	0005883a 	mov	r2,zero
 8005674:	003f3706 	br	8005354 <__subdf3+0x164>
 8005678:	80002a26 	beq	r16,zero,8005724 <__subdf3+0x534>
 800567c:	0101ffc4 	movi	r4,2047
 8005680:	49006626 	beq	r9,r4,800581c <__subdf3+0x62c>
 8005684:	0085c83a 	sub	r2,zero,r2
 8005688:	18c02034 	orhi	r3,r3,128
 800568c:	01000e04 	movi	r4,56
 8005690:	20807e16 	blt	r4,r2,800588c <__subdf3+0x69c>
 8005694:	010007c4 	movi	r4,31
 8005698:	2080e716 	blt	r4,r2,8005a38 <__subdf3+0x848>
 800569c:	01000804 	movi	r4,32
 80056a0:	2089c83a 	sub	r4,r4,r2
 80056a4:	1914983a 	sll	r10,r3,r4
 80056a8:	8890d83a 	srl	r8,r17,r2
 80056ac:	8908983a 	sll	r4,r17,r4
 80056b0:	1884d83a 	srl	r2,r3,r2
 80056b4:	5222b03a 	or	r17,r10,r8
 80056b8:	2006c03a 	cmpne	r3,r4,zero
 80056bc:	88e2b03a 	or	r17,r17,r3
 80056c0:	3463c83a 	sub	r17,r6,r17
 80056c4:	2885c83a 	sub	r2,r5,r2
 80056c8:	344d803a 	cmpltu	r6,r6,r17
 80056cc:	1187c83a 	sub	r3,r2,r6
 80056d0:	4821883a 	mov	r16,r9
 80056d4:	3825883a 	mov	r18,r7
 80056d8:	003f2306 	br	8005368 <__subdf3+0x178>
 80056dc:	24d0b03a 	or	r8,r4,r19
 80056e0:	40001b1e 	bne	r8,zero,8005750 <__subdf3+0x560>
 80056e4:	0005883a 	mov	r2,zero
 80056e8:	0009883a 	mov	r4,zero
 80056ec:	0021883a 	mov	r16,zero
 80056f0:	003f4906 	br	8005418 <__subdf3+0x228>
 80056f4:	010007c4 	movi	r4,31
 80056f8:	20803a16 	blt	r4,r2,80057e4 <__subdf3+0x5f4>
 80056fc:	01000804 	movi	r4,32
 8005700:	2089c83a 	sub	r4,r4,r2
 8005704:	2912983a 	sll	r9,r5,r4
 8005708:	3090d83a 	srl	r8,r6,r2
 800570c:	3108983a 	sll	r4,r6,r4
 8005710:	2884d83a 	srl	r2,r5,r2
 8005714:	4a12b03a 	or	r9,r9,r8
 8005718:	2008c03a 	cmpne	r4,r4,zero
 800571c:	4912b03a 	or	r9,r9,r4
 8005720:	003f4e06 	br	800545c <__subdf3+0x26c>
 8005724:	1c48b03a 	or	r4,r3,r17
 8005728:	20003c26 	beq	r4,zero,800581c <__subdf3+0x62c>
 800572c:	0084303a 	nor	r2,zero,r2
 8005730:	1000381e 	bne	r2,zero,8005814 <__subdf3+0x624>
 8005734:	3463c83a 	sub	r17,r6,r17
 8005738:	28c5c83a 	sub	r2,r5,r3
 800573c:	344d803a 	cmpltu	r6,r6,r17
 8005740:	1187c83a 	sub	r3,r2,r6
 8005744:	4821883a 	mov	r16,r9
 8005748:	3825883a 	mov	r18,r7
 800574c:	003f0606 	br	8005368 <__subdf3+0x178>
 8005750:	2023883a 	mov	r17,r4
 8005754:	003f0906 	br	800537c <__subdf3+0x18c>
 8005758:	0101ffc4 	movi	r4,2047
 800575c:	813f3a1e 	bne	r16,r4,8005448 <__subdf3+0x258>
 8005760:	003ec406 	br	8005274 <__subdf3+0x84>
 8005764:	0005883a 	mov	r2,zero
 8005768:	003fb106 	br	8005630 <__subdf3+0x440>
 800576c:	0005883a 	mov	r2,zero
 8005770:	003fbc06 	br	8005664 <__subdf3+0x474>
 8005774:	1c44b03a 	or	r2,r3,r17
 8005778:	80008e1e 	bne	r16,zero,80059b4 <__subdf3+0x7c4>
 800577c:	1000c826 	beq	r2,zero,8005aa0 <__subdf3+0x8b0>
 8005780:	2984b03a 	or	r2,r5,r6
 8005784:	103ebb26 	beq	r2,zero,8005274 <__subdf3+0x84>
 8005788:	8989883a 	add	r4,r17,r6
 800578c:	1945883a 	add	r2,r3,r5
 8005790:	2447803a 	cmpltu	r3,r4,r17
 8005794:	1887883a 	add	r3,r3,r2
 8005798:	1880202c 	andhi	r2,r3,128
 800579c:	2023883a 	mov	r17,r4
 80057a0:	103f1626 	beq	r2,zero,80053fc <__subdf3+0x20c>
 80057a4:	00bfe034 	movhi	r2,65408
 80057a8:	10bfffc4 	addi	r2,r2,-1
 80057ac:	5021883a 	mov	r16,r10
 80057b0:	1886703a 	and	r3,r3,r2
 80057b4:	003eaf06 	br	8005274 <__subdf3+0x84>
 80057b8:	3825883a 	mov	r18,r7
 80057bc:	003f0f06 	br	80053fc <__subdf3+0x20c>
 80057c0:	1c44b03a 	or	r2,r3,r17
 80057c4:	8000251e 	bne	r16,zero,800585c <__subdf3+0x66c>
 80057c8:	1000661e 	bne	r2,zero,8005964 <__subdf3+0x774>
 80057cc:	2990b03a 	or	r8,r5,r6
 80057d0:	40009626 	beq	r8,zero,8005a2c <__subdf3+0x83c>
 80057d4:	2807883a 	mov	r3,r5
 80057d8:	3023883a 	mov	r17,r6
 80057dc:	3825883a 	mov	r18,r7
 80057e0:	003ea406 	br	8005274 <__subdf3+0x84>
 80057e4:	127ff804 	addi	r9,r2,-32
 80057e8:	01000804 	movi	r4,32
 80057ec:	2a52d83a 	srl	r9,r5,r9
 80057f0:	11008c26 	beq	r2,r4,8005a24 <__subdf3+0x834>
 80057f4:	01001004 	movi	r4,64
 80057f8:	2085c83a 	sub	r2,r4,r2
 80057fc:	2884983a 	sll	r2,r5,r2
 8005800:	118cb03a 	or	r6,r2,r6
 8005804:	300cc03a 	cmpne	r6,r6,zero
 8005808:	4992b03a 	or	r9,r9,r6
 800580c:	0005883a 	mov	r2,zero
 8005810:	003f1206 	br	800545c <__subdf3+0x26c>
 8005814:	0101ffc4 	movi	r4,2047
 8005818:	493f9c1e 	bne	r9,r4,800568c <__subdf3+0x49c>
 800581c:	2807883a 	mov	r3,r5
 8005820:	3023883a 	mov	r17,r6
 8005824:	4821883a 	mov	r16,r9
 8005828:	3825883a 	mov	r18,r7
 800582c:	003e9106 	br	8005274 <__subdf3+0x84>
 8005830:	80001f1e 	bne	r16,zero,80058b0 <__subdf3+0x6c0>
 8005834:	1c48b03a 	or	r4,r3,r17
 8005838:	20005a26 	beq	r4,zero,80059a4 <__subdf3+0x7b4>
 800583c:	0084303a 	nor	r2,zero,r2
 8005840:	1000561e 	bne	r2,zero,800599c <__subdf3+0x7ac>
 8005844:	89a3883a 	add	r17,r17,r6
 8005848:	1945883a 	add	r2,r3,r5
 800584c:	898d803a 	cmpltu	r6,r17,r6
 8005850:	3087883a 	add	r3,r6,r2
 8005854:	4821883a 	mov	r16,r9
 8005858:	003f0506 	br	8005470 <__subdf3+0x280>
 800585c:	10002b1e 	bne	r2,zero,800590c <__subdf3+0x71c>
 8005860:	2984b03a 	or	r2,r5,r6
 8005864:	10008026 	beq	r2,zero,8005a68 <__subdf3+0x878>
 8005868:	2807883a 	mov	r3,r5
 800586c:	3023883a 	mov	r17,r6
 8005870:	3825883a 	mov	r18,r7
 8005874:	0401ffc4 	movi	r16,2047
 8005878:	003e7e06 	br	8005274 <__subdf3+0x84>
 800587c:	3809883a 	mov	r4,r7
 8005880:	0011883a 	mov	r8,zero
 8005884:	0005883a 	mov	r2,zero
 8005888:	003ee306 	br	8005418 <__subdf3+0x228>
 800588c:	1c62b03a 	or	r17,r3,r17
 8005890:	8822c03a 	cmpne	r17,r17,zero
 8005894:	0005883a 	mov	r2,zero
 8005898:	003f8906 	br	80056c0 <__subdf3+0x4d0>
 800589c:	3809883a 	mov	r4,r7
 80058a0:	4821883a 	mov	r16,r9
 80058a4:	0011883a 	mov	r8,zero
 80058a8:	0005883a 	mov	r2,zero
 80058ac:	003eda06 	br	8005418 <__subdf3+0x228>
 80058b0:	0101ffc4 	movi	r4,2047
 80058b4:	49003b26 	beq	r9,r4,80059a4 <__subdf3+0x7b4>
 80058b8:	0085c83a 	sub	r2,zero,r2
 80058bc:	18c02034 	orhi	r3,r3,128
 80058c0:	01000e04 	movi	r4,56
 80058c4:	20806e16 	blt	r4,r2,8005a80 <__subdf3+0x890>
 80058c8:	010007c4 	movi	r4,31
 80058cc:	20807716 	blt	r4,r2,8005aac <__subdf3+0x8bc>
 80058d0:	01000804 	movi	r4,32
 80058d4:	2089c83a 	sub	r4,r4,r2
 80058d8:	1914983a 	sll	r10,r3,r4
 80058dc:	8890d83a 	srl	r8,r17,r2
 80058e0:	8908983a 	sll	r4,r17,r4
 80058e4:	1884d83a 	srl	r2,r3,r2
 80058e8:	5222b03a 	or	r17,r10,r8
 80058ec:	2006c03a 	cmpne	r3,r4,zero
 80058f0:	88e2b03a 	or	r17,r17,r3
 80058f4:	89a3883a 	add	r17,r17,r6
 80058f8:	1145883a 	add	r2,r2,r5
 80058fc:	898d803a 	cmpltu	r6,r17,r6
 8005900:	3087883a 	add	r3,r6,r2
 8005904:	4821883a 	mov	r16,r9
 8005908:	003ed906 	br	8005470 <__subdf3+0x280>
 800590c:	2984b03a 	or	r2,r5,r6
 8005910:	10004226 	beq	r2,zero,8005a1c <__subdf3+0x82c>
 8005914:	1808d0fa 	srli	r4,r3,3
 8005918:	8822d0fa 	srli	r17,r17,3
 800591c:	1806977a 	slli	r3,r3,29
 8005920:	2080022c 	andhi	r2,r4,8
 8005924:	1c62b03a 	or	r17,r3,r17
 8005928:	10000826 	beq	r2,zero,800594c <__subdf3+0x75c>
 800592c:	2812d0fa 	srli	r9,r5,3
 8005930:	4880022c 	andhi	r2,r9,8
 8005934:	1000051e 	bne	r2,zero,800594c <__subdf3+0x75c>
 8005938:	300cd0fa 	srli	r6,r6,3
 800593c:	2804977a 	slli	r2,r5,29
 8005940:	4809883a 	mov	r4,r9
 8005944:	3825883a 	mov	r18,r7
 8005948:	11a2b03a 	or	r17,r2,r6
 800594c:	8806d77a 	srli	r3,r17,29
 8005950:	200890fa 	slli	r4,r4,3
 8005954:	882290fa 	slli	r17,r17,3
 8005958:	0401ffc4 	movi	r16,2047
 800595c:	1906b03a 	or	r3,r3,r4
 8005960:	003e4406 	br	8005274 <__subdf3+0x84>
 8005964:	2984b03a 	or	r2,r5,r6
 8005968:	103e4226 	beq	r2,zero,8005274 <__subdf3+0x84>
 800596c:	8989c83a 	sub	r4,r17,r6
 8005970:	8911803a 	cmpltu	r8,r17,r4
 8005974:	1945c83a 	sub	r2,r3,r5
 8005978:	1205c83a 	sub	r2,r2,r8
 800597c:	1200202c 	andhi	r8,r2,128
 8005980:	403e9a26 	beq	r8,zero,80053ec <__subdf3+0x1fc>
 8005984:	3463c83a 	sub	r17,r6,r17
 8005988:	28c5c83a 	sub	r2,r5,r3
 800598c:	344d803a 	cmpltu	r6,r6,r17
 8005990:	1187c83a 	sub	r3,r2,r6
 8005994:	3825883a 	mov	r18,r7
 8005998:	003e3606 	br	8005274 <__subdf3+0x84>
 800599c:	0101ffc4 	movi	r4,2047
 80059a0:	493fc71e 	bne	r9,r4,80058c0 <__subdf3+0x6d0>
 80059a4:	2807883a 	mov	r3,r5
 80059a8:	3023883a 	mov	r17,r6
 80059ac:	4821883a 	mov	r16,r9
 80059b0:	003e3006 	br	8005274 <__subdf3+0x84>
 80059b4:	10003626 	beq	r2,zero,8005a90 <__subdf3+0x8a0>
 80059b8:	2984b03a 	or	r2,r5,r6
 80059bc:	10001726 	beq	r2,zero,8005a1c <__subdf3+0x82c>
 80059c0:	1808d0fa 	srli	r4,r3,3
 80059c4:	8822d0fa 	srli	r17,r17,3
 80059c8:	1806977a 	slli	r3,r3,29
 80059cc:	2080022c 	andhi	r2,r4,8
 80059d0:	1c62b03a 	or	r17,r3,r17
 80059d4:	10000726 	beq	r2,zero,80059f4 <__subdf3+0x804>
 80059d8:	2812d0fa 	srli	r9,r5,3
 80059dc:	4880022c 	andhi	r2,r9,8
 80059e0:	1000041e 	bne	r2,zero,80059f4 <__subdf3+0x804>
 80059e4:	300cd0fa 	srli	r6,r6,3
 80059e8:	2804977a 	slli	r2,r5,29
 80059ec:	4809883a 	mov	r4,r9
 80059f0:	11a2b03a 	or	r17,r2,r6
 80059f4:	8806d77a 	srli	r3,r17,29
 80059f8:	200890fa 	slli	r4,r4,3
 80059fc:	882290fa 	slli	r17,r17,3
 8005a00:	3825883a 	mov	r18,r7
 8005a04:	1906b03a 	or	r3,r3,r4
 8005a08:	0401ffc4 	movi	r16,2047
 8005a0c:	003e1906 	br	8005274 <__subdf3+0x84>
 8005a10:	000b883a 	mov	r5,zero
 8005a14:	0005883a 	mov	r2,zero
 8005a18:	003e2e06 	br	80052d4 <__subdf3+0xe4>
 8005a1c:	0401ffc4 	movi	r16,2047
 8005a20:	003e1406 	br	8005274 <__subdf3+0x84>
 8005a24:	0005883a 	mov	r2,zero
 8005a28:	003f7506 	br	8005800 <__subdf3+0x610>
 8005a2c:	0005883a 	mov	r2,zero
 8005a30:	0009883a 	mov	r4,zero
 8005a34:	003e7806 	br	8005418 <__subdf3+0x228>
 8005a38:	123ff804 	addi	r8,r2,-32
 8005a3c:	01000804 	movi	r4,32
 8005a40:	1a10d83a 	srl	r8,r3,r8
 8005a44:	11002526 	beq	r2,r4,8005adc <__subdf3+0x8ec>
 8005a48:	01001004 	movi	r4,64
 8005a4c:	2085c83a 	sub	r2,r4,r2
 8005a50:	1884983a 	sll	r2,r3,r2
 8005a54:	1444b03a 	or	r2,r2,r17
 8005a58:	1004c03a 	cmpne	r2,r2,zero
 8005a5c:	40a2b03a 	or	r17,r8,r2
 8005a60:	0005883a 	mov	r2,zero
 8005a64:	003f1606 	br	80056c0 <__subdf3+0x4d0>
 8005a68:	02000434 	movhi	r8,16
 8005a6c:	0009883a 	mov	r4,zero
 8005a70:	423fffc4 	addi	r8,r8,-1
 8005a74:	00bfffc4 	movi	r2,-1
 8005a78:	0401ffc4 	movi	r16,2047
 8005a7c:	003e6606 	br	8005418 <__subdf3+0x228>
 8005a80:	1c62b03a 	or	r17,r3,r17
 8005a84:	8822c03a 	cmpne	r17,r17,zero
 8005a88:	0005883a 	mov	r2,zero
 8005a8c:	003f9906 	br	80058f4 <__subdf3+0x704>
 8005a90:	2807883a 	mov	r3,r5
 8005a94:	3023883a 	mov	r17,r6
 8005a98:	0401ffc4 	movi	r16,2047
 8005a9c:	003df506 	br	8005274 <__subdf3+0x84>
 8005aa0:	2807883a 	mov	r3,r5
 8005aa4:	3023883a 	mov	r17,r6
 8005aa8:	003df206 	br	8005274 <__subdf3+0x84>
 8005aac:	123ff804 	addi	r8,r2,-32
 8005ab0:	01000804 	movi	r4,32
 8005ab4:	1a10d83a 	srl	r8,r3,r8
 8005ab8:	11000a26 	beq	r2,r4,8005ae4 <__subdf3+0x8f4>
 8005abc:	01001004 	movi	r4,64
 8005ac0:	2085c83a 	sub	r2,r4,r2
 8005ac4:	1884983a 	sll	r2,r3,r2
 8005ac8:	1444b03a 	or	r2,r2,r17
 8005acc:	1004c03a 	cmpne	r2,r2,zero
 8005ad0:	40a2b03a 	or	r17,r8,r2
 8005ad4:	0005883a 	mov	r2,zero
 8005ad8:	003f8606 	br	80058f4 <__subdf3+0x704>
 8005adc:	0005883a 	mov	r2,zero
 8005ae0:	003fdc06 	br	8005a54 <__subdf3+0x864>
 8005ae4:	0005883a 	mov	r2,zero
 8005ae8:	003ff706 	br	8005ac8 <__subdf3+0x8d8>

08005aec <__fixdfsi>:
 8005aec:	280cd53a 	srli	r6,r5,20
 8005af0:	00c00434 	movhi	r3,16
 8005af4:	18ffffc4 	addi	r3,r3,-1
 8005af8:	3181ffcc 	andi	r6,r6,2047
 8005afc:	01c0ff84 	movi	r7,1022
 8005b00:	28c6703a 	and	r3,r5,r3
 8005b04:	280ad7fa 	srli	r5,r5,31
 8005b08:	3980120e 	bge	r7,r6,8005b54 <__fixdfsi+0x68>
 8005b0c:	00810744 	movi	r2,1053
 8005b10:	11800c16 	blt	r2,r6,8005b44 <__fixdfsi+0x58>
 8005b14:	00810cc4 	movi	r2,1075
 8005b18:	1185c83a 	sub	r2,r2,r6
 8005b1c:	01c007c4 	movi	r7,31
 8005b20:	18c00434 	orhi	r3,r3,16
 8005b24:	38800d16 	blt	r7,r2,8005b5c <__fixdfsi+0x70>
 8005b28:	31befb44 	addi	r6,r6,-1043
 8005b2c:	2084d83a 	srl	r2,r4,r2
 8005b30:	1986983a 	sll	r3,r3,r6
 8005b34:	1884b03a 	or	r2,r3,r2
 8005b38:	28000726 	beq	r5,zero,8005b58 <__fixdfsi+0x6c>
 8005b3c:	0085c83a 	sub	r2,zero,r2
 8005b40:	f800283a 	ret
 8005b44:	00a00034 	movhi	r2,32768
 8005b48:	10bfffc4 	addi	r2,r2,-1
 8005b4c:	2885883a 	add	r2,r5,r2
 8005b50:	f800283a 	ret
 8005b54:	0005883a 	mov	r2,zero
 8005b58:	f800283a 	ret
 8005b5c:	008104c4 	movi	r2,1043
 8005b60:	1185c83a 	sub	r2,r2,r6
 8005b64:	1884d83a 	srl	r2,r3,r2
 8005b68:	003ff306 	br	8005b38 <__fixdfsi+0x4c>

08005b6c <__floatsidf>:
 8005b6c:	defffd04 	addi	sp,sp,-12
 8005b70:	dfc00215 	stw	ra,8(sp)
 8005b74:	dc400115 	stw	r17,4(sp)
 8005b78:	dc000015 	stw	r16,0(sp)
 8005b7c:	20002b26 	beq	r4,zero,8005c2c <__floatsidf+0xc0>
 8005b80:	2023883a 	mov	r17,r4
 8005b84:	2020d7fa 	srli	r16,r4,31
 8005b88:	20002d16 	blt	r4,zero,8005c40 <__floatsidf+0xd4>
 8005b8c:	8809883a 	mov	r4,r17
 8005b90:	8005d580 	call	8005d58 <__clzsi2>
 8005b94:	01410784 	movi	r5,1054
 8005b98:	288bc83a 	sub	r5,r5,r2
 8005b9c:	01010cc4 	movi	r4,1075
 8005ba0:	2149c83a 	sub	r4,r4,r5
 8005ba4:	00c007c4 	movi	r3,31
 8005ba8:	1900160e 	bge	r3,r4,8005c04 <__floatsidf+0x98>
 8005bac:	00c104c4 	movi	r3,1043
 8005bb0:	1947c83a 	sub	r3,r3,r5
 8005bb4:	88c6983a 	sll	r3,r17,r3
 8005bb8:	00800434 	movhi	r2,16
 8005bbc:	10bfffc4 	addi	r2,r2,-1
 8005bc0:	1886703a 	and	r3,r3,r2
 8005bc4:	2941ffcc 	andi	r5,r5,2047
 8005bc8:	800d883a 	mov	r6,r16
 8005bcc:	0005883a 	mov	r2,zero
 8005bd0:	280a953a 	slli	r5,r5,20
 8005bd4:	31803fcc 	andi	r6,r6,255
 8005bd8:	01000434 	movhi	r4,16
 8005bdc:	300c97fa 	slli	r6,r6,31
 8005be0:	213fffc4 	addi	r4,r4,-1
 8005be4:	1906703a 	and	r3,r3,r4
 8005be8:	1946b03a 	or	r3,r3,r5
 8005bec:	1986b03a 	or	r3,r3,r6
 8005bf0:	dfc00217 	ldw	ra,8(sp)
 8005bf4:	dc400117 	ldw	r17,4(sp)
 8005bf8:	dc000017 	ldw	r16,0(sp)
 8005bfc:	dec00304 	addi	sp,sp,12
 8005c00:	f800283a 	ret
 8005c04:	00c002c4 	movi	r3,11
 8005c08:	1887c83a 	sub	r3,r3,r2
 8005c0c:	88c6d83a 	srl	r3,r17,r3
 8005c10:	8904983a 	sll	r2,r17,r4
 8005c14:	01000434 	movhi	r4,16
 8005c18:	213fffc4 	addi	r4,r4,-1
 8005c1c:	2941ffcc 	andi	r5,r5,2047
 8005c20:	1906703a 	and	r3,r3,r4
 8005c24:	800d883a 	mov	r6,r16
 8005c28:	003fe906 	br	8005bd0 <__floatsidf+0x64>
 8005c2c:	000d883a 	mov	r6,zero
 8005c30:	000b883a 	mov	r5,zero
 8005c34:	0007883a 	mov	r3,zero
 8005c38:	0005883a 	mov	r2,zero
 8005c3c:	003fe406 	br	8005bd0 <__floatsidf+0x64>
 8005c40:	0123c83a 	sub	r17,zero,r4
 8005c44:	003fd106 	br	8005b8c <__floatsidf+0x20>

08005c48 <__extendsfdf2>:
 8005c48:	200ad5fa 	srli	r5,r4,23
 8005c4c:	defffd04 	addi	sp,sp,-12
 8005c50:	dc400115 	stw	r17,4(sp)
 8005c54:	29403fcc 	andi	r5,r5,255
 8005c58:	29800044 	addi	r6,r5,1
 8005c5c:	04402034 	movhi	r17,128
 8005c60:	dc000015 	stw	r16,0(sp)
 8005c64:	8c7fffc4 	addi	r17,r17,-1
 8005c68:	dfc00215 	stw	ra,8(sp)
 8005c6c:	31803fcc 	andi	r6,r6,255
 8005c70:	00800044 	movi	r2,1
 8005c74:	8922703a 	and	r17,r17,r4
 8005c78:	2020d7fa 	srli	r16,r4,31
 8005c7c:	1180110e 	bge	r2,r6,8005cc4 <__extendsfdf2+0x7c>
 8005c80:	880cd0fa 	srli	r6,r17,3
 8005c84:	8822977a 	slli	r17,r17,29
 8005c88:	2940e004 	addi	r5,r5,896
 8005c8c:	2941ffcc 	andi	r5,r5,2047
 8005c90:	2804953a 	slli	r2,r5,20
 8005c94:	01400434 	movhi	r5,16
 8005c98:	800697fa 	slli	r3,r16,31
 8005c9c:	297fffc4 	addi	r5,r5,-1
 8005ca0:	314a703a 	and	r5,r6,r5
 8005ca4:	288ab03a 	or	r5,r5,r2
 8005ca8:	28c6b03a 	or	r3,r5,r3
 8005cac:	8805883a 	mov	r2,r17
 8005cb0:	dfc00217 	ldw	ra,8(sp)
 8005cb4:	dc400117 	ldw	r17,4(sp)
 8005cb8:	dc000017 	ldw	r16,0(sp)
 8005cbc:	dec00304 	addi	sp,sp,12
 8005cc0:	f800283a 	ret
 8005cc4:	2800111e 	bne	r5,zero,8005d0c <__extendsfdf2+0xc4>
 8005cc8:	88001c26 	beq	r17,zero,8005d3c <__extendsfdf2+0xf4>
 8005ccc:	8809883a 	mov	r4,r17
 8005cd0:	8005d580 	call	8005d58 <__clzsi2>
 8005cd4:	00c00284 	movi	r3,10
 8005cd8:	18801b16 	blt	r3,r2,8005d48 <__extendsfdf2+0x100>
 8005cdc:	018002c4 	movi	r6,11
 8005ce0:	308dc83a 	sub	r6,r6,r2
 8005ce4:	11000544 	addi	r4,r2,21
 8005ce8:	8986d83a 	srl	r3,r17,r6
 8005cec:	8922983a 	sll	r17,r17,r4
 8005cf0:	0180e244 	movi	r6,905
 8005cf4:	01400434 	movhi	r5,16
 8005cf8:	3085c83a 	sub	r2,r6,r2
 8005cfc:	297fffc4 	addi	r5,r5,-1
 8005d00:	194c703a 	and	r6,r3,r5
 8005d04:	1141ffcc 	andi	r5,r2,2047
 8005d08:	003fe006 	br	8005c8c <__extendsfdf2+0x44>
 8005d0c:	88000826 	beq	r17,zero,8005d30 <__extendsfdf2+0xe8>
 8005d10:	880cd0fa 	srli	r6,r17,3
 8005d14:	00800434 	movhi	r2,16
 8005d18:	10bfffc4 	addi	r2,r2,-1
 8005d1c:	31800234 	orhi	r6,r6,8
 8005d20:	8822977a 	slli	r17,r17,29
 8005d24:	308c703a 	and	r6,r6,r2
 8005d28:	0141ffc4 	movi	r5,2047
 8005d2c:	003fd706 	br	8005c8c <__extendsfdf2+0x44>
 8005d30:	0141ffc4 	movi	r5,2047
 8005d34:	000d883a 	mov	r6,zero
 8005d38:	003fd406 	br	8005c8c <__extendsfdf2+0x44>
 8005d3c:	000b883a 	mov	r5,zero
 8005d40:	000d883a 	mov	r6,zero
 8005d44:	003fd106 	br	8005c8c <__extendsfdf2+0x44>
 8005d48:	11bffd44 	addi	r6,r2,-11
 8005d4c:	8986983a 	sll	r3,r17,r6
 8005d50:	0023883a 	mov	r17,zero
 8005d54:	003fe606 	br	8005cf0 <__extendsfdf2+0xa8>

08005d58 <__clzsi2>:
 8005d58:	00bfffd4 	movui	r2,65535
 8005d5c:	11000536 	bltu	r2,r4,8005d74 <__clzsi2+0x1c>
 8005d60:	00803fc4 	movi	r2,255
 8005d64:	11000f36 	bltu	r2,r4,8005da4 <__clzsi2+0x4c>
 8005d68:	00800804 	movi	r2,32
 8005d6c:	0007883a 	mov	r3,zero
 8005d70:	00000506 	br	8005d88 <__clzsi2+0x30>
 8005d74:	00804034 	movhi	r2,256
 8005d78:	10bfffc4 	addi	r2,r2,-1
 8005d7c:	11000c2e 	bgeu	r2,r4,8005db0 <__clzsi2+0x58>
 8005d80:	00800204 	movi	r2,8
 8005d84:	00c00604 	movi	r3,24
 8005d88:	20c8d83a 	srl	r4,r4,r3
 8005d8c:	00c20134 	movhi	r3,2052
 8005d90:	18d92604 	addi	r3,r3,25752
 8005d94:	1909883a 	add	r4,r3,r4
 8005d98:	20c00003 	ldbu	r3,0(r4)
 8005d9c:	10c5c83a 	sub	r2,r2,r3
 8005da0:	f800283a 	ret
 8005da4:	00800604 	movi	r2,24
 8005da8:	00c00204 	movi	r3,8
 8005dac:	003ff606 	br	8005d88 <__clzsi2+0x30>
 8005db0:	00800404 	movi	r2,16
 8005db4:	1007883a 	mov	r3,r2
 8005db8:	003ff306 	br	8005d88 <__clzsi2+0x30>

08005dbc <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
 8005dbc:	defff104 	addi	sp,sp,-60
 8005dc0:	dfc00e15 	stw	ra,56(sp)
 8005dc4:	df000d15 	stw	fp,52(sp)
 8005dc8:	df000d04 	addi	fp,sp,52
 8005dcc:	e13ffe15 	stw	r4,-8(fp)
 8005dd0:	e17fff15 	stw	r5,-4(fp)
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
 8005dd4:	e13fff17 	ldw	r4,-4(fp)
 8005dd8:	8005f0c0 	call	8005f0c <strlen>
 8005ddc:	e0bff315 	stw	r2,-52(fp)
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
 8005de0:	e0bfff17 	ldw	r2,-4(fp)
 8005de4:	e0bffa15 	stw	r2,-24(fp)
  iov[0].iov_len = c;
 8005de8:	e0bff317 	ldw	r2,-52(fp)
 8005dec:	e0bffb15 	stw	r2,-20(fp)
  iov[1].iov_base = "\n";
 8005df0:	00820134 	movhi	r2,2052
 8005df4:	10996604 	addi	r2,r2,26008
 8005df8:	e0bffc15 	stw	r2,-16(fp)
  iov[1].iov_len = 1;
 8005dfc:	00800044 	movi	r2,1
 8005e00:	e0bffd15 	stw	r2,-12(fp)
  uio.uio_resid = c + 1;
 8005e04:	e0bff317 	ldw	r2,-52(fp)
 8005e08:	10800044 	addi	r2,r2,1
 8005e0c:	e0bff915 	stw	r2,-28(fp)
  uio.uio_iov = &iov[0];
 8005e10:	e0bffa04 	addi	r2,fp,-24
 8005e14:	e0bff715 	stw	r2,-36(fp)
  uio.uio_iovcnt = 2;
 8005e18:	00800084 	movi	r2,2
 8005e1c:	e0bff815 	stw	r2,-32(fp)

  CHECK_STD_INIT (ptr);
 8005e20:	e0bffe17 	ldw	r2,-8(fp)
 8005e24:	e0bff415 	stw	r2,-48(fp)
 8005e28:	e0bff417 	ldw	r2,-48(fp)
 8005e2c:	10000526 	beq	r2,zero,8005e44 <_puts_r+0x88>
 8005e30:	e0bff417 	ldw	r2,-48(fp)
 8005e34:	10800e17 	ldw	r2,56(r2)
 8005e38:	1000021e 	bne	r2,zero,8005e44 <_puts_r+0x88>
 8005e3c:	e13ff417 	ldw	r4,-48(fp)
 8005e40:	80063a40 	call	80063a4 <__sinit>
  fp = _stdout_r (ptr);
 8005e44:	e0bffe17 	ldw	r2,-8(fp)
 8005e48:	10800217 	ldw	r2,8(r2)
 8005e4c:	e0bff515 	stw	r2,-44(fp)
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
 8005e50:	e0bff517 	ldw	r2,-44(fp)
 8005e54:	1080030b 	ldhu	r2,12(r2)
 8005e58:	10bfffcc 	andi	r2,r2,65535
 8005e5c:	1088000c 	andi	r2,r2,8192
 8005e60:	10000c1e 	bne	r2,zero,8005e94 <_puts_r+0xd8>
 8005e64:	e0bff517 	ldw	r2,-44(fp)
 8005e68:	1080030b 	ldhu	r2,12(r2)
 8005e6c:	10880014 	ori	r2,r2,8192
 8005e70:	1007883a 	mov	r3,r2
 8005e74:	e0bff517 	ldw	r2,-44(fp)
 8005e78:	10c0030d 	sth	r3,12(r2)
 8005e7c:	e0bff517 	ldw	r2,-44(fp)
 8005e80:	10c01917 	ldw	r3,100(r2)
 8005e84:	00b7ffc4 	movi	r2,-8193
 8005e88:	1886703a 	and	r3,r3,r2
 8005e8c:	e0bff517 	ldw	r2,-44(fp)
 8005e90:	10c01915 	stw	r3,100(r2)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
 8005e94:	e0bff704 	addi	r2,fp,-36
 8005e98:	100d883a 	mov	r6,r2
 8005e9c:	e17ff517 	ldw	r5,-44(fp)
 8005ea0:	e13ffe17 	ldw	r4,-8(fp)
 8005ea4:	80065c40 	call	80065c4 <__sfvwrite_r>
 8005ea8:	10000226 	beq	r2,zero,8005eb4 <_puts_r+0xf8>
 8005eac:	00bfffc4 	movi	r2,-1
 8005eb0:	00000106 	br	8005eb8 <_puts_r+0xfc>
 8005eb4:	00800284 	movi	r2,10
 8005eb8:	e0bff615 	stw	r2,-40(fp)
  _newlib_flockfile_end (fp);
  return result;
 8005ebc:	e0bff617 	ldw	r2,-40(fp)

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
 8005ec0:	e037883a 	mov	sp,fp
 8005ec4:	dfc00117 	ldw	ra,4(sp)
 8005ec8:	df000017 	ldw	fp,0(sp)
 8005ecc:	dec00204 	addi	sp,sp,8
 8005ed0:	f800283a 	ret

08005ed4 <puts>:
#ifndef _REENT_ONLY

int
_DEFUN(puts, (s),
       char _CONST * s)
{
 8005ed4:	defffd04 	addi	sp,sp,-12
 8005ed8:	dfc00215 	stw	ra,8(sp)
 8005edc:	df000115 	stw	fp,4(sp)
 8005ee0:	df000104 	addi	fp,sp,4
 8005ee4:	e13fff15 	stw	r4,-4(fp)
  return _puts_r (_REENT, s);
 8005ee8:	d0a04217 	ldw	r2,-32504(gp)
 8005eec:	e17fff17 	ldw	r5,-4(fp)
 8005ef0:	1009883a 	mov	r4,r2
 8005ef4:	8005dbc0 	call	8005dbc <_puts_r>
}
 8005ef8:	e037883a 	mov	sp,fp
 8005efc:	dfc00117 	ldw	ra,4(sp)
 8005f00:	df000017 	ldw	fp,0(sp)
 8005f04:	dec00204 	addi	sp,sp,8
 8005f08:	f800283a 	ret

08005f0c <strlen>:
#endif

size_t
_DEFUN (strlen, (str),
	_CONST char *str)
{
 8005f0c:	defffc04 	addi	sp,sp,-16
 8005f10:	df000315 	stw	fp,12(sp)
 8005f14:	df000304 	addi	fp,sp,12
 8005f18:	e13fff15 	stw	r4,-4(fp)
  _CONST char *start = str;
 8005f1c:	e0bfff17 	ldw	r2,-4(fp)
 8005f20:	e0bffe15 	stw	r2,-8(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 8005f24:	00000d06 	br	8005f5c <strlen+0x50>
    {
      if (!*str)
 8005f28:	e0bfff17 	ldw	r2,-4(fp)
 8005f2c:	10800003 	ldbu	r2,0(r2)
 8005f30:	10803fcc 	andi	r2,r2,255
 8005f34:	1080201c 	xori	r2,r2,128
 8005f38:	10bfe004 	addi	r2,r2,-128
 8005f3c:	1000041e 	bne	r2,zero,8005f50 <strlen+0x44>
	return str - start;
 8005f40:	e0ffff17 	ldw	r3,-4(fp)
 8005f44:	e0bffe17 	ldw	r2,-8(fp)
 8005f48:	1885c83a 	sub	r2,r3,r2
 8005f4c:	00002806 	br	8005ff0 <strlen+0xe4>
      str++;
 8005f50:	e0bfff17 	ldw	r2,-4(fp)
 8005f54:	10800044 	addi	r2,r2,1
 8005f58:	e0bfff15 	stw	r2,-4(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 8005f5c:	e0bfff17 	ldw	r2,-4(fp)
 8005f60:	108000cc 	andi	r2,r2,3
 8005f64:	103ff01e 	bne	r2,zero,8005f28 <strlen+0x1c>
      str++;
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
 8005f68:	e0bfff17 	ldw	r2,-4(fp)
 8005f6c:	e0bffd15 	stw	r2,-12(fp)
  while (!DETECTNULL (*aligned_addr))
 8005f70:	00000306 	br	8005f80 <strlen+0x74>
    aligned_addr++;
 8005f74:	e0bffd17 	ldw	r2,-12(fp)
 8005f78:	10800104 	addi	r2,r2,4
 8005f7c:	e0bffd15 	stw	r2,-12(fp)
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
  while (!DETECTNULL (*aligned_addr))
 8005f80:	e0bffd17 	ldw	r2,-12(fp)
 8005f84:	10c00017 	ldw	r3,0(r2)
 8005f88:	00bfbff4 	movhi	r2,65279
 8005f8c:	10bfbfc4 	addi	r2,r2,-257
 8005f90:	1887883a 	add	r3,r3,r2
 8005f94:	e0bffd17 	ldw	r2,-12(fp)
 8005f98:	10800017 	ldw	r2,0(r2)
 8005f9c:	0084303a 	nor	r2,zero,r2
 8005fa0:	1886703a 	and	r3,r3,r2
 8005fa4:	00a02074 	movhi	r2,32897
 8005fa8:	10a02004 	addi	r2,r2,-32640
 8005fac:	1884703a 	and	r2,r3,r2
 8005fb0:	103ff026 	beq	r2,zero,8005f74 <strlen+0x68>
    aligned_addr++;

  /* Once a null is detected, we check each byte in that block for a
     precise position of the null.  */
  str = (char *) aligned_addr;
 8005fb4:	e0bffd17 	ldw	r2,-12(fp)
 8005fb8:	e0bfff15 	stw	r2,-4(fp)

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 8005fbc:	00000306 	br	8005fcc <strlen+0xc0>
    str++;
 8005fc0:	e0bfff17 	ldw	r2,-4(fp)
 8005fc4:	10800044 	addi	r2,r2,1
 8005fc8:	e0bfff15 	stw	r2,-4(fp)
     precise position of the null.  */
  str = (char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 8005fcc:	e0bfff17 	ldw	r2,-4(fp)
 8005fd0:	10800003 	ldbu	r2,0(r2)
 8005fd4:	10803fcc 	andi	r2,r2,255
 8005fd8:	1080201c 	xori	r2,r2,128
 8005fdc:	10bfe004 	addi	r2,r2,-128
 8005fe0:	103ff71e 	bne	r2,zero,8005fc0 <strlen+0xb4>
    str++;
  return str - start;
 8005fe4:	e0ffff17 	ldw	r3,-4(fp)
 8005fe8:	e0bffe17 	ldw	r2,-8(fp)
 8005fec:	1885c83a 	sub	r2,r3,r2
}
 8005ff0:	e037883a 	mov	sp,fp
 8005ff4:	df000017 	ldw	fp,0(sp)
 8005ff8:	dec00104 	addi	sp,sp,4
 8005ffc:	f800283a 	ret

08006000 <std>:
_DEFUN(std, (ptr, flags, file, data),
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
 8006000:	defffa04 	addi	sp,sp,-24
 8006004:	dfc00515 	stw	ra,20(sp)
 8006008:	df000415 	stw	fp,16(sp)
 800600c:	df000404 	addi	fp,sp,16
 8006010:	e13ffc15 	stw	r4,-16(fp)
 8006014:	e17ffd15 	stw	r5,-12(fp)
 8006018:	e1bffe15 	stw	r6,-8(fp)
 800601c:	e1ffff15 	stw	r7,-4(fp)
  ptr->_p = 0;
 8006020:	e0bffc17 	ldw	r2,-16(fp)
 8006024:	10000015 	stw	zero,0(r2)
  ptr->_r = 0;
 8006028:	e0bffc17 	ldw	r2,-16(fp)
 800602c:	10000115 	stw	zero,4(r2)
  ptr->_w = 0;
 8006030:	e0bffc17 	ldw	r2,-16(fp)
 8006034:	10000215 	stw	zero,8(r2)
  ptr->_flags = flags;
 8006038:	e0bffd17 	ldw	r2,-12(fp)
 800603c:	1007883a 	mov	r3,r2
 8006040:	e0bffc17 	ldw	r2,-16(fp)
 8006044:	10c0030d 	sth	r3,12(r2)
  ptr->_flags2 = 0;
 8006048:	e0bffc17 	ldw	r2,-16(fp)
 800604c:	10001915 	stw	zero,100(r2)
  ptr->_file = file;
 8006050:	e0bffe17 	ldw	r2,-8(fp)
 8006054:	1007883a 	mov	r3,r2
 8006058:	e0bffc17 	ldw	r2,-16(fp)
 800605c:	10c0038d 	sth	r3,14(r2)
  ptr->_bf._base = 0;
 8006060:	e0bffc17 	ldw	r2,-16(fp)
 8006064:	10000415 	stw	zero,16(r2)
  ptr->_bf._size = 0;
 8006068:	e0bffc17 	ldw	r2,-16(fp)
 800606c:	10000515 	stw	zero,20(r2)
  ptr->_lbfsize = 0;
 8006070:	e0bffc17 	ldw	r2,-16(fp)
 8006074:	10000615 	stw	zero,24(r2)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
 8006078:	e0bffc17 	ldw	r2,-16(fp)
 800607c:	10801704 	addi	r2,r2,92
 8006080:	01800204 	movi	r6,8
 8006084:	000b883a 	mov	r5,zero
 8006088:	1009883a 	mov	r4,r2
 800608c:	80081d00 	call	80081d0 <memset>
  ptr->_cookie = ptr;
 8006090:	e0bffc17 	ldw	r2,-16(fp)
 8006094:	e0fffc17 	ldw	r3,-16(fp)
 8006098:	10c00715 	stw	r3,28(r2)
  ptr->_read = __sread;
 800609c:	e0fffc17 	ldw	r3,-16(fp)
 80060a0:	00820074 	movhi	r2,2049
 80060a4:	10a3f904 	addi	r2,r2,-28700
 80060a8:	18800815 	stw	r2,32(r3)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
 80060ac:	e0fffc17 	ldw	r3,-16(fp)
 80060b0:	00820074 	movhi	r2,2049
 80060b4:	10a42c04 	addi	r2,r2,-28496
 80060b8:	18800915 	stw	r2,36(r3)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
 80060bc:	e0fffc17 	ldw	r3,-16(fp)
 80060c0:	00820074 	movhi	r2,2049
 80060c4:	10a45904 	addi	r2,r2,-28316
 80060c8:	18800a15 	stw	r2,40(r3)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
 80060cc:	e0fffc17 	ldw	r3,-16(fp)
 80060d0:	00820074 	movhi	r2,2049
 80060d4:	10a48104 	addi	r2,r2,-28156
 80060d8:	18800b15 	stw	r2,44(r3)

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
 80060dc:	0001883a 	nop
 80060e0:	e037883a 	mov	sp,fp
 80060e4:	dfc00117 	ldw	ra,4(sp)
 80060e8:	df000017 	ldw	fp,0(sp)
 80060ec:	dec00204 	addi	sp,sp,8
 80060f0:	f800283a 	ret

080060f4 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
 80060f4:	defffb04 	addi	sp,sp,-20
 80060f8:	dfc00415 	stw	ra,16(sp)
 80060fc:	df000315 	stw	fp,12(sp)
 8006100:	dc000215 	stw	r16,8(sp)
 8006104:	df000304 	addi	fp,sp,12
 8006108:	e13ffe15 	stw	r4,-8(fp)
 800610c:	2821883a 	mov	r16,r5
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
 8006110:	80bfffc4 	addi	r2,r16,-1
 8006114:	10801a24 	muli	r2,r2,104
 8006118:	10801d04 	addi	r2,r2,116
       struct _reent *d _AND
       register int n)
{
  struct glue_with_file *g;

  g = (struct glue_with_file *)
 800611c:	100b883a 	mov	r5,r2
 8006120:	e13ffe17 	ldw	r4,-8(fp)
 8006124:	80071080 	call	8007108 <_malloc_r>
 8006128:	e0bffd15 	stw	r2,-12(fp)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
 800612c:	e0bffd17 	ldw	r2,-12(fp)
 8006130:	1000021e 	bne	r2,zero,800613c <__sfmoreglue+0x48>
    return NULL;
 8006134:	0005883a 	mov	r2,zero
 8006138:	00001106 	br	8006180 <__sfmoreglue+0x8c>
  g->glue._next = NULL;
 800613c:	e0bffd17 	ldw	r2,-12(fp)
 8006140:	10000015 	stw	zero,0(r2)
  g->glue._niobs = n;
 8006144:	e0bffd17 	ldw	r2,-12(fp)
 8006148:	14000115 	stw	r16,4(r2)
  g->glue._iobs = &g->file;
 800614c:	e0bffd17 	ldw	r2,-12(fp)
 8006150:	10c00304 	addi	r3,r2,12
 8006154:	e0bffd17 	ldw	r2,-12(fp)
 8006158:	10c00215 	stw	r3,8(r2)
  memset (&g->file, 0, n * sizeof (FILE));
 800615c:	e0bffd17 	ldw	r2,-12(fp)
 8006160:	10800304 	addi	r2,r2,12
 8006164:	8007883a 	mov	r3,r16
 8006168:	18c01a24 	muli	r3,r3,104
 800616c:	180d883a 	mov	r6,r3
 8006170:	000b883a 	mov	r5,zero
 8006174:	1009883a 	mov	r4,r2
 8006178:	80081d00 	call	80081d0 <memset>
  return &g->glue;
 800617c:	e0bffd17 	ldw	r2,-12(fp)
}
 8006180:	e6ffff04 	addi	sp,fp,-4
 8006184:	dfc00217 	ldw	ra,8(sp)
 8006188:	df000117 	ldw	fp,4(sp)
 800618c:	dc000017 	ldw	r16,0(sp)
 8006190:	dec00304 	addi	sp,sp,12
 8006194:	f800283a 	ret

08006198 <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
 8006198:	defffa04 	addi	sp,sp,-24
 800619c:	dfc00515 	stw	ra,20(sp)
 80061a0:	df000415 	stw	fp,16(sp)
 80061a4:	df000404 	addi	fp,sp,16
 80061a8:	e13fff15 	stw	r4,-4(fp)
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
 80061ac:	800647c0 	call	800647c <__sfp_lock_acquire>

  if (!_GLOBAL_REENT->__sdidinit)
 80061b0:	d0a04317 	ldw	r2,-32500(gp)
 80061b4:	10800e17 	ldw	r2,56(r2)
 80061b8:	1000031e 	bne	r2,zero,80061c8 <__sfp+0x30>
    __sinit (_GLOBAL_REENT);
 80061bc:	d0a04317 	ldw	r2,-32500(gp)
 80061c0:	1009883a 	mov	r4,r2
 80061c4:	80063a40 	call	80063a4 <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 80061c8:	d0a04317 	ldw	r2,-32500(gp)
 80061cc:	1080b804 	addi	r2,r2,736
 80061d0:	e0bffe15 	stw	r2,-8(fp)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 80061d4:	e0bffe17 	ldw	r2,-8(fp)
 80061d8:	10800217 	ldw	r2,8(r2)
 80061dc:	e0bffc15 	stw	r2,-16(fp)
 80061e0:	e0bffe17 	ldw	r2,-8(fp)
 80061e4:	10800117 	ldw	r2,4(r2)
 80061e8:	e0bffd15 	stw	r2,-12(fp)
 80061ec:	00000906 	br	8006214 <__sfp+0x7c>
	if (fp->_flags == 0)
 80061f0:	e0bffc17 	ldw	r2,-16(fp)
 80061f4:	1080030b 	ldhu	r2,12(r2)
 80061f8:	10bfffcc 	andi	r2,r2,65535
 80061fc:	10a0001c 	xori	r2,r2,32768
 8006200:	10a00004 	addi	r2,r2,-32768
 8006204:	10001f26 	beq	r2,zero,8006284 <__sfp+0xec>

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006208:	e0bffc17 	ldw	r2,-16(fp)
 800620c:	10801a04 	addi	r2,r2,104
 8006210:	e0bffc15 	stw	r2,-16(fp)
 8006214:	e0bffd17 	ldw	r2,-12(fp)
 8006218:	10bfffc4 	addi	r2,r2,-1
 800621c:	e0bffd15 	stw	r2,-12(fp)
 8006220:	e0bffd17 	ldw	r2,-12(fp)
 8006224:	103ff20e 	bge	r2,zero,80061f0 <__sfp+0x58>
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
 8006228:	e0bffe17 	ldw	r2,-8(fp)
 800622c:	10800017 	ldw	r2,0(r2)
 8006230:	1000091e 	bne	r2,zero,8006258 <__sfp+0xc0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
 8006234:	01400104 	movi	r5,4
 8006238:	e13fff17 	ldw	r4,-4(fp)
 800623c:	80060f40 	call	80060f4 <__sfmoreglue>
 8006240:	1007883a 	mov	r3,r2
 8006244:	e0bffe17 	ldw	r2,-8(fp)
 8006248:	10c00015 	stw	r3,0(r2)
 800624c:	e0bffe17 	ldw	r2,-8(fp)
 8006250:	10800017 	ldw	r2,0(r2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
 8006254:	10000426 	beq	r2,zero,8006268 <__sfp+0xd0>

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 8006258:	e0bffe17 	ldw	r2,-8(fp)
 800625c:	10800017 	ldw	r2,0(r2)
 8006260:	e0bffe15 	stw	r2,-8(fp)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
 8006264:	003fdb06 	br	80061d4 <__sfp+0x3c>
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
 8006268:	0001883a 	nop
    }
  _newlib_sfp_lock_exit ();
 800626c:	800649c0 	call	800649c <__sfp_lock_release>
  d->_errno = ENOMEM;
 8006270:	e0bfff17 	ldw	r2,-4(fp)
 8006274:	00c00304 	movi	r3,12
 8006278:	10c00015 	stw	r3,0(r2)
  return NULL;
 800627c:	0005883a 	mov	r2,zero
 8006280:	00002506 	br	8006318 <__sfp+0x180>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
 8006284:	0001883a 	nop
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
 8006288:	e0bffc17 	ldw	r2,-16(fp)
 800628c:	00ffffc4 	movi	r3,-1
 8006290:	10c0038d 	sth	r3,14(r2)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
 8006294:	e0bffc17 	ldw	r2,-16(fp)
 8006298:	00c00044 	movi	r3,1
 800629c:	10c0030d 	sth	r3,12(r2)
  fp->_flags2 = 0;
 80062a0:	e0bffc17 	ldw	r2,-16(fp)
 80062a4:	10001915 	stw	zero,100(r2)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();
 80062a8:	800649c0 	call	800649c <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
 80062ac:	e0bffc17 	ldw	r2,-16(fp)
 80062b0:	10000015 	stw	zero,0(r2)
  fp->_w = 0;			/* nothing to read or write */
 80062b4:	e0bffc17 	ldw	r2,-16(fp)
 80062b8:	10000215 	stw	zero,8(r2)
  fp->_r = 0;
 80062bc:	e0bffc17 	ldw	r2,-16(fp)
 80062c0:	10000115 	stw	zero,4(r2)
  fp->_bf._base = NULL;		/* no buffer */
 80062c4:	e0bffc17 	ldw	r2,-16(fp)
 80062c8:	10000415 	stw	zero,16(r2)
  fp->_bf._size = 0;
 80062cc:	e0bffc17 	ldw	r2,-16(fp)
 80062d0:	10000515 	stw	zero,20(r2)
  fp->_lbfsize = 0;		/* not line buffered */
 80062d4:	e0bffc17 	ldw	r2,-16(fp)
 80062d8:	10000615 	stw	zero,24(r2)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
 80062dc:	e0bffc17 	ldw	r2,-16(fp)
 80062e0:	10801704 	addi	r2,r2,92
 80062e4:	01800204 	movi	r6,8
 80062e8:	000b883a 	mov	r5,zero
 80062ec:	1009883a 	mov	r4,r2
 80062f0:	80081d00 	call	80081d0 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
 80062f4:	e0bffc17 	ldw	r2,-16(fp)
 80062f8:	10000c15 	stw	zero,48(r2)
  fp->_ub._size = 0;
 80062fc:	e0bffc17 	ldw	r2,-16(fp)
 8006300:	10000d15 	stw	zero,52(r2)
  fp->_lb._base = NULL;		/* no line buffer */
 8006304:	e0bffc17 	ldw	r2,-16(fp)
 8006308:	10001115 	stw	zero,68(r2)
  fp->_lb._size = 0;
 800630c:	e0bffc17 	ldw	r2,-16(fp)
 8006310:	10001215 	stw	zero,72(r2)

  return fp;
 8006314:	e0bffc17 	ldw	r2,-16(fp)
}
 8006318:	e037883a 	mov	sp,fp
 800631c:	dfc00117 	ldw	ra,4(sp)
 8006320:	df000017 	ldw	fp,0(sp)
 8006324:	dec00204 	addi	sp,sp,8
 8006328:	f800283a 	ret

0800632c <_cleanup_r>:
 */

_VOID
_DEFUN(_cleanup_r, (ptr),
       struct _reent *ptr)
{
 800632c:	defffc04 	addi	sp,sp,-16
 8006330:	dfc00315 	stw	ra,12(sp)
 8006334:	df000215 	stw	fp,8(sp)
 8006338:	df000204 	addi	fp,sp,8
 800633c:	e13fff15 	stw	r4,-4(fp)
  /* Otherwise close files and flush read streams, too.
     Note we call flush directly if "--enable-lite-exit" is in effect.  */
#ifdef _LITE_EXIT
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
 8006340:	00820074 	movhi	r2,2049
 8006344:	10a53204 	addi	r2,r2,-27448
 8006348:	e0bffe15 	stw	r2,-8(fp)
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
 800634c:	e17ffe17 	ldw	r5,-8(fp)
 8006350:	e13fff17 	ldw	r4,-4(fp)
 8006354:	8006c780 	call	8006c78 <_fwalk_reent>
}
 8006358:	0001883a 	nop
 800635c:	e037883a 	mov	sp,fp
 8006360:	dfc00117 	ldw	ra,4(sp)
 8006364:	df000017 	ldw	fp,0(sp)
 8006368:	dec00204 	addi	sp,sp,8
 800636c:	f800283a 	ret

08006370 <_cleanup>:

#ifndef _REENT_ONLY
_VOID
_DEFUN_VOID(_cleanup)
{
 8006370:	defffe04 	addi	sp,sp,-8
 8006374:	dfc00115 	stw	ra,4(sp)
 8006378:	df000015 	stw	fp,0(sp)
 800637c:	d839883a 	mov	fp,sp
  _cleanup_r (_GLOBAL_REENT);
 8006380:	d0a04317 	ldw	r2,-32500(gp)
 8006384:	1009883a 	mov	r4,r2
 8006388:	800632c0 	call	800632c <_cleanup_r>
}
 800638c:	0001883a 	nop
 8006390:	e037883a 	mov	sp,fp
 8006394:	dfc00117 	ldw	ra,4(sp)
 8006398:	df000017 	ldw	fp,0(sp)
 800639c:	dec00204 	addi	sp,sp,8
 80063a0:	f800283a 	ret

080063a4 <__sinit>:
 */

_VOID
_DEFUN(__sinit, (s),
       struct _reent *s)
{
 80063a4:	defffd04 	addi	sp,sp,-12
 80063a8:	dfc00215 	stw	ra,8(sp)
 80063ac:	df000115 	stw	fp,4(sp)
 80063b0:	df000104 	addi	fp,sp,4
 80063b4:	e13fff15 	stw	r4,-4(fp)
  __sinit_lock_acquire ();
 80063b8:	80064bc0 	call	80064bc <__sinit_lock_acquire>

  if (s->__sdidinit)
 80063bc:	e0bfff17 	ldw	r2,-4(fp)
 80063c0:	10800e17 	ldw	r2,56(r2)
 80063c4:	10000226 	beq	r2,zero,80063d0 <__sinit+0x2c>
    {
      __sinit_lock_release ();
 80063c8:	80064dc0 	call	80064dc <__sinit_lock_release>
      return;
 80063cc:	00002606 	br	8006468 <__sinit+0xc4>
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
 80063d0:	e0ffff17 	ldw	r3,-4(fp)
 80063d4:	00820034 	movhi	r2,2048
 80063d8:	1098cb04 	addi	r2,r2,25388
 80063dc:	18800f15 	stw	r2,60(r3)

  s->__sglue._next = NULL;
 80063e0:	e0bfff17 	ldw	r2,-4(fp)
 80063e4:	1000b815 	stw	zero,736(r2)
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
 80063e8:	e0bfff17 	ldw	r2,-4(fp)
 80063ec:	00c000c4 	movi	r3,3
 80063f0:	10c0b915 	stw	r3,740(r2)
  s->__sglue._iobs = &s->__sf[0];
 80063f4:	e0bfff17 	ldw	r2,-4(fp)
 80063f8:	10c0bb04 	addi	r3,r2,748
 80063fc:	e0bfff17 	ldw	r2,-4(fp)
 8006400:	10c0ba15 	stw	r3,744(r2)
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
 8006404:	e0bfff17 	ldw	r2,-4(fp)
 8006408:	10800117 	ldw	r2,4(r2)
 800640c:	e1ffff17 	ldw	r7,-4(fp)
 8006410:	000d883a 	mov	r6,zero
 8006414:	01400104 	movi	r5,4
 8006418:	1009883a 	mov	r4,r2
 800641c:	80060000 	call	8006000 <std>
#ifdef HAVE_FCNTL
/*std (s->_stdout, __SWR, 1, s); */
  std (s->_stdout, __SWR | __SNBF, 1, s);	/* AlteraSpecific: Change to have no buffering on stdout. */
#else
/*std (s->_stdout, __SWR | __SLBF, 1, s); */
  std (s->_stdout, __SWR | __SNBF, 1, s);	/* AlteraSpecific: Change to have no buffering on stdout. */
 8006420:	e0bfff17 	ldw	r2,-4(fp)
 8006424:	10800217 	ldw	r2,8(r2)
 8006428:	e1ffff17 	ldw	r7,-4(fp)
 800642c:	01800044 	movi	r6,1
 8006430:	01400284 	movi	r5,10
 8006434:	1009883a 	mov	r4,r2
 8006438:	80060000 	call	8006000 <std>
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
 800643c:	e0bfff17 	ldw	r2,-4(fp)
 8006440:	10800317 	ldw	r2,12(r2)
 8006444:	e1ffff17 	ldw	r7,-4(fp)
 8006448:	01800084 	movi	r6,2
 800644c:	01400484 	movi	r5,18
 8006450:	1009883a 	mov	r4,r2
 8006454:	80060000 	call	8006000 <std>

  s->__sdidinit = 1;
 8006458:	e0bfff17 	ldw	r2,-4(fp)
 800645c:	00c00044 	movi	r3,1
 8006460:	10c00e15 	stw	r3,56(r2)

  __sinit_lock_release ();
 8006464:	80064dc0 	call	80064dc <__sinit_lock_release>
}
 8006468:	e037883a 	mov	sp,fp
 800646c:	dfc00117 	ldw	ra,4(sp)
 8006470:	df000017 	ldw	fp,0(sp)
 8006474:	dec00204 	addi	sp,sp,8
 8006478:	f800283a 	ret

0800647c <__sfp_lock_acquire>:
__LOCK_INIT_RECURSIVE(static, __sfp_lock);
__LOCK_INIT_RECURSIVE(static, __sinit_lock);

_VOID
_DEFUN_VOID(__sfp_lock_acquire)
{
 800647c:	deffff04 	addi	sp,sp,-4
 8006480:	df000015 	stw	fp,0(sp)
 8006484:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sfp_lock);
}
 8006488:	0001883a 	nop
 800648c:	e037883a 	mov	sp,fp
 8006490:	df000017 	ldw	fp,0(sp)
 8006494:	dec00104 	addi	sp,sp,4
 8006498:	f800283a 	ret

0800649c <__sfp_lock_release>:

_VOID
_DEFUN_VOID(__sfp_lock_release)
{
 800649c:	deffff04 	addi	sp,sp,-4
 80064a0:	df000015 	stw	fp,0(sp)
 80064a4:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sfp_lock);
}
 80064a8:	0001883a 	nop
 80064ac:	e037883a 	mov	sp,fp
 80064b0:	df000017 	ldw	fp,0(sp)
 80064b4:	dec00104 	addi	sp,sp,4
 80064b8:	f800283a 	ret

080064bc <__sinit_lock_acquire>:

_VOID
_DEFUN_VOID(__sinit_lock_acquire)
{
 80064bc:	deffff04 	addi	sp,sp,-4
 80064c0:	df000015 	stw	fp,0(sp)
 80064c4:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sinit_lock);
}
 80064c8:	0001883a 	nop
 80064cc:	e037883a 	mov	sp,fp
 80064d0:	df000017 	ldw	fp,0(sp)
 80064d4:	dec00104 	addi	sp,sp,4
 80064d8:	f800283a 	ret

080064dc <__sinit_lock_release>:

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
 80064dc:	deffff04 	addi	sp,sp,-4
 80064e0:	df000015 	stw	fp,0(sp)
 80064e4:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sinit_lock);
}
 80064e8:	0001883a 	nop
 80064ec:	e037883a 	mov	sp,fp
 80064f0:	df000017 	ldw	fp,0(sp)
 80064f4:	dec00104 	addi	sp,sp,4
 80064f8:	f800283a 	ret

080064fc <__fp_lock>:

/* Walkable file locking routine.  */
static int
_DEFUN(__fp_lock, (ptr),
       FILE * ptr)
{
 80064fc:	defffe04 	addi	sp,sp,-8
 8006500:	df000115 	stw	fp,4(sp)
 8006504:	df000104 	addi	fp,sp,4
 8006508:	e13fff15 	stw	r4,-4(fp)
  _flockfile (ptr);

  return 0;
 800650c:	0005883a 	mov	r2,zero
}
 8006510:	e037883a 	mov	sp,fp
 8006514:	df000017 	ldw	fp,0(sp)
 8006518:	dec00104 	addi	sp,sp,4
 800651c:	f800283a 	ret

08006520 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
_DEFUN(__fp_unlock, (ptr),
       FILE * ptr)
{
 8006520:	defffe04 	addi	sp,sp,-8
 8006524:	df000115 	stw	fp,4(sp)
 8006528:	df000104 	addi	fp,sp,4
 800652c:	e13fff15 	stw	r4,-4(fp)
  _funlockfile (ptr);

  return 0;
 8006530:	0005883a 	mov	r2,zero
}
 8006534:	e037883a 	mov	sp,fp
 8006538:	df000017 	ldw	fp,0(sp)
 800653c:	dec00104 	addi	sp,sp,4
 8006540:	f800283a 	ret

08006544 <__fp_lock_all>:

_VOID
_DEFUN_VOID(__fp_lock_all)
{
 8006544:	defffe04 	addi	sp,sp,-8
 8006548:	dfc00115 	stw	ra,4(sp)
 800654c:	df000015 	stw	fp,0(sp)
 8006550:	d839883a 	mov	fp,sp
  __sfp_lock_acquire ();
 8006554:	800647c0 	call	800647c <__sfp_lock_acquire>

  _CAST_VOID _fwalk (_REENT, __fp_lock);
 8006558:	d0a04217 	ldw	r2,-32504(gp)
 800655c:	01420034 	movhi	r5,2048
 8006560:	29593f04 	addi	r5,r5,25852
 8006564:	1009883a 	mov	r4,r2
 8006568:	8006ba00 	call	8006ba0 <_fwalk>
}
 800656c:	0001883a 	nop
 8006570:	e037883a 	mov	sp,fp
 8006574:	dfc00117 	ldw	ra,4(sp)
 8006578:	df000017 	ldw	fp,0(sp)
 800657c:	dec00204 	addi	sp,sp,8
 8006580:	f800283a 	ret

08006584 <__fp_unlock_all>:

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
 8006584:	defffe04 	addi	sp,sp,-8
 8006588:	dfc00115 	stw	ra,4(sp)
 800658c:	df000015 	stw	fp,0(sp)
 8006590:	d839883a 	mov	fp,sp
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
 8006594:	d0a04217 	ldw	r2,-32504(gp)
 8006598:	01420034 	movhi	r5,2048
 800659c:	29594804 	addi	r5,r5,25888
 80065a0:	1009883a 	mov	r4,r2
 80065a4:	8006ba00 	call	8006ba0 <_fwalk>

  __sfp_lock_release ();
 80065a8:	800649c0 	call	800649c <__sfp_lock_release>
}
 80065ac:	0001883a 	nop
 80065b0:	e037883a 	mov	sp,fp
 80065b4:	dfc00117 	ldw	ra,4(sp)
 80065b8:	df000017 	ldw	fp,0(sp)
 80065bc:	dec00204 	addi	sp,sp,8
 80065c0:	f800283a 	ret

080065c4 <__sfvwrite_r>:
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
 80065c4:	defff004 	addi	sp,sp,-64
 80065c8:	dfc00f15 	stw	ra,60(sp)
 80065cc:	df000e15 	stw	fp,56(sp)
 80065d0:	dd800d15 	stw	r22,52(sp)
 80065d4:	dd400c15 	stw	r21,48(sp)
 80065d8:	dd000b15 	stw	r20,44(sp)
 80065dc:	dcc00a15 	stw	r19,40(sp)
 80065e0:	dc800915 	stw	r18,36(sp)
 80065e4:	dc400815 	stw	r17,32(sp)
 80065e8:	dc000715 	stw	r16,28(sp)
 80065ec:	df000e04 	addi	fp,sp,56
 80065f0:	e13ff815 	stw	r4,-32(fp)
 80065f4:	2821883a 	mov	r16,r5
 80065f8:	302b883a 	mov	r21,r6
  register size_t len;
  register _CONST char *p = NULL;
 80065fc:	0027883a 	mov	r19,zero
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
 8006600:	ac800217 	ldw	r18,8(r21)
 8006604:	9000021e 	bne	r18,zero,8006610 <__sfvwrite_r+0x4c>
    return 0;
 8006608:	0005883a 	mov	r2,zero
 800660c:	00015806 	br	8006b70 <__sfvwrite_r+0x5ac>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
 8006610:	8080030b 	ldhu	r2,12(r16)
 8006614:	10bfffcc 	andi	r2,r2,65535
 8006618:	1080020c 	andi	r2,r2,8
 800661c:	10000226 	beq	r2,zero,8006628 <__sfvwrite_r+0x64>
 8006620:	80800417 	ldw	r2,16(r16)
 8006624:	1000061e 	bne	r2,zero,8006640 <__sfvwrite_r+0x7c>
 8006628:	800b883a 	mov	r5,r16
 800662c:	e13ff817 	ldw	r4,-32(fp)
 8006630:	80092c80 	call	80092c8 <__swsetup_r>
 8006634:	10000226 	beq	r2,zero,8006640 <__sfvwrite_r+0x7c>
    return EOF;
 8006638:	00bfffc4 	movi	r2,-1
 800663c:	00014c06 	br	8006b70 <__sfvwrite_r+0x5ac>

  iov = uio->uio_iov;
 8006640:	ad000017 	ldw	r20,0(r21)
  len = 0;
 8006644:	0025883a 	mov	r18,zero
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
 8006648:	8080030b 	ldhu	r2,12(r16)
 800664c:	10bfffcc 	andi	r2,r2,65535
 8006650:	1080008c 	andi	r2,r2,2
 8006654:	10001f26 	beq	r2,zero,80066d4 <__sfvwrite_r+0x110>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
 8006658:	00000306 	br	8006668 <__sfvwrite_r+0xa4>
 800665c:	a4c00017 	ldw	r19,0(r20)
 8006660:	a4800117 	ldw	r18,4(r20)
 8006664:	a5000204 	addi	r20,r20,8
 8006668:	903ffc26 	beq	r18,zero,800665c <__sfvwrite_r+0x98>
	  w = fp->_write (ptr, fp->_cookie, p,
 800666c:	82000917 	ldw	r8,36(r16)
 8006670:	81000717 	ldw	r4,28(r16)
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
 8006674:	9005883a 	mov	r2,r18
 8006678:	00e00034 	movhi	r3,32768
 800667c:	18ff0004 	addi	r3,r3,-1024
 8006680:	1880022e 	bgeu	r3,r2,800668c <__sfvwrite_r+0xc8>
 8006684:	00a00034 	movhi	r2,32768
 8006688:	10bf0004 	addi	r2,r2,-1024
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
 800668c:	100f883a 	mov	r7,r2
 8006690:	980d883a 	mov	r6,r19
 8006694:	200b883a 	mov	r5,r4
 8006698:	e13ff817 	ldw	r4,-32(fp)
 800669c:	403ee83a 	callr	r8
 80066a0:	1023883a 	mov	r17,r2
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
 80066a4:	0441290e 	bge	zero,r17,8006b4c <__sfvwrite_r+0x588>
	    goto err;
	  p += w;
 80066a8:	8805883a 	mov	r2,r17
 80066ac:	98a7883a 	add	r19,r19,r2
	  len -= w;
 80066b0:	8805883a 	mov	r2,r17
 80066b4:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 80066b8:	a8800217 	ldw	r2,8(r21)
 80066bc:	8807883a 	mov	r3,r17
 80066c0:	10c5c83a 	sub	r2,r2,r3
 80066c4:	a8800215 	stw	r2,8(r21)
 80066c8:	a8800217 	ldw	r2,8(r21)
 80066cc:	103fe61e 	bne	r2,zero,8006668 <__sfvwrite_r+0xa4>
 80066d0:	00011c06 	br	8006b44 <__sfvwrite_r+0x580>
    }
  else if ((fp->_flags & __SLBF) == 0)
 80066d4:	8080030b 	ldhu	r2,12(r16)
 80066d8:	10bfffcc 	andi	r2,r2,65535
 80066dc:	1080004c 	andi	r2,r2,1
 80066e0:	1000b51e 	bne	r2,zero,80069b8 <__sfvwrite_r+0x3f4>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
 80066e4:	00000306 	br	80066f4 <__sfvwrite_r+0x130>
 80066e8:	a4c00017 	ldw	r19,0(r20)
 80066ec:	a4800117 	ldw	r18,4(r20)
 80066f0:	a5000204 	addi	r20,r20,8
 80066f4:	903ffc26 	beq	r18,zero,80066e8 <__sfvwrite_r+0x124>
	  w = fp->_w;
 80066f8:	84400217 	ldw	r17,8(r16)
	  if (fp->_flags & __SSTR)
 80066fc:	8080030b 	ldhu	r2,12(r16)
 8006700:	10bfffcc 	andi	r2,r2,65535
 8006704:	1080800c 	andi	r2,r2,512
 8006708:	10006b26 	beq	r2,zero,80068b8 <__sfvwrite_r+0x2f4>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
 800670c:	8805883a 	mov	r2,r17
 8006710:	90805736 	bltu	r18,r2,8006870 <__sfvwrite_r+0x2ac>
 8006714:	8080030b 	ldhu	r2,12(r16)
 8006718:	10bfffcc 	andi	r2,r2,65535
 800671c:	1081200c 	andi	r2,r2,1152
 8006720:	10005326 	beq	r2,zero,8006870 <__sfvwrite_r+0x2ac>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
 8006724:	80800017 	ldw	r2,0(r16)
 8006728:	1007883a 	mov	r3,r2
 800672c:	80800417 	ldw	r2,16(r16)
 8006730:	1885c83a 	sub	r2,r3,r2
 8006734:	e0bff615 	stw	r2,-40(fp)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
 8006738:	80c00517 	ldw	r3,20(r16)
 800673c:	1805883a 	mov	r2,r3
 8006740:	1085883a 	add	r2,r2,r2
 8006744:	10c5883a 	add	r2,r2,r3
 8006748:	1006d7fa 	srli	r3,r2,31
 800674c:	1885883a 	add	r2,r3,r2
 8006750:	1005d07a 	srai	r2,r2,1
 8006754:	e0bff515 	stw	r2,-44(fp)
		  if (newsize < curpos + len + 1)
 8006758:	e0bff617 	ldw	r2,-40(fp)
 800675c:	1485883a 	add	r2,r2,r18
 8006760:	10800044 	addi	r2,r2,1
 8006764:	e0fff517 	ldw	r3,-44(fp)
 8006768:	1880042e 	bgeu	r3,r2,800677c <__sfvwrite_r+0x1b8>
		    newsize = curpos + len + 1;
 800676c:	e0bff617 	ldw	r2,-40(fp)
 8006770:	1485883a 	add	r2,r2,r18
 8006774:	10800044 	addi	r2,r2,1
 8006778:	e0bff515 	stw	r2,-44(fp)
		  if (fp->_flags & __SOPT)
 800677c:	8080030b 	ldhu	r2,12(r16)
 8006780:	10bfffcc 	andi	r2,r2,65535
 8006784:	1081000c 	andi	r2,r2,1024
 8006788:	10001726 	beq	r2,zero,80067e8 <__sfvwrite_r+0x224>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
 800678c:	e0bff517 	ldw	r2,-44(fp)
 8006790:	100b883a 	mov	r5,r2
 8006794:	e13ff817 	ldw	r4,-32(fp)
 8006798:	80071080 	call	8007108 <_malloc_r>
 800679c:	e0bff415 	stw	r2,-48(fp)
		      if (!str)
 80067a0:	e0bff417 	ldw	r2,-48(fp)
 80067a4:	1000041e 	bne	r2,zero,80067b8 <__sfvwrite_r+0x1f4>
			{
			  ptr->_errno = ENOMEM;
 80067a8:	e0bff817 	ldw	r2,-32(fp)
 80067ac:	00c00304 	movi	r3,12
 80067b0:	10c00015 	stw	r3,0(r2)
			  goto err;
 80067b4:	0000ea06 	br	8006b60 <__sfvwrite_r+0x59c>
			}
		      memcpy (str, fp->_bf._base, curpos);
 80067b8:	80800417 	ldw	r2,16(r16)
 80067bc:	e0fff617 	ldw	r3,-40(fp)
 80067c0:	180d883a 	mov	r6,r3
 80067c4:	100b883a 	mov	r5,r2
 80067c8:	e13ff417 	ldw	r4,-48(fp)
 80067cc:	8007e400 	call	8007e40 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
 80067d0:	80c0030b 	ldhu	r3,12(r16)
 80067d4:	00bedfc4 	movi	r2,-1153
 80067d8:	1884703a 	and	r2,r3,r2
 80067dc:	10802014 	ori	r2,r2,128
 80067e0:	8080030d 	sth	r2,12(r16)
 80067e4:	00001506 	br	800683c <__sfvwrite_r+0x278>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
 80067e8:	80800417 	ldw	r2,16(r16)
 80067ec:	e0fff517 	ldw	r3,-44(fp)
 80067f0:	180d883a 	mov	r6,r3
 80067f4:	100b883a 	mov	r5,r2
 80067f8:	e13ff817 	ldw	r4,-32(fp)
 80067fc:	80083940 	call	8008394 <_realloc_r>
 8006800:	e0bff415 	stw	r2,-48(fp)
							 newsize);
		      if (!str)
 8006804:	e0bff417 	ldw	r2,-48(fp)
 8006808:	10000c1e 	bne	r2,zero,800683c <__sfvwrite_r+0x278>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
 800680c:	80800417 	ldw	r2,16(r16)
 8006810:	100b883a 	mov	r5,r2
 8006814:	e13ff817 	ldw	r4,-32(fp)
 8006818:	8009a0c0 	call	8009a0c <_free_r>
			  fp->_flags &=  ~__SMBF;
 800681c:	80c0030b 	ldhu	r3,12(r16)
 8006820:	00bfdfc4 	movi	r2,-129
 8006824:	1884703a 	and	r2,r3,r2
 8006828:	8080030d 	sth	r2,12(r16)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
 800682c:	e0bff817 	ldw	r2,-32(fp)
 8006830:	00c00304 	movi	r3,12
 8006834:	10c00015 	stw	r3,0(r2)
			  goto err;
 8006838:	0000c906 	br	8006b60 <__sfvwrite_r+0x59c>
			}
		    }
		  fp->_bf._base = str;
 800683c:	e0bff417 	ldw	r2,-48(fp)
 8006840:	80800415 	stw	r2,16(r16)
		  fp->_p = str + curpos;
 8006844:	e0bff617 	ldw	r2,-40(fp)
 8006848:	e0fff417 	ldw	r3,-48(fp)
 800684c:	1885883a 	add	r2,r3,r2
 8006850:	80800015 	stw	r2,0(r16)
		  fp->_bf._size = newsize;
 8006854:	e0bff517 	ldw	r2,-44(fp)
 8006858:	80800515 	stw	r2,20(r16)
		  w = len;
 800685c:	9023883a 	mov	r17,r18
		  fp->_w = newsize - curpos;
 8006860:	e0fff517 	ldw	r3,-44(fp)
 8006864:	e0bff617 	ldw	r2,-40(fp)
 8006868:	1885c83a 	sub	r2,r3,r2
 800686c:	80800215 	stw	r2,8(r16)
		}
	      if (len < w)
 8006870:	8805883a 	mov	r2,r17
 8006874:	9080012e 	bgeu	r18,r2,800687c <__sfvwrite_r+0x2b8>
		w = len;
 8006878:	9023883a 	mov	r17,r18
	      COPY (w);		/* copy MIN(fp->_w,len), */
 800687c:	80800017 	ldw	r2,0(r16)
 8006880:	8807883a 	mov	r3,r17
 8006884:	180d883a 	mov	r6,r3
 8006888:	980b883a 	mov	r5,r19
 800688c:	1009883a 	mov	r4,r2
 8006890:	8007fc80 	call	8007fc8 <memmove>
	      fp->_w -= w;
 8006894:	80800217 	ldw	r2,8(r16)
 8006898:	1445c83a 	sub	r2,r2,r17
 800689c:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 80068a0:	80800017 	ldw	r2,0(r16)
 80068a4:	8807883a 	mov	r3,r17
 80068a8:	10c5883a 	add	r2,r2,r3
 80068ac:	80800015 	stw	r2,0(r16)
	      w = len;		/* but pretend copied all */
 80068b0:	9023883a 	mov	r17,r18
 80068b4:	00003506 	br	800698c <__sfvwrite_r+0x3c8>
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
 80068b8:	80800017 	ldw	r2,0(r16)
 80068bc:	80c00417 	ldw	r3,16(r16)
 80068c0:	18800236 	bltu	r3,r2,80068cc <__sfvwrite_r+0x308>
 80068c4:	80800517 	ldw	r2,20(r16)
 80068c8:	9080182e 	bgeu	r18,r2,800692c <__sfvwrite_r+0x368>
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
 80068cc:	8805883a 	mov	r2,r17
 80068d0:	9080012e 	bgeu	r18,r2,80068d8 <__sfvwrite_r+0x314>
 80068d4:	9005883a 	mov	r2,r18
 80068d8:	1023883a 	mov	r17,r2
	      COPY (w);
 80068dc:	80800017 	ldw	r2,0(r16)
 80068e0:	8807883a 	mov	r3,r17
 80068e4:	180d883a 	mov	r6,r3
 80068e8:	980b883a 	mov	r5,r19
 80068ec:	1009883a 	mov	r4,r2
 80068f0:	8007fc80 	call	8007fc8 <memmove>
	      fp->_w -= w;
 80068f4:	80800217 	ldw	r2,8(r16)
 80068f8:	1445c83a 	sub	r2,r2,r17
 80068fc:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 8006900:	80800017 	ldw	r2,0(r16)
 8006904:	8807883a 	mov	r3,r17
 8006908:	10c5883a 	add	r2,r2,r3
 800690c:	80800015 	stw	r2,0(r16)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 8006910:	80800217 	ldw	r2,8(r16)
 8006914:	10001c1e 	bne	r2,zero,8006988 <__sfvwrite_r+0x3c4>
 8006918:	800b883a 	mov	r5,r16
 800691c:	e13ff817 	ldw	r4,-32(fp)
 8006920:	80099300 	call	8009930 <_fflush_r>
 8006924:	10001826 	beq	r2,zero,8006988 <__sfvwrite_r+0x3c4>
		goto err;
 8006928:	00008d06 	br	8006b60 <__sfvwrite_r+0x59c>
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
 800692c:	9005883a 	mov	r2,r18
 8006930:	00e00034 	movhi	r3,32768
 8006934:	10c00236 	bltu	r2,r3,8006940 <__sfvwrite_r+0x37c>
 8006938:	00a00034 	movhi	r2,32768
 800693c:	10bfffc4 	addi	r2,r2,-1
 8006940:	1007883a 	mov	r3,r2
 8006944:	80800517 	ldw	r2,20(r16)
 8006948:	100b883a 	mov	r5,r2
 800694c:	1809883a 	mov	r4,r3
 8006950:	8003f140 	call	8003f14 <__divsi3>
 8006954:	1007883a 	mov	r3,r2
 8006958:	80800517 	ldw	r2,20(r16)
 800695c:	18a3383a 	mul	r17,r3,r2
	      w = fp->_write (ptr, fp->_cookie, p, w);
 8006960:	80800917 	ldw	r2,36(r16)
 8006964:	80c00717 	ldw	r3,28(r16)
 8006968:	880f883a 	mov	r7,r17
 800696c:	980d883a 	mov	r6,r19
 8006970:	180b883a 	mov	r5,r3
 8006974:	e13ff817 	ldw	r4,-32(fp)
 8006978:	103ee83a 	callr	r2
 800697c:	1023883a 	mov	r17,r2
	      if (w <= 0)
 8006980:	0440740e 	bge	zero,r17,8006b54 <__sfvwrite_r+0x590>
 8006984:	00000106 	br	800698c <__sfvwrite_r+0x3c8>
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 8006988:	0001883a 	nop
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
 800698c:	8805883a 	mov	r2,r17
 8006990:	98a7883a 	add	r19,r19,r2
	  len -= w;
 8006994:	8805883a 	mov	r2,r17
 8006998:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 800699c:	a8800217 	ldw	r2,8(r21)
 80069a0:	8807883a 	mov	r3,r17
 80069a4:	10c5c83a 	sub	r2,r2,r3
 80069a8:	a8800215 	stw	r2,8(r21)
 80069ac:	a8800217 	ldw	r2,8(r21)
 80069b0:	103f501e 	bne	r2,zero,80066f4 <__sfvwrite_r+0x130>
 80069b4:	00006306 	br	8006b44 <__sfvwrite_r+0x580>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
 80069b8:	e03ff215 	stw	zero,-56(fp)
      nldist = 0;
 80069bc:	e03ff315 	stw	zero,-52(fp)
      do
	{
	  GETIOV (nlknown = 0);
 80069c0:	00000406 	br	80069d4 <__sfvwrite_r+0x410>
 80069c4:	e03ff215 	stw	zero,-56(fp)
 80069c8:	a4c00017 	ldw	r19,0(r20)
 80069cc:	a4800117 	ldw	r18,4(r20)
 80069d0:	a5000204 	addi	r20,r20,8
 80069d4:	903ffb26 	beq	r18,zero,80069c4 <__sfvwrite_r+0x400>
	  if (!nlknown)
 80069d8:	e0bff217 	ldw	r2,-56(fp)
 80069dc:	1000111e 	bne	r2,zero,8006a24 <__sfvwrite_r+0x460>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
 80069e0:	900d883a 	mov	r6,r18
 80069e4:	01400284 	movi	r5,10
 80069e8:	9809883a 	mov	r4,r19
 80069ec:	8007c840 	call	8007c84 <memchr>
 80069f0:	e0bff715 	stw	r2,-36(fp)
	      nldist = nl ? nl + 1 - p : len + 1;
 80069f4:	e0bff717 	ldw	r2,-36(fp)
 80069f8:	10000626 	beq	r2,zero,8006a14 <__sfvwrite_r+0x450>
 80069fc:	e0bff717 	ldw	r2,-36(fp)
 8006a00:	10800044 	addi	r2,r2,1
 8006a04:	1007883a 	mov	r3,r2
 8006a08:	9805883a 	mov	r2,r19
 8006a0c:	1885c83a 	sub	r2,r3,r2
 8006a10:	00000106 	br	8006a18 <__sfvwrite_r+0x454>
 8006a14:	90800044 	addi	r2,r18,1
 8006a18:	e0bff315 	stw	r2,-52(fp)
	      nlknown = 1;
 8006a1c:	00800044 	movi	r2,1
 8006a20:	e0bff215 	stw	r2,-56(fp)
	    }
	  s = MIN (len, nldist);
 8006a24:	e0bff317 	ldw	r2,-52(fp)
 8006a28:	9080012e 	bgeu	r18,r2,8006a30 <__sfvwrite_r+0x46c>
 8006a2c:	9005883a 	mov	r2,r18
 8006a30:	102d883a 	mov	r22,r2
	  w = fp->_w + fp->_bf._size;
 8006a34:	80c00217 	ldw	r3,8(r16)
 8006a38:	80800517 	ldw	r2,20(r16)
 8006a3c:	18a3883a 	add	r17,r3,r2
	  if (fp->_p > fp->_bf._base && s > w)
 8006a40:	80800017 	ldw	r2,0(r16)
 8006a44:	80c00417 	ldw	r3,16(r16)
 8006a48:	1880102e 	bgeu	r3,r2,8006a8c <__sfvwrite_r+0x4c8>
 8006a4c:	8d800f0e 	bge	r17,r22,8006a8c <__sfvwrite_r+0x4c8>
	    {
	      COPY (w);
 8006a50:	80800017 	ldw	r2,0(r16)
 8006a54:	8807883a 	mov	r3,r17
 8006a58:	180d883a 	mov	r6,r3
 8006a5c:	980b883a 	mov	r5,r19
 8006a60:	1009883a 	mov	r4,r2
 8006a64:	8007fc80 	call	8007fc8 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
 8006a68:	80800017 	ldw	r2,0(r16)
 8006a6c:	8807883a 	mov	r3,r17
 8006a70:	10c5883a 	add	r2,r2,r3
 8006a74:	80800015 	stw	r2,0(r16)
	      if (_fflush_r (ptr, fp))
 8006a78:	800b883a 	mov	r5,r16
 8006a7c:	e13ff817 	ldw	r4,-32(fp)
 8006a80:	80099300 	call	8009930 <_fflush_r>
 8006a84:	10001b26 	beq	r2,zero,8006af4 <__sfvwrite_r+0x530>
		goto err;
 8006a88:	00003506 	br	8006b60 <__sfvwrite_r+0x59c>
	    }
	  else if (s >= (w = fp->_bf._size))
 8006a8c:	84400517 	ldw	r17,20(r16)
 8006a90:	b4400a16 	blt	r22,r17,8006abc <__sfvwrite_r+0x4f8>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
 8006a94:	80800917 	ldw	r2,36(r16)
 8006a98:	80c00717 	ldw	r3,28(r16)
 8006a9c:	880f883a 	mov	r7,r17
 8006aa0:	980d883a 	mov	r6,r19
 8006aa4:	180b883a 	mov	r5,r3
 8006aa8:	e13ff817 	ldw	r4,-32(fp)
 8006aac:	103ee83a 	callr	r2
 8006ab0:	1023883a 	mov	r17,r2
	      if (w <= 0)
 8006ab4:	04400f16 	blt	zero,r17,8006af4 <__sfvwrite_r+0x530>
		goto err;
 8006ab8:	00002906 	br	8006b60 <__sfvwrite_r+0x59c>
	    }
	  else
	    {
	      w = s;
 8006abc:	b023883a 	mov	r17,r22
	      COPY (w);
 8006ac0:	80800017 	ldw	r2,0(r16)
 8006ac4:	8807883a 	mov	r3,r17
 8006ac8:	180d883a 	mov	r6,r3
 8006acc:	980b883a 	mov	r5,r19
 8006ad0:	1009883a 	mov	r4,r2
 8006ad4:	8007fc80 	call	8007fc8 <memmove>
	      fp->_w -= w;
 8006ad8:	80800217 	ldw	r2,8(r16)
 8006adc:	1445c83a 	sub	r2,r2,r17
 8006ae0:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 8006ae4:	80800017 	ldw	r2,0(r16)
 8006ae8:	8807883a 	mov	r3,r17
 8006aec:	10c5883a 	add	r2,r2,r3
 8006af0:	80800015 	stw	r2,0(r16)
	    }
	  if ((nldist -= w) == 0)
 8006af4:	e0bff317 	ldw	r2,-52(fp)
 8006af8:	1445c83a 	sub	r2,r2,r17
 8006afc:	e0bff315 	stw	r2,-52(fp)
 8006b00:	e0bff317 	ldw	r2,-52(fp)
 8006b04:	1000051e 	bne	r2,zero,8006b1c <__sfvwrite_r+0x558>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
 8006b08:	800b883a 	mov	r5,r16
 8006b0c:	e13ff817 	ldw	r4,-32(fp)
 8006b10:	80099300 	call	8009930 <_fflush_r>
 8006b14:	1000111e 	bne	r2,zero,8006b5c <__sfvwrite_r+0x598>
		goto err;
	      nlknown = 0;
 8006b18:	e03ff215 	stw	zero,-56(fp)
	    }
	  p += w;
 8006b1c:	8805883a 	mov	r2,r17
 8006b20:	98a7883a 	add	r19,r19,r2
	  len -= w;
 8006b24:	8805883a 	mov	r2,r17
 8006b28:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 8006b2c:	a8800217 	ldw	r2,8(r21)
 8006b30:	8807883a 	mov	r3,r17
 8006b34:	10c5c83a 	sub	r2,r2,r3
 8006b38:	a8800215 	stw	r2,8(r21)
 8006b3c:	a8800217 	ldw	r2,8(r21)
 8006b40:	103fa41e 	bne	r2,zero,80069d4 <__sfvwrite_r+0x410>
    }
  return 0;
 8006b44:	0005883a 	mov	r2,zero
 8006b48:	00000906 	br	8006b70 <__sfvwrite_r+0x5ac>
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
 8006b4c:	0001883a 	nop
 8006b50:	00000306 	br	8006b60 <__sfvwrite_r+0x59c>
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
 8006b54:	0001883a 	nop
 8006b58:	00000106 	br	8006b60 <__sfvwrite_r+0x59c>
	    }
	  if ((nldist -= w) == 0)
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
 8006b5c:	0001883a 	nop
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
 8006b60:	8080030b 	ldhu	r2,12(r16)
 8006b64:	10801014 	ori	r2,r2,64
 8006b68:	8080030d 	sth	r2,12(r16)
  return EOF;
 8006b6c:	00bfffc4 	movi	r2,-1
}
 8006b70:	e6fff904 	addi	sp,fp,-28
 8006b74:	dfc00817 	ldw	ra,32(sp)
 8006b78:	df000717 	ldw	fp,28(sp)
 8006b7c:	dd800617 	ldw	r22,24(sp)
 8006b80:	dd400517 	ldw	r21,20(sp)
 8006b84:	dd000417 	ldw	r20,16(sp)
 8006b88:	dcc00317 	ldw	r19,12(sp)
 8006b8c:	dc800217 	ldw	r18,8(sp)
 8006b90:	dc400117 	ldw	r17,4(sp)
 8006b94:	dc000017 	ldw	r16,0(sp)
 8006b98:	dec00904 	addi	sp,sp,36
 8006b9c:	f800283a 	ret

08006ba0 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
 8006ba0:	defff804 	addi	sp,sp,-32
 8006ba4:	dfc00715 	stw	ra,28(sp)
 8006ba8:	df000615 	stw	fp,24(sp)
 8006bac:	dd000515 	stw	r20,20(sp)
 8006bb0:	dcc00415 	stw	r19,16(sp)
 8006bb4:	dc800315 	stw	r18,12(sp)
 8006bb8:	dc400215 	stw	r17,8(sp)
 8006bbc:	dc000115 	stw	r16,4(sp)
 8006bc0:	df000604 	addi	fp,sp,24
 8006bc4:	e13ffa15 	stw	r4,-24(fp)
 8006bc8:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 8006bcc:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8006bd0:	e0bffa17 	ldw	r2,-24(fp)
 8006bd4:	1440b804 	addi	r17,r2,736
 8006bd8:	00001b06 	br	8006c48 <_fwalk+0xa8>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006bdc:	8c000217 	ldw	r16,8(r17)
 8006be0:	8c800117 	ldw	r18,4(r17)
 8006be4:	00001506 	br	8006c3c <_fwalk+0x9c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 8006be8:	8080030b 	ldhu	r2,12(r16)
 8006bec:	10bfffcc 	andi	r2,r2,65535
 8006bf0:	10a0001c 	xori	r2,r2,32768
 8006bf4:	10a00004 	addi	r2,r2,-32768
 8006bf8:	10000f26 	beq	r2,zero,8006c38 <_fwalk+0x98>
 8006bfc:	8080030b 	ldhu	r2,12(r16)
 8006c00:	10bfffcc 	andi	r2,r2,65535
 8006c04:	10a0001c 	xori	r2,r2,32768
 8006c08:	10a00004 	addi	r2,r2,-32768
 8006c0c:	10800060 	cmpeqi	r2,r2,1
 8006c10:	1000091e 	bne	r2,zero,8006c38 <_fwalk+0x98>
 8006c14:	8080038b 	ldhu	r2,14(r16)
 8006c18:	10bfffcc 	andi	r2,r2,65535
 8006c1c:	10a0001c 	xori	r2,r2,32768
 8006c20:	10a00004 	addi	r2,r2,-32768
 8006c24:	10bfffe0 	cmpeqi	r2,r2,-1
 8006c28:	1000031e 	bne	r2,zero,8006c38 <_fwalk+0x98>
	ret |= (*function) (fp);
 8006c2c:	8009883a 	mov	r4,r16
 8006c30:	a03ee83a 	callr	r20
 8006c34:	98a6b03a 	or	r19,r19,r2
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006c38:	84001a04 	addi	r16,r16,104
 8006c3c:	94bfffc4 	addi	r18,r18,-1
 8006c40:	903fe90e 	bge	r18,zero,8006be8 <_fwalk+0x48>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8006c44:	8c400017 	ldw	r17,0(r17)
 8006c48:	883fe41e 	bne	r17,zero,8006bdc <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
 8006c4c:	9805883a 	mov	r2,r19
}
 8006c50:	e6fffb04 	addi	sp,fp,-20
 8006c54:	dfc00617 	ldw	ra,24(sp)
 8006c58:	df000517 	ldw	fp,20(sp)
 8006c5c:	dd000417 	ldw	r20,16(sp)
 8006c60:	dcc00317 	ldw	r19,12(sp)
 8006c64:	dc800217 	ldw	r18,8(sp)
 8006c68:	dc400117 	ldw	r17,4(sp)
 8006c6c:	dc000017 	ldw	r16,0(sp)
 8006c70:	dec00704 	addi	sp,sp,28
 8006c74:	f800283a 	ret

08006c78 <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
 8006c78:	defff804 	addi	sp,sp,-32
 8006c7c:	dfc00715 	stw	ra,28(sp)
 8006c80:	df000615 	stw	fp,24(sp)
 8006c84:	dd000515 	stw	r20,20(sp)
 8006c88:	dcc00415 	stw	r19,16(sp)
 8006c8c:	dc800315 	stw	r18,12(sp)
 8006c90:	dc400215 	stw	r17,8(sp)
 8006c94:	dc000115 	stw	r16,4(sp)
 8006c98:	df000604 	addi	fp,sp,24
 8006c9c:	e13ffa15 	stw	r4,-24(fp)
 8006ca0:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 8006ca4:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8006ca8:	e0bffa17 	ldw	r2,-24(fp)
 8006cac:	1440b804 	addi	r17,r2,736
 8006cb0:	00001c06 	br	8006d24 <_fwalk_reent+0xac>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006cb4:	8c000217 	ldw	r16,8(r17)
 8006cb8:	8c800117 	ldw	r18,4(r17)
 8006cbc:	00001606 	br	8006d18 <_fwalk_reent+0xa0>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 8006cc0:	8080030b 	ldhu	r2,12(r16)
 8006cc4:	10bfffcc 	andi	r2,r2,65535
 8006cc8:	10a0001c 	xori	r2,r2,32768
 8006ccc:	10a00004 	addi	r2,r2,-32768
 8006cd0:	10001026 	beq	r2,zero,8006d14 <_fwalk_reent+0x9c>
 8006cd4:	8080030b 	ldhu	r2,12(r16)
 8006cd8:	10bfffcc 	andi	r2,r2,65535
 8006cdc:	10a0001c 	xori	r2,r2,32768
 8006ce0:	10a00004 	addi	r2,r2,-32768
 8006ce4:	10800060 	cmpeqi	r2,r2,1
 8006ce8:	10000a1e 	bne	r2,zero,8006d14 <_fwalk_reent+0x9c>
 8006cec:	8080038b 	ldhu	r2,14(r16)
 8006cf0:	10bfffcc 	andi	r2,r2,65535
 8006cf4:	10a0001c 	xori	r2,r2,32768
 8006cf8:	10a00004 	addi	r2,r2,-32768
 8006cfc:	10bfffe0 	cmpeqi	r2,r2,-1
 8006d00:	1000041e 	bne	r2,zero,8006d14 <_fwalk_reent+0x9c>
	ret |= (*reent_function) (ptr, fp);
 8006d04:	800b883a 	mov	r5,r16
 8006d08:	e13ffa17 	ldw	r4,-24(fp)
 8006d0c:	a03ee83a 	callr	r20
 8006d10:	98a6b03a 	or	r19,r19,r2
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 8006d14:	84001a04 	addi	r16,r16,104
 8006d18:	94bfffc4 	addi	r18,r18,-1
 8006d1c:	903fe80e 	bge	r18,zero,8006cc0 <_fwalk_reent+0x48>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 8006d20:	8c400017 	ldw	r17,0(r17)
 8006d24:	883fe31e 	bne	r17,zero,8006cb4 <_fwalk_reent+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
 8006d28:	9805883a 	mov	r2,r19
}
 8006d2c:	e6fffb04 	addi	sp,fp,-20
 8006d30:	dfc00617 	ldw	ra,24(sp)
 8006d34:	df000517 	ldw	fp,20(sp)
 8006d38:	dd000417 	ldw	r20,16(sp)
 8006d3c:	dcc00317 	ldw	r19,12(sp)
 8006d40:	dc800217 	ldw	r18,8(sp)
 8006d44:	dc400117 	ldw	r17,4(sp)
 8006d48:	dc000017 	ldw	r16,0(sp)
 8006d4c:	dec00704 	addi	sp,sp,28
 8006d50:	f800283a 	ret

08006d54 <malloc_extend_top>:
#if __STD_C
static void malloc_extend_top(RARG INTERNAL_SIZE_T nb)
#else
static void malloc_extend_top(RARG nb) RDECL INTERNAL_SIZE_T nb;
#endif
{
 8006d54:	defff104 	addi	sp,sp,-60
 8006d58:	dfc00e15 	stw	ra,56(sp)
 8006d5c:	df000d15 	stw	fp,52(sp)
 8006d60:	df000d04 	addi	fp,sp,52
 8006d64:	e13ffe15 	stw	r4,-8(fp)
 8006d68:	e17fff15 	stw	r5,-4(fp)
  char*     brk;                  /* return value from sbrk */
  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of sbrked space */
  INTERNAL_SIZE_T correction;     /* bytes for 2nd sbrk call */
  int correction_failed = 0;      /* whether we should relax the assertion */
 8006d6c:	e03ff715 	stw	zero,-36(fp)
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
 8006d70:	00820134 	movhi	r2,2052
 8006d74:	109a9f04 	addi	r2,r2,27260
 8006d78:	10800217 	ldw	r2,8(r2)
 8006d7c:	e0bff815 	stw	r2,-32(fp)
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
 8006d80:	e0bff817 	ldw	r2,-32(fp)
 8006d84:	10c00117 	ldw	r3,4(r2)
 8006d88:	00bfff04 	movi	r2,-4
 8006d8c:	1884703a 	and	r2,r3,r2
 8006d90:	e0bff915 	stw	r2,-28(fp)
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
 8006d94:	e0fff817 	ldw	r3,-32(fp)
 8006d98:	e0bff917 	ldw	r2,-28(fp)
 8006d9c:	1885883a 	add	r2,r3,r2
 8006da0:	e0bffa15 	stw	r2,-24(fp)

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
 8006da4:	d0e76717 	ldw	r3,-25188(gp)
 8006da8:	e0bfff17 	ldw	r2,-4(fp)
 8006dac:	1885883a 	add	r2,r3,r2
 8006db0:	10800404 	addi	r2,r2,16
 8006db4:	e0bff615 	stw	r2,-40(fp)
  unsigned long pagesz    = malloc_getpagesize;
 8006db8:	00840004 	movi	r2,4096
 8006dbc:	e0bffb15 	stw	r2,-20(fp)

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
 8006dc0:	d0a04517 	ldw	r2,-32492(gp)
 8006dc4:	10bfffe0 	cmpeqi	r2,r2,-1
 8006dc8:	1000081e 	bne	r2,zero,8006dec <malloc_extend_top+0x98>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
 8006dcc:	e0fffb17 	ldw	r3,-20(fp)
 8006dd0:	e0bff617 	ldw	r2,-40(fp)
 8006dd4:	1885883a 	add	r2,r3,r2
 8006dd8:	10ffffc4 	addi	r3,r2,-1
 8006ddc:	e0bffb17 	ldw	r2,-20(fp)
 8006de0:	0085c83a 	sub	r2,zero,r2
 8006de4:	1884703a 	and	r2,r3,r2
 8006de8:	e0bff615 	stw	r2,-40(fp)

  brk = (char*)(MORECORE (sbrk_size));
 8006dec:	e0bff617 	ldw	r2,-40(fp)
 8006df0:	100b883a 	mov	r5,r2
 8006df4:	e13ffe17 	ldw	r4,-8(fp)
 8006df8:	8008f840 	call	8008f84 <_sbrk_r>
 8006dfc:	e0bff315 	stw	r2,-52(fp)

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
 8006e00:	e0bff317 	ldw	r2,-52(fp)
 8006e04:	10bfffe0 	cmpeqi	r2,r2,-1
 8006e08:	1000b91e 	bne	r2,zero,80070f0 <malloc_extend_top+0x39c>
 8006e0c:	e0fff317 	ldw	r3,-52(fp)
 8006e10:	e0bffa17 	ldw	r2,-24(fp)
 8006e14:	1880042e 	bgeu	r3,r2,8006e28 <malloc_extend_top+0xd4>
      (brk < old_end && old_top != initial_top))
 8006e18:	00820134 	movhi	r2,2052
 8006e1c:	109a9f04 	addi	r2,r2,27260
 8006e20:	e0fff817 	ldw	r3,-32(fp)
 8006e24:	1880b21e 	bne	r3,r2,80070f0 <malloc_extend_top+0x39c>
    return;

  sbrked_mem += sbrk_size;
 8006e28:	00820174 	movhi	r2,2053
 8006e2c:	10a7ce04 	addi	r2,r2,-24776
 8006e30:	10800017 	ldw	r2,0(r2)
 8006e34:	1007883a 	mov	r3,r2
 8006e38:	e0bff617 	ldw	r2,-40(fp)
 8006e3c:	1885883a 	add	r2,r3,r2
 8006e40:	1007883a 	mov	r3,r2
 8006e44:	00820174 	movhi	r2,2053
 8006e48:	10a7ce04 	addi	r2,r2,-24776
 8006e4c:	10c00015 	stw	r3,0(r2)

  if (brk == old_end /* can just add bytes to current top, unless
 8006e50:	e0fff317 	ldw	r3,-52(fp)
 8006e54:	e0bffa17 	ldw	r2,-24(fp)
 8006e58:	1880101e 	bne	r3,r2,8006e9c <malloc_extend_top+0x148>
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
 8006e5c:	e0bffb17 	ldw	r2,-20(fp)
 8006e60:	10ffffc4 	addi	r3,r2,-1
 8006e64:	e0bffa17 	ldw	r2,-24(fp)
 8006e68:	1884703a 	and	r2,r3,r2
 8006e6c:	10000b1e 	bne	r2,zero,8006e9c <malloc_extend_top+0x148>
  {
    top_size = sbrk_size + old_top_size;
 8006e70:	e0fff617 	ldw	r3,-40(fp)
 8006e74:	e0bff917 	ldw	r2,-28(fp)
 8006e78:	1885883a 	add	r2,r3,r2
 8006e7c:	e0bffc15 	stw	r2,-16(fp)
    set_head(top, top_size | PREV_INUSE);
 8006e80:	00820134 	movhi	r2,2052
 8006e84:	109a9f04 	addi	r2,r2,27260
 8006e88:	10800217 	ldw	r2,8(r2)
 8006e8c:	e0fffc17 	ldw	r3,-16(fp)
 8006e90:	18c00054 	ori	r3,r3,1
 8006e94:	10c00115 	stw	r3,4(r2)
 8006e98:	00008006 	br	800709c <malloc_extend_top+0x348>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
 8006e9c:	d0a04517 	ldw	r2,-32492(gp)
 8006ea0:	10bfffd8 	cmpnei	r2,r2,-1
 8006ea4:	1000031e 	bne	r2,zero,8006eb4 <malloc_extend_top+0x160>
      sbrk_base = brk;
 8006ea8:	e0bff317 	ldw	r2,-52(fp)
 8006eac:	d0a04515 	stw	r2,-32492(gp)
 8006eb0:	00000a06 	br	8006edc <malloc_extend_top+0x188>
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
 8006eb4:	00820174 	movhi	r2,2053
 8006eb8:	10a7ce04 	addi	r2,r2,-24776
 8006ebc:	10c00017 	ldw	r3,0(r2)
 8006ec0:	e13ff317 	ldw	r4,-52(fp)
 8006ec4:	e0bffa17 	ldw	r2,-24(fp)
 8006ec8:	2085c83a 	sub	r2,r4,r2
 8006ecc:	1887883a 	add	r3,r3,r2
 8006ed0:	00820174 	movhi	r2,2053
 8006ed4:	10a7ce04 	addi	r2,r2,-24776
 8006ed8:	10c00015 	stw	r3,0(r2)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
 8006edc:	e0bff317 	ldw	r2,-52(fp)
 8006ee0:	10800204 	addi	r2,r2,8
 8006ee4:	108001cc 	andi	r2,r2,7
 8006ee8:	e0bffd15 	stw	r2,-12(fp)
    if (front_misalign > 0) 
 8006eec:	e0bffd17 	ldw	r2,-12(fp)
 8006ef0:	10000926 	beq	r2,zero,8006f18 <malloc_extend_top+0x1c4>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
 8006ef4:	00c00204 	movi	r3,8
 8006ef8:	e0bffd17 	ldw	r2,-12(fp)
 8006efc:	1885c83a 	sub	r2,r3,r2
 8006f00:	e0bff415 	stw	r2,-48(fp)
      brk += correction;
 8006f04:	e0fff317 	ldw	r3,-52(fp)
 8006f08:	e0bff417 	ldw	r2,-48(fp)
 8006f0c:	1885883a 	add	r2,r3,r2
 8006f10:	e0bff315 	stw	r2,-52(fp)
 8006f14:	00000106 	br	8006f1c <malloc_extend_top+0x1c8>
    }
    else
      correction = 0;
 8006f18:	e03ff415 	stw	zero,-48(fp)

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
 8006f1c:	e0fff317 	ldw	r3,-52(fp)
 8006f20:	e0bff617 	ldw	r2,-40(fp)
 8006f24:	1885883a 	add	r2,r3,r2
 8006f28:	1007883a 	mov	r3,r2
 8006f2c:	e0bffb17 	ldw	r2,-20(fp)
 8006f30:	10bfffc4 	addi	r2,r2,-1
 8006f34:	1884703a 	and	r2,r3,r2
 8006f38:	e0fffb17 	ldw	r3,-20(fp)
 8006f3c:	1885c83a 	sub	r2,r3,r2
 8006f40:	e0fff417 	ldw	r3,-48(fp)
 8006f44:	1885883a 	add	r2,r3,r2
 8006f48:	e0bff415 	stw	r2,-48(fp)

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
 8006f4c:	e0bff417 	ldw	r2,-48(fp)
 8006f50:	100b883a 	mov	r5,r2
 8006f54:	e13ffe17 	ldw	r4,-8(fp)
 8006f58:	8008f840 	call	8008f84 <_sbrk_r>
 8006f5c:	e0bff515 	stw	r2,-44(fp)
    if (new_brk == (char*)(MORECORE_FAILURE))
 8006f60:	e0bff517 	ldw	r2,-44(fp)
 8006f64:	10bfffd8 	cmpnei	r2,r2,-1
 8006f68:	1000051e 	bne	r2,zero,8006f80 <malloc_extend_top+0x22c>
      {
	correction = 0;
 8006f6c:	e03ff415 	stw	zero,-48(fp)
	correction_failed = 1;
 8006f70:	00800044 	movi	r2,1
 8006f74:	e0bff715 	stw	r2,-36(fp)
	new_brk = brk;
 8006f78:	e0bff317 	ldw	r2,-52(fp)
 8006f7c:	e0bff515 	stw	r2,-44(fp)
      }

    sbrked_mem += correction;
 8006f80:	00820174 	movhi	r2,2053
 8006f84:	10a7ce04 	addi	r2,r2,-24776
 8006f88:	10800017 	ldw	r2,0(r2)
 8006f8c:	1007883a 	mov	r3,r2
 8006f90:	e0bff417 	ldw	r2,-48(fp)
 8006f94:	1885883a 	add	r2,r3,r2
 8006f98:	1007883a 	mov	r3,r2
 8006f9c:	00820174 	movhi	r2,2053
 8006fa0:	10a7ce04 	addi	r2,r2,-24776
 8006fa4:	10c00015 	stw	r3,0(r2)

    top = (mchunkptr)brk;
 8006fa8:	00820134 	movhi	r2,2052
 8006fac:	109a9f04 	addi	r2,r2,27260
 8006fb0:	e0fff317 	ldw	r3,-52(fp)
 8006fb4:	10c00215 	stw	r3,8(r2)
    top_size = new_brk - brk + correction;
 8006fb8:	e0fff517 	ldw	r3,-44(fp)
 8006fbc:	e0bff317 	ldw	r2,-52(fp)
 8006fc0:	1885c83a 	sub	r2,r3,r2
 8006fc4:	1007883a 	mov	r3,r2
 8006fc8:	e0bff417 	ldw	r2,-48(fp)
 8006fcc:	1885883a 	add	r2,r3,r2
 8006fd0:	e0bffc15 	stw	r2,-16(fp)
    set_head(top, top_size | PREV_INUSE);
 8006fd4:	00820134 	movhi	r2,2052
 8006fd8:	109a9f04 	addi	r2,r2,27260
 8006fdc:	10800217 	ldw	r2,8(r2)
 8006fe0:	e0fffc17 	ldw	r3,-16(fp)
 8006fe4:	18c00054 	ori	r3,r3,1
 8006fe8:	10c00115 	stw	r3,4(r2)

    if (old_top != initial_top)
 8006fec:	00820134 	movhi	r2,2052
 8006ff0:	109a9f04 	addi	r2,r2,27260
 8006ff4:	e0fff817 	ldw	r3,-32(fp)
 8006ff8:	18802826 	beq	r3,r2,800709c <malloc_extend_top+0x348>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
 8006ffc:	e0bff917 	ldw	r2,-28(fp)
 8007000:	10800428 	cmpgeui	r2,r2,16
 8007004:	1000061e 	bne	r2,zero,8007020 <malloc_extend_top+0x2cc>
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
 8007008:	00820134 	movhi	r2,2052
 800700c:	109a9f04 	addi	r2,r2,27260
 8007010:	10800217 	ldw	r2,8(r2)
 8007014:	00c00044 	movi	r3,1
 8007018:	10c00115 	stw	r3,4(r2)
        return;
 800701c:	00003506 	br	80070f4 <malloc_extend_top+0x3a0>
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
 8007020:	e0bff917 	ldw	r2,-28(fp)
 8007024:	10fffd04 	addi	r3,r2,-12
 8007028:	00bffe04 	movi	r2,-8
 800702c:	1884703a 	and	r2,r3,r2
 8007030:	e0bff915 	stw	r2,-28(fp)
      set_head_size(old_top, old_top_size);
 8007034:	e0bff817 	ldw	r2,-32(fp)
 8007038:	10800117 	ldw	r2,4(r2)
 800703c:	10c0004c 	andi	r3,r2,1
 8007040:	e0bff917 	ldw	r2,-28(fp)
 8007044:	1886b03a 	or	r3,r3,r2
 8007048:	e0bff817 	ldw	r2,-32(fp)
 800704c:	10c00115 	stw	r3,4(r2)
      chunk_at_offset(old_top, old_top_size          )->size =
 8007050:	e0fff817 	ldw	r3,-32(fp)
 8007054:	e0bff917 	ldw	r2,-28(fp)
 8007058:	1885883a 	add	r2,r3,r2
 800705c:	00c00144 	movi	r3,5
 8007060:	10c00115 	stw	r3,4(r2)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
 8007064:	e0bff917 	ldw	r2,-28(fp)
 8007068:	10800104 	addi	r2,r2,4
 800706c:	e0fff817 	ldw	r3,-32(fp)
 8007070:	1885883a 	add	r2,r3,r2
 8007074:	00c00144 	movi	r3,5
 8007078:	10c00115 	stw	r3,4(r2)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
 800707c:	e0bff917 	ldw	r2,-28(fp)
 8007080:	10800430 	cmpltui	r2,r2,16
 8007084:	1000051e 	bne	r2,zero,800709c <malloc_extend_top+0x348>
        fREe(RCALL chunk2mem(old_top));
 8007088:	e0bff817 	ldw	r2,-32(fp)
 800708c:	10800204 	addi	r2,r2,8
 8007090:	100b883a 	mov	r5,r2
 8007094:	e13ffe17 	ldw	r4,-8(fp)
 8007098:	8009a0c0 	call	8009a0c <_free_r>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
 800709c:	00820174 	movhi	r2,2053
 80070a0:	10a7ce04 	addi	r2,r2,-24776
 80070a4:	10800017 	ldw	r2,0(r2)
 80070a8:	1007883a 	mov	r3,r2
 80070ac:	d0a76817 	ldw	r2,-25184(gp)
 80070b0:	10c0042e 	bgeu	r2,r3,80070c4 <malloc_extend_top+0x370>
    max_sbrked_mem = sbrked_mem;
 80070b4:	00820174 	movhi	r2,2053
 80070b8:	10a7ce04 	addi	r2,r2,-24776
 80070bc:	10800017 	ldw	r2,0(r2)
 80070c0:	d0a76815 	stw	r2,-25184(gp)
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
 80070c4:	00820174 	movhi	r2,2053
 80070c8:	10a7ce04 	addi	r2,r2,-24776
 80070cc:	10800017 	ldw	r2,0(r2)
 80070d0:	1007883a 	mov	r3,r2
 80070d4:	d0a76917 	ldw	r2,-25180(gp)
 80070d8:	10c0062e 	bgeu	r2,r3,80070f4 <malloc_extend_top+0x3a0>
    max_total_mem = sbrked_mem;
 80070dc:	00820174 	movhi	r2,2053
 80070e0:	10a7ce04 	addi	r2,r2,-24776
 80070e4:	10800017 	ldw	r2,0(r2)
 80070e8:	d0a76915 	stw	r2,-25180(gp)
 80070ec:	00000106 	br	80070f4 <malloc_extend_top+0x3a0>
  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
    return;
 80070f0:	0001883a 	nop
#endif

  /* We always land on a page boundary */
  assert(((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0
	 || correction_failed);
}
 80070f4:	e037883a 	mov	sp,fp
 80070f8:	dfc00117 	ldw	ra,4(sp)
 80070fc:	df000017 	ldw	fp,0(sp)
 8007100:	dec00204 	addi	sp,sp,8
 8007104:	f800283a 	ret

08007108 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
 8007108:	deffef04 	addi	sp,sp,-68
 800710c:	dfc01015 	stw	ra,64(sp)
 8007110:	df000f15 	stw	fp,60(sp)
 8007114:	df000f04 	addi	fp,sp,60
 8007118:	e13ffe15 	stw	r4,-8(fp)
 800711c:	e17fff15 	stw	r5,-4(fp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
 8007120:	e0bfff17 	ldw	r2,-4(fp)
 8007124:	108002c4 	addi	r2,r2,11
 8007128:	108005f0 	cmpltui	r2,r2,23
 800712c:	1000051e 	bne	r2,zero,8007144 <_malloc_r+0x3c>
 8007130:	e0bfff17 	ldw	r2,-4(fp)
 8007134:	10c002c4 	addi	r3,r2,11
 8007138:	00bffe04 	movi	r2,-8
 800713c:	1884703a 	and	r2,r3,r2
 8007140:	00000106 	br	8007148 <_malloc_r+0x40>
 8007144:	00800404 	movi	r2,16
 8007148:	e0bffa15 	stw	r2,-24(fp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
 800714c:	e0bffa17 	ldw	r2,-24(fp)
 8007150:	10000316 	blt	r2,zero,8007160 <_malloc_r+0x58>
 8007154:	e0fffa17 	ldw	r3,-24(fp)
 8007158:	e0bfff17 	ldw	r2,-4(fp)
 800715c:	1880052e 	bgeu	r3,r2,8007174 <_malloc_r+0x6c>
  {
    RERRNO = ENOMEM;
 8007160:	e0bffe17 	ldw	r2,-8(fp)
 8007164:	00c00304 	movi	r3,12
 8007168:	10c00015 	stw	r3,0(r2)
    return 0;
 800716c:	0005883a 	mov	r2,zero
 8007170:	0002bf06 	br	8007c70 <_malloc_r+0xb68>
  }

  MALLOC_LOCK;
 8007174:	e13ffe17 	ldw	r4,-8(fp)
 8007178:	800aa6c0 	call	800aa6c <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
 800717c:	e0bffa17 	ldw	r2,-24(fp)
 8007180:	10807e28 	cmpgeui	r2,r2,504
 8007184:	10003f1e 	bne	r2,zero,8007284 <_malloc_r+0x17c>
  {
    idx = smallbin_index(nb); 
 8007188:	e0bffa17 	ldw	r2,-24(fp)
 800718c:	1004d0fa 	srli	r2,r2,3
 8007190:	e0bff215 	stw	r2,-56(fp)

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
 8007194:	e0bff217 	ldw	r2,-56(fp)
 8007198:	10800044 	addi	r2,r2,1
 800719c:	1085883a 	add	r2,r2,r2
 80071a0:	1085883a 	add	r2,r2,r2
 80071a4:	1087883a 	add	r3,r2,r2
 80071a8:	00820134 	movhi	r2,2052
 80071ac:	109a9f04 	addi	r2,r2,27260
 80071b0:	1885883a 	add	r2,r3,r2
 80071b4:	10bffe04 	addi	r2,r2,-8
 80071b8:	e0bff915 	stw	r2,-28(fp)
    victim = last(q);
 80071bc:	e0bff917 	ldw	r2,-28(fp)
 80071c0:	10800317 	ldw	r2,12(r2)
 80071c4:	e0bff115 	stw	r2,-60(fp)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
 80071c8:	e0fff117 	ldw	r3,-60(fp)
 80071cc:	e0bff917 	ldw	r2,-28(fp)
 80071d0:	1880061e 	bne	r3,r2,80071ec <_malloc_r+0xe4>
    {
      q = next_bin(q);
 80071d4:	e0bff917 	ldw	r2,-28(fp)
 80071d8:	10800204 	addi	r2,r2,8
 80071dc:	e0bff915 	stw	r2,-28(fp)
      victim = last(q);
 80071e0:	e0bff917 	ldw	r2,-28(fp)
 80071e4:	10800317 	ldw	r2,12(r2)
 80071e8:	e0bff115 	stw	r2,-60(fp)
    }
#endif
    if (victim != q)
 80071ec:	e0fff117 	ldw	r3,-60(fp)
 80071f0:	e0bff917 	ldw	r2,-28(fp)
 80071f4:	18801f26 	beq	r3,r2,8007274 <_malloc_r+0x16c>
    {
      victim_size = chunksize(victim);
 80071f8:	e0bff117 	ldw	r2,-60(fp)
 80071fc:	10c00117 	ldw	r3,4(r2)
 8007200:	00bfff04 	movi	r2,-4
 8007204:	1884703a 	and	r2,r3,r2
 8007208:	e0bffb15 	stw	r2,-20(fp)
      unlink(victim, bck, fwd);
 800720c:	e0bff117 	ldw	r2,-60(fp)
 8007210:	10800317 	ldw	r2,12(r2)
 8007214:	e0bff815 	stw	r2,-32(fp)
 8007218:	e0bff117 	ldw	r2,-60(fp)
 800721c:	10800217 	ldw	r2,8(r2)
 8007220:	e0bff715 	stw	r2,-36(fp)
 8007224:	e0bff717 	ldw	r2,-36(fp)
 8007228:	e0fff817 	ldw	r3,-32(fp)
 800722c:	10c00315 	stw	r3,12(r2)
 8007230:	e0bff817 	ldw	r2,-32(fp)
 8007234:	e0fff717 	ldw	r3,-36(fp)
 8007238:	10c00215 	stw	r3,8(r2)
      set_inuse_bit_at_offset(victim, victim_size);
 800723c:	e0fff117 	ldw	r3,-60(fp)
 8007240:	e0bffb17 	ldw	r2,-20(fp)
 8007244:	1885883a 	add	r2,r3,r2
 8007248:	e13ff117 	ldw	r4,-60(fp)
 800724c:	e0fffb17 	ldw	r3,-20(fp)
 8007250:	20c7883a 	add	r3,r4,r3
 8007254:	18c00117 	ldw	r3,4(r3)
 8007258:	18c00054 	ori	r3,r3,1
 800725c:	10c00115 	stw	r3,4(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 8007260:	e13ffe17 	ldw	r4,-8(fp)
 8007264:	800aa900 	call	800aa90 <__malloc_unlock>
      return chunk2mem(victim);
 8007268:	e0bff117 	ldw	r2,-60(fp)
 800726c:	10800204 	addi	r2,r2,8
 8007270:	00027f06 	br	8007c70 <_malloc_r+0xb68>
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
 8007274:	e0bff217 	ldw	r2,-56(fp)
 8007278:	10800084 	addi	r2,r2,2
 800727c:	e0bff215 	stw	r2,-56(fp)
 8007280:	00007306 	br	8007450 <_malloc_r+0x348>

  }
  else
  {
    idx = bin_index(nb);
 8007284:	e0bffa17 	ldw	r2,-24(fp)
 8007288:	1004d27a 	srli	r2,r2,9
 800728c:	1000031e 	bne	r2,zero,800729c <_malloc_r+0x194>
 8007290:	e0bffa17 	ldw	r2,-24(fp)
 8007294:	1004d0fa 	srli	r2,r2,3
 8007298:	00002906 	br	8007340 <_malloc_r+0x238>
 800729c:	e0bffa17 	ldw	r2,-24(fp)
 80072a0:	1004d27a 	srli	r2,r2,9
 80072a4:	10800168 	cmpgeui	r2,r2,5
 80072a8:	1000041e 	bne	r2,zero,80072bc <_malloc_r+0x1b4>
 80072ac:	e0bffa17 	ldw	r2,-24(fp)
 80072b0:	1004d1ba 	srli	r2,r2,6
 80072b4:	10800e04 	addi	r2,r2,56
 80072b8:	00002106 	br	8007340 <_malloc_r+0x238>
 80072bc:	e0bffa17 	ldw	r2,-24(fp)
 80072c0:	1004d27a 	srli	r2,r2,9
 80072c4:	10800568 	cmpgeui	r2,r2,21
 80072c8:	1000041e 	bne	r2,zero,80072dc <_malloc_r+0x1d4>
 80072cc:	e0bffa17 	ldw	r2,-24(fp)
 80072d0:	1004d27a 	srli	r2,r2,9
 80072d4:	108016c4 	addi	r2,r2,91
 80072d8:	00001906 	br	8007340 <_malloc_r+0x238>
 80072dc:	e0bffa17 	ldw	r2,-24(fp)
 80072e0:	1004d27a 	srli	r2,r2,9
 80072e4:	10801568 	cmpgeui	r2,r2,85
 80072e8:	1000041e 	bne	r2,zero,80072fc <_malloc_r+0x1f4>
 80072ec:	e0bffa17 	ldw	r2,-24(fp)
 80072f0:	1004d33a 	srli	r2,r2,12
 80072f4:	10801b84 	addi	r2,r2,110
 80072f8:	00001106 	br	8007340 <_malloc_r+0x238>
 80072fc:	e0bffa17 	ldw	r2,-24(fp)
 8007300:	1004d27a 	srli	r2,r2,9
 8007304:	10805568 	cmpgeui	r2,r2,341
 8007308:	1000041e 	bne	r2,zero,800731c <_malloc_r+0x214>
 800730c:	e0bffa17 	ldw	r2,-24(fp)
 8007310:	1004d3fa 	srli	r2,r2,15
 8007314:	10801dc4 	addi	r2,r2,119
 8007318:	00000906 	br	8007340 <_malloc_r+0x238>
 800731c:	e0bffa17 	ldw	r2,-24(fp)
 8007320:	1004d27a 	srli	r2,r2,9
 8007324:	10815568 	cmpgeui	r2,r2,1365
 8007328:	1000041e 	bne	r2,zero,800733c <_malloc_r+0x234>
 800732c:	e0bffa17 	ldw	r2,-24(fp)
 8007330:	1004d4ba 	srli	r2,r2,18
 8007334:	10801f04 	addi	r2,r2,124
 8007338:	00000106 	br	8007340 <_malloc_r+0x238>
 800733c:	00801f84 	movi	r2,126
 8007340:	e0bff215 	stw	r2,-56(fp)
    bin = bin_at(idx);
 8007344:	e0bff217 	ldw	r2,-56(fp)
 8007348:	10800044 	addi	r2,r2,1
 800734c:	1085883a 	add	r2,r2,r2
 8007350:	1085883a 	add	r2,r2,r2
 8007354:	1087883a 	add	r3,r2,r2
 8007358:	00820134 	movhi	r2,2052
 800735c:	109a9f04 	addi	r2,r2,27260
 8007360:	1885883a 	add	r2,r3,r2
 8007364:	10bffe04 	addi	r2,r2,-8
 8007368:	e0bff315 	stw	r2,-52(fp)

    for (victim = last(bin); victim != bin; victim = victim->bk)
 800736c:	e0bff317 	ldw	r2,-52(fp)
 8007370:	10800317 	ldw	r2,12(r2)
 8007374:	e0bff115 	stw	r2,-60(fp)
 8007378:	00002f06 	br	8007438 <_malloc_r+0x330>
    {
      victim_size = chunksize(victim);
 800737c:	e0bff117 	ldw	r2,-60(fp)
 8007380:	10c00117 	ldw	r3,4(r2)
 8007384:	00bfff04 	movi	r2,-4
 8007388:	1884703a 	and	r2,r3,r2
 800738c:	e0bffb15 	stw	r2,-20(fp)
      remainder_size = long_sub_size_t(victim_size, nb);
 8007390:	e0fffb17 	ldw	r3,-20(fp)
 8007394:	e0bffa17 	ldw	r2,-24(fp)
 8007398:	1885c83a 	sub	r2,r3,r2
 800739c:	e0bff415 	stw	r2,-48(fp)
      
      if (remainder_size >= (long)MINSIZE) /* too big */
 80073a0:	e0bff417 	ldw	r2,-48(fp)
 80073a4:	10800410 	cmplti	r2,r2,16
 80073a8:	1000041e 	bne	r2,zero,80073bc <_malloc_r+0x2b4>
      {
        --idx; /* adjust to rescan below after checking last remainder */
 80073ac:	e0bff217 	ldw	r2,-56(fp)
 80073b0:	10bfffc4 	addi	r2,r2,-1
 80073b4:	e0bff215 	stw	r2,-56(fp)
        break;   
 80073b8:	00002206 	br	8007444 <_malloc_r+0x33c>
      }

      else if (remainder_size >= 0) /* exact fit */
 80073bc:	e0bff417 	ldw	r2,-48(fp)
 80073c0:	10001a16 	blt	r2,zero,800742c <_malloc_r+0x324>
      {
        unlink(victim, bck, fwd);
 80073c4:	e0bff117 	ldw	r2,-60(fp)
 80073c8:	10800317 	ldw	r2,12(r2)
 80073cc:	e0bff815 	stw	r2,-32(fp)
 80073d0:	e0bff117 	ldw	r2,-60(fp)
 80073d4:	10800217 	ldw	r2,8(r2)
 80073d8:	e0bff715 	stw	r2,-36(fp)
 80073dc:	e0bff717 	ldw	r2,-36(fp)
 80073e0:	e0fff817 	ldw	r3,-32(fp)
 80073e4:	10c00315 	stw	r3,12(r2)
 80073e8:	e0bff817 	ldw	r2,-32(fp)
 80073ec:	e0fff717 	ldw	r3,-36(fp)
 80073f0:	10c00215 	stw	r3,8(r2)
        set_inuse_bit_at_offset(victim, victim_size);
 80073f4:	e0fff117 	ldw	r3,-60(fp)
 80073f8:	e0bffb17 	ldw	r2,-20(fp)
 80073fc:	1885883a 	add	r2,r3,r2
 8007400:	e13ff117 	ldw	r4,-60(fp)
 8007404:	e0fffb17 	ldw	r3,-20(fp)
 8007408:	20c7883a 	add	r3,r4,r3
 800740c:	18c00117 	ldw	r3,4(r3)
 8007410:	18c00054 	ori	r3,r3,1
 8007414:	10c00115 	stw	r3,4(r2)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
 8007418:	e13ffe17 	ldw	r4,-8(fp)
 800741c:	800aa900 	call	800aa90 <__malloc_unlock>
        return chunk2mem(victim);
 8007420:	e0bff117 	ldw	r2,-60(fp)
 8007424:	10800204 	addi	r2,r2,8
 8007428:	00021106 	br	8007c70 <_malloc_r+0xb68>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
 800742c:	e0bff117 	ldw	r2,-60(fp)
 8007430:	10800317 	ldw	r2,12(r2)
 8007434:	e0bff115 	stw	r2,-60(fp)
 8007438:	e0fff117 	ldw	r3,-60(fp)
 800743c:	e0bff317 	ldw	r2,-52(fp)
 8007440:	18bfce1e 	bne	r3,r2,800737c <_malloc_r+0x274>
	MALLOC_UNLOCK;
        return chunk2mem(victim);
      }
    }

    ++idx; 
 8007444:	e0bff217 	ldw	r2,-56(fp)
 8007448:	10800044 	addi	r2,r2,1
 800744c:	e0bff215 	stw	r2,-56(fp)

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
 8007450:	00820134 	movhi	r2,2052
 8007454:	109aa104 	addi	r2,r2,27268
 8007458:	10800217 	ldw	r2,8(r2)
 800745c:	e0bff115 	stw	r2,-60(fp)
 8007460:	00820134 	movhi	r2,2052
 8007464:	109aa104 	addi	r2,r2,27268
 8007468:	e0fff117 	ldw	r3,-60(fp)
 800746c:	1880e626 	beq	r3,r2,8007808 <_malloc_r+0x700>
  {
    victim_size = chunksize(victim);
 8007470:	e0bff117 	ldw	r2,-60(fp)
 8007474:	10c00117 	ldw	r3,4(r2)
 8007478:	00bfff04 	movi	r2,-4
 800747c:	1884703a 	and	r2,r3,r2
 8007480:	e0bffb15 	stw	r2,-20(fp)
    remainder_size = long_sub_size_t(victim_size, nb);
 8007484:	e0fffb17 	ldw	r3,-20(fp)
 8007488:	e0bffa17 	ldw	r2,-24(fp)
 800748c:	1885c83a 	sub	r2,r3,r2
 8007490:	e0bff415 	stw	r2,-48(fp)

    if (remainder_size >= (long)MINSIZE) /* re-split */
 8007494:	e0bff417 	ldw	r2,-48(fp)
 8007498:	10800410 	cmplti	r2,r2,16
 800749c:	1000271e 	bne	r2,zero,800753c <_malloc_r+0x434>
    {
      remainder = chunk_at_offset(victim, nb);
 80074a0:	e0fff117 	ldw	r3,-60(fp)
 80074a4:	e0bffa17 	ldw	r2,-24(fp)
 80074a8:	1885883a 	add	r2,r3,r2
 80074ac:	e0bffc15 	stw	r2,-16(fp)
      set_head(victim, nb | PREV_INUSE);
 80074b0:	e0bffa17 	ldw	r2,-24(fp)
 80074b4:	10c00054 	ori	r3,r2,1
 80074b8:	e0bff117 	ldw	r2,-60(fp)
 80074bc:	10c00115 	stw	r3,4(r2)
      link_last_remainder(remainder);
 80074c0:	00c20134 	movhi	r3,2052
 80074c4:	18daa104 	addi	r3,r3,27268
 80074c8:	00820134 	movhi	r2,2052
 80074cc:	109aa104 	addi	r2,r2,27268
 80074d0:	e13ffc17 	ldw	r4,-16(fp)
 80074d4:	11000315 	stw	r4,12(r2)
 80074d8:	10800317 	ldw	r2,12(r2)
 80074dc:	18800215 	stw	r2,8(r3)
 80074e0:	00820134 	movhi	r2,2052
 80074e4:	109aa104 	addi	r2,r2,27268
 80074e8:	e0fffc17 	ldw	r3,-16(fp)
 80074ec:	18800315 	stw	r2,12(r3)
 80074f0:	e0bffc17 	ldw	r2,-16(fp)
 80074f4:	10c00317 	ldw	r3,12(r2)
 80074f8:	e0bffc17 	ldw	r2,-16(fp)
 80074fc:	10c00215 	stw	r3,8(r2)
      set_head(remainder, remainder_size | PREV_INUSE);
 8007500:	e0bff417 	ldw	r2,-48(fp)
 8007504:	10800054 	ori	r2,r2,1
 8007508:	1007883a 	mov	r3,r2
 800750c:	e0bffc17 	ldw	r2,-16(fp)
 8007510:	10c00115 	stw	r3,4(r2)
      set_foot(remainder, remainder_size);
 8007514:	e0bff417 	ldw	r2,-48(fp)
 8007518:	e0fffc17 	ldw	r3,-16(fp)
 800751c:	1885883a 	add	r2,r3,r2
 8007520:	e0fff417 	ldw	r3,-48(fp)
 8007524:	10c00015 	stw	r3,0(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 8007528:	e13ffe17 	ldw	r4,-8(fp)
 800752c:	800aa900 	call	800aa90 <__malloc_unlock>
      return chunk2mem(victim);
 8007530:	e0bff117 	ldw	r2,-60(fp)
 8007534:	10800204 	addi	r2,r2,8
 8007538:	0001cd06 	br	8007c70 <_malloc_r+0xb68>
    }

    clear_last_remainder;
 800753c:	00c20134 	movhi	r3,2052
 8007540:	18daa104 	addi	r3,r3,27268
 8007544:	00820134 	movhi	r2,2052
 8007548:	109aa104 	addi	r2,r2,27268
 800754c:	01020134 	movhi	r4,2052
 8007550:	211aa104 	addi	r4,r4,27268
 8007554:	11000315 	stw	r4,12(r2)
 8007558:	10800317 	ldw	r2,12(r2)
 800755c:	18800215 	stw	r2,8(r3)

    if (remainder_size >= 0)  /* exhaust */
 8007560:	e0bff417 	ldw	r2,-48(fp)
 8007564:	10000e16 	blt	r2,zero,80075a0 <_malloc_r+0x498>
    {
      set_inuse_bit_at_offset(victim, victim_size);
 8007568:	e0fff117 	ldw	r3,-60(fp)
 800756c:	e0bffb17 	ldw	r2,-20(fp)
 8007570:	1885883a 	add	r2,r3,r2
 8007574:	e13ff117 	ldw	r4,-60(fp)
 8007578:	e0fffb17 	ldw	r3,-20(fp)
 800757c:	20c7883a 	add	r3,r4,r3
 8007580:	18c00117 	ldw	r3,4(r3)
 8007584:	18c00054 	ori	r3,r3,1
 8007588:	10c00115 	stw	r3,4(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 800758c:	e13ffe17 	ldw	r4,-8(fp)
 8007590:	800aa900 	call	800aa90 <__malloc_unlock>
      return chunk2mem(victim);
 8007594:	e0bff117 	ldw	r2,-60(fp)
 8007598:	10800204 	addi	r2,r2,8
 800759c:	0001b406 	br	8007c70 <_malloc_r+0xb68>
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
 80075a0:	e0bffb17 	ldw	r2,-20(fp)
 80075a4:	10808028 	cmpgeui	r2,r2,512
 80075a8:	10002c1e 	bne	r2,zero,800765c <_malloc_r+0x554>
 80075ac:	e0bffb17 	ldw	r2,-20(fp)
 80075b0:	1004d0fa 	srli	r2,r2,3
 80075b4:	e0bffd15 	stw	r2,-12(fp)
 80075b8:	00c20134 	movhi	r3,2052
 80075bc:	18da9f04 	addi	r3,r3,27260
 80075c0:	00820134 	movhi	r2,2052
 80075c4:	109a9f04 	addi	r2,r2,27260
 80075c8:	11000117 	ldw	r4,4(r2)
 80075cc:	e0bffd17 	ldw	r2,-12(fp)
 80075d0:	1000010e 	bge	r2,zero,80075d8 <_malloc_r+0x4d0>
 80075d4:	108000c4 	addi	r2,r2,3
 80075d8:	1005d0ba 	srai	r2,r2,2
 80075dc:	100b883a 	mov	r5,r2
 80075e0:	00800044 	movi	r2,1
 80075e4:	1144983a 	sll	r2,r2,r5
 80075e8:	2084b03a 	or	r2,r4,r2
 80075ec:	18800115 	stw	r2,4(r3)
 80075f0:	e0bffd17 	ldw	r2,-12(fp)
 80075f4:	10800044 	addi	r2,r2,1
 80075f8:	1085883a 	add	r2,r2,r2
 80075fc:	1085883a 	add	r2,r2,r2
 8007600:	1087883a 	add	r3,r2,r2
 8007604:	00820134 	movhi	r2,2052
 8007608:	109a9f04 	addi	r2,r2,27260
 800760c:	1885883a 	add	r2,r3,r2
 8007610:	10bffe04 	addi	r2,r2,-8
 8007614:	e0bff815 	stw	r2,-32(fp)
 8007618:	e0bff817 	ldw	r2,-32(fp)
 800761c:	10800217 	ldw	r2,8(r2)
 8007620:	e0bff715 	stw	r2,-36(fp)
 8007624:	e0bff117 	ldw	r2,-60(fp)
 8007628:	e0fff817 	ldw	r3,-32(fp)
 800762c:	10c00315 	stw	r3,12(r2)
 8007630:	e0bff117 	ldw	r2,-60(fp)
 8007634:	e0fff717 	ldw	r3,-36(fp)
 8007638:	10c00215 	stw	r3,8(r2)
 800763c:	e0bff817 	ldw	r2,-32(fp)
 8007640:	e0fff117 	ldw	r3,-60(fp)
 8007644:	10c00215 	stw	r3,8(r2)
 8007648:	e0bff817 	ldw	r2,-32(fp)
 800764c:	10c00217 	ldw	r3,8(r2)
 8007650:	e0bff717 	ldw	r2,-36(fp)
 8007654:	10c00315 	stw	r3,12(r2)
 8007658:	00006b06 	br	8007808 <_malloc_r+0x700>
 800765c:	e0bffb17 	ldw	r2,-20(fp)
 8007660:	1004d27a 	srli	r2,r2,9
 8007664:	1000031e 	bne	r2,zero,8007674 <_malloc_r+0x56c>
 8007668:	e0bffb17 	ldw	r2,-20(fp)
 800766c:	1004d0fa 	srli	r2,r2,3
 8007670:	00002906 	br	8007718 <_malloc_r+0x610>
 8007674:	e0bffb17 	ldw	r2,-20(fp)
 8007678:	1004d27a 	srli	r2,r2,9
 800767c:	10800168 	cmpgeui	r2,r2,5
 8007680:	1000041e 	bne	r2,zero,8007694 <_malloc_r+0x58c>
 8007684:	e0bffb17 	ldw	r2,-20(fp)
 8007688:	1004d1ba 	srli	r2,r2,6
 800768c:	10800e04 	addi	r2,r2,56
 8007690:	00002106 	br	8007718 <_malloc_r+0x610>
 8007694:	e0bffb17 	ldw	r2,-20(fp)
 8007698:	1004d27a 	srli	r2,r2,9
 800769c:	10800568 	cmpgeui	r2,r2,21
 80076a0:	1000041e 	bne	r2,zero,80076b4 <_malloc_r+0x5ac>
 80076a4:	e0bffb17 	ldw	r2,-20(fp)
 80076a8:	1004d27a 	srli	r2,r2,9
 80076ac:	108016c4 	addi	r2,r2,91
 80076b0:	00001906 	br	8007718 <_malloc_r+0x610>
 80076b4:	e0bffb17 	ldw	r2,-20(fp)
 80076b8:	1004d27a 	srli	r2,r2,9
 80076bc:	10801568 	cmpgeui	r2,r2,85
 80076c0:	1000041e 	bne	r2,zero,80076d4 <_malloc_r+0x5cc>
 80076c4:	e0bffb17 	ldw	r2,-20(fp)
 80076c8:	1004d33a 	srli	r2,r2,12
 80076cc:	10801b84 	addi	r2,r2,110
 80076d0:	00001106 	br	8007718 <_malloc_r+0x610>
 80076d4:	e0bffb17 	ldw	r2,-20(fp)
 80076d8:	1004d27a 	srli	r2,r2,9
 80076dc:	10805568 	cmpgeui	r2,r2,341
 80076e0:	1000041e 	bne	r2,zero,80076f4 <_malloc_r+0x5ec>
 80076e4:	e0bffb17 	ldw	r2,-20(fp)
 80076e8:	1004d3fa 	srli	r2,r2,15
 80076ec:	10801dc4 	addi	r2,r2,119
 80076f0:	00000906 	br	8007718 <_malloc_r+0x610>
 80076f4:	e0bffb17 	ldw	r2,-20(fp)
 80076f8:	1004d27a 	srli	r2,r2,9
 80076fc:	10815568 	cmpgeui	r2,r2,1365
 8007700:	1000041e 	bne	r2,zero,8007714 <_malloc_r+0x60c>
 8007704:	e0bffb17 	ldw	r2,-20(fp)
 8007708:	1004d4ba 	srli	r2,r2,18
 800770c:	10801f04 	addi	r2,r2,124
 8007710:	00000106 	br	8007718 <_malloc_r+0x610>
 8007714:	00801f84 	movi	r2,126
 8007718:	e0bffd15 	stw	r2,-12(fp)
 800771c:	e0bffd17 	ldw	r2,-12(fp)
 8007720:	10800044 	addi	r2,r2,1
 8007724:	1085883a 	add	r2,r2,r2
 8007728:	1085883a 	add	r2,r2,r2
 800772c:	1087883a 	add	r3,r2,r2
 8007730:	00820134 	movhi	r2,2052
 8007734:	109a9f04 	addi	r2,r2,27260
 8007738:	1885883a 	add	r2,r3,r2
 800773c:	10bffe04 	addi	r2,r2,-8
 8007740:	e0bff815 	stw	r2,-32(fp)
 8007744:	e0bff817 	ldw	r2,-32(fp)
 8007748:	10800217 	ldw	r2,8(r2)
 800774c:	e0bff715 	stw	r2,-36(fp)
 8007750:	e0fff717 	ldw	r3,-36(fp)
 8007754:	e0bff817 	ldw	r2,-32(fp)
 8007758:	1880121e 	bne	r3,r2,80077a4 <_malloc_r+0x69c>
 800775c:	00c20134 	movhi	r3,2052
 8007760:	18da9f04 	addi	r3,r3,27260
 8007764:	00820134 	movhi	r2,2052
 8007768:	109a9f04 	addi	r2,r2,27260
 800776c:	11000117 	ldw	r4,4(r2)
 8007770:	e0bffd17 	ldw	r2,-12(fp)
 8007774:	1000010e 	bge	r2,zero,800777c <_malloc_r+0x674>
 8007778:	108000c4 	addi	r2,r2,3
 800777c:	1005d0ba 	srai	r2,r2,2
 8007780:	100b883a 	mov	r5,r2
 8007784:	00800044 	movi	r2,1
 8007788:	1144983a 	sll	r2,r2,r5
 800778c:	2084b03a 	or	r2,r4,r2
 8007790:	18800115 	stw	r2,4(r3)
 8007794:	00000f06 	br	80077d4 <_malloc_r+0x6cc>
 8007798:	e0bff717 	ldw	r2,-36(fp)
 800779c:	10800217 	ldw	r2,8(r2)
 80077a0:	e0bff715 	stw	r2,-36(fp)
 80077a4:	e0fff717 	ldw	r3,-36(fp)
 80077a8:	e0bff817 	ldw	r2,-32(fp)
 80077ac:	18800626 	beq	r3,r2,80077c8 <_malloc_r+0x6c0>
 80077b0:	e0bff717 	ldw	r2,-36(fp)
 80077b4:	10c00117 	ldw	r3,4(r2)
 80077b8:	00bfff04 	movi	r2,-4
 80077bc:	1884703a 	and	r2,r3,r2
 80077c0:	e0fffb17 	ldw	r3,-20(fp)
 80077c4:	18bff436 	bltu	r3,r2,8007798 <_malloc_r+0x690>
 80077c8:	e0bff717 	ldw	r2,-36(fp)
 80077cc:	10800317 	ldw	r2,12(r2)
 80077d0:	e0bff815 	stw	r2,-32(fp)
 80077d4:	e0bff117 	ldw	r2,-60(fp)
 80077d8:	e0fff817 	ldw	r3,-32(fp)
 80077dc:	10c00315 	stw	r3,12(r2)
 80077e0:	e0bff117 	ldw	r2,-60(fp)
 80077e4:	e0fff717 	ldw	r3,-36(fp)
 80077e8:	10c00215 	stw	r3,8(r2)
 80077ec:	e0bff817 	ldw	r2,-32(fp)
 80077f0:	e0fff117 	ldw	r3,-60(fp)
 80077f4:	10c00215 	stw	r3,8(r2)
 80077f8:	e0bff817 	ldw	r2,-32(fp)
 80077fc:	10c00217 	ldw	r3,8(r2)
 8007800:	e0bff717 	ldw	r2,-36(fp)
 8007804:	10c00315 	stw	r3,12(r2)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
 8007808:	e0bff217 	ldw	r2,-56(fp)
 800780c:	1000010e 	bge	r2,zero,8007814 <_malloc_r+0x70c>
 8007810:	108000c4 	addi	r2,r2,3
 8007814:	1005d0ba 	srai	r2,r2,2
 8007818:	1007883a 	mov	r3,r2
 800781c:	00800044 	movi	r2,1
 8007820:	10c4983a 	sll	r2,r2,r3
 8007824:	e0bff515 	stw	r2,-44(fp)
 8007828:	00820134 	movhi	r2,2052
 800782c:	109a9f04 	addi	r2,r2,27260
 8007830:	10c00117 	ldw	r3,4(r2)
 8007834:	e0bff517 	ldw	r2,-44(fp)
 8007838:	1880c636 	bltu	r3,r2,8007b54 <_malloc_r+0xa4c>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
 800783c:	00820134 	movhi	r2,2052
 8007840:	109a9f04 	addi	r2,r2,27260
 8007844:	10c00117 	ldw	r3,4(r2)
 8007848:	e0bff517 	ldw	r2,-44(fp)
 800784c:	1884703a 	and	r2,r3,r2
 8007850:	1000151e 	bne	r2,zero,80078a8 <_malloc_r+0x7a0>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
 8007854:	e0fff217 	ldw	r3,-56(fp)
 8007858:	00bfff04 	movi	r2,-4
 800785c:	1884703a 	and	r2,r3,r2
 8007860:	10800104 	addi	r2,r2,4
 8007864:	e0bff215 	stw	r2,-56(fp)
      block <<= 1;
 8007868:	e0bff517 	ldw	r2,-44(fp)
 800786c:	1085883a 	add	r2,r2,r2
 8007870:	e0bff515 	stw	r2,-44(fp)
      while ((block & binblocks) == 0)
 8007874:	00000606 	br	8007890 <_malloc_r+0x788>
      {
        idx += BINBLOCKWIDTH;
 8007878:	e0bff217 	ldw	r2,-56(fp)
 800787c:	10800104 	addi	r2,r2,4
 8007880:	e0bff215 	stw	r2,-56(fp)
        block <<= 1;
 8007884:	e0bff517 	ldw	r2,-44(fp)
 8007888:	1085883a 	add	r2,r2,r2
 800788c:	e0bff515 	stw	r2,-44(fp)
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
 8007890:	00820134 	movhi	r2,2052
 8007894:	109a9f04 	addi	r2,r2,27260
 8007898:	10c00117 	ldw	r3,4(r2)
 800789c:	e0bff517 	ldw	r2,-44(fp)
 80078a0:	1884703a 	and	r2,r3,r2
 80078a4:	103ff426 	beq	r2,zero,8007878 <_malloc_r+0x770>
    }
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
 80078a8:	e0bff217 	ldw	r2,-56(fp)
 80078ac:	e0bff615 	stw	r2,-40(fp)
      q = bin = bin_at(idx);
 80078b0:	e0bff217 	ldw	r2,-56(fp)
 80078b4:	10800044 	addi	r2,r2,1
 80078b8:	1085883a 	add	r2,r2,r2
 80078bc:	1085883a 	add	r2,r2,r2
 80078c0:	1087883a 	add	r3,r2,r2
 80078c4:	00820134 	movhi	r2,2052
 80078c8:	109a9f04 	addi	r2,r2,27260
 80078cc:	1885883a 	add	r2,r3,r2
 80078d0:	10bffe04 	addi	r2,r2,-8
 80078d4:	e0bff315 	stw	r2,-52(fp)
 80078d8:	e0bff317 	ldw	r2,-52(fp)
 80078dc:	e0bff915 	stw	r2,-28(fp)
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
 80078e0:	e0bff317 	ldw	r2,-52(fp)
 80078e4:	10800317 	ldw	r2,12(r2)
 80078e8:	e0bff115 	stw	r2,-60(fp)
 80078ec:	00005e06 	br	8007a68 <_malloc_r+0x960>
        {
          victim_size = chunksize(victim);
 80078f0:	e0bff117 	ldw	r2,-60(fp)
 80078f4:	10c00117 	ldw	r3,4(r2)
 80078f8:	00bfff04 	movi	r2,-4
 80078fc:	1884703a 	and	r2,r3,r2
 8007900:	e0bffb15 	stw	r2,-20(fp)
          remainder_size = long_sub_size_t(victim_size, nb);
 8007904:	e0fffb17 	ldw	r3,-20(fp)
 8007908:	e0bffa17 	ldw	r2,-24(fp)
 800790c:	1885c83a 	sub	r2,r3,r2
 8007910:	e0bff415 	stw	r2,-48(fp)

          if (remainder_size >= (long)MINSIZE) /* split */
 8007914:	e0bff417 	ldw	r2,-48(fp)
 8007918:	10800410 	cmplti	r2,r2,16
 800791c:	1000331e 	bne	r2,zero,80079ec <_malloc_r+0x8e4>
          {
            remainder = chunk_at_offset(victim, nb);
 8007920:	e0fff117 	ldw	r3,-60(fp)
 8007924:	e0bffa17 	ldw	r2,-24(fp)
 8007928:	1885883a 	add	r2,r3,r2
 800792c:	e0bffc15 	stw	r2,-16(fp)
            set_head(victim, nb | PREV_INUSE);
 8007930:	e0bffa17 	ldw	r2,-24(fp)
 8007934:	10c00054 	ori	r3,r2,1
 8007938:	e0bff117 	ldw	r2,-60(fp)
 800793c:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 8007940:	e0bff117 	ldw	r2,-60(fp)
 8007944:	10800317 	ldw	r2,12(r2)
 8007948:	e0bff815 	stw	r2,-32(fp)
 800794c:	e0bff117 	ldw	r2,-60(fp)
 8007950:	10800217 	ldw	r2,8(r2)
 8007954:	e0bff715 	stw	r2,-36(fp)
 8007958:	e0bff717 	ldw	r2,-36(fp)
 800795c:	e0fff817 	ldw	r3,-32(fp)
 8007960:	10c00315 	stw	r3,12(r2)
 8007964:	e0bff817 	ldw	r2,-32(fp)
 8007968:	e0fff717 	ldw	r3,-36(fp)
 800796c:	10c00215 	stw	r3,8(r2)
            link_last_remainder(remainder);
 8007970:	00c20134 	movhi	r3,2052
 8007974:	18daa104 	addi	r3,r3,27268
 8007978:	00820134 	movhi	r2,2052
 800797c:	109aa104 	addi	r2,r2,27268
 8007980:	e13ffc17 	ldw	r4,-16(fp)
 8007984:	11000315 	stw	r4,12(r2)
 8007988:	10800317 	ldw	r2,12(r2)
 800798c:	18800215 	stw	r2,8(r3)
 8007990:	00820134 	movhi	r2,2052
 8007994:	109aa104 	addi	r2,r2,27268
 8007998:	e0fffc17 	ldw	r3,-16(fp)
 800799c:	18800315 	stw	r2,12(r3)
 80079a0:	e0bffc17 	ldw	r2,-16(fp)
 80079a4:	10c00317 	ldw	r3,12(r2)
 80079a8:	e0bffc17 	ldw	r2,-16(fp)
 80079ac:	10c00215 	stw	r3,8(r2)
            set_head(remainder, remainder_size | PREV_INUSE);
 80079b0:	e0bff417 	ldw	r2,-48(fp)
 80079b4:	10800054 	ori	r2,r2,1
 80079b8:	1007883a 	mov	r3,r2
 80079bc:	e0bffc17 	ldw	r2,-16(fp)
 80079c0:	10c00115 	stw	r3,4(r2)
            set_foot(remainder, remainder_size);
 80079c4:	e0bff417 	ldw	r2,-48(fp)
 80079c8:	e0fffc17 	ldw	r3,-16(fp)
 80079cc:	1885883a 	add	r2,r3,r2
 80079d0:	e0fff417 	ldw	r3,-48(fp)
 80079d4:	10c00015 	stw	r3,0(r2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
 80079d8:	e13ffe17 	ldw	r4,-8(fp)
 80079dc:	800aa900 	call	800aa90 <__malloc_unlock>
            return chunk2mem(victim);
 80079e0:	e0bff117 	ldw	r2,-60(fp)
 80079e4:	10800204 	addi	r2,r2,8
 80079e8:	0000a106 	br	8007c70 <_malloc_r+0xb68>
          }

          else if (remainder_size >= 0)  /* take */
 80079ec:	e0bff417 	ldw	r2,-48(fp)
 80079f0:	10001a16 	blt	r2,zero,8007a5c <_malloc_r+0x954>
          {
            set_inuse_bit_at_offset(victim, victim_size);
 80079f4:	e0fff117 	ldw	r3,-60(fp)
 80079f8:	e0bffb17 	ldw	r2,-20(fp)
 80079fc:	1885883a 	add	r2,r3,r2
 8007a00:	e13ff117 	ldw	r4,-60(fp)
 8007a04:	e0fffb17 	ldw	r3,-20(fp)
 8007a08:	20c7883a 	add	r3,r4,r3
 8007a0c:	18c00117 	ldw	r3,4(r3)
 8007a10:	18c00054 	ori	r3,r3,1
 8007a14:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 8007a18:	e0bff117 	ldw	r2,-60(fp)
 8007a1c:	10800317 	ldw	r2,12(r2)
 8007a20:	e0bff815 	stw	r2,-32(fp)
 8007a24:	e0bff117 	ldw	r2,-60(fp)
 8007a28:	10800217 	ldw	r2,8(r2)
 8007a2c:	e0bff715 	stw	r2,-36(fp)
 8007a30:	e0bff717 	ldw	r2,-36(fp)
 8007a34:	e0fff817 	ldw	r3,-32(fp)
 8007a38:	10c00315 	stw	r3,12(r2)
 8007a3c:	e0bff817 	ldw	r2,-32(fp)
 8007a40:	e0fff717 	ldw	r3,-36(fp)
 8007a44:	10c00215 	stw	r3,8(r2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
 8007a48:	e13ffe17 	ldw	r4,-8(fp)
 8007a4c:	800aa900 	call	800aa90 <__malloc_unlock>
            return chunk2mem(victim);
 8007a50:	e0bff117 	ldw	r2,-60(fp)
 8007a54:	10800204 	addi	r2,r2,8
 8007a58:	00008506 	br	8007c70 <_malloc_r+0xb68>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
 8007a5c:	e0bff117 	ldw	r2,-60(fp)
 8007a60:	10800317 	ldw	r2,12(r2)
 8007a64:	e0bff115 	stw	r2,-60(fp)
 8007a68:	e0fff117 	ldw	r3,-60(fp)
 8007a6c:	e0bff317 	ldw	r2,-52(fp)
 8007a70:	18bf9f1e 	bne	r3,r2,80078f0 <_malloc_r+0x7e8>
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
 8007a74:	e0bff317 	ldw	r2,-52(fp)
 8007a78:	10800204 	addi	r2,r2,8
 8007a7c:	e0bff315 	stw	r2,-52(fp)
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
 8007a80:	e0bff217 	ldw	r2,-56(fp)
 8007a84:	10800044 	addi	r2,r2,1
 8007a88:	e0bff215 	stw	r2,-56(fp)
 8007a8c:	e0bff217 	ldw	r2,-56(fp)
 8007a90:	108000cc 	andi	r2,r2,3
 8007a94:	103f921e 	bne	r2,zero,80078e0 <_malloc_r+0x7d8>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
 8007a98:	e0bff617 	ldw	r2,-40(fp)
 8007a9c:	108000cc 	andi	r2,r2,3
 8007aa0:	10000a1e 	bne	r2,zero,8007acc <_malloc_r+0x9c4>
        {
          binblocks &= ~block;
 8007aa4:	00820134 	movhi	r2,2052
 8007aa8:	109a9f04 	addi	r2,r2,27260
 8007aac:	00c20134 	movhi	r3,2052
 8007ab0:	18da9f04 	addi	r3,r3,27260
 8007ab4:	19000117 	ldw	r4,4(r3)
 8007ab8:	e0fff517 	ldw	r3,-44(fp)
 8007abc:	00c6303a 	nor	r3,zero,r3
 8007ac0:	20c6703a 	and	r3,r4,r3
 8007ac4:	10c00115 	stw	r3,4(r2)
          break;
 8007ac8:	00000a06 	br	8007af4 <_malloc_r+0x9ec>
        }
        --startidx;
 8007acc:	e0bff617 	ldw	r2,-40(fp)
 8007ad0:	10bfffc4 	addi	r2,r2,-1
 8007ad4:	e0bff615 	stw	r2,-40(fp)
       q = prev_bin(q);
 8007ad8:	e0bff917 	ldw	r2,-28(fp)
 8007adc:	10bffe04 	addi	r2,r2,-8
 8007ae0:	e0bff915 	stw	r2,-28(fp)
      } while (first(q) == q);
 8007ae4:	e0bff917 	ldw	r2,-28(fp)
 8007ae8:	10c00217 	ldw	r3,8(r2)
 8007aec:	e0bff917 	ldw	r2,-28(fp)
 8007af0:	18bfe926 	beq	r3,r2,8007a98 <_malloc_r+0x990>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
 8007af4:	e0bff517 	ldw	r2,-44(fp)
 8007af8:	1085883a 	add	r2,r2,r2
 8007afc:	e0bff515 	stw	r2,-44(fp)
 8007b00:	00820134 	movhi	r2,2052
 8007b04:	109a9f04 	addi	r2,r2,27260
 8007b08:	10c00117 	ldw	r3,4(r2)
 8007b0c:	e0bff517 	ldw	r2,-44(fp)
 8007b10:	18801036 	bltu	r3,r2,8007b54 <_malloc_r+0xa4c>
 8007b14:	e0bff517 	ldw	r2,-44(fp)
 8007b18:	10000e26 	beq	r2,zero,8007b54 <_malloc_r+0xa4c>
      {
        while ((block & binblocks) == 0)
 8007b1c:	00000606 	br	8007b38 <_malloc_r+0xa30>
        {
          idx += BINBLOCKWIDTH;
 8007b20:	e0bff217 	ldw	r2,-56(fp)
 8007b24:	10800104 	addi	r2,r2,4
 8007b28:	e0bff215 	stw	r2,-56(fp)
          block <<= 1;
 8007b2c:	e0bff517 	ldw	r2,-44(fp)
 8007b30:	1085883a 	add	r2,r2,r2
 8007b34:	e0bff515 	stw	r2,-44(fp)

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
 8007b38:	00820134 	movhi	r2,2052
 8007b3c:	109a9f04 	addi	r2,r2,27260
 8007b40:	10c00117 	ldw	r3,4(r2)
 8007b44:	e0bff517 	ldw	r2,-44(fp)
 8007b48:	1884703a 	and	r2,r3,r2
 8007b4c:	103ff426 	beq	r2,zero,8007b20 <_malloc_r+0xa18>
          block <<= 1;
        }
      }
      else
        break;
    }
 8007b50:	003f5506 	br	80078a8 <_malloc_r+0x7a0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
 8007b54:	00820134 	movhi	r2,2052
 8007b58:	109a9f04 	addi	r2,r2,27260
 8007b5c:	10800217 	ldw	r2,8(r2)
 8007b60:	10c00117 	ldw	r3,4(r2)
 8007b64:	00bfff04 	movi	r2,-4
 8007b68:	1886703a 	and	r3,r3,r2
 8007b6c:	e0bffa17 	ldw	r2,-24(fp)
 8007b70:	1885c83a 	sub	r2,r3,r2
 8007b74:	e0bff415 	stw	r2,-48(fp)
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 8007b78:	00820134 	movhi	r2,2052
 8007b7c:	109a9f04 	addi	r2,r2,27260
 8007b80:	10800217 	ldw	r2,8(r2)
 8007b84:	10c00117 	ldw	r3,4(r2)
 8007b88:	00bfff04 	movi	r2,-4
 8007b8c:	1886703a 	and	r3,r3,r2
 8007b90:	e0bffa17 	ldw	r2,-24(fp)
 8007b94:	18800336 	bltu	r3,r2,8007ba4 <_malloc_r+0xa9c>
 8007b98:	e0bff417 	ldw	r2,-48(fp)
 8007b9c:	10800408 	cmpgei	r2,r2,16
 8007ba0:	10001b1e 	bne	r2,zero,8007c10 <_malloc_r+0xb08>
      return chunk2mem(victim);
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
 8007ba4:	e17ffa17 	ldw	r5,-24(fp)
 8007ba8:	e13ffe17 	ldw	r4,-8(fp)
 8007bac:	8006d540 	call	8006d54 <malloc_extend_top>
    remainder_size = long_sub_size_t(chunksize(top), nb);
 8007bb0:	00820134 	movhi	r2,2052
 8007bb4:	109a9f04 	addi	r2,r2,27260
 8007bb8:	10800217 	ldw	r2,8(r2)
 8007bbc:	10c00117 	ldw	r3,4(r2)
 8007bc0:	00bfff04 	movi	r2,-4
 8007bc4:	1886703a 	and	r3,r3,r2
 8007bc8:	e0bffa17 	ldw	r2,-24(fp)
 8007bcc:	1885c83a 	sub	r2,r3,r2
 8007bd0:	e0bff415 	stw	r2,-48(fp)
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 8007bd4:	00820134 	movhi	r2,2052
 8007bd8:	109a9f04 	addi	r2,r2,27260
 8007bdc:	10800217 	ldw	r2,8(r2)
 8007be0:	10c00117 	ldw	r3,4(r2)
 8007be4:	00bfff04 	movi	r2,-4
 8007be8:	1886703a 	and	r3,r3,r2
 8007bec:	e0bffa17 	ldw	r2,-24(fp)
 8007bf0:	18800336 	bltu	r3,r2,8007c00 <_malloc_r+0xaf8>
 8007bf4:	e0bff417 	ldw	r2,-48(fp)
 8007bf8:	10800408 	cmpgei	r2,r2,16
 8007bfc:	1000041e 	bne	r2,zero,8007c10 <_malloc_r+0xb08>
    {
      MALLOC_UNLOCK;
 8007c00:	e13ffe17 	ldw	r4,-8(fp)
 8007c04:	800aa900 	call	800aa90 <__malloc_unlock>
      return 0; /* propagate failure */
 8007c08:	0005883a 	mov	r2,zero
 8007c0c:	00001806 	br	8007c70 <_malloc_r+0xb68>
    }
  }

  victim = top;
 8007c10:	00820134 	movhi	r2,2052
 8007c14:	109a9f04 	addi	r2,r2,27260
 8007c18:	10800217 	ldw	r2,8(r2)
 8007c1c:	e0bff115 	stw	r2,-60(fp)
  set_head(victim, nb | PREV_INUSE);
 8007c20:	e0bffa17 	ldw	r2,-24(fp)
 8007c24:	10c00054 	ori	r3,r2,1
 8007c28:	e0bff117 	ldw	r2,-60(fp)
 8007c2c:	10c00115 	stw	r3,4(r2)
  top = chunk_at_offset(victim, nb);
 8007c30:	00820134 	movhi	r2,2052
 8007c34:	109a9f04 	addi	r2,r2,27260
 8007c38:	e13ff117 	ldw	r4,-60(fp)
 8007c3c:	e0fffa17 	ldw	r3,-24(fp)
 8007c40:	20c7883a 	add	r3,r4,r3
 8007c44:	10c00215 	stw	r3,8(r2)
  set_head(top, remainder_size | PREV_INUSE);
 8007c48:	00820134 	movhi	r2,2052
 8007c4c:	109a9f04 	addi	r2,r2,27260
 8007c50:	10800217 	ldw	r2,8(r2)
 8007c54:	e0fff417 	ldw	r3,-48(fp)
 8007c58:	18c00054 	ori	r3,r3,1
 8007c5c:	10c00115 	stw	r3,4(r2)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
 8007c60:	e13ffe17 	ldw	r4,-8(fp)
 8007c64:	800aa900 	call	800aa90 <__malloc_unlock>
  return chunk2mem(victim);
 8007c68:	e0bff117 	ldw	r2,-60(fp)
 8007c6c:	10800204 	addi	r2,r2,8

#endif /* MALLOC_PROVIDED */
}
 8007c70:	e037883a 	mov	sp,fp
 8007c74:	dfc00117 	ldw	ra,4(sp)
 8007c78:	df000017 	ldw	fp,0(sp)
 8007c7c:	dec00204 	addi	sp,sp,8
 8007c80:	f800283a 	ret

08007c84 <memchr>:
_PTR
_DEFUN (memchr, (src_void, c, length),
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
 8007c84:	defff704 	addi	sp,sp,-36
 8007c88:	df000815 	stw	fp,32(sp)
 8007c8c:	df000804 	addi	fp,sp,32
 8007c90:	e13ffd15 	stw	r4,-12(fp)
 8007c94:	e17ffe15 	stw	r5,-8(fp)
 8007c98:	e1bfff15 	stw	r6,-4(fp)
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
 8007c9c:	e0bffd17 	ldw	r2,-12(fp)
 8007ca0:	e0bff815 	stw	r2,-32(fp)
  unsigned char d = c;
 8007ca4:	e0bffe17 	ldw	r2,-8(fp)
 8007ca8:	e0bffc05 	stb	r2,-16(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 8007cac:	00001006 	br	8007cf0 <memchr+0x6c>
    {
      if (!length--)
 8007cb0:	e0bfff17 	ldw	r2,-4(fp)
 8007cb4:	10ffffc4 	addi	r3,r2,-1
 8007cb8:	e0ffff15 	stw	r3,-4(fp)
 8007cbc:	1000021e 	bne	r2,zero,8007cc8 <memchr+0x44>
        return NULL;
 8007cc0:	0005883a 	mov	r2,zero
 8007cc4:	00005a06 	br	8007e30 <memchr+0x1ac>
      if (*src == d)
 8007cc8:	e0bff817 	ldw	r2,-32(fp)
 8007ccc:	10800003 	ldbu	r2,0(r2)
 8007cd0:	10c03fcc 	andi	r3,r2,255
 8007cd4:	e0bffc03 	ldbu	r2,-16(fp)
 8007cd8:	1880021e 	bne	r3,r2,8007ce4 <memchr+0x60>
        return (void *) src;
 8007cdc:	e0bff817 	ldw	r2,-32(fp)
 8007ce0:	00005306 	br	8007e30 <memchr+0x1ac>
      src++;
 8007ce4:	e0bff817 	ldw	r2,-32(fp)
 8007ce8:	10800044 	addi	r2,r2,1
 8007cec:	e0bff815 	stw	r2,-32(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 8007cf0:	e0bff817 	ldw	r2,-32(fp)
 8007cf4:	108000cc 	andi	r2,r2,3
 8007cf8:	103fed1e 	bne	r2,zero,8007cb0 <memchr+0x2c>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
 8007cfc:	e0bfff17 	ldw	r2,-4(fp)
 8007d00:	10800130 	cmpltui	r2,r2,4
 8007d04:	1000451e 	bne	r2,zero,8007e1c <memchr+0x198>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
 8007d08:	e0bff817 	ldw	r2,-32(fp)
 8007d0c:	e0bff915 	stw	r2,-28(fp)
      mask = d << 8 | d;
 8007d10:	e0bffc03 	ldbu	r2,-16(fp)
 8007d14:	1006923a 	slli	r3,r2,8
 8007d18:	e0bffc03 	ldbu	r2,-16(fp)
 8007d1c:	1884b03a 	or	r2,r3,r2
 8007d20:	e0bffa15 	stw	r2,-24(fp)
      mask = mask << 16 | mask;
 8007d24:	e0bffa17 	ldw	r2,-24(fp)
 8007d28:	1004943a 	slli	r2,r2,16
 8007d2c:	e0fffa17 	ldw	r3,-24(fp)
 8007d30:	1884b03a 	or	r2,r3,r2
 8007d34:	e0bffa15 	stw	r2,-24(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 8007d38:	00800804 	movi	r2,32
 8007d3c:	e0bffb15 	stw	r2,-20(fp)
 8007d40:	00000906 	br	8007d68 <memchr+0xe4>
        mask = (mask << i) | mask;
 8007d44:	e0fffa17 	ldw	r3,-24(fp)
 8007d48:	e0bffb17 	ldw	r2,-20(fp)
 8007d4c:	1884983a 	sll	r2,r3,r2
 8007d50:	e0fffa17 	ldw	r3,-24(fp)
 8007d54:	1884b03a 	or	r2,r3,r2
 8007d58:	e0bffa15 	stw	r2,-24(fp)
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 8007d5c:	e0bffb17 	ldw	r2,-20(fp)
 8007d60:	1085883a 	add	r2,r2,r2
 8007d64:	e0bffb15 	stw	r2,-20(fp)
 8007d68:	e0bffb17 	ldw	r2,-20(fp)
 8007d6c:	10800830 	cmpltui	r2,r2,32
 8007d70:	103ff41e 	bne	r2,zero,8007d44 <memchr+0xc0>
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
 8007d74:	00001706 	br	8007dd4 <memchr+0x150>
        {
          if (DETECTCHAR (*asrc, mask))
 8007d78:	e0bff917 	ldw	r2,-28(fp)
 8007d7c:	10c00017 	ldw	r3,0(r2)
 8007d80:	e0bffa17 	ldw	r2,-24(fp)
 8007d84:	1886f03a 	xor	r3,r3,r2
 8007d88:	00bfbff4 	movhi	r2,65279
 8007d8c:	10bfbfc4 	addi	r2,r2,-257
 8007d90:	1887883a 	add	r3,r3,r2
 8007d94:	e0bff917 	ldw	r2,-28(fp)
 8007d98:	11000017 	ldw	r4,0(r2)
 8007d9c:	e0bffa17 	ldw	r2,-24(fp)
 8007da0:	2084f03a 	xor	r2,r4,r2
 8007da4:	0084303a 	nor	r2,zero,r2
 8007da8:	1886703a 	and	r3,r3,r2
 8007dac:	00a02074 	movhi	r2,32897
 8007db0:	10a02004 	addi	r2,r2,-32640
 8007db4:	1884703a 	and	r2,r3,r2
 8007db8:	10000a1e 	bne	r2,zero,8007de4 <memchr+0x160>
            break;
          length -= LBLOCKSIZE;
 8007dbc:	e0bfff17 	ldw	r2,-4(fp)
 8007dc0:	10bfff04 	addi	r2,r2,-4
 8007dc4:	e0bfff15 	stw	r2,-4(fp)
          asrc++;
 8007dc8:	e0bff917 	ldw	r2,-28(fp)
 8007dcc:	10800104 	addi	r2,r2,4
 8007dd0:	e0bff915 	stw	r2,-28(fp)
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
 8007dd4:	e0bfff17 	ldw	r2,-4(fp)
 8007dd8:	10800128 	cmpgeui	r2,r2,4
 8007ddc:	103fe61e 	bne	r2,zero,8007d78 <memchr+0xf4>
 8007de0:	00000106 	br	8007de8 <memchr+0x164>
        {
          if (DETECTCHAR (*asrc, mask))
            break;
 8007de4:	0001883a 	nop
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
 8007de8:	e0bff917 	ldw	r2,-28(fp)
 8007dec:	e0bff815 	stw	r2,-32(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 8007df0:	00000a06 	br	8007e1c <memchr+0x198>
    {
      if (*src == d)
 8007df4:	e0bff817 	ldw	r2,-32(fp)
 8007df8:	10800003 	ldbu	r2,0(r2)
 8007dfc:	10c03fcc 	andi	r3,r2,255
 8007e00:	e0bffc03 	ldbu	r2,-16(fp)
 8007e04:	1880021e 	bne	r3,r2,8007e10 <memchr+0x18c>
        return (void *) src;
 8007e08:	e0bff817 	ldw	r2,-32(fp)
 8007e0c:	00000806 	br	8007e30 <memchr+0x1ac>
      src++;
 8007e10:	e0bff817 	ldw	r2,-32(fp)
 8007e14:	10800044 	addi	r2,r2,1
 8007e18:	e0bff815 	stw	r2,-32(fp)
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 8007e1c:	e0bfff17 	ldw	r2,-4(fp)
 8007e20:	10ffffc4 	addi	r3,r2,-1
 8007e24:	e0ffff15 	stw	r3,-4(fp)
 8007e28:	103ff21e 	bne	r2,zero,8007df4 <memchr+0x170>
      if (*src == d)
        return (void *) src;
      src++;
    }

  return NULL;
 8007e2c:	0005883a 	mov	r2,zero
}
 8007e30:	e037883a 	mov	sp,fp
 8007e34:	df000017 	ldw	fp,0(sp)
 8007e38:	dec00104 	addi	sp,sp,4
 8007e3c:	f800283a 	ret

08007e40 <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR __restrict dst0 _AND
	_CONST _PTR __restrict src0 _AND
	size_t len0)
{
 8007e40:	defff804 	addi	sp,sp,-32
 8007e44:	df000715 	stw	fp,28(sp)
 8007e48:	df000704 	addi	fp,sp,28
 8007e4c:	e13ffd15 	stw	r4,-12(fp)
 8007e50:	e17ffe15 	stw	r5,-8(fp)
 8007e54:	e1bfff15 	stw	r6,-4(fp)
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
 8007e58:	e0bffd17 	ldw	r2,-12(fp)
 8007e5c:	e0bff915 	stw	r2,-28(fp)
  _CONST char *src = src0;
 8007e60:	e0bffe17 	ldw	r2,-8(fp)
 8007e64:	e0bffa15 	stw	r2,-24(fp)
  long *aligned_dst;
  _CONST long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
 8007e68:	e0bfff17 	ldw	r2,-4(fp)
 8007e6c:	10800430 	cmpltui	r2,r2,16
 8007e70:	10004c1e 	bne	r2,zero,8007fa4 <memcpy+0x164>
 8007e74:	e0fffa17 	ldw	r3,-24(fp)
 8007e78:	e0bff917 	ldw	r2,-28(fp)
 8007e7c:	1884b03a 	or	r2,r3,r2
 8007e80:	108000cc 	andi	r2,r2,3
 8007e84:	1000471e 	bne	r2,zero,8007fa4 <memcpy+0x164>
    {
      aligned_dst = (long*)dst;
 8007e88:	e0bff917 	ldw	r2,-28(fp)
 8007e8c:	e0bffb15 	stw	r2,-20(fp)
      aligned_src = (long*)src;
 8007e90:	e0bffa17 	ldw	r2,-24(fp)
 8007e94:	e0bffc15 	stw	r2,-16(fp)

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 8007e98:	00002306 	br	8007f28 <memcpy+0xe8>
        {
          *aligned_dst++ = *aligned_src++;
 8007e9c:	e0bffb17 	ldw	r2,-20(fp)
 8007ea0:	10c00104 	addi	r3,r2,4
 8007ea4:	e0fffb15 	stw	r3,-20(fp)
 8007ea8:	e0fffc17 	ldw	r3,-16(fp)
 8007eac:	19000104 	addi	r4,r3,4
 8007eb0:	e13ffc15 	stw	r4,-16(fp)
 8007eb4:	18c00017 	ldw	r3,0(r3)
 8007eb8:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 8007ebc:	e0bffb17 	ldw	r2,-20(fp)
 8007ec0:	10c00104 	addi	r3,r2,4
 8007ec4:	e0fffb15 	stw	r3,-20(fp)
 8007ec8:	e0fffc17 	ldw	r3,-16(fp)
 8007ecc:	19000104 	addi	r4,r3,4
 8007ed0:	e13ffc15 	stw	r4,-16(fp)
 8007ed4:	18c00017 	ldw	r3,0(r3)
 8007ed8:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 8007edc:	e0bffb17 	ldw	r2,-20(fp)
 8007ee0:	10c00104 	addi	r3,r2,4
 8007ee4:	e0fffb15 	stw	r3,-20(fp)
 8007ee8:	e0fffc17 	ldw	r3,-16(fp)
 8007eec:	19000104 	addi	r4,r3,4
 8007ef0:	e13ffc15 	stw	r4,-16(fp)
 8007ef4:	18c00017 	ldw	r3,0(r3)
 8007ef8:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 8007efc:	e0bffb17 	ldw	r2,-20(fp)
 8007f00:	10c00104 	addi	r3,r2,4
 8007f04:	e0fffb15 	stw	r3,-20(fp)
 8007f08:	e0fffc17 	ldw	r3,-16(fp)
 8007f0c:	19000104 	addi	r4,r3,4
 8007f10:	e13ffc15 	stw	r4,-16(fp)
 8007f14:	18c00017 	ldw	r3,0(r3)
 8007f18:	10c00015 	stw	r3,0(r2)
          len0 -= BIGBLOCKSIZE;
 8007f1c:	e0bfff17 	ldw	r2,-4(fp)
 8007f20:	10bffc04 	addi	r2,r2,-16
 8007f24:	e0bfff15 	stw	r2,-4(fp)
    {
      aligned_dst = (long*)dst;
      aligned_src = (long*)src;

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 8007f28:	e0bfff17 	ldw	r2,-4(fp)
 8007f2c:	10800428 	cmpgeui	r2,r2,16
 8007f30:	103fda1e 	bne	r2,zero,8007e9c <memcpy+0x5c>
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 8007f34:	00000b06 	br	8007f64 <memcpy+0x124>
        {
          *aligned_dst++ = *aligned_src++;
 8007f38:	e0bffb17 	ldw	r2,-20(fp)
 8007f3c:	10c00104 	addi	r3,r2,4
 8007f40:	e0fffb15 	stw	r3,-20(fp)
 8007f44:	e0fffc17 	ldw	r3,-16(fp)
 8007f48:	19000104 	addi	r4,r3,4
 8007f4c:	e13ffc15 	stw	r4,-16(fp)
 8007f50:	18c00017 	ldw	r3,0(r3)
 8007f54:	10c00015 	stw	r3,0(r2)
          len0 -= LITTLEBLOCKSIZE;
 8007f58:	e0bfff17 	ldw	r2,-4(fp)
 8007f5c:	10bfff04 	addi	r2,r2,-4
 8007f60:	e0bfff15 	stw	r2,-4(fp)
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 8007f64:	e0bfff17 	ldw	r2,-4(fp)
 8007f68:	10800128 	cmpgeui	r2,r2,4
 8007f6c:	103ff21e 	bne	r2,zero,8007f38 <memcpy+0xf8>
          *aligned_dst++ = *aligned_src++;
          len0 -= LITTLEBLOCKSIZE;
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
 8007f70:	e0bffb17 	ldw	r2,-20(fp)
 8007f74:	e0bff915 	stw	r2,-28(fp)
      src = (char*)aligned_src;
 8007f78:	e0bffc17 	ldw	r2,-16(fp)
 8007f7c:	e0bffa15 	stw	r2,-24(fp)
    }

  while (len0--)
 8007f80:	00000806 	br	8007fa4 <memcpy+0x164>
    *dst++ = *src++;
 8007f84:	e0bff917 	ldw	r2,-28(fp)
 8007f88:	10c00044 	addi	r3,r2,1
 8007f8c:	e0fff915 	stw	r3,-28(fp)
 8007f90:	e0fffa17 	ldw	r3,-24(fp)
 8007f94:	19000044 	addi	r4,r3,1
 8007f98:	e13ffa15 	stw	r4,-24(fp)
 8007f9c:	18c00003 	ldbu	r3,0(r3)
 8007fa0:	10c00005 	stb	r3,0(r2)
       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }

  while (len0--)
 8007fa4:	e0bfff17 	ldw	r2,-4(fp)
 8007fa8:	10ffffc4 	addi	r3,r2,-1
 8007fac:	e0ffff15 	stw	r3,-4(fp)
 8007fb0:	103ff41e 	bne	r2,zero,8007f84 <memcpy+0x144>
    *dst++ = *src++;

  return dst0;
 8007fb4:	e0bffd17 	ldw	r2,-12(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 8007fb8:	e037883a 	mov	sp,fp
 8007fbc:	df000017 	ldw	fp,0(sp)
 8007fc0:	dec00104 	addi	sp,sp,4
 8007fc4:	f800283a 	ret

08007fc8 <memmove>:
__inhibit_loop_to_libcall
_DEFUN (memmove, (dst_void, src_void, length),
	_PTR dst_void _AND
	_CONST _PTR src_void _AND
	size_t length)
{
 8007fc8:	defff804 	addi	sp,sp,-32
 8007fcc:	df000715 	stw	fp,28(sp)
 8007fd0:	df000704 	addi	fp,sp,28
 8007fd4:	e13ffd15 	stw	r4,-12(fp)
 8007fd8:	e17ffe15 	stw	r5,-8(fp)
 8007fdc:	e1bfff15 	stw	r6,-4(fp)
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
 8007fe0:	e0bffd17 	ldw	r2,-12(fp)
 8007fe4:	e0bff915 	stw	r2,-28(fp)
  _CONST char *src = src_void;
 8007fe8:	e0bffe17 	ldw	r2,-8(fp)
 8007fec:	e0bffa15 	stw	r2,-24(fp)
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
 8007ff0:	e0fffa17 	ldw	r3,-24(fp)
 8007ff4:	e0bff917 	ldw	r2,-28(fp)
 8007ff8:	18801d2e 	bgeu	r3,r2,8008070 <memmove+0xa8>
 8007ffc:	e0fffa17 	ldw	r3,-24(fp)
 8008000:	e0bfff17 	ldw	r2,-4(fp)
 8008004:	1885883a 	add	r2,r3,r2
 8008008:	e0fff917 	ldw	r3,-28(fp)
 800800c:	1880182e 	bgeu	r3,r2,8008070 <memmove+0xa8>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
 8008010:	e0fffa17 	ldw	r3,-24(fp)
 8008014:	e0bfff17 	ldw	r2,-4(fp)
 8008018:	1885883a 	add	r2,r3,r2
 800801c:	e0bffa15 	stw	r2,-24(fp)
      dst += length;
 8008020:	e0fff917 	ldw	r3,-28(fp)
 8008024:	e0bfff17 	ldw	r2,-4(fp)
 8008028:	1885883a 	add	r2,r3,r2
 800802c:	e0bff915 	stw	r2,-28(fp)
      while (length--)
 8008030:	00000a06 	br	800805c <memmove+0x94>
	{
	  *--dst = *--src;
 8008034:	e0bff917 	ldw	r2,-28(fp)
 8008038:	10bfffc4 	addi	r2,r2,-1
 800803c:	e0bff915 	stw	r2,-28(fp)
 8008040:	e0bffa17 	ldw	r2,-24(fp)
 8008044:	10bfffc4 	addi	r2,r2,-1
 8008048:	e0bffa15 	stw	r2,-24(fp)
 800804c:	e0bffa17 	ldw	r2,-24(fp)
 8008050:	10c00003 	ldbu	r3,0(r2)
 8008054:	e0bff917 	ldw	r2,-28(fp)
 8008058:	10c00005 	stb	r3,0(r2)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
 800805c:	e0bfff17 	ldw	r2,-4(fp)
 8008060:	10ffffc4 	addi	r3,r2,-1
 8008064:	e0ffff15 	stw	r3,-4(fp)
 8008068:	103ff21e 	bne	r2,zero,8008034 <memmove+0x6c>
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
 800806c:	00005306 	br	80081bc <memmove+0x1f4>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
 8008070:	e0bfff17 	ldw	r2,-4(fp)
 8008074:	10800430 	cmpltui	r2,r2,16
 8008078:	10004c1e 	bne	r2,zero,80081ac <memmove+0x1e4>
 800807c:	e0fffa17 	ldw	r3,-24(fp)
 8008080:	e0bff917 	ldw	r2,-28(fp)
 8008084:	1884b03a 	or	r2,r3,r2
 8008088:	108000cc 	andi	r2,r2,3
 800808c:	1000471e 	bne	r2,zero,80081ac <memmove+0x1e4>
        {
          aligned_dst = (long*)dst;
 8008090:	e0bff917 	ldw	r2,-28(fp)
 8008094:	e0bffb15 	stw	r2,-20(fp)
          aligned_src = (long*)src;
 8008098:	e0bffa17 	ldw	r2,-24(fp)
 800809c:	e0bffc15 	stw	r2,-16(fp)

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 80080a0:	00002306 	br	8008130 <memmove+0x168>
            {
              *aligned_dst++ = *aligned_src++;
 80080a4:	e0bffb17 	ldw	r2,-20(fp)
 80080a8:	10c00104 	addi	r3,r2,4
 80080ac:	e0fffb15 	stw	r3,-20(fp)
 80080b0:	e0fffc17 	ldw	r3,-16(fp)
 80080b4:	19000104 	addi	r4,r3,4
 80080b8:	e13ffc15 	stw	r4,-16(fp)
 80080bc:	18c00017 	ldw	r3,0(r3)
 80080c0:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 80080c4:	e0bffb17 	ldw	r2,-20(fp)
 80080c8:	10c00104 	addi	r3,r2,4
 80080cc:	e0fffb15 	stw	r3,-20(fp)
 80080d0:	e0fffc17 	ldw	r3,-16(fp)
 80080d4:	19000104 	addi	r4,r3,4
 80080d8:	e13ffc15 	stw	r4,-16(fp)
 80080dc:	18c00017 	ldw	r3,0(r3)
 80080e0:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 80080e4:	e0bffb17 	ldw	r2,-20(fp)
 80080e8:	10c00104 	addi	r3,r2,4
 80080ec:	e0fffb15 	stw	r3,-20(fp)
 80080f0:	e0fffc17 	ldw	r3,-16(fp)
 80080f4:	19000104 	addi	r4,r3,4
 80080f8:	e13ffc15 	stw	r4,-16(fp)
 80080fc:	18c00017 	ldw	r3,0(r3)
 8008100:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 8008104:	e0bffb17 	ldw	r2,-20(fp)
 8008108:	10c00104 	addi	r3,r2,4
 800810c:	e0fffb15 	stw	r3,-20(fp)
 8008110:	e0fffc17 	ldw	r3,-16(fp)
 8008114:	19000104 	addi	r4,r3,4
 8008118:	e13ffc15 	stw	r4,-16(fp)
 800811c:	18c00017 	ldw	r3,0(r3)
 8008120:	10c00015 	stw	r3,0(r2)
              length -= BIGBLOCKSIZE;
 8008124:	e0bfff17 	ldw	r2,-4(fp)
 8008128:	10bffc04 	addi	r2,r2,-16
 800812c:	e0bfff15 	stw	r2,-4(fp)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 8008130:	e0bfff17 	ldw	r2,-4(fp)
 8008134:	10800428 	cmpgeui	r2,r2,16
 8008138:	103fda1e 	bne	r2,zero,80080a4 <memmove+0xdc>
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 800813c:	00000b06 	br	800816c <memmove+0x1a4>
            {
              *aligned_dst++ = *aligned_src++;
 8008140:	e0bffb17 	ldw	r2,-20(fp)
 8008144:	10c00104 	addi	r3,r2,4
 8008148:	e0fffb15 	stw	r3,-20(fp)
 800814c:	e0fffc17 	ldw	r3,-16(fp)
 8008150:	19000104 	addi	r4,r3,4
 8008154:	e13ffc15 	stw	r4,-16(fp)
 8008158:	18c00017 	ldw	r3,0(r3)
 800815c:	10c00015 	stw	r3,0(r2)
              length -= LITTLEBLOCKSIZE;
 8008160:	e0bfff17 	ldw	r2,-4(fp)
 8008164:	10bfff04 	addi	r2,r2,-4
 8008168:	e0bfff15 	stw	r2,-4(fp)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 800816c:	e0bfff17 	ldw	r2,-4(fp)
 8008170:	10800128 	cmpgeui	r2,r2,4
 8008174:	103ff21e 	bne	r2,zero,8008140 <memmove+0x178>
              *aligned_dst++ = *aligned_src++;
              length -= LITTLEBLOCKSIZE;
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
 8008178:	e0bffb17 	ldw	r2,-20(fp)
 800817c:	e0bff915 	stw	r2,-28(fp)
          src = (char*)aligned_src;
 8008180:	e0bffc17 	ldw	r2,-16(fp)
 8008184:	e0bffa15 	stw	r2,-24(fp)
        }

      while (length--)
 8008188:	00000806 	br	80081ac <memmove+0x1e4>
        {
          *dst++ = *src++;
 800818c:	e0bff917 	ldw	r2,-28(fp)
 8008190:	10c00044 	addi	r3,r2,1
 8008194:	e0fff915 	stw	r3,-28(fp)
 8008198:	e0fffa17 	ldw	r3,-24(fp)
 800819c:	19000044 	addi	r4,r3,1
 80081a0:	e13ffa15 	stw	r4,-24(fp)
 80081a4:	18c00003 	ldbu	r3,0(r3)
 80081a8:	10c00005 	stb	r3,0(r2)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
 80081ac:	e0bfff17 	ldw	r2,-4(fp)
 80081b0:	10ffffc4 	addi	r3,r2,-1
 80081b4:	e0ffff15 	stw	r3,-4(fp)
 80081b8:	103ff41e 	bne	r2,zero,800818c <memmove+0x1c4>
        {
          *dst++ = *src++;
        }
    }

  return dst_void;
 80081bc:	e0bffd17 	ldw	r2,-12(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 80081c0:	e037883a 	mov	sp,fp
 80081c4:	df000017 	ldw	fp,0(sp)
 80081c8:	dec00104 	addi	sp,sp,4
 80081cc:	f800283a 	ret

080081d0 <memset>:
__inhibit_loop_to_libcall
_DEFUN (memset, (m, c, n),
	_PTR m _AND
	int c _AND
	size_t n)
{
 80081d0:	defff704 	addi	sp,sp,-36
 80081d4:	df000815 	stw	fp,32(sp)
 80081d8:	df000804 	addi	fp,sp,32
 80081dc:	e13ffd15 	stw	r4,-12(fp)
 80081e0:	e17ffe15 	stw	r5,-8(fp)
 80081e4:	e1bfff15 	stw	r6,-4(fp)
  char *s = (char *) m;
 80081e8:	e0bffd17 	ldw	r2,-12(fp)
 80081ec:	e0bff815 	stw	r2,-32(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
 80081f0:	e0bffe17 	ldw	r2,-8(fp)
 80081f4:	10803fcc 	andi	r2,r2,255
 80081f8:	e0bffc15 	stw	r2,-16(fp)
				   unsigned variable.  */

  while (UNALIGNED (s))
 80081fc:	00000c06 	br	8008230 <memset+0x60>
    {
      if (n--)
 8008200:	e0bfff17 	ldw	r2,-4(fp)
 8008204:	10ffffc4 	addi	r3,r2,-1
 8008208:	e0ffff15 	stw	r3,-4(fp)
 800820c:	10000626 	beq	r2,zero,8008228 <memset+0x58>
        *s++ = (char) c;
 8008210:	e0bff817 	ldw	r2,-32(fp)
 8008214:	10c00044 	addi	r3,r2,1
 8008218:	e0fff815 	stw	r3,-32(fp)
 800821c:	e0fffe17 	ldw	r3,-8(fp)
 8008220:	10c00005 	stb	r3,0(r2)
 8008224:	00000206 	br	8008230 <memset+0x60>
      else
        return m;
 8008228:	e0bffd17 	ldw	r2,-12(fp)
 800822c:	00005506 	br	8008384 <memset+0x1b4>
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
				   unsigned variable.  */

  while (UNALIGNED (s))
 8008230:	e0bff817 	ldw	r2,-32(fp)
 8008234:	108000cc 	andi	r2,r2,3
 8008238:	103ff11e 	bne	r2,zero,8008200 <memset+0x30>
        *s++ = (char) c;
      else
        return m;
    }

  if (!TOO_SMALL (n))
 800823c:	e0bfff17 	ldw	r2,-4(fp)
 8008240:	10800130 	cmpltui	r2,r2,4
 8008244:	10004a1e 	bne	r2,zero,8008370 <memset+0x1a0>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
 8008248:	e0bff817 	ldw	r2,-32(fp)
 800824c:	e0bffb15 	stw	r2,-20(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
 8008250:	e0bffc17 	ldw	r2,-16(fp)
 8008254:	1006923a 	slli	r3,r2,8
 8008258:	e0bffc17 	ldw	r2,-16(fp)
 800825c:	1884b03a 	or	r2,r3,r2
 8008260:	e0bffa15 	stw	r2,-24(fp)
      buffer |= (buffer << 16);
 8008264:	e0bffa17 	ldw	r2,-24(fp)
 8008268:	1004943a 	slli	r2,r2,16
 800826c:	e0fffa17 	ldw	r3,-24(fp)
 8008270:	1884b03a 	or	r2,r3,r2
 8008274:	e0bffa15 	stw	r2,-24(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 8008278:	00800804 	movi	r2,32
 800827c:	e0bff915 	stw	r2,-28(fp)
 8008280:	00000906 	br	80082a8 <memset+0xd8>
        buffer = (buffer << i) | buffer;
 8008284:	e0fffa17 	ldw	r3,-24(fp)
 8008288:	e0bff917 	ldw	r2,-28(fp)
 800828c:	1884983a 	sll	r2,r3,r2
 8008290:	e0fffa17 	ldw	r3,-24(fp)
 8008294:	1884b03a 	or	r2,r3,r2
 8008298:	e0bffa15 	stw	r2,-24(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 800829c:	e0bff917 	ldw	r2,-28(fp)
 80082a0:	1085883a 	add	r2,r2,r2
 80082a4:	e0bff915 	stw	r2,-28(fp)
 80082a8:	e0bff917 	ldw	r2,-28(fp)
 80082ac:	10800830 	cmpltui	r2,r2,32
 80082b0:	103ff41e 	bne	r2,zero,8008284 <memset+0xb4>
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 80082b4:	00001706 	br	8008314 <memset+0x144>
        {
          *aligned_addr++ = buffer;
 80082b8:	e0bffb17 	ldw	r2,-20(fp)
 80082bc:	10c00104 	addi	r3,r2,4
 80082c0:	e0fffb15 	stw	r3,-20(fp)
 80082c4:	e0fffa17 	ldw	r3,-24(fp)
 80082c8:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 80082cc:	e0bffb17 	ldw	r2,-20(fp)
 80082d0:	10c00104 	addi	r3,r2,4
 80082d4:	e0fffb15 	stw	r3,-20(fp)
 80082d8:	e0fffa17 	ldw	r3,-24(fp)
 80082dc:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 80082e0:	e0bffb17 	ldw	r2,-20(fp)
 80082e4:	10c00104 	addi	r3,r2,4
 80082e8:	e0fffb15 	stw	r3,-20(fp)
 80082ec:	e0fffa17 	ldw	r3,-24(fp)
 80082f0:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 80082f4:	e0bffb17 	ldw	r2,-20(fp)
 80082f8:	10c00104 	addi	r3,r2,4
 80082fc:	e0fffb15 	stw	r3,-20(fp)
 8008300:	e0fffa17 	ldw	r3,-24(fp)
 8008304:	10c00015 	stw	r3,0(r2)
          n -= 4*LBLOCKSIZE;
 8008308:	e0bfff17 	ldw	r2,-4(fp)
 800830c:	10bffc04 	addi	r2,r2,-16
 8008310:	e0bfff15 	stw	r2,-4(fp)
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 8008314:	e0bfff17 	ldw	r2,-4(fp)
 8008318:	10800428 	cmpgeui	r2,r2,16
 800831c:	103fe61e 	bne	r2,zero,80082b8 <memset+0xe8>
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
 8008320:	00000806 	br	8008344 <memset+0x174>
        {
          *aligned_addr++ = buffer;
 8008324:	e0bffb17 	ldw	r2,-20(fp)
 8008328:	10c00104 	addi	r3,r2,4
 800832c:	e0fffb15 	stw	r3,-20(fp)
 8008330:	e0fffa17 	ldw	r3,-24(fp)
 8008334:	10c00015 	stw	r3,0(r2)
          n -= LBLOCKSIZE;
 8008338:	e0bfff17 	ldw	r2,-4(fp)
 800833c:	10bfff04 	addi	r2,r2,-4
 8008340:	e0bfff15 	stw	r2,-4(fp)
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
 8008344:	e0bfff17 	ldw	r2,-4(fp)
 8008348:	10800128 	cmpgeui	r2,r2,4
 800834c:	103ff51e 	bne	r2,zero,8008324 <memset+0x154>
        {
          *aligned_addr++ = buffer;
          n -= LBLOCKSIZE;
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
 8008350:	e0bffb17 	ldw	r2,-20(fp)
 8008354:	e0bff815 	stw	r2,-32(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 8008358:	00000506 	br	8008370 <memset+0x1a0>
    *s++ = (char) c;
 800835c:	e0bff817 	ldw	r2,-32(fp)
 8008360:	10c00044 	addi	r3,r2,1
 8008364:	e0fff815 	stw	r3,-32(fp)
 8008368:	e0fffe17 	ldw	r3,-8(fp)
 800836c:	10c00005 	stb	r3,0(r2)
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 8008370:	e0bfff17 	ldw	r2,-4(fp)
 8008374:	10ffffc4 	addi	r3,r2,-1
 8008378:	e0ffff15 	stw	r3,-4(fp)
 800837c:	103ff71e 	bne	r2,zero,800835c <memset+0x18c>
    *s++ = (char) c;

  return m;
 8008380:	e0bffd17 	ldw	r2,-12(fp)
}
 8008384:	e037883a 	mov	sp,fp
 8008388:	df000017 	ldw	fp,0(sp)
 800838c:	dec00104 	addi	sp,sp,4
 8008390:	f800283a 	ret

08008394 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
 8008394:	deffe104 	addi	sp,sp,-124
 8008398:	dfc01e15 	stw	ra,120(sp)
 800839c:	df001d15 	stw	fp,116(sp)
 80083a0:	df001d04 	addi	fp,sp,116
 80083a4:	e13ffd15 	stw	r4,-12(fp)
 80083a8:	e17ffe15 	stw	r5,-8(fp)
 80083ac:	e1bfff15 	stw	r6,-4(fp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
 80083b0:	e0bffe17 	ldw	r2,-8(fp)
 80083b4:	1000041e 	bne	r2,zero,80083c8 <_realloc_r+0x34>
 80083b8:	e17fff17 	ldw	r5,-4(fp)
 80083bc:	e13ffd17 	ldw	r4,-12(fp)
 80083c0:	80071080 	call	8007108 <_malloc_r>
 80083c4:	0002ea06 	br	8008f70 <_realloc_r+0xbdc>

  MALLOC_LOCK;
 80083c8:	e13ffd17 	ldw	r4,-12(fp)
 80083cc:	800aa6c0 	call	800aa6c <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
 80083d0:	e0bffe17 	ldw	r2,-8(fp)
 80083d4:	10bffe04 	addi	r2,r2,-8
 80083d8:	e0bfef15 	stw	r2,-68(fp)
 80083dc:	e0bfef17 	ldw	r2,-68(fp)
 80083e0:	e0bfe315 	stw	r2,-116(fp)
  newsize = oldsize = chunksize(oldp);
 80083e4:	e0bfef17 	ldw	r2,-68(fp)
 80083e8:	10c00117 	ldw	r3,4(r2)
 80083ec:	00bfff04 	movi	r2,-4
 80083f0:	1884703a 	and	r2,r3,r2
 80083f4:	e0bff015 	stw	r2,-64(fp)
 80083f8:	e0bff017 	ldw	r2,-64(fp)
 80083fc:	e0bfe415 	stw	r2,-112(fp)


  nb = request2size(bytes);
 8008400:	e0bfff17 	ldw	r2,-4(fp)
 8008404:	108002c4 	addi	r2,r2,11
 8008408:	108005f0 	cmpltui	r2,r2,23
 800840c:	1000051e 	bne	r2,zero,8008424 <_realloc_r+0x90>
 8008410:	e0bfff17 	ldw	r2,-4(fp)
 8008414:	10c002c4 	addi	r3,r2,11
 8008418:	00bffe04 	movi	r2,-8
 800841c:	1884703a 	and	r2,r3,r2
 8008420:	00000106 	br	8008428 <_realloc_r+0x94>
 8008424:	00800404 	movi	r2,16
 8008428:	e0bff115 	stw	r2,-60(fp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
 800842c:	e0bff117 	ldw	r2,-60(fp)
 8008430:	10000316 	blt	r2,zero,8008440 <_realloc_r+0xac>
 8008434:	e0fff117 	ldw	r3,-60(fp)
 8008438:	e0bfff17 	ldw	r2,-4(fp)
 800843c:	1880052e 	bgeu	r3,r2,8008454 <_realloc_r+0xc0>
  {
    RERRNO = ENOMEM;
 8008440:	e0bffd17 	ldw	r2,-12(fp)
 8008444:	00c00304 	movi	r3,12
 8008448:	10c00015 	stw	r3,0(r2)
    return 0;
 800844c:	0005883a 	mov	r2,zero
 8008450:	0002c706 	br	8008f70 <_realloc_r+0xbdc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
 8008454:	e0fff017 	ldw	r3,-64(fp)
 8008458:	e0bff117 	ldw	r2,-60(fp)
 800845c:	18828b0e 	bge	r3,r2,8008e8c <_realloc_r+0xaf8>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
 8008460:	e0ffef17 	ldw	r3,-68(fp)
 8008464:	e0bff017 	ldw	r2,-64(fp)
 8008468:	1885883a 	add	r2,r3,r2
 800846c:	e0bfe515 	stw	r2,-108(fp)
    if (next == top || !inuse(next)) 
 8008470:	00820134 	movhi	r2,2052
 8008474:	109a9f04 	addi	r2,r2,27260
 8008478:	10c00217 	ldw	r3,8(r2)
 800847c:	e0bfe517 	ldw	r2,-108(fp)
 8008480:	18800926 	beq	r3,r2,80084a8 <_realloc_r+0x114>
 8008484:	e0bfe517 	ldw	r2,-108(fp)
 8008488:	10c00117 	ldw	r3,4(r2)
 800848c:	00bfff84 	movi	r2,-2
 8008490:	1884703a 	and	r2,r3,r2
 8008494:	e0ffe517 	ldw	r3,-108(fp)
 8008498:	1885883a 	add	r2,r3,r2
 800849c:	10800117 	ldw	r2,4(r2)
 80084a0:	1080004c 	andi	r2,r2,1
 80084a4:	1000461e 	bne	r2,zero,80085c0 <_realloc_r+0x22c>
    {
      nextsize = chunksize(next);
 80084a8:	e0bfe517 	ldw	r2,-108(fp)
 80084ac:	10c00117 	ldw	r3,4(r2)
 80084b0:	00bfff04 	movi	r2,-4
 80084b4:	1884703a 	and	r2,r3,r2
 80084b8:	e0bfe615 	stw	r2,-104(fp)

      /* Forward into top only if a remainder */
      if (next == top)
 80084bc:	00820134 	movhi	r2,2052
 80084c0:	109a9f04 	addi	r2,r2,27260
 80084c4:	10c00217 	ldw	r3,8(r2)
 80084c8:	e0bfe517 	ldw	r2,-108(fp)
 80084cc:	1880251e 	bne	r3,r2,8008564 <_realloc_r+0x1d0>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
 80084d0:	e0ffe617 	ldw	r3,-104(fp)
 80084d4:	e0bfe417 	ldw	r2,-112(fp)
 80084d8:	1885883a 	add	r2,r3,r2
 80084dc:	1007883a 	mov	r3,r2
 80084e0:	e0bff117 	ldw	r2,-60(fp)
 80084e4:	10800404 	addi	r2,r2,16
 80084e8:	18803816 	blt	r3,r2,80085cc <_realloc_r+0x238>
        {
          newsize += nextsize;
 80084ec:	e0ffe417 	ldw	r3,-112(fp)
 80084f0:	e0bfe617 	ldw	r2,-104(fp)
 80084f4:	1885883a 	add	r2,r3,r2
 80084f8:	e0bfe415 	stw	r2,-112(fp)
          top = chunk_at_offset(oldp, nb);
 80084fc:	00820134 	movhi	r2,2052
 8008500:	109a9f04 	addi	r2,r2,27260
 8008504:	e13fef17 	ldw	r4,-68(fp)
 8008508:	e0fff117 	ldw	r3,-60(fp)
 800850c:	20c7883a 	add	r3,r4,r3
 8008510:	10c00215 	stw	r3,8(r2)
          set_head(top, (newsize - nb) | PREV_INUSE);
 8008514:	00820134 	movhi	r2,2052
 8008518:	109a9f04 	addi	r2,r2,27260
 800851c:	10800217 	ldw	r2,8(r2)
 8008520:	e13fe417 	ldw	r4,-112(fp)
 8008524:	e0fff117 	ldw	r3,-60(fp)
 8008528:	20c7c83a 	sub	r3,r4,r3
 800852c:	18c00054 	ori	r3,r3,1
 8008530:	10c00115 	stw	r3,4(r2)
          set_head_size(oldp, nb);
 8008534:	e0bfef17 	ldw	r2,-68(fp)
 8008538:	10800117 	ldw	r2,4(r2)
 800853c:	10c0004c 	andi	r3,r2,1
 8008540:	e0bff117 	ldw	r2,-60(fp)
 8008544:	1886b03a 	or	r3,r3,r2
 8008548:	e0bfef17 	ldw	r2,-68(fp)
 800854c:	10c00115 	stw	r3,4(r2)
	  MALLOC_UNLOCK;
 8008550:	e13ffd17 	ldw	r4,-12(fp)
 8008554:	800aa900 	call	800aa90 <__malloc_unlock>
          return chunk2mem(oldp);
 8008558:	e0bfef17 	ldw	r2,-68(fp)
 800855c:	10800204 	addi	r2,r2,8
 8008560:	00028306 	br	8008f70 <_realloc_r+0xbdc>
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
 8008564:	e0ffe617 	ldw	r3,-104(fp)
 8008568:	e0bfe417 	ldw	r2,-112(fp)
 800856c:	1885883a 	add	r2,r3,r2
 8008570:	1007883a 	mov	r3,r2
 8008574:	e0bff117 	ldw	r2,-60(fp)
 8008578:	18801416 	blt	r3,r2,80085cc <_realloc_r+0x238>
      { 
        unlink(next, bck, fwd);
 800857c:	e0bfe517 	ldw	r2,-108(fp)
 8008580:	10800317 	ldw	r2,12(r2)
 8008584:	e0bff215 	stw	r2,-56(fp)
 8008588:	e0bfe517 	ldw	r2,-108(fp)
 800858c:	10800217 	ldw	r2,8(r2)
 8008590:	e0bff315 	stw	r2,-52(fp)
 8008594:	e0bff317 	ldw	r2,-52(fp)
 8008598:	e0fff217 	ldw	r3,-56(fp)
 800859c:	10c00315 	stw	r3,12(r2)
 80085a0:	e0bff217 	ldw	r2,-56(fp)
 80085a4:	e0fff317 	ldw	r3,-52(fp)
 80085a8:	10c00215 	stw	r3,8(r2)
        newsize  += nextsize;
 80085ac:	e0ffe417 	ldw	r3,-112(fp)
 80085b0:	e0bfe617 	ldw	r2,-104(fp)
 80085b4:	1885883a 	add	r2,r3,r2
 80085b8:	e0bfe415 	stw	r2,-112(fp)
        goto split;
 80085bc:	00023306 	br	8008e8c <_realloc_r+0xaf8>
      }
    }
    else
    {
      next = 0;
 80085c0:	e03fe515 	stw	zero,-108(fp)
      nextsize = 0;
 80085c4:	e03fe615 	stw	zero,-104(fp)
 80085c8:	00000106 	br	80085d0 <_realloc_r+0x23c>
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
 80085cc:	0001883a 	nop
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
 80085d0:	e0bfef17 	ldw	r2,-68(fp)
 80085d4:	10800117 	ldw	r2,4(r2)
 80085d8:	1080004c 	andi	r2,r2,1
 80085dc:	1001a91e 	bne	r2,zero,8008c84 <_realloc_r+0x8f0>
    {
      prev = prev_chunk(oldp);
 80085e0:	e0bfef17 	ldw	r2,-68(fp)
 80085e4:	10800017 	ldw	r2,0(r2)
 80085e8:	0085c83a 	sub	r2,zero,r2
 80085ec:	e0ffef17 	ldw	r3,-68(fp)
 80085f0:	1885883a 	add	r2,r3,r2
 80085f4:	e0bff415 	stw	r2,-48(fp)
      prevsize = chunksize(prev);
 80085f8:	e0bff417 	ldw	r2,-48(fp)
 80085fc:	10c00117 	ldw	r3,4(r2)
 8008600:	00bfff04 	movi	r2,-4
 8008604:	1884703a 	and	r2,r3,r2
 8008608:	e0bff515 	stw	r2,-44(fp)

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
 800860c:	e0bfe517 	ldw	r2,-108(fp)
 8008610:	10012226 	beq	r2,zero,8008a9c <_realloc_r+0x708>
      {
        /* into top */
        if (next == top)
 8008614:	00820134 	movhi	r2,2052
 8008618:	109a9f04 	addi	r2,r2,27260
 800861c:	10c00217 	ldw	r3,8(r2)
 8008620:	e0bfe517 	ldw	r2,-108(fp)
 8008624:	1880951e 	bne	r3,r2,800887c <_realloc_r+0x4e8>
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
 8008628:	e0ffe617 	ldw	r3,-104(fp)
 800862c:	e0bff517 	ldw	r2,-44(fp)
 8008630:	1887883a 	add	r3,r3,r2
 8008634:	e0bfe417 	ldw	r2,-112(fp)
 8008638:	1885883a 	add	r2,r3,r2
 800863c:	1007883a 	mov	r3,r2
 8008640:	e0bff117 	ldw	r2,-60(fp)
 8008644:	10800404 	addi	r2,r2,16
 8008648:	18811416 	blt	r3,r2,8008a9c <_realloc_r+0x708>
          {
            unlink(prev, bck, fwd);
 800864c:	e0bff417 	ldw	r2,-48(fp)
 8008650:	10800317 	ldw	r2,12(r2)
 8008654:	e0bff215 	stw	r2,-56(fp)
 8008658:	e0bff417 	ldw	r2,-48(fp)
 800865c:	10800217 	ldw	r2,8(r2)
 8008660:	e0bff315 	stw	r2,-52(fp)
 8008664:	e0bff317 	ldw	r2,-52(fp)
 8008668:	e0fff217 	ldw	r3,-56(fp)
 800866c:	10c00315 	stw	r3,12(r2)
 8008670:	e0bff217 	ldw	r2,-56(fp)
 8008674:	e0fff317 	ldw	r3,-52(fp)
 8008678:	10c00215 	stw	r3,8(r2)
            newp = prev;
 800867c:	e0bff417 	ldw	r2,-48(fp)
 8008680:	e0bfe315 	stw	r2,-116(fp)
            newsize += prevsize + nextsize;
 8008684:	e0fff517 	ldw	r3,-44(fp)
 8008688:	e0bfe617 	ldw	r2,-104(fp)
 800868c:	1885883a 	add	r2,r3,r2
 8008690:	e0ffe417 	ldw	r3,-112(fp)
 8008694:	1885883a 	add	r2,r3,r2
 8008698:	e0bfe415 	stw	r2,-112(fp)
            newmem = chunk2mem(newp);
 800869c:	e0bfe317 	ldw	r2,-116(fp)
 80086a0:	10800204 	addi	r2,r2,8
 80086a4:	e0bff615 	stw	r2,-40(fp)
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 80086a8:	e0bff017 	ldw	r2,-64(fp)
 80086ac:	10bfff04 	addi	r2,r2,-4
 80086b0:	e0bff715 	stw	r2,-36(fp)
 80086b4:	e0bff717 	ldw	r2,-36(fp)
 80086b8:	10800968 	cmpgeui	r2,r2,37
 80086bc:	1000521e 	bne	r2,zero,8008808 <_realloc_r+0x474>
 80086c0:	e0bffe17 	ldw	r2,-8(fp)
 80086c4:	e0bfe715 	stw	r2,-100(fp)
 80086c8:	e0bff617 	ldw	r2,-40(fp)
 80086cc:	e0bfe815 	stw	r2,-96(fp)
 80086d0:	e0bff717 	ldw	r2,-36(fp)
 80086d4:	10800530 	cmpltui	r2,r2,20
 80086d8:	1000361e 	bne	r2,zero,80087b4 <_realloc_r+0x420>
 80086dc:	e0bfe817 	ldw	r2,-96(fp)
 80086e0:	10c00104 	addi	r3,r2,4
 80086e4:	e0ffe815 	stw	r3,-96(fp)
 80086e8:	e0ffe717 	ldw	r3,-100(fp)
 80086ec:	19000104 	addi	r4,r3,4
 80086f0:	e13fe715 	stw	r4,-100(fp)
 80086f4:	18c00017 	ldw	r3,0(r3)
 80086f8:	10c00015 	stw	r3,0(r2)
 80086fc:	e0bfe817 	ldw	r2,-96(fp)
 8008700:	10c00104 	addi	r3,r2,4
 8008704:	e0ffe815 	stw	r3,-96(fp)
 8008708:	e0ffe717 	ldw	r3,-100(fp)
 800870c:	19000104 	addi	r4,r3,4
 8008710:	e13fe715 	stw	r4,-100(fp)
 8008714:	18c00017 	ldw	r3,0(r3)
 8008718:	10c00015 	stw	r3,0(r2)
 800871c:	e0bff717 	ldw	r2,-36(fp)
 8008720:	10800730 	cmpltui	r2,r2,28
 8008724:	1000231e 	bne	r2,zero,80087b4 <_realloc_r+0x420>
 8008728:	e0bfe817 	ldw	r2,-96(fp)
 800872c:	10c00104 	addi	r3,r2,4
 8008730:	e0ffe815 	stw	r3,-96(fp)
 8008734:	e0ffe717 	ldw	r3,-100(fp)
 8008738:	19000104 	addi	r4,r3,4
 800873c:	e13fe715 	stw	r4,-100(fp)
 8008740:	18c00017 	ldw	r3,0(r3)
 8008744:	10c00015 	stw	r3,0(r2)
 8008748:	e0bfe817 	ldw	r2,-96(fp)
 800874c:	10c00104 	addi	r3,r2,4
 8008750:	e0ffe815 	stw	r3,-96(fp)
 8008754:	e0ffe717 	ldw	r3,-100(fp)
 8008758:	19000104 	addi	r4,r3,4
 800875c:	e13fe715 	stw	r4,-100(fp)
 8008760:	18c00017 	ldw	r3,0(r3)
 8008764:	10c00015 	stw	r3,0(r2)
 8008768:	e0bff717 	ldw	r2,-36(fp)
 800876c:	10800930 	cmpltui	r2,r2,36
 8008770:	1000101e 	bne	r2,zero,80087b4 <_realloc_r+0x420>
 8008774:	e0bfe817 	ldw	r2,-96(fp)
 8008778:	10c00104 	addi	r3,r2,4
 800877c:	e0ffe815 	stw	r3,-96(fp)
 8008780:	e0ffe717 	ldw	r3,-100(fp)
 8008784:	19000104 	addi	r4,r3,4
 8008788:	e13fe715 	stw	r4,-100(fp)
 800878c:	18c00017 	ldw	r3,0(r3)
 8008790:	10c00015 	stw	r3,0(r2)
 8008794:	e0bfe817 	ldw	r2,-96(fp)
 8008798:	10c00104 	addi	r3,r2,4
 800879c:	e0ffe815 	stw	r3,-96(fp)
 80087a0:	e0ffe717 	ldw	r3,-100(fp)
 80087a4:	19000104 	addi	r4,r3,4
 80087a8:	e13fe715 	stw	r4,-100(fp)
 80087ac:	18c00017 	ldw	r3,0(r3)
 80087b0:	10c00015 	stw	r3,0(r2)
 80087b4:	e0bfe817 	ldw	r2,-96(fp)
 80087b8:	10c00104 	addi	r3,r2,4
 80087bc:	e0ffe815 	stw	r3,-96(fp)
 80087c0:	e0ffe717 	ldw	r3,-100(fp)
 80087c4:	19000104 	addi	r4,r3,4
 80087c8:	e13fe715 	stw	r4,-100(fp)
 80087cc:	18c00017 	ldw	r3,0(r3)
 80087d0:	10c00015 	stw	r3,0(r2)
 80087d4:	e0bfe817 	ldw	r2,-96(fp)
 80087d8:	10c00104 	addi	r3,r2,4
 80087dc:	e0ffe815 	stw	r3,-96(fp)
 80087e0:	e0ffe717 	ldw	r3,-100(fp)
 80087e4:	19000104 	addi	r4,r3,4
 80087e8:	e13fe715 	stw	r4,-100(fp)
 80087ec:	18c00017 	ldw	r3,0(r3)
 80087f0:	10c00015 	stw	r3,0(r2)
 80087f4:	e0bfe717 	ldw	r2,-100(fp)
 80087f8:	10c00017 	ldw	r3,0(r2)
 80087fc:	e0bfe817 	ldw	r2,-96(fp)
 8008800:	10c00015 	stw	r3,0(r2)
 8008804:	00000406 	br	8008818 <_realloc_r+0x484>
 8008808:	e1bff717 	ldw	r6,-36(fp)
 800880c:	e17ffe17 	ldw	r5,-8(fp)
 8008810:	e13ff617 	ldw	r4,-40(fp)
 8008814:	8007fc80 	call	8007fc8 <memmove>
            top = chunk_at_offset(newp, nb);
 8008818:	00820134 	movhi	r2,2052
 800881c:	109a9f04 	addi	r2,r2,27260
 8008820:	e13fe317 	ldw	r4,-116(fp)
 8008824:	e0fff117 	ldw	r3,-60(fp)
 8008828:	20c7883a 	add	r3,r4,r3
 800882c:	10c00215 	stw	r3,8(r2)
            set_head(top, (newsize - nb) | PREV_INUSE);
 8008830:	00820134 	movhi	r2,2052
 8008834:	109a9f04 	addi	r2,r2,27260
 8008838:	10800217 	ldw	r2,8(r2)
 800883c:	e13fe417 	ldw	r4,-112(fp)
 8008840:	e0fff117 	ldw	r3,-60(fp)
 8008844:	20c7c83a 	sub	r3,r4,r3
 8008848:	18c00054 	ori	r3,r3,1
 800884c:	10c00115 	stw	r3,4(r2)
            set_head_size(newp, nb);
 8008850:	e0bfe317 	ldw	r2,-116(fp)
 8008854:	10800117 	ldw	r2,4(r2)
 8008858:	10c0004c 	andi	r3,r2,1
 800885c:	e0bff117 	ldw	r2,-60(fp)
 8008860:	1886b03a 	or	r3,r3,r2
 8008864:	e0bfe317 	ldw	r2,-116(fp)
 8008868:	10c00115 	stw	r3,4(r2)
	    MALLOC_UNLOCK;
 800886c:	e13ffd17 	ldw	r4,-12(fp)
 8008870:	800aa900 	call	800aa90 <__malloc_unlock>
            return newmem;
 8008874:	e0bff617 	ldw	r2,-40(fp)
 8008878:	0001bd06 	br	8008f70 <_realloc_r+0xbdc>
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
 800887c:	e0ffe617 	ldw	r3,-104(fp)
 8008880:	e0bff517 	ldw	r2,-44(fp)
 8008884:	1887883a 	add	r3,r3,r2
 8008888:	e0bfe417 	ldw	r2,-112(fp)
 800888c:	1885883a 	add	r2,r3,r2
 8008890:	1007883a 	mov	r3,r2
 8008894:	e0bff117 	ldw	r2,-60(fp)
 8008898:	18808016 	blt	r3,r2,8008a9c <_realloc_r+0x708>
        {
          unlink(next, bck, fwd);
 800889c:	e0bfe517 	ldw	r2,-108(fp)
 80088a0:	10800317 	ldw	r2,12(r2)
 80088a4:	e0bff215 	stw	r2,-56(fp)
 80088a8:	e0bfe517 	ldw	r2,-108(fp)
 80088ac:	10800217 	ldw	r2,8(r2)
 80088b0:	e0bff315 	stw	r2,-52(fp)
 80088b4:	e0bff317 	ldw	r2,-52(fp)
 80088b8:	e0fff217 	ldw	r3,-56(fp)
 80088bc:	10c00315 	stw	r3,12(r2)
 80088c0:	e0bff217 	ldw	r2,-56(fp)
 80088c4:	e0fff317 	ldw	r3,-52(fp)
 80088c8:	10c00215 	stw	r3,8(r2)
          unlink(prev, bck, fwd);
 80088cc:	e0bff417 	ldw	r2,-48(fp)
 80088d0:	10800317 	ldw	r2,12(r2)
 80088d4:	e0bff215 	stw	r2,-56(fp)
 80088d8:	e0bff417 	ldw	r2,-48(fp)
 80088dc:	10800217 	ldw	r2,8(r2)
 80088e0:	e0bff315 	stw	r2,-52(fp)
 80088e4:	e0bff317 	ldw	r2,-52(fp)
 80088e8:	e0fff217 	ldw	r3,-56(fp)
 80088ec:	10c00315 	stw	r3,12(r2)
 80088f0:	e0bff217 	ldw	r2,-56(fp)
 80088f4:	e0fff317 	ldw	r3,-52(fp)
 80088f8:	10c00215 	stw	r3,8(r2)
          newp = prev;
 80088fc:	e0bff417 	ldw	r2,-48(fp)
 8008900:	e0bfe315 	stw	r2,-116(fp)
          newsize += nextsize + prevsize;
 8008904:	e0ffe617 	ldw	r3,-104(fp)
 8008908:	e0bff517 	ldw	r2,-44(fp)
 800890c:	1885883a 	add	r2,r3,r2
 8008910:	e0ffe417 	ldw	r3,-112(fp)
 8008914:	1885883a 	add	r2,r3,r2
 8008918:	e0bfe415 	stw	r2,-112(fp)
          newmem = chunk2mem(newp);
 800891c:	e0bfe317 	ldw	r2,-116(fp)
 8008920:	10800204 	addi	r2,r2,8
 8008924:	e0bff615 	stw	r2,-40(fp)
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008928:	e0bff017 	ldw	r2,-64(fp)
 800892c:	10bfff04 	addi	r2,r2,-4
 8008930:	e0bff815 	stw	r2,-32(fp)
 8008934:	e0bff817 	ldw	r2,-32(fp)
 8008938:	10800968 	cmpgeui	r2,r2,37
 800893c:	1000521e 	bne	r2,zero,8008a88 <_realloc_r+0x6f4>
 8008940:	e0bffe17 	ldw	r2,-8(fp)
 8008944:	e0bfe915 	stw	r2,-92(fp)
 8008948:	e0bff617 	ldw	r2,-40(fp)
 800894c:	e0bfea15 	stw	r2,-88(fp)
 8008950:	e0bff817 	ldw	r2,-32(fp)
 8008954:	10800530 	cmpltui	r2,r2,20
 8008958:	1000361e 	bne	r2,zero,8008a34 <_realloc_r+0x6a0>
 800895c:	e0bfea17 	ldw	r2,-88(fp)
 8008960:	10c00104 	addi	r3,r2,4
 8008964:	e0ffea15 	stw	r3,-88(fp)
 8008968:	e0ffe917 	ldw	r3,-92(fp)
 800896c:	19000104 	addi	r4,r3,4
 8008970:	e13fe915 	stw	r4,-92(fp)
 8008974:	18c00017 	ldw	r3,0(r3)
 8008978:	10c00015 	stw	r3,0(r2)
 800897c:	e0bfea17 	ldw	r2,-88(fp)
 8008980:	10c00104 	addi	r3,r2,4
 8008984:	e0ffea15 	stw	r3,-88(fp)
 8008988:	e0ffe917 	ldw	r3,-92(fp)
 800898c:	19000104 	addi	r4,r3,4
 8008990:	e13fe915 	stw	r4,-92(fp)
 8008994:	18c00017 	ldw	r3,0(r3)
 8008998:	10c00015 	stw	r3,0(r2)
 800899c:	e0bff817 	ldw	r2,-32(fp)
 80089a0:	10800730 	cmpltui	r2,r2,28
 80089a4:	1000231e 	bne	r2,zero,8008a34 <_realloc_r+0x6a0>
 80089a8:	e0bfea17 	ldw	r2,-88(fp)
 80089ac:	10c00104 	addi	r3,r2,4
 80089b0:	e0ffea15 	stw	r3,-88(fp)
 80089b4:	e0ffe917 	ldw	r3,-92(fp)
 80089b8:	19000104 	addi	r4,r3,4
 80089bc:	e13fe915 	stw	r4,-92(fp)
 80089c0:	18c00017 	ldw	r3,0(r3)
 80089c4:	10c00015 	stw	r3,0(r2)
 80089c8:	e0bfea17 	ldw	r2,-88(fp)
 80089cc:	10c00104 	addi	r3,r2,4
 80089d0:	e0ffea15 	stw	r3,-88(fp)
 80089d4:	e0ffe917 	ldw	r3,-92(fp)
 80089d8:	19000104 	addi	r4,r3,4
 80089dc:	e13fe915 	stw	r4,-92(fp)
 80089e0:	18c00017 	ldw	r3,0(r3)
 80089e4:	10c00015 	stw	r3,0(r2)
 80089e8:	e0bff817 	ldw	r2,-32(fp)
 80089ec:	10800930 	cmpltui	r2,r2,36
 80089f0:	1000101e 	bne	r2,zero,8008a34 <_realloc_r+0x6a0>
 80089f4:	e0bfea17 	ldw	r2,-88(fp)
 80089f8:	10c00104 	addi	r3,r2,4
 80089fc:	e0ffea15 	stw	r3,-88(fp)
 8008a00:	e0ffe917 	ldw	r3,-92(fp)
 8008a04:	19000104 	addi	r4,r3,4
 8008a08:	e13fe915 	stw	r4,-92(fp)
 8008a0c:	18c00017 	ldw	r3,0(r3)
 8008a10:	10c00015 	stw	r3,0(r2)
 8008a14:	e0bfea17 	ldw	r2,-88(fp)
 8008a18:	10c00104 	addi	r3,r2,4
 8008a1c:	e0ffea15 	stw	r3,-88(fp)
 8008a20:	e0ffe917 	ldw	r3,-92(fp)
 8008a24:	19000104 	addi	r4,r3,4
 8008a28:	e13fe915 	stw	r4,-92(fp)
 8008a2c:	18c00017 	ldw	r3,0(r3)
 8008a30:	10c00015 	stw	r3,0(r2)
 8008a34:	e0bfea17 	ldw	r2,-88(fp)
 8008a38:	10c00104 	addi	r3,r2,4
 8008a3c:	e0ffea15 	stw	r3,-88(fp)
 8008a40:	e0ffe917 	ldw	r3,-92(fp)
 8008a44:	19000104 	addi	r4,r3,4
 8008a48:	e13fe915 	stw	r4,-92(fp)
 8008a4c:	18c00017 	ldw	r3,0(r3)
 8008a50:	10c00015 	stw	r3,0(r2)
 8008a54:	e0bfea17 	ldw	r2,-88(fp)
 8008a58:	10c00104 	addi	r3,r2,4
 8008a5c:	e0ffea15 	stw	r3,-88(fp)
 8008a60:	e0ffe917 	ldw	r3,-92(fp)
 8008a64:	19000104 	addi	r4,r3,4
 8008a68:	e13fe915 	stw	r4,-92(fp)
 8008a6c:	18c00017 	ldw	r3,0(r3)
 8008a70:	10c00015 	stw	r3,0(r2)
 8008a74:	e0bfe917 	ldw	r2,-92(fp)
 8008a78:	10c00017 	ldw	r3,0(r2)
 8008a7c:	e0bfea17 	ldw	r2,-88(fp)
 8008a80:	10c00015 	stw	r3,0(r2)
          goto split;
 8008a84:	00010106 	br	8008e8c <_realloc_r+0xaf8>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008a88:	e1bff817 	ldw	r6,-32(fp)
 8008a8c:	e17ffe17 	ldw	r5,-8(fp)
 8008a90:	e13ff617 	ldw	r4,-40(fp)
 8008a94:	8007fc80 	call	8007fc8 <memmove>
          goto split;
 8008a98:	0000fc06 	br	8008e8c <_realloc_r+0xaf8>
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
 8008a9c:	e0bff417 	ldw	r2,-48(fp)
 8008aa0:	10007826 	beq	r2,zero,8008c84 <_realloc_r+0x8f0>
 8008aa4:	e0fff517 	ldw	r3,-44(fp)
 8008aa8:	e0bfe417 	ldw	r2,-112(fp)
 8008aac:	1885883a 	add	r2,r3,r2
 8008ab0:	1007883a 	mov	r3,r2
 8008ab4:	e0bff117 	ldw	r2,-60(fp)
 8008ab8:	18807216 	blt	r3,r2,8008c84 <_realloc_r+0x8f0>
      {
        unlink(prev, bck, fwd);
 8008abc:	e0bff417 	ldw	r2,-48(fp)
 8008ac0:	10800317 	ldw	r2,12(r2)
 8008ac4:	e0bff215 	stw	r2,-56(fp)
 8008ac8:	e0bff417 	ldw	r2,-48(fp)
 8008acc:	10800217 	ldw	r2,8(r2)
 8008ad0:	e0bff315 	stw	r2,-52(fp)
 8008ad4:	e0bff317 	ldw	r2,-52(fp)
 8008ad8:	e0fff217 	ldw	r3,-56(fp)
 8008adc:	10c00315 	stw	r3,12(r2)
 8008ae0:	e0bff217 	ldw	r2,-56(fp)
 8008ae4:	e0fff317 	ldw	r3,-52(fp)
 8008ae8:	10c00215 	stw	r3,8(r2)
        newp = prev;
 8008aec:	e0bff417 	ldw	r2,-48(fp)
 8008af0:	e0bfe315 	stw	r2,-116(fp)
        newsize += prevsize;
 8008af4:	e0ffe417 	ldw	r3,-112(fp)
 8008af8:	e0bff517 	ldw	r2,-44(fp)
 8008afc:	1885883a 	add	r2,r3,r2
 8008b00:	e0bfe415 	stw	r2,-112(fp)
        newmem = chunk2mem(newp);
 8008b04:	e0bfe317 	ldw	r2,-116(fp)
 8008b08:	10800204 	addi	r2,r2,8
 8008b0c:	e0bff615 	stw	r2,-40(fp)
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008b10:	e0bff017 	ldw	r2,-64(fp)
 8008b14:	10bfff04 	addi	r2,r2,-4
 8008b18:	e0bff915 	stw	r2,-28(fp)
 8008b1c:	e0bff917 	ldw	r2,-28(fp)
 8008b20:	10800968 	cmpgeui	r2,r2,37
 8008b24:	1000521e 	bne	r2,zero,8008c70 <_realloc_r+0x8dc>
 8008b28:	e0bffe17 	ldw	r2,-8(fp)
 8008b2c:	e0bfeb15 	stw	r2,-84(fp)
 8008b30:	e0bff617 	ldw	r2,-40(fp)
 8008b34:	e0bfec15 	stw	r2,-80(fp)
 8008b38:	e0bff917 	ldw	r2,-28(fp)
 8008b3c:	10800530 	cmpltui	r2,r2,20
 8008b40:	1000361e 	bne	r2,zero,8008c1c <_realloc_r+0x888>
 8008b44:	e0bfec17 	ldw	r2,-80(fp)
 8008b48:	10c00104 	addi	r3,r2,4
 8008b4c:	e0ffec15 	stw	r3,-80(fp)
 8008b50:	e0ffeb17 	ldw	r3,-84(fp)
 8008b54:	19000104 	addi	r4,r3,4
 8008b58:	e13feb15 	stw	r4,-84(fp)
 8008b5c:	18c00017 	ldw	r3,0(r3)
 8008b60:	10c00015 	stw	r3,0(r2)
 8008b64:	e0bfec17 	ldw	r2,-80(fp)
 8008b68:	10c00104 	addi	r3,r2,4
 8008b6c:	e0ffec15 	stw	r3,-80(fp)
 8008b70:	e0ffeb17 	ldw	r3,-84(fp)
 8008b74:	19000104 	addi	r4,r3,4
 8008b78:	e13feb15 	stw	r4,-84(fp)
 8008b7c:	18c00017 	ldw	r3,0(r3)
 8008b80:	10c00015 	stw	r3,0(r2)
 8008b84:	e0bff917 	ldw	r2,-28(fp)
 8008b88:	10800730 	cmpltui	r2,r2,28
 8008b8c:	1000231e 	bne	r2,zero,8008c1c <_realloc_r+0x888>
 8008b90:	e0bfec17 	ldw	r2,-80(fp)
 8008b94:	10c00104 	addi	r3,r2,4
 8008b98:	e0ffec15 	stw	r3,-80(fp)
 8008b9c:	e0ffeb17 	ldw	r3,-84(fp)
 8008ba0:	19000104 	addi	r4,r3,4
 8008ba4:	e13feb15 	stw	r4,-84(fp)
 8008ba8:	18c00017 	ldw	r3,0(r3)
 8008bac:	10c00015 	stw	r3,0(r2)
 8008bb0:	e0bfec17 	ldw	r2,-80(fp)
 8008bb4:	10c00104 	addi	r3,r2,4
 8008bb8:	e0ffec15 	stw	r3,-80(fp)
 8008bbc:	e0ffeb17 	ldw	r3,-84(fp)
 8008bc0:	19000104 	addi	r4,r3,4
 8008bc4:	e13feb15 	stw	r4,-84(fp)
 8008bc8:	18c00017 	ldw	r3,0(r3)
 8008bcc:	10c00015 	stw	r3,0(r2)
 8008bd0:	e0bff917 	ldw	r2,-28(fp)
 8008bd4:	10800930 	cmpltui	r2,r2,36
 8008bd8:	1000101e 	bne	r2,zero,8008c1c <_realloc_r+0x888>
 8008bdc:	e0bfec17 	ldw	r2,-80(fp)
 8008be0:	10c00104 	addi	r3,r2,4
 8008be4:	e0ffec15 	stw	r3,-80(fp)
 8008be8:	e0ffeb17 	ldw	r3,-84(fp)
 8008bec:	19000104 	addi	r4,r3,4
 8008bf0:	e13feb15 	stw	r4,-84(fp)
 8008bf4:	18c00017 	ldw	r3,0(r3)
 8008bf8:	10c00015 	stw	r3,0(r2)
 8008bfc:	e0bfec17 	ldw	r2,-80(fp)
 8008c00:	10c00104 	addi	r3,r2,4
 8008c04:	e0ffec15 	stw	r3,-80(fp)
 8008c08:	e0ffeb17 	ldw	r3,-84(fp)
 8008c0c:	19000104 	addi	r4,r3,4
 8008c10:	e13feb15 	stw	r4,-84(fp)
 8008c14:	18c00017 	ldw	r3,0(r3)
 8008c18:	10c00015 	stw	r3,0(r2)
 8008c1c:	e0bfec17 	ldw	r2,-80(fp)
 8008c20:	10c00104 	addi	r3,r2,4
 8008c24:	e0ffec15 	stw	r3,-80(fp)
 8008c28:	e0ffeb17 	ldw	r3,-84(fp)
 8008c2c:	19000104 	addi	r4,r3,4
 8008c30:	e13feb15 	stw	r4,-84(fp)
 8008c34:	18c00017 	ldw	r3,0(r3)
 8008c38:	10c00015 	stw	r3,0(r2)
 8008c3c:	e0bfec17 	ldw	r2,-80(fp)
 8008c40:	10c00104 	addi	r3,r2,4
 8008c44:	e0ffec15 	stw	r3,-80(fp)
 8008c48:	e0ffeb17 	ldw	r3,-84(fp)
 8008c4c:	19000104 	addi	r4,r3,4
 8008c50:	e13feb15 	stw	r4,-84(fp)
 8008c54:	18c00017 	ldw	r3,0(r3)
 8008c58:	10c00015 	stw	r3,0(r2)
 8008c5c:	e0bfeb17 	ldw	r2,-84(fp)
 8008c60:	10c00017 	ldw	r3,0(r2)
 8008c64:	e0bfec17 	ldw	r2,-80(fp)
 8008c68:	10c00015 	stw	r3,0(r2)
        goto split;
 8008c6c:	00008706 	br	8008e8c <_realloc_r+0xaf8>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008c70:	e1bff917 	ldw	r6,-28(fp)
 8008c74:	e17ffe17 	ldw	r5,-8(fp)
 8008c78:	e13ff617 	ldw	r4,-40(fp)
 8008c7c:	8007fc80 	call	8007fc8 <memmove>
        goto split;
 8008c80:	00008206 	br	8008e8c <_realloc_r+0xaf8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
 8008c84:	e17fff17 	ldw	r5,-4(fp)
 8008c88:	e13ffd17 	ldw	r4,-12(fp)
 8008c8c:	80071080 	call	8007108 <_malloc_r>
 8008c90:	e0bff615 	stw	r2,-40(fp)

    if (newmem == 0)  /* propagate failure */
 8008c94:	e0bff617 	ldw	r2,-40(fp)
 8008c98:	1000041e 	bne	r2,zero,8008cac <_realloc_r+0x918>
    {
      MALLOC_UNLOCK;
 8008c9c:	e13ffd17 	ldw	r4,-12(fp)
 8008ca0:	800aa900 	call	800aa90 <__malloc_unlock>
      return 0;
 8008ca4:	0005883a 	mov	r2,zero
 8008ca8:	0000b106 	br	8008f70 <_realloc_r+0xbdc>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
 8008cac:	e0bff617 	ldw	r2,-40(fp)
 8008cb0:	10bffe04 	addi	r2,r2,-8
 8008cb4:	e0bfe315 	stw	r2,-116(fp)
 8008cb8:	e0bfef17 	ldw	r2,-68(fp)
 8008cbc:	10c00117 	ldw	r3,4(r2)
 8008cc0:	00bfff84 	movi	r2,-2
 8008cc4:	1884703a 	and	r2,r3,r2
 8008cc8:	e0ffef17 	ldw	r3,-68(fp)
 8008ccc:	1885883a 	add	r2,r3,r2
 8008cd0:	e0ffe317 	ldw	r3,-116(fp)
 8008cd4:	18800a1e 	bne	r3,r2,8008d00 <_realloc_r+0x96c>
    {
      newsize += chunksize(newp);
 8008cd8:	e0bfe317 	ldw	r2,-116(fp)
 8008cdc:	10c00117 	ldw	r3,4(r2)
 8008ce0:	00bfff04 	movi	r2,-4
 8008ce4:	1884703a 	and	r2,r3,r2
 8008ce8:	e0ffe417 	ldw	r3,-112(fp)
 8008cec:	1885883a 	add	r2,r3,r2
 8008cf0:	e0bfe415 	stw	r2,-112(fp)
      newp = oldp;
 8008cf4:	e0bfef17 	ldw	r2,-68(fp)
 8008cf8:	e0bfe315 	stw	r2,-116(fp)
      goto split;
 8008cfc:	00006306 	br	8008e8c <_realloc_r+0xaf8>
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 8008d00:	e0bff017 	ldw	r2,-64(fp)
 8008d04:	10bfff04 	addi	r2,r2,-4
 8008d08:	e0bffa15 	stw	r2,-24(fp)
 8008d0c:	e0bffa17 	ldw	r2,-24(fp)
 8008d10:	10800968 	cmpgeui	r2,r2,37
 8008d14:	1000521e 	bne	r2,zero,8008e60 <_realloc_r+0xacc>
 8008d18:	e0bffe17 	ldw	r2,-8(fp)
 8008d1c:	e0bfed15 	stw	r2,-76(fp)
 8008d20:	e0bff617 	ldw	r2,-40(fp)
 8008d24:	e0bfee15 	stw	r2,-72(fp)
 8008d28:	e0bffa17 	ldw	r2,-24(fp)
 8008d2c:	10800530 	cmpltui	r2,r2,20
 8008d30:	1000361e 	bne	r2,zero,8008e0c <_realloc_r+0xa78>
 8008d34:	e0bfee17 	ldw	r2,-72(fp)
 8008d38:	10c00104 	addi	r3,r2,4
 8008d3c:	e0ffee15 	stw	r3,-72(fp)
 8008d40:	e0ffed17 	ldw	r3,-76(fp)
 8008d44:	19000104 	addi	r4,r3,4
 8008d48:	e13fed15 	stw	r4,-76(fp)
 8008d4c:	18c00017 	ldw	r3,0(r3)
 8008d50:	10c00015 	stw	r3,0(r2)
 8008d54:	e0bfee17 	ldw	r2,-72(fp)
 8008d58:	10c00104 	addi	r3,r2,4
 8008d5c:	e0ffee15 	stw	r3,-72(fp)
 8008d60:	e0ffed17 	ldw	r3,-76(fp)
 8008d64:	19000104 	addi	r4,r3,4
 8008d68:	e13fed15 	stw	r4,-76(fp)
 8008d6c:	18c00017 	ldw	r3,0(r3)
 8008d70:	10c00015 	stw	r3,0(r2)
 8008d74:	e0bffa17 	ldw	r2,-24(fp)
 8008d78:	10800730 	cmpltui	r2,r2,28
 8008d7c:	1000231e 	bne	r2,zero,8008e0c <_realloc_r+0xa78>
 8008d80:	e0bfee17 	ldw	r2,-72(fp)
 8008d84:	10c00104 	addi	r3,r2,4
 8008d88:	e0ffee15 	stw	r3,-72(fp)
 8008d8c:	e0ffed17 	ldw	r3,-76(fp)
 8008d90:	19000104 	addi	r4,r3,4
 8008d94:	e13fed15 	stw	r4,-76(fp)
 8008d98:	18c00017 	ldw	r3,0(r3)
 8008d9c:	10c00015 	stw	r3,0(r2)
 8008da0:	e0bfee17 	ldw	r2,-72(fp)
 8008da4:	10c00104 	addi	r3,r2,4
 8008da8:	e0ffee15 	stw	r3,-72(fp)
 8008dac:	e0ffed17 	ldw	r3,-76(fp)
 8008db0:	19000104 	addi	r4,r3,4
 8008db4:	e13fed15 	stw	r4,-76(fp)
 8008db8:	18c00017 	ldw	r3,0(r3)
 8008dbc:	10c00015 	stw	r3,0(r2)
 8008dc0:	e0bffa17 	ldw	r2,-24(fp)
 8008dc4:	10800930 	cmpltui	r2,r2,36
 8008dc8:	1000101e 	bne	r2,zero,8008e0c <_realloc_r+0xa78>
 8008dcc:	e0bfee17 	ldw	r2,-72(fp)
 8008dd0:	10c00104 	addi	r3,r2,4
 8008dd4:	e0ffee15 	stw	r3,-72(fp)
 8008dd8:	e0ffed17 	ldw	r3,-76(fp)
 8008ddc:	19000104 	addi	r4,r3,4
 8008de0:	e13fed15 	stw	r4,-76(fp)
 8008de4:	18c00017 	ldw	r3,0(r3)
 8008de8:	10c00015 	stw	r3,0(r2)
 8008dec:	e0bfee17 	ldw	r2,-72(fp)
 8008df0:	10c00104 	addi	r3,r2,4
 8008df4:	e0ffee15 	stw	r3,-72(fp)
 8008df8:	e0ffed17 	ldw	r3,-76(fp)
 8008dfc:	19000104 	addi	r4,r3,4
 8008e00:	e13fed15 	stw	r4,-76(fp)
 8008e04:	18c00017 	ldw	r3,0(r3)
 8008e08:	10c00015 	stw	r3,0(r2)
 8008e0c:	e0bfee17 	ldw	r2,-72(fp)
 8008e10:	10c00104 	addi	r3,r2,4
 8008e14:	e0ffee15 	stw	r3,-72(fp)
 8008e18:	e0ffed17 	ldw	r3,-76(fp)
 8008e1c:	19000104 	addi	r4,r3,4
 8008e20:	e13fed15 	stw	r4,-76(fp)
 8008e24:	18c00017 	ldw	r3,0(r3)
 8008e28:	10c00015 	stw	r3,0(r2)
 8008e2c:	e0bfee17 	ldw	r2,-72(fp)
 8008e30:	10c00104 	addi	r3,r2,4
 8008e34:	e0ffee15 	stw	r3,-72(fp)
 8008e38:	e0ffed17 	ldw	r3,-76(fp)
 8008e3c:	19000104 	addi	r4,r3,4
 8008e40:	e13fed15 	stw	r4,-76(fp)
 8008e44:	18c00017 	ldw	r3,0(r3)
 8008e48:	10c00015 	stw	r3,0(r2)
 8008e4c:	e0bfed17 	ldw	r2,-76(fp)
 8008e50:	10c00017 	ldw	r3,0(r2)
 8008e54:	e0bfee17 	ldw	r2,-72(fp)
 8008e58:	10c00015 	stw	r3,0(r2)
 8008e5c:	00000406 	br	8008e70 <_realloc_r+0xadc>
 8008e60:	e1bffa17 	ldw	r6,-24(fp)
 8008e64:	e17ffe17 	ldw	r5,-8(fp)
 8008e68:	e13ff617 	ldw	r4,-40(fp)
 8008e6c:	8007fc80 	call	8007fc8 <memmove>
    fREe(RCALL oldmem);
 8008e70:	e17ffe17 	ldw	r5,-8(fp)
 8008e74:	e13ffd17 	ldw	r4,-12(fp)
 8008e78:	8009a0c0 	call	8009a0c <_free_r>
    MALLOC_UNLOCK;
 8008e7c:	e13ffd17 	ldw	r4,-12(fp)
 8008e80:	800aa900 	call	800aa90 <__malloc_unlock>
    return newmem;
 8008e84:	e0bff617 	ldw	r2,-40(fp)
 8008e88:	00003906 	br	8008f70 <_realloc_r+0xbdc>
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
 8008e8c:	e0ffe417 	ldw	r3,-112(fp)
 8008e90:	e0bff117 	ldw	r2,-60(fp)
 8008e94:	1885c83a 	sub	r2,r3,r2
 8008e98:	e0bffb15 	stw	r2,-20(fp)

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
 8008e9c:	e0bffb17 	ldw	r2,-20(fp)
 8008ea0:	10800430 	cmpltui	r2,r2,16
 8008ea4:	10001e1e 	bne	r2,zero,8008f20 <_realloc_r+0xb8c>
  {
    remainder = chunk_at_offset(newp, nb);
 8008ea8:	e0ffe317 	ldw	r3,-116(fp)
 8008eac:	e0bff117 	ldw	r2,-60(fp)
 8008eb0:	1885883a 	add	r2,r3,r2
 8008eb4:	e0bffc15 	stw	r2,-16(fp)
    set_head_size(newp, nb);
 8008eb8:	e0bfe317 	ldw	r2,-116(fp)
 8008ebc:	10800117 	ldw	r2,4(r2)
 8008ec0:	10c0004c 	andi	r3,r2,1
 8008ec4:	e0bff117 	ldw	r2,-60(fp)
 8008ec8:	1886b03a 	or	r3,r3,r2
 8008ecc:	e0bfe317 	ldw	r2,-116(fp)
 8008ed0:	10c00115 	stw	r3,4(r2)
    set_head(remainder, remainder_size | PREV_INUSE);
 8008ed4:	e0bffb17 	ldw	r2,-20(fp)
 8008ed8:	10c00054 	ori	r3,r2,1
 8008edc:	e0bffc17 	ldw	r2,-16(fp)
 8008ee0:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(remainder, remainder_size);
 8008ee4:	e0fffc17 	ldw	r3,-16(fp)
 8008ee8:	e0bffb17 	ldw	r2,-20(fp)
 8008eec:	1885883a 	add	r2,r3,r2
 8008ef0:	e13ffc17 	ldw	r4,-16(fp)
 8008ef4:	e0fffb17 	ldw	r3,-20(fp)
 8008ef8:	20c7883a 	add	r3,r4,r3
 8008efc:	18c00117 	ldw	r3,4(r3)
 8008f00:	18c00054 	ori	r3,r3,1
 8008f04:	10c00115 	stw	r3,4(r2)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
 8008f08:	e0bffc17 	ldw	r2,-16(fp)
 8008f0c:	10800204 	addi	r2,r2,8
 8008f10:	100b883a 	mov	r5,r2
 8008f14:	e13ffd17 	ldw	r4,-12(fp)
 8008f18:	8009a0c0 	call	8009a0c <_free_r>
 8008f1c:	00001006 	br	8008f60 <_realloc_r+0xbcc>
  }
  else
  {
    set_head_size(newp, newsize);
 8008f20:	e0bfe317 	ldw	r2,-116(fp)
 8008f24:	10800117 	ldw	r2,4(r2)
 8008f28:	10c0004c 	andi	r3,r2,1
 8008f2c:	e0bfe417 	ldw	r2,-112(fp)
 8008f30:	1886b03a 	or	r3,r3,r2
 8008f34:	e0bfe317 	ldw	r2,-116(fp)
 8008f38:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(newp, newsize);
 8008f3c:	e0ffe317 	ldw	r3,-116(fp)
 8008f40:	e0bfe417 	ldw	r2,-112(fp)
 8008f44:	1885883a 	add	r2,r3,r2
 8008f48:	e13fe317 	ldw	r4,-116(fp)
 8008f4c:	e0ffe417 	ldw	r3,-112(fp)
 8008f50:	20c7883a 	add	r3,r4,r3
 8008f54:	18c00117 	ldw	r3,4(r3)
 8008f58:	18c00054 	ori	r3,r3,1
 8008f5c:	10c00115 	stw	r3,4(r2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
 8008f60:	e13ffd17 	ldw	r4,-12(fp)
 8008f64:	800aa900 	call	800aa90 <__malloc_unlock>
  return chunk2mem(newp);
 8008f68:	e0bfe317 	ldw	r2,-116(fp)
 8008f6c:	10800204 	addi	r2,r2,8

#endif /* MALLOC_PROVIDED */
}
 8008f70:	e037883a 	mov	sp,fp
 8008f74:	dfc00117 	ldw	ra,4(sp)
 8008f78:	df000017 	ldw	fp,0(sp)
 8008f7c:	dec00204 	addi	sp,sp,8
 8008f80:	f800283a 	ret

08008f84 <_sbrk_r>:

void *
_DEFUN (_sbrk_r, (ptr, incr),
     struct _reent *ptr _AND
     ptrdiff_t incr)
{
 8008f84:	defffb04 	addi	sp,sp,-20
 8008f88:	dfc00415 	stw	ra,16(sp)
 8008f8c:	df000315 	stw	fp,12(sp)
 8008f90:	df000304 	addi	fp,sp,12
 8008f94:	e13ffe15 	stw	r4,-8(fp)
 8008f98:	e17fff15 	stw	r5,-4(fp)
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
 8008f9c:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
 8008fa0:	e13fff17 	ldw	r4,-4(fp)
 8008fa4:	800ac500 	call	800ac50 <sbrk>
 8008fa8:	e0bffd15 	stw	r2,-12(fp)
 8008fac:	e0bffd17 	ldw	r2,-12(fp)
 8008fb0:	10bfffd8 	cmpnei	r2,r2,-1
 8008fb4:	1000051e 	bne	r2,zero,8008fcc <_sbrk_r+0x48>
 8008fb8:	d0a76a17 	ldw	r2,-25176(gp)
 8008fbc:	10000326 	beq	r2,zero,8008fcc <_sbrk_r+0x48>
    ptr->_errno = errno;
 8008fc0:	d0e76a17 	ldw	r3,-25176(gp)
 8008fc4:	e0bffe17 	ldw	r2,-8(fp)
 8008fc8:	10c00015 	stw	r3,0(r2)
  return ret;
 8008fcc:	e0bffd17 	ldw	r2,-12(fp)
}
 8008fd0:	e037883a 	mov	sp,fp
 8008fd4:	dfc00117 	ldw	ra,4(sp)
 8008fd8:	df000017 	ldw	fp,0(sp)
 8008fdc:	dec00204 	addi	sp,sp,8
 8008fe0:	f800283a 	ret

08008fe4 <__sread>:
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
 8008fe4:	defff804 	addi	sp,sp,-32
 8008fe8:	dfc00715 	stw	ra,28(sp)
 8008fec:	df000615 	stw	fp,24(sp)
 8008ff0:	dc400515 	stw	r17,20(sp)
 8008ff4:	dc000415 	stw	r16,16(sp)
 8008ff8:	df000604 	addi	fp,sp,24
 8008ffc:	e13ffa15 	stw	r4,-24(fp)
 8009000:	e17ffb15 	stw	r5,-20(fp)
 8009004:	e1bffc15 	stw	r6,-16(fp)
 8009008:	e1fffd15 	stw	r7,-12(fp)
  register FILE *fp = (FILE *) cookie;
 800900c:	e43ffb17 	ldw	r16,-20(fp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
 8009010:	8080038b 	ldhu	r2,14(r16)
 8009014:	10bfffcc 	andi	r2,r2,65535
 8009018:	10a0001c 	xori	r2,r2,32768
 800901c:	10a00004 	addi	r2,r2,-32768
 8009020:	e0fffd17 	ldw	r3,-12(fp)
 8009024:	180f883a 	mov	r7,r3
 8009028:	e1bffc17 	ldw	r6,-16(fp)
 800902c:	100b883a 	mov	r5,r2
 8009030:	e13ffa17 	ldw	r4,-24(fp)
 8009034:	800a3d40 	call	800a3d4 <_read_r>
 8009038:	1023883a 	mov	r17,r2
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
 800903c:	88000416 	blt	r17,zero,8009050 <__sread+0x6c>
    fp->_offset += ret;
 8009040:	80801417 	ldw	r2,80(r16)
 8009044:	1445883a 	add	r2,r2,r17
 8009048:	80801415 	stw	r2,80(r16)
 800904c:	00000406 	br	8009060 <__sread+0x7c>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
 8009050:	80c0030b 	ldhu	r3,12(r16)
 8009054:	00bbffc4 	movi	r2,-4097
 8009058:	1884703a 	and	r2,r3,r2
 800905c:	8080030d 	sth	r2,12(r16)
  return ret;
 8009060:	8805883a 	mov	r2,r17
}
 8009064:	e6fffe04 	addi	sp,fp,-8
 8009068:	dfc00317 	ldw	ra,12(sp)
 800906c:	df000217 	ldw	fp,8(sp)
 8009070:	dc400117 	ldw	r17,4(sp)
 8009074:	dc000017 	ldw	r16,0(sp)
 8009078:	dec00404 	addi	sp,sp,16
 800907c:	f800283a 	ret

08009080 <__seofread>:
_DEFUN(__seofread, (ptr, cookie, buf, len),
       struct _reent *_ptr _AND
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
 8009080:	defffb04 	addi	sp,sp,-20
 8009084:	df000415 	stw	fp,16(sp)
 8009088:	df000404 	addi	fp,sp,16
 800908c:	e13ffc15 	stw	r4,-16(fp)
 8009090:	e17ffd15 	stw	r5,-12(fp)
 8009094:	e1bffe15 	stw	r6,-8(fp)
 8009098:	e1ffff15 	stw	r7,-4(fp)
  return 0;
 800909c:	0005883a 	mov	r2,zero
}
 80090a0:	e037883a 	mov	sp,fp
 80090a4:	df000017 	ldw	fp,0(sp)
 80090a8:	dec00104 	addi	sp,sp,4
 80090ac:	f800283a 	ret

080090b0 <__swrite>:
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
 80090b0:	defff804 	addi	sp,sp,-32
 80090b4:	dfc00715 	stw	ra,28(sp)
 80090b8:	df000615 	stw	fp,24(sp)
 80090bc:	dc000515 	stw	r16,20(sp)
 80090c0:	df000604 	addi	fp,sp,24
 80090c4:	e13ffb15 	stw	r4,-20(fp)
 80090c8:	e17ffc15 	stw	r5,-16(fp)
 80090cc:	e1bffd15 	stw	r6,-12(fp)
 80090d0:	e1fffe15 	stw	r7,-8(fp)
  register FILE *fp = (FILE *) cookie;
 80090d4:	e43ffc17 	ldw	r16,-16(fp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
 80090d8:	8080030b 	ldhu	r2,12(r16)
 80090dc:	10bfffcc 	andi	r2,r2,65535
 80090e0:	1080400c 	andi	r2,r2,256
 80090e4:	10000926 	beq	r2,zero,800910c <__swrite+0x5c>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
 80090e8:	8080038b 	ldhu	r2,14(r16)
 80090ec:	10bfffcc 	andi	r2,r2,65535
 80090f0:	10a0001c 	xori	r2,r2,32768
 80090f4:	10a00004 	addi	r2,r2,-32768
 80090f8:	01c00084 	movi	r7,2
 80090fc:	000d883a 	mov	r6,zero
 8009100:	100b883a 	mov	r5,r2
 8009104:	e13ffb17 	ldw	r4,-20(fp)
 8009108:	800a1380 	call	800a138 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
 800910c:	80c0030b 	ldhu	r3,12(r16)
 8009110:	00bbffc4 	movi	r2,-4097
 8009114:	1884703a 	and	r2,r3,r2
 8009118:	8080030d 	sth	r2,12(r16)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
 800911c:	8080038b 	ldhu	r2,14(r16)
 8009120:	10bfffcc 	andi	r2,r2,65535
 8009124:	10a0001c 	xori	r2,r2,32768
 8009128:	10a00004 	addi	r2,r2,-32768
 800912c:	e0fffe17 	ldw	r3,-8(fp)
 8009130:	180f883a 	mov	r7,r3
 8009134:	e1bffd17 	ldw	r6,-12(fp)
 8009138:	100b883a 	mov	r5,r2
 800913c:	e13ffb17 	ldw	r4,-20(fp)
 8009140:	80092580 	call	8009258 <_write_r>
 8009144:	e0bffa15 	stw	r2,-24(fp)
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
 8009148:	e0bffa17 	ldw	r2,-24(fp)
}
 800914c:	e6ffff04 	addi	sp,fp,-4
 8009150:	dfc00217 	ldw	ra,8(sp)
 8009154:	df000117 	ldw	fp,4(sp)
 8009158:	dc000017 	ldw	r16,0(sp)
 800915c:	dec00304 	addi	sp,sp,12
 8009160:	f800283a 	ret

08009164 <__sseek>:
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
 8009164:	defff804 	addi	sp,sp,-32
 8009168:	dfc00715 	stw	ra,28(sp)
 800916c:	df000615 	stw	fp,24(sp)
 8009170:	dc400515 	stw	r17,20(sp)
 8009174:	dc000415 	stw	r16,16(sp)
 8009178:	df000604 	addi	fp,sp,24
 800917c:	e13ffa15 	stw	r4,-24(fp)
 8009180:	e17ffb15 	stw	r5,-20(fp)
 8009184:	e1bffc15 	stw	r6,-16(fp)
 8009188:	e1fffd15 	stw	r7,-12(fp)
  register FILE *fp = (FILE *) cookie;
 800918c:	e43ffb17 	ldw	r16,-20(fp)
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
 8009190:	8080038b 	ldhu	r2,14(r16)
 8009194:	10bfffcc 	andi	r2,r2,65535
 8009198:	10a0001c 	xori	r2,r2,32768
 800919c:	10a00004 	addi	r2,r2,-32768
 80091a0:	e1fffd17 	ldw	r7,-12(fp)
 80091a4:	e1bffc17 	ldw	r6,-16(fp)
 80091a8:	100b883a 	mov	r5,r2
 80091ac:	e13ffa17 	ldw	r4,-24(fp)
 80091b0:	800a1380 	call	800a138 <_lseek_r>
 80091b4:	1023883a 	mov	r17,r2
  if (ret == -1L)
 80091b8:	88bfffd8 	cmpnei	r2,r17,-1
 80091bc:	1000051e 	bne	r2,zero,80091d4 <__sseek+0x70>
    fp->_flags &= ~__SOFF;
 80091c0:	80c0030b 	ldhu	r3,12(r16)
 80091c4:	00bbffc4 	movi	r2,-4097
 80091c8:	1884703a 	and	r2,r3,r2
 80091cc:	8080030d 	sth	r2,12(r16)
 80091d0:	00000406 	br	80091e4 <__sseek+0x80>
  else
    {
      fp->_flags |= __SOFF;
 80091d4:	8080030b 	ldhu	r2,12(r16)
 80091d8:	10840014 	ori	r2,r2,4096
 80091dc:	8080030d 	sth	r2,12(r16)
      fp->_offset = ret;
 80091e0:	84401415 	stw	r17,80(r16)
    }
  return ret;
 80091e4:	8805883a 	mov	r2,r17
}
 80091e8:	e6fffe04 	addi	sp,fp,-8
 80091ec:	dfc00317 	ldw	ra,12(sp)
 80091f0:	df000217 	ldw	fp,8(sp)
 80091f4:	dc400117 	ldw	r17,4(sp)
 80091f8:	dc000017 	ldw	r16,0(sp)
 80091fc:	dec00404 	addi	sp,sp,16
 8009200:	f800283a 	ret

08009204 <__sclose>:

int
_DEFUN(__sclose, (ptr, cookie),
       struct _reent *ptr _AND
       void *cookie)
{
 8009204:	defffb04 	addi	sp,sp,-20
 8009208:	dfc00415 	stw	ra,16(sp)
 800920c:	df000315 	stw	fp,12(sp)
 8009210:	df000304 	addi	fp,sp,12
 8009214:	e13ffe15 	stw	r4,-8(fp)
 8009218:	e17fff15 	stw	r5,-4(fp)
  FILE *fp = (FILE *) cookie;
 800921c:	e0bfff17 	ldw	r2,-4(fp)
 8009220:	e0bffd15 	stw	r2,-12(fp)

  return _close_r (ptr, fp->_file);
 8009224:	e0bffd17 	ldw	r2,-12(fp)
 8009228:	1080038b 	ldhu	r2,14(r2)
 800922c:	10bfffcc 	andi	r2,r2,65535
 8009230:	10a0001c 	xori	r2,r2,32768
 8009234:	10a00004 	addi	r2,r2,-32768
 8009238:	100b883a 	mov	r5,r2
 800923c:	e13ffe17 	ldw	r4,-8(fp)
 8009240:	80094680 	call	8009468 <_close_r>
}
 8009244:	e037883a 	mov	sp,fp
 8009248:	dfc00117 	ldw	ra,4(sp)
 800924c:	df000017 	ldw	fp,0(sp)
 8009250:	dec00204 	addi	sp,sp,8
 8009254:	f800283a 	ret

08009258 <_write_r>:
_DEFUN (_write_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _CONST _PTR buf _AND
     size_t cnt)
{
 8009258:	defff904 	addi	sp,sp,-28
 800925c:	dfc00615 	stw	ra,24(sp)
 8009260:	df000515 	stw	fp,20(sp)
 8009264:	df000504 	addi	fp,sp,20
 8009268:	e13ffc15 	stw	r4,-16(fp)
 800926c:	e17ffd15 	stw	r5,-12(fp)
 8009270:	e1bffe15 	stw	r6,-8(fp)
 8009274:	e1ffff15 	stw	r7,-4(fp)
  _ssize_t ret;

  errno = 0;
 8009278:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
 800927c:	e1bfff17 	ldw	r6,-4(fp)
 8009280:	e17ffe17 	ldw	r5,-8(fp)
 8009284:	e13ffd17 	ldw	r4,-12(fp)
 8009288:	800aee00 	call	800aee0 <write>
 800928c:	e0bffb15 	stw	r2,-20(fp)
 8009290:	e0bffb17 	ldw	r2,-20(fp)
 8009294:	10bfffd8 	cmpnei	r2,r2,-1
 8009298:	1000051e 	bne	r2,zero,80092b0 <_write_r+0x58>
 800929c:	d0a76a17 	ldw	r2,-25176(gp)
 80092a0:	10000326 	beq	r2,zero,80092b0 <_write_r+0x58>
    ptr->_errno = errno;
 80092a4:	d0e76a17 	ldw	r3,-25176(gp)
 80092a8:	e0bffc17 	ldw	r2,-16(fp)
 80092ac:	10c00015 	stw	r3,0(r2)
  return ret;
 80092b0:	e0bffb17 	ldw	r2,-20(fp)
}
 80092b4:	e037883a 	mov	sp,fp
 80092b8:	dfc00117 	ldw	ra,4(sp)
 80092bc:	df000017 	ldw	fp,0(sp)
 80092c0:	dec00204 	addi	sp,sp,8
 80092c4:	f800283a 	ret

080092c8 <__swsetup_r>:

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 80092c8:	defffb04 	addi	sp,sp,-20
 80092cc:	dfc00415 	stw	ra,16(sp)
 80092d0:	df000315 	stw	fp,12(sp)
 80092d4:	dc000215 	stw	r16,8(sp)
 80092d8:	df000304 	addi	fp,sp,12
 80092dc:	e13ffe15 	stw	r4,-8(fp)
 80092e0:	2821883a 	mov	r16,r5
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
 80092e4:	d0a04217 	ldw	r2,-32504(gp)
 80092e8:	e0bffd15 	stw	r2,-12(fp)
 80092ec:	e0bffd17 	ldw	r2,-12(fp)
 80092f0:	10000526 	beq	r2,zero,8009308 <__swsetup_r+0x40>
 80092f4:	e0bffd17 	ldw	r2,-12(fp)
 80092f8:	10800e17 	ldw	r2,56(r2)
 80092fc:	1000021e 	bne	r2,zero,8009308 <__swsetup_r+0x40>
 8009300:	e13ffd17 	ldw	r4,-12(fp)
 8009304:	80063a40 	call	80063a4 <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
 8009308:	8080030b 	ldhu	r2,12(r16)
 800930c:	10bfffcc 	andi	r2,r2,65535
 8009310:	1080020c 	andi	r2,r2,8
 8009314:	1000241e 	bne	r2,zero,80093a8 <__swsetup_r+0xe0>
    {
      if ((fp->_flags & __SRW) == 0)
 8009318:	8080030b 	ldhu	r2,12(r16)
 800931c:	10bfffcc 	andi	r2,r2,65535
 8009320:	1080040c 	andi	r2,r2,16
 8009324:	1000081e 	bne	r2,zero,8009348 <__swsetup_r+0x80>
        {
	  ptr->_errno = EBADF;
 8009328:	e0bffe17 	ldw	r2,-8(fp)
 800932c:	00c00244 	movi	r3,9
 8009330:	10c00015 	stw	r3,0(r2)
	  fp->_flags |= __SERR;
 8009334:	8080030b 	ldhu	r2,12(r16)
 8009338:	10801014 	ori	r2,r2,64
 800933c:	8080030d 	sth	r2,12(r16)
	  return EOF;
 8009340:	00bfffc4 	movi	r2,-1
 8009344:	00004206 	br	8009450 <__swsetup_r+0x188>
        }
      if (fp->_flags & __SRD)
 8009348:	8080030b 	ldhu	r2,12(r16)
 800934c:	10bfffcc 	andi	r2,r2,65535
 8009350:	1080010c 	andi	r2,r2,4
 8009354:	10001126 	beq	r2,zero,800939c <__swsetup_r+0xd4>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
 8009358:	80800c17 	ldw	r2,48(r16)
 800935c:	10000826 	beq	r2,zero,8009380 <__swsetup_r+0xb8>
	    FREEUB (ptr, fp);
 8009360:	80c00c17 	ldw	r3,48(r16)
 8009364:	80801004 	addi	r2,r16,64
 8009368:	18800426 	beq	r3,r2,800937c <__swsetup_r+0xb4>
 800936c:	80800c17 	ldw	r2,48(r16)
 8009370:	100b883a 	mov	r5,r2
 8009374:	e13ffe17 	ldw	r4,-8(fp)
 8009378:	8009a0c0 	call	8009a0c <_free_r>
 800937c:	80000c15 	stw	zero,48(r16)
	  fp->_flags &= ~(__SRD | __SEOF);
 8009380:	80c0030b 	ldhu	r3,12(r16)
 8009384:	00bff6c4 	movi	r2,-37
 8009388:	1884703a 	and	r2,r3,r2
 800938c:	8080030d 	sth	r2,12(r16)
	  fp->_r = 0;
 8009390:	80000115 	stw	zero,4(r16)
	  fp->_p = fp->_bf._base;
 8009394:	80800417 	ldw	r2,16(r16)
 8009398:	80800015 	stw	r2,0(r16)
	}
      fp->_flags |= __SWR;
 800939c:	8080030b 	ldhu	r2,12(r16)
 80093a0:	10800214 	ori	r2,r2,8
 80093a4:	8080030d 	sth	r2,12(r16)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
 80093a8:	80800417 	ldw	r2,16(r16)
 80093ac:	10000b1e 	bne	r2,zero,80093dc <__swsetup_r+0x114>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
 80093b0:	8080030b 	ldhu	r2,12(r16)
 80093b4:	10bfffcc 	andi	r2,r2,65535
 80093b8:	1080800c 	andi	r2,r2,512
 80093bc:	10000426 	beq	r2,zero,80093d0 <__swsetup_r+0x108>
 80093c0:	8080030b 	ldhu	r2,12(r16)
 80093c4:	10bfffcc 	andi	r2,r2,65535
 80093c8:	1080200c 	andi	r2,r2,128
 80093cc:	10000326 	beq	r2,zero,80093dc <__swsetup_r+0x114>
    __smakebuf_r (ptr, fp);
 80093d0:	800b883a 	mov	r5,r16
 80093d4:	e13ffe17 	ldw	r4,-8(fp)
 80093d8:	800a1a80 	call	800a1a8 <__smakebuf_r>

  if (fp->_flags & __SLBF)
 80093dc:	8080030b 	ldhu	r2,12(r16)
 80093e0:	10bfffcc 	andi	r2,r2,65535
 80093e4:	1080004c 	andi	r2,r2,1
 80093e8:	10000526 	beq	r2,zero,8009400 <__swsetup_r+0x138>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
 80093ec:	80000215 	stw	zero,8(r16)
      fp->_lbfsize = -fp->_bf._size;
 80093f0:	80800517 	ldw	r2,20(r16)
 80093f4:	0085c83a 	sub	r2,zero,r2
 80093f8:	80800615 	stw	r2,24(r16)
 80093fc:	00000806 	br	8009420 <__swsetup_r+0x158>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
 8009400:	8080030b 	ldhu	r2,12(r16)
 8009404:	10bfffcc 	andi	r2,r2,65535
 8009408:	1080008c 	andi	r2,r2,2
 800940c:	1000021e 	bne	r2,zero,8009418 <__swsetup_r+0x150>
 8009410:	80800517 	ldw	r2,20(r16)
 8009414:	00000106 	br	800941c <__swsetup_r+0x154>
 8009418:	0005883a 	mov	r2,zero
 800941c:	80800215 	stw	r2,8(r16)

  if (!fp->_bf._base && (fp->_flags & __SMBF))
 8009420:	80800417 	ldw	r2,16(r16)
 8009424:	1000091e 	bne	r2,zero,800944c <__swsetup_r+0x184>
 8009428:	8080030b 	ldhu	r2,12(r16)
 800942c:	10bfffcc 	andi	r2,r2,65535
 8009430:	1080200c 	andi	r2,r2,128
 8009434:	10000526 	beq	r2,zero,800944c <__swsetup_r+0x184>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
 8009438:	8080030b 	ldhu	r2,12(r16)
 800943c:	10801014 	ori	r2,r2,64
 8009440:	8080030d 	sth	r2,12(r16)
      return EOF;
 8009444:	00bfffc4 	movi	r2,-1
 8009448:	00000106 	br	8009450 <__swsetup_r+0x188>
    }
  return 0;
 800944c:	0005883a 	mov	r2,zero
}
 8009450:	e6ffff04 	addi	sp,fp,-4
 8009454:	dfc00217 	ldw	ra,8(sp)
 8009458:	df000117 	ldw	fp,4(sp)
 800945c:	dc000017 	ldw	r16,0(sp)
 8009460:	dec00304 	addi	sp,sp,12
 8009464:	f800283a 	ret

08009468 <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 8009468:	defffb04 	addi	sp,sp,-20
 800946c:	dfc00415 	stw	ra,16(sp)
 8009470:	df000315 	stw	fp,12(sp)
 8009474:	df000304 	addi	fp,sp,12
 8009478:	e13ffe15 	stw	r4,-8(fp)
 800947c:	e17fff15 	stw	r5,-4(fp)
  int ret;

  errno = 0;
 8009480:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = _close (fd)) == -1 && errno != 0)
 8009484:	e13fff17 	ldw	r4,-4(fp)
 8009488:	800a5480 	call	800a548 <close>
 800948c:	e0bffd15 	stw	r2,-12(fp)
 8009490:	e0bffd17 	ldw	r2,-12(fp)
 8009494:	10bfffd8 	cmpnei	r2,r2,-1
 8009498:	1000051e 	bne	r2,zero,80094b0 <_close_r+0x48>
 800949c:	d0a76a17 	ldw	r2,-25176(gp)
 80094a0:	10000326 	beq	r2,zero,80094b0 <_close_r+0x48>
    ptr->_errno = errno;
 80094a4:	d0e76a17 	ldw	r3,-25176(gp)
 80094a8:	e0bffe17 	ldw	r2,-8(fp)
 80094ac:	10c00015 	stw	r3,0(r2)
  return ret;
 80094b0:	e0bffd17 	ldw	r2,-12(fp)
}
 80094b4:	e037883a 	mov	sp,fp
 80094b8:	dfc00117 	ldw	ra,4(sp)
 80094bc:	df000017 	ldw	fp,0(sp)
 80094c0:	dec00204 	addi	sp,sp,8
 80094c4:	f800283a 	ret

080094c8 <_fclose_r>:

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
 80094c8:	defffa04 	addi	sp,sp,-24
 80094cc:	dfc00515 	stw	ra,20(sp)
 80094d0:	df000415 	stw	fp,16(sp)
 80094d4:	dc000315 	stw	r16,12(sp)
 80094d8:	df000404 	addi	fp,sp,16
 80094dc:	e13ffe15 	stw	r4,-8(fp)
 80094e0:	2821883a 	mov	r16,r5
  int r;

  if (fp == NULL)
 80094e4:	8000021e 	bne	r16,zero,80094f0 <_fclose_r+0x28>
    return (0);			/* on NULL */
 80094e8:	0005883a 	mov	r2,zero
 80094ec:	00003b06 	br	80095dc <_fclose_r+0x114>

  CHECK_INIT (rptr, fp);
 80094f0:	e0bffe17 	ldw	r2,-8(fp)
 80094f4:	e0bffd15 	stw	r2,-12(fp)
 80094f8:	e0bffd17 	ldw	r2,-12(fp)
 80094fc:	10000526 	beq	r2,zero,8009514 <_fclose_r+0x4c>
 8009500:	e0bffd17 	ldw	r2,-12(fp)
 8009504:	10800e17 	ldw	r2,56(r2)
 8009508:	1000021e 	bne	r2,zero,8009514 <_fclose_r+0x4c>
 800950c:	e13ffd17 	ldw	r4,-12(fp)
 8009510:	80063a40 	call	80063a4 <__sinit>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
 8009514:	8080030b 	ldhu	r2,12(r16)
 8009518:	10bfffcc 	andi	r2,r2,65535
 800951c:	10a0001c 	xori	r2,r2,32768
 8009520:	10a00004 	addi	r2,r2,-32768
 8009524:	1000021e 	bne	r2,zero,8009530 <_fclose_r+0x68>
    {
      _funlockfile (fp);
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
 8009528:	0005883a 	mov	r2,zero
 800952c:	00002b06 	br	80095dc <_fclose_r+0x114>
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
 8009530:	800b883a 	mov	r5,r16
 8009534:	e13ffe17 	ldw	r4,-8(fp)
 8009538:	800962c0 	call	800962c <__sflush_r>
 800953c:	e0bffc15 	stw	r2,-16(fp)
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
 8009540:	80800b17 	ldw	r2,44(r16)
 8009544:	10000826 	beq	r2,zero,8009568 <_fclose_r+0xa0>
 8009548:	80800b17 	ldw	r2,44(r16)
 800954c:	80c00717 	ldw	r3,28(r16)
 8009550:	180b883a 	mov	r5,r3
 8009554:	e13ffe17 	ldw	r4,-8(fp)
 8009558:	103ee83a 	callr	r2
 800955c:	1000020e 	bge	r2,zero,8009568 <_fclose_r+0xa0>
    r = EOF;
 8009560:	00bfffc4 	movi	r2,-1
 8009564:	e0bffc15 	stw	r2,-16(fp)
  if (fp->_flags & __SMBF)
 8009568:	8080030b 	ldhu	r2,12(r16)
 800956c:	10bfffcc 	andi	r2,r2,65535
 8009570:	1080200c 	andi	r2,r2,128
 8009574:	10000426 	beq	r2,zero,8009588 <_fclose_r+0xc0>
    _free_r (rptr, (char *) fp->_bf._base);
 8009578:	80800417 	ldw	r2,16(r16)
 800957c:	100b883a 	mov	r5,r2
 8009580:	e13ffe17 	ldw	r4,-8(fp)
 8009584:	8009a0c0 	call	8009a0c <_free_r>
  if (HASUB (fp))
 8009588:	80800c17 	ldw	r2,48(r16)
 800958c:	10000826 	beq	r2,zero,80095b0 <_fclose_r+0xe8>
    FREEUB (rptr, fp);
 8009590:	80c00c17 	ldw	r3,48(r16)
 8009594:	80801004 	addi	r2,r16,64
 8009598:	18800426 	beq	r3,r2,80095ac <_fclose_r+0xe4>
 800959c:	80800c17 	ldw	r2,48(r16)
 80095a0:	100b883a 	mov	r5,r2
 80095a4:	e13ffe17 	ldw	r4,-8(fp)
 80095a8:	8009a0c0 	call	8009a0c <_free_r>
 80095ac:	80000c15 	stw	zero,48(r16)
  if (HASLB (fp))
 80095b0:	80801117 	ldw	r2,68(r16)
 80095b4:	10000526 	beq	r2,zero,80095cc <_fclose_r+0x104>
    FREELB (rptr, fp);
 80095b8:	80801117 	ldw	r2,68(r16)
 80095bc:	100b883a 	mov	r5,r2
 80095c0:	e13ffe17 	ldw	r4,-8(fp)
 80095c4:	8009a0c0 	call	8009a0c <_free_r>
 80095c8:	80001115 	stw	zero,68(r16)
  __sfp_lock_acquire ();
 80095cc:	800647c0 	call	800647c <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
 80095d0:	8000030d 	sth	zero,12(r16)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
 80095d4:	800649c0 	call	800649c <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
 80095d8:	e0bffc17 	ldw	r2,-16(fp)
}
 80095dc:	e6ffff04 	addi	sp,fp,-4
 80095e0:	dfc00217 	ldw	ra,8(sp)
 80095e4:	df000117 	ldw	fp,4(sp)
 80095e8:	dc000017 	ldw	r16,0(sp)
 80095ec:	dec00304 	addi	sp,sp,12
 80095f0:	f800283a 	ret

080095f4 <fclose>:
#ifndef _REENT_ONLY

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
 80095f4:	defffe04 	addi	sp,sp,-8
 80095f8:	dfc00115 	stw	ra,4(sp)
 80095fc:	df000015 	stw	fp,0(sp)
 8009600:	d839883a 	mov	fp,sp
 8009604:	2007883a 	mov	r3,r4
  return _fclose_r(_REENT, fp);
 8009608:	d0a04217 	ldw	r2,-32504(gp)
 800960c:	180b883a 	mov	r5,r3
 8009610:	1009883a 	mov	r4,r2
 8009614:	80094c80 	call	80094c8 <_fclose_r>
}
 8009618:	e037883a 	mov	sp,fp
 800961c:	dfc00117 	ldw	ra,4(sp)
 8009620:	df000017 	ldw	fp,0(sp)
 8009624:	dec00204 	addi	sp,sp,8
 8009628:	f800283a 	ret

0800962c <__sflush_r>:
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 800962c:	defff504 	addi	sp,sp,-44
 8009630:	dfc00a15 	stw	ra,40(sp)
 8009634:	df000915 	stw	fp,36(sp)
 8009638:	dcc00815 	stw	r19,32(sp)
 800963c:	dc800715 	stw	r18,28(sp)
 8009640:	dc400615 	stw	r17,24(sp)
 8009644:	dc000515 	stw	r16,20(sp)
 8009648:	df000904 	addi	fp,sp,36
 800964c:	e13ffb15 	stw	r4,-20(fp)
 8009650:	2821883a 	mov	r16,r5
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
 8009654:	8080030b 	ldhu	r2,12(r16)
 8009658:	e0bff90d 	sth	r2,-28(fp)
  if ((flags & __SWR) == 0)
 800965c:	e0bff90b 	ldhu	r2,-28(fp)
 8009660:	10bfffcc 	andi	r2,r2,65535
 8009664:	1080020c 	andi	r2,r2,8
 8009668:	1000831e 	bne	r2,zero,8009878 <__sflush_r+0x24c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
 800966c:	8080030b 	ldhu	r2,12(r16)
 8009670:	10820014 	ori	r2,r2,2048
 8009674:	8080030d 	sth	r2,12(r16)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
 8009678:	80800117 	ldw	r2,4(r16)
 800967c:	00800216 	blt	zero,r2,8009688 <__sflush_r+0x5c>
 8009680:	80800f17 	ldw	r2,60(r16)
 8009684:	00807a0e 	bge	zero,r2,8009870 <__sflush_r+0x244>
 8009688:	80800a17 	ldw	r2,40(r16)
 800968c:	10007826 	beq	r2,zero,8009870 <__sflush_r+0x244>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
 8009690:	e0bffb17 	ldw	r2,-20(fp)
 8009694:	10800017 	ldw	r2,0(r2)
 8009698:	e0bffa15 	stw	r2,-24(fp)
	  ptr->_errno = 0;
 800969c:	e0bffb17 	ldw	r2,-20(fp)
 80096a0:	10000015 	stw	zero,0(r2)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
 80096a4:	8080030b 	ldhu	r2,12(r16)
 80096a8:	10bfffcc 	andi	r2,r2,65535
 80096ac:	1084000c 	andi	r2,r2,4096
 80096b0:	10000326 	beq	r2,zero,80096c0 <__sflush_r+0x94>
	    curoff = fp->_offset;
 80096b4:	80801417 	ldw	r2,80(r16)
 80096b8:	e0bff715 	stw	r2,-36(fp)
 80096bc:	00002206 	br	8009748 <__sflush_r+0x11c>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
 80096c0:	80800a17 	ldw	r2,40(r16)
 80096c4:	80c00717 	ldw	r3,28(r16)
 80096c8:	01c00044 	movi	r7,1
 80096cc:	000d883a 	mov	r6,zero
 80096d0:	180b883a 	mov	r5,r3
 80096d4:	e13ffb17 	ldw	r4,-20(fp)
 80096d8:	103ee83a 	callr	r2
 80096dc:	e0bff715 	stw	r2,-36(fp)
	      if (curoff == -1L && ptr->_errno != 0)
 80096e0:	e0bff717 	ldw	r2,-36(fp)
 80096e4:	10bfffd8 	cmpnei	r2,r2,-1
 80096e8:	1000171e 	bne	r2,zero,8009748 <__sflush_r+0x11c>
 80096ec:	e0bffb17 	ldw	r2,-20(fp)
 80096f0:	10800017 	ldw	r2,0(r2)
 80096f4:	10001426 	beq	r2,zero,8009748 <__sflush_r+0x11c>
		{
		  int result = EOF;
 80096f8:	00bfffc4 	movi	r2,-1
 80096fc:	e0bff815 	stw	r2,-32(fp)
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 8009700:	e0bffb17 	ldw	r2,-20(fp)
 8009704:	10800017 	ldw	r2,0(r2)
 8009708:	10800760 	cmpeqi	r2,r2,29
 800970c:	1000041e 	bne	r2,zero,8009720 <__sflush_r+0xf4>
 8009710:	e0bffb17 	ldw	r2,-20(fp)
 8009714:	10800017 	ldw	r2,0(r2)
 8009718:	10800598 	cmpnei	r2,r2,22
 800971c:	1000051e 	bne	r2,zero,8009734 <__sflush_r+0x108>
		    {
		      result = 0;
 8009720:	e03ff815 	stw	zero,-32(fp)
		      ptr->_errno = tmp_errno;
 8009724:	e0bffb17 	ldw	r2,-20(fp)
 8009728:	e0fffa17 	ldw	r3,-24(fp)
 800972c:	10c00015 	stw	r3,0(r2)
 8009730:	00000306 	br	8009740 <__sflush_r+0x114>
		    }
		  else
		    fp->_flags |= __SERR;
 8009734:	8080030b 	ldhu	r2,12(r16)
 8009738:	10801014 	ori	r2,r2,64
 800973c:	8080030d 	sth	r2,12(r16)
		  return result;
 8009740:	e0bff817 	ldw	r2,-32(fp)
 8009744:	00007106 	br	800990c <__sflush_r+0x2e0>
		}
            }
          if (fp->_flags & __SRD)
 8009748:	8080030b 	ldhu	r2,12(r16)
 800974c:	10bfffcc 	andi	r2,r2,65535
 8009750:	1080010c 	andi	r2,r2,4
 8009754:	10000a26 	beq	r2,zero,8009780 <__sflush_r+0x154>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
 8009758:	80800117 	ldw	r2,4(r16)
 800975c:	e0fff717 	ldw	r3,-36(fp)
 8009760:	1885c83a 	sub	r2,r3,r2
 8009764:	e0bff715 	stw	r2,-36(fp)
              if (HASUB (fp))
 8009768:	80800c17 	ldw	r2,48(r16)
 800976c:	10000426 	beq	r2,zero,8009780 <__sflush_r+0x154>
                curoff -= fp->_ur;
 8009770:	80800f17 	ldw	r2,60(r16)
 8009774:	e0fff717 	ldw	r3,-36(fp)
 8009778:	1885c83a 	sub	r2,r3,r2
 800977c:	e0bff715 	stw	r2,-36(fp)
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
 8009780:	80800a17 	ldw	r2,40(r16)
 8009784:	80c00717 	ldw	r3,28(r16)
 8009788:	000f883a 	mov	r7,zero
 800978c:	e1bff717 	ldw	r6,-36(fp)
 8009790:	180b883a 	mov	r5,r3
 8009794:	e13ffb17 	ldw	r4,-20(fp)
 8009798:	103ee83a 	callr	r2
 800979c:	e0bff715 	stw	r2,-36(fp)
	  if (curoff != -1 || ptr->_errno == 0
 80097a0:	e0bff717 	ldw	r2,-36(fp)
 80097a4:	10bfffd8 	cmpnei	r2,r2,-1
 80097a8:	10000b1e 	bne	r2,zero,80097d8 <__sflush_r+0x1ac>
 80097ac:	e0bffb17 	ldw	r2,-20(fp)
 80097b0:	10800017 	ldw	r2,0(r2)
 80097b4:	10000826 	beq	r2,zero,80097d8 <__sflush_r+0x1ac>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 80097b8:	e0bffb17 	ldw	r2,-20(fp)
 80097bc:	10800017 	ldw	r2,0(r2)
 80097c0:	10800760 	cmpeqi	r2,r2,29
 80097c4:	1000041e 	bne	r2,zero,80097d8 <__sflush_r+0x1ac>
 80097c8:	e0bffb17 	ldw	r2,-20(fp)
 80097cc:	10800017 	ldw	r2,0(r2)
 80097d0:	10800598 	cmpnei	r2,r2,22
 80097d4:	1000211e 	bne	r2,zero,800985c <__sflush_r+0x230>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
 80097d8:	80c0030b 	ldhu	r3,12(r16)
 80097dc:	00bdffc4 	movi	r2,-2049
 80097e0:	1884703a 	and	r2,r3,r2
 80097e4:	8080030d 	sth	r2,12(r16)
#endif
	      fp->_r = 0;
 80097e8:	80000115 	stw	zero,4(r16)
	      fp->_p = fp->_bf._base;
 80097ec:	80800417 	ldw	r2,16(r16)
 80097f0:	80800015 	stw	r2,0(r16)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
 80097f4:	8080030b 	ldhu	r2,12(r16)
 80097f8:	10bfffcc 	andi	r2,r2,65535
 80097fc:	1084000c 	andi	r2,r2,4096
 8009800:	10000826 	beq	r2,zero,8009824 <__sflush_r+0x1f8>
 8009804:	e0bff717 	ldw	r2,-36(fp)
 8009808:	10bfffd8 	cmpnei	r2,r2,-1
 800980c:	1000031e 	bne	r2,zero,800981c <__sflush_r+0x1f0>
 8009810:	e0bffb17 	ldw	r2,-20(fp)
 8009814:	10800017 	ldw	r2,0(r2)
 8009818:	1000021e 	bne	r2,zero,8009824 <__sflush_r+0x1f8>
		fp->_offset = curoff;
 800981c:	e0bff717 	ldw	r2,-36(fp)
 8009820:	80801415 	stw	r2,80(r16)
	      ptr->_errno = tmp_errno;
 8009824:	e0bffb17 	ldw	r2,-20(fp)
 8009828:	e0fffa17 	ldw	r3,-24(fp)
 800982c:	10c00015 	stw	r3,0(r2)
	      if (HASUB (fp))
 8009830:	80800c17 	ldw	r2,48(r16)
 8009834:	10000e26 	beq	r2,zero,8009870 <__sflush_r+0x244>
		FREEUB (ptr, fp);
 8009838:	80c00c17 	ldw	r3,48(r16)
 800983c:	80801004 	addi	r2,r16,64
 8009840:	18800426 	beq	r3,r2,8009854 <__sflush_r+0x228>
 8009844:	80800c17 	ldw	r2,48(r16)
 8009848:	100b883a 	mov	r5,r2
 800984c:	e13ffb17 	ldw	r4,-20(fp)
 8009850:	8009a0c0 	call	8009a0c <_free_r>
 8009854:	80000c15 	stw	zero,48(r16)
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
 8009858:	00000506 	br	8009870 <__sflush_r+0x244>
		FREEUB (ptr, fp);
	    }
	  else
	    {
	      fp->_flags |= __SERR;
 800985c:	8080030b 	ldhu	r2,12(r16)
 8009860:	10801014 	ori	r2,r2,64
 8009864:	8080030d 	sth	r2,12(r16)
	      return EOF;
 8009868:	00bfffc4 	movi	r2,-1
 800986c:	00002706 	br	800990c <__sflush_r+0x2e0>
	    }
	}
      return 0;
 8009870:	0005883a 	mov	r2,zero
 8009874:	00002506 	br	800990c <__sflush_r+0x2e0>
    }
  if ((p = fp->_bf._base) == NULL)
 8009878:	84400417 	ldw	r17,16(r16)
 800987c:	8800021e 	bne	r17,zero,8009888 <__sflush_r+0x25c>
    {
      /* Nothing to flush.  */
      return 0;
 8009880:	0005883a 	mov	r2,zero
 8009884:	00002106 	br	800990c <__sflush_r+0x2e0>
    }
  n = fp->_p - p;		/* write this much */
 8009888:	80800017 	ldw	r2,0(r16)
 800988c:	1007883a 	mov	r3,r2
 8009890:	8805883a 	mov	r2,r17
 8009894:	18a5c83a 	sub	r18,r3,r2
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
 8009898:	84400015 	stw	r17,0(r16)
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
 800989c:	e0bff90b 	ldhu	r2,-28(fp)
 80098a0:	10bfffcc 	andi	r2,r2,65535
 80098a4:	108000cc 	andi	r2,r2,3
 80098a8:	1000021e 	bne	r2,zero,80098b4 <__sflush_r+0x288>
 80098ac:	80800517 	ldw	r2,20(r16)
 80098b0:	00000106 	br	80098b8 <__sflush_r+0x28c>
 80098b4:	0005883a 	mov	r2,zero
 80098b8:	80800215 	stw	r2,8(r16)

  while (n > 0)
 80098bc:	00001106 	br	8009904 <__sflush_r+0x2d8>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
 80098c0:	80800917 	ldw	r2,36(r16)
 80098c4:	80c00717 	ldw	r3,28(r16)
 80098c8:	900f883a 	mov	r7,r18
 80098cc:	880d883a 	mov	r6,r17
 80098d0:	180b883a 	mov	r5,r3
 80098d4:	e13ffb17 	ldw	r4,-20(fp)
 80098d8:	103ee83a 	callr	r2
 80098dc:	1027883a 	mov	r19,r2
      if (t <= 0)
 80098e0:	04c00516 	blt	zero,r19,80098f8 <__sflush_r+0x2cc>
	{
          fp->_flags |= __SERR;
 80098e4:	8080030b 	ldhu	r2,12(r16)
 80098e8:	10801014 	ori	r2,r2,64
 80098ec:	8080030d 	sth	r2,12(r16)
          return EOF;
 80098f0:	00bfffc4 	movi	r2,-1
 80098f4:	00000506 	br	800990c <__sflush_r+0x2e0>
	}
      p += t;
 80098f8:	9805883a 	mov	r2,r19
 80098fc:	88a3883a 	add	r17,r17,r2
      n -= t;
 8009900:	94e5c83a 	sub	r18,r18,r19
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
 8009904:	04bfee16 	blt	zero,r18,80098c0 <__sflush_r+0x294>
          return EOF;
	}
      p += t;
      n -= t;
    }
  return 0;
 8009908:	0005883a 	mov	r2,zero
}
 800990c:	e6fffc04 	addi	sp,fp,-16
 8009910:	dfc00517 	ldw	ra,20(sp)
 8009914:	df000417 	ldw	fp,16(sp)
 8009918:	dcc00317 	ldw	r19,12(sp)
 800991c:	dc800217 	ldw	r18,8(sp)
 8009920:	dc400117 	ldw	r17,4(sp)
 8009924:	dc000017 	ldw	r16,0(sp)
 8009928:	dec00604 	addi	sp,sp,24
 800992c:	f800283a 	ret

08009930 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 8009930:	defffa04 	addi	sp,sp,-24
 8009934:	dfc00515 	stw	ra,20(sp)
 8009938:	df000415 	stw	fp,16(sp)
 800993c:	dc000315 	stw	r16,12(sp)
 8009940:	df000404 	addi	fp,sp,16
 8009944:	e13ffe15 	stw	r4,-8(fp)
 8009948:	2821883a 	mov	r16,r5
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
 800994c:	e0bffe17 	ldw	r2,-8(fp)
 8009950:	e0bffc15 	stw	r2,-16(fp)
 8009954:	e0bffc17 	ldw	r2,-16(fp)
 8009958:	10000526 	beq	r2,zero,8009970 <_fflush_r+0x40>
 800995c:	e0bffc17 	ldw	r2,-16(fp)
 8009960:	10800e17 	ldw	r2,56(r2)
 8009964:	1000021e 	bne	r2,zero,8009970 <_fflush_r+0x40>
 8009968:	e13ffc17 	ldw	r4,-16(fp)
 800996c:	80063a40 	call	80063a4 <__sinit>

  if (!fp->_flags)
 8009970:	8080030b 	ldhu	r2,12(r16)
 8009974:	10bfffcc 	andi	r2,r2,65535
 8009978:	10a0001c 	xori	r2,r2,32768
 800997c:	10a00004 	addi	r2,r2,-32768
 8009980:	1000021e 	bne	r2,zero,800998c <_fflush_r+0x5c>
    return 0;
 8009984:	0005883a 	mov	r2,zero
 8009988:	00000506 	br	80099a0 <_fflush_r+0x70>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
 800998c:	800b883a 	mov	r5,r16
 8009990:	e13ffe17 	ldw	r4,-8(fp)
 8009994:	800962c0 	call	800962c <__sflush_r>
 8009998:	e0bffd15 	stw	r2,-12(fp)
  _newlib_flockfile_end (fp);
  return ret;
 800999c:	e0bffd17 	ldw	r2,-12(fp)
}
 80099a0:	e6ffff04 	addi	sp,fp,-4
 80099a4:	dfc00217 	ldw	ra,8(sp)
 80099a8:	df000117 	ldw	fp,4(sp)
 80099ac:	dc000017 	ldw	r16,0(sp)
 80099b0:	dec00304 	addi	sp,sp,12
 80099b4:	f800283a 	ret

080099b8 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
 80099b8:	defffe04 	addi	sp,sp,-8
 80099bc:	dfc00115 	stw	ra,4(sp)
 80099c0:	df000015 	stw	fp,0(sp)
 80099c4:	d839883a 	mov	fp,sp
 80099c8:	2005883a 	mov	r2,r4
  if (fp == NULL)
 80099cc:	1000061e 	bne	r2,zero,80099e8 <fflush+0x30>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
 80099d0:	d0a04317 	ldw	r2,-32500(gp)
 80099d4:	01420074 	movhi	r5,2049
 80099d8:	29664c04 	addi	r5,r5,-26320
 80099dc:	1009883a 	mov	r4,r2
 80099e0:	8006c780 	call	8006c78 <_fwalk_reent>
 80099e4:	00000406 	br	80099f8 <fflush+0x40>

  return _fflush_r (_REENT, fp);
 80099e8:	d0e04217 	ldw	r3,-32504(gp)
 80099ec:	100b883a 	mov	r5,r2
 80099f0:	1809883a 	mov	r4,r3
 80099f4:	80099300 	call	8009930 <_fflush_r>
}
 80099f8:	e037883a 	mov	sp,fp
 80099fc:	dfc00117 	ldw	ra,4(sp)
 8009a00:	df000017 	ldw	fp,0(sp)
 8009a04:	dec00204 	addi	sp,sp,8
 8009a08:	f800283a 	ret

08009a0c <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
 8009a0c:	defff204 	addi	sp,sp,-56
 8009a10:	dfc00d15 	stw	ra,52(sp)
 8009a14:	df000c15 	stw	fp,48(sp)
 8009a18:	df000c04 	addi	fp,sp,48
 8009a1c:	e13ffe15 	stw	r4,-8(fp)
 8009a20:	e17fff15 	stw	r5,-4(fp)
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
 8009a24:	e0bfff17 	ldw	r2,-4(fp)
 8009a28:	10014a26 	beq	r2,zero,8009f54 <_free_r+0x548>
    return;

  MALLOC_LOCK;
 8009a2c:	e13ffe17 	ldw	r4,-8(fp)
 8009a30:	800aa6c0 	call	800aa6c <__malloc_lock>

  p = mem2chunk(mem);
 8009a34:	e0bfff17 	ldw	r2,-4(fp)
 8009a38:	10bffe04 	addi	r2,r2,-8
 8009a3c:	e0bff415 	stw	r2,-48(fp)
  hd = p->size;
 8009a40:	e0bff417 	ldw	r2,-48(fp)
 8009a44:	10800117 	ldw	r2,4(r2)
 8009a48:	e0bff915 	stw	r2,-28(fp)
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
 8009a4c:	e0fff917 	ldw	r3,-28(fp)
 8009a50:	00bfff84 	movi	r2,-2
 8009a54:	1884703a 	and	r2,r3,r2
 8009a58:	e0bff515 	stw	r2,-44(fp)
  next = chunk_at_offset(p, sz);
 8009a5c:	e0fff417 	ldw	r3,-48(fp)
 8009a60:	e0bff517 	ldw	r2,-44(fp)
 8009a64:	1885883a 	add	r2,r3,r2
 8009a68:	e0bffa15 	stw	r2,-24(fp)
  nextsz = chunksize(next);
 8009a6c:	e0bffa17 	ldw	r2,-24(fp)
 8009a70:	10c00117 	ldw	r3,4(r2)
 8009a74:	00bfff04 	movi	r2,-4
 8009a78:	1884703a 	and	r2,r3,r2
 8009a7c:	e0bffb15 	stw	r2,-20(fp)
  
  if (next == top)                            /* merge with top */
 8009a80:	00820134 	movhi	r2,2052
 8009a84:	109a9f04 	addi	r2,r2,27260
 8009a88:	10c00217 	ldw	r3,8(r2)
 8009a8c:	e0bffa17 	ldw	r2,-24(fp)
 8009a90:	1880311e 	bne	r3,r2,8009b58 <_free_r+0x14c>
  {
    sz += nextsz;
 8009a94:	e0fff517 	ldw	r3,-44(fp)
 8009a98:	e0bffb17 	ldw	r2,-20(fp)
 8009a9c:	1885883a 	add	r2,r3,r2
 8009aa0:	e0bff515 	stw	r2,-44(fp)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
 8009aa4:	e0bff917 	ldw	r2,-28(fp)
 8009aa8:	1080004c 	andi	r2,r2,1
 8009aac:	1000181e 	bne	r2,zero,8009b10 <_free_r+0x104>
    {
      prevsz = p->prev_size;
 8009ab0:	e0bff417 	ldw	r2,-48(fp)
 8009ab4:	10800017 	ldw	r2,0(r2)
 8009ab8:	e0bffc15 	stw	r2,-16(fp)
      p = chunk_at_offset(p, -prevsz);
 8009abc:	e0bffc17 	ldw	r2,-16(fp)
 8009ac0:	0085c83a 	sub	r2,zero,r2
 8009ac4:	e0fff417 	ldw	r3,-48(fp)
 8009ac8:	1885883a 	add	r2,r3,r2
 8009acc:	e0bff415 	stw	r2,-48(fp)
      sz += prevsz;
 8009ad0:	e0fff517 	ldw	r3,-44(fp)
 8009ad4:	e0bffc17 	ldw	r2,-16(fp)
 8009ad8:	1885883a 	add	r2,r3,r2
 8009adc:	e0bff515 	stw	r2,-44(fp)
      unlink(p, bck, fwd);
 8009ae0:	e0bff417 	ldw	r2,-48(fp)
 8009ae4:	10800317 	ldw	r2,12(r2)
 8009ae8:	e0bff615 	stw	r2,-40(fp)
 8009aec:	e0bff417 	ldw	r2,-48(fp)
 8009af0:	10800217 	ldw	r2,8(r2)
 8009af4:	e0bff715 	stw	r2,-36(fp)
 8009af8:	e0bff717 	ldw	r2,-36(fp)
 8009afc:	e0fff617 	ldw	r3,-40(fp)
 8009b00:	10c00315 	stw	r3,12(r2)
 8009b04:	e0bff617 	ldw	r2,-40(fp)
 8009b08:	e0fff717 	ldw	r3,-36(fp)
 8009b0c:	10c00215 	stw	r3,8(r2)
    }

    set_head(p, sz | PREV_INUSE);
 8009b10:	e0bff517 	ldw	r2,-44(fp)
 8009b14:	10c00054 	ori	r3,r2,1
 8009b18:	e0bff417 	ldw	r2,-48(fp)
 8009b1c:	10c00115 	stw	r3,4(r2)
    top = p;
 8009b20:	00820134 	movhi	r2,2052
 8009b24:	109a9f04 	addi	r2,r2,27260
 8009b28:	e0fff417 	ldw	r3,-48(fp)
 8009b2c:	10c00215 	stw	r3,8(r2)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
 8009b30:	d0a04417 	ldw	r2,-32496(gp)
 8009b34:	e0fff517 	ldw	r3,-44(fp)
 8009b38:	18800436 	bltu	r3,r2,8009b4c <_free_r+0x140>
      malloc_trim(RCALL top_pad); 
 8009b3c:	d0a76717 	ldw	r2,-25188(gp)
 8009b40:	100b883a 	mov	r5,r2
 8009b44:	e13ffe17 	ldw	r4,-8(fp)
 8009b48:	8009f6c0 	call	8009f6c <_malloc_trim_r>
    MALLOC_UNLOCK;
 8009b4c:	e13ffe17 	ldw	r4,-8(fp)
 8009b50:	800aa900 	call	800aa90 <__malloc_unlock>
    return;
 8009b54:	00010006 	br	8009f58 <_free_r+0x54c>
  }

  set_head(next, nextsz);                    /* clear inuse bit */
 8009b58:	e0bffa17 	ldw	r2,-24(fp)
 8009b5c:	e0fffb17 	ldw	r3,-20(fp)
 8009b60:	10c00115 	stw	r3,4(r2)

  islr = 0;
 8009b64:	e03ff815 	stw	zero,-32(fp)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
 8009b68:	e0bff917 	ldw	r2,-28(fp)
 8009b6c:	1080004c 	andi	r2,r2,1
 8009b70:	1000201e 	bne	r2,zero,8009bf4 <_free_r+0x1e8>
  {
    prevsz = p->prev_size;
 8009b74:	e0bff417 	ldw	r2,-48(fp)
 8009b78:	10800017 	ldw	r2,0(r2)
 8009b7c:	e0bffc15 	stw	r2,-16(fp)
    p = chunk_at_offset(p, -prevsz);
 8009b80:	e0bffc17 	ldw	r2,-16(fp)
 8009b84:	0085c83a 	sub	r2,zero,r2
 8009b88:	e0fff417 	ldw	r3,-48(fp)
 8009b8c:	1885883a 	add	r2,r3,r2
 8009b90:	e0bff415 	stw	r2,-48(fp)
    sz += prevsz;
 8009b94:	e0fff517 	ldw	r3,-44(fp)
 8009b98:	e0bffc17 	ldw	r2,-16(fp)
 8009b9c:	1885883a 	add	r2,r3,r2
 8009ba0:	e0bff515 	stw	r2,-44(fp)
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
 8009ba4:	e0bff417 	ldw	r2,-48(fp)
 8009ba8:	10c00217 	ldw	r3,8(r2)
 8009bac:	00820134 	movhi	r2,2052
 8009bb0:	109aa104 	addi	r2,r2,27268
 8009bb4:	1880031e 	bne	r3,r2,8009bc4 <_free_r+0x1b8>
      islr = 1;
 8009bb8:	00800044 	movi	r2,1
 8009bbc:	e0bff815 	stw	r2,-32(fp)
 8009bc0:	00000c06 	br	8009bf4 <_free_r+0x1e8>
    else
      unlink(p, bck, fwd);
 8009bc4:	e0bff417 	ldw	r2,-48(fp)
 8009bc8:	10800317 	ldw	r2,12(r2)
 8009bcc:	e0bff615 	stw	r2,-40(fp)
 8009bd0:	e0bff417 	ldw	r2,-48(fp)
 8009bd4:	10800217 	ldw	r2,8(r2)
 8009bd8:	e0bff715 	stw	r2,-36(fp)
 8009bdc:	e0bff717 	ldw	r2,-36(fp)
 8009be0:	e0fff617 	ldw	r3,-40(fp)
 8009be4:	10c00315 	stw	r3,12(r2)
 8009be8:	e0bff617 	ldw	r2,-40(fp)
 8009bec:	e0fff717 	ldw	r3,-36(fp)
 8009bf0:	10c00215 	stw	r3,8(r2)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
 8009bf4:	e0fffa17 	ldw	r3,-24(fp)
 8009bf8:	e0bffb17 	ldw	r2,-20(fp)
 8009bfc:	1885883a 	add	r2,r3,r2
 8009c00:	10800117 	ldw	r2,4(r2)
 8009c04:	1080004c 	andi	r2,r2,1
 8009c08:	10002a1e 	bne	r2,zero,8009cb4 <_free_r+0x2a8>
  {
    sz += nextsz;
 8009c0c:	e0fff517 	ldw	r3,-44(fp)
 8009c10:	e0bffb17 	ldw	r2,-20(fp)
 8009c14:	1885883a 	add	r2,r3,r2
 8009c18:	e0bff515 	stw	r2,-44(fp)
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
 8009c1c:	e0bff817 	ldw	r2,-32(fp)
 8009c20:	1000181e 	bne	r2,zero,8009c84 <_free_r+0x278>
 8009c24:	e0bffa17 	ldw	r2,-24(fp)
 8009c28:	10c00217 	ldw	r3,8(r2)
 8009c2c:	00820134 	movhi	r2,2052
 8009c30:	109aa104 	addi	r2,r2,27268
 8009c34:	1880131e 	bne	r3,r2,8009c84 <_free_r+0x278>
    {
      islr = 1;
 8009c38:	00800044 	movi	r2,1
 8009c3c:	e0bff815 	stw	r2,-32(fp)
      link_last_remainder(p);   
 8009c40:	00c20134 	movhi	r3,2052
 8009c44:	18daa104 	addi	r3,r3,27268
 8009c48:	00820134 	movhi	r2,2052
 8009c4c:	109aa104 	addi	r2,r2,27268
 8009c50:	e13ff417 	ldw	r4,-48(fp)
 8009c54:	11000315 	stw	r4,12(r2)
 8009c58:	10800317 	ldw	r2,12(r2)
 8009c5c:	18800215 	stw	r2,8(r3)
 8009c60:	00820134 	movhi	r2,2052
 8009c64:	109aa104 	addi	r2,r2,27268
 8009c68:	e0fff417 	ldw	r3,-48(fp)
 8009c6c:	18800315 	stw	r2,12(r3)
 8009c70:	e0bff417 	ldw	r2,-48(fp)
 8009c74:	10c00317 	ldw	r3,12(r2)
 8009c78:	e0bff417 	ldw	r2,-48(fp)
 8009c7c:	10c00215 	stw	r3,8(r2)
 8009c80:	00000c06 	br	8009cb4 <_free_r+0x2a8>
    }
    else
      unlink(next, bck, fwd);
 8009c84:	e0bffa17 	ldw	r2,-24(fp)
 8009c88:	10800317 	ldw	r2,12(r2)
 8009c8c:	e0bff615 	stw	r2,-40(fp)
 8009c90:	e0bffa17 	ldw	r2,-24(fp)
 8009c94:	10800217 	ldw	r2,8(r2)
 8009c98:	e0bff715 	stw	r2,-36(fp)
 8009c9c:	e0bff717 	ldw	r2,-36(fp)
 8009ca0:	e0fff617 	ldw	r3,-40(fp)
 8009ca4:	10c00315 	stw	r3,12(r2)
 8009ca8:	e0bff617 	ldw	r2,-40(fp)
 8009cac:	e0fff717 	ldw	r3,-36(fp)
 8009cb0:	10c00215 	stw	r3,8(r2)
  }


  set_head(p, sz | PREV_INUSE);
 8009cb4:	e0bff517 	ldw	r2,-44(fp)
 8009cb8:	10c00054 	ori	r3,r2,1
 8009cbc:	e0bff417 	ldw	r2,-48(fp)
 8009cc0:	10c00115 	stw	r3,4(r2)
  set_foot(p, sz);
 8009cc4:	e0fff417 	ldw	r3,-48(fp)
 8009cc8:	e0bff517 	ldw	r2,-44(fp)
 8009ccc:	1885883a 	add	r2,r3,r2
 8009cd0:	e0fff517 	ldw	r3,-44(fp)
 8009cd4:	10c00015 	stw	r3,0(r2)
  if (!islr)
 8009cd8:	e0bff817 	ldw	r2,-32(fp)
 8009cdc:	10009a1e 	bne	r2,zero,8009f48 <_free_r+0x53c>
    frontlink(p, sz, idx, bck, fwd);  
 8009ce0:	e0bff517 	ldw	r2,-44(fp)
 8009ce4:	10808028 	cmpgeui	r2,r2,512
 8009ce8:	10002c1e 	bne	r2,zero,8009d9c <_free_r+0x390>
 8009cec:	e0bff517 	ldw	r2,-44(fp)
 8009cf0:	1004d0fa 	srli	r2,r2,3
 8009cf4:	e0bffd15 	stw	r2,-12(fp)
 8009cf8:	00c20134 	movhi	r3,2052
 8009cfc:	18da9f04 	addi	r3,r3,27260
 8009d00:	00820134 	movhi	r2,2052
 8009d04:	109a9f04 	addi	r2,r2,27260
 8009d08:	11000117 	ldw	r4,4(r2)
 8009d0c:	e0bffd17 	ldw	r2,-12(fp)
 8009d10:	1000010e 	bge	r2,zero,8009d18 <_free_r+0x30c>
 8009d14:	108000c4 	addi	r2,r2,3
 8009d18:	1005d0ba 	srai	r2,r2,2
 8009d1c:	100b883a 	mov	r5,r2
 8009d20:	00800044 	movi	r2,1
 8009d24:	1144983a 	sll	r2,r2,r5
 8009d28:	2084b03a 	or	r2,r4,r2
 8009d2c:	18800115 	stw	r2,4(r3)
 8009d30:	e0bffd17 	ldw	r2,-12(fp)
 8009d34:	10800044 	addi	r2,r2,1
 8009d38:	1085883a 	add	r2,r2,r2
 8009d3c:	1085883a 	add	r2,r2,r2
 8009d40:	1087883a 	add	r3,r2,r2
 8009d44:	00820134 	movhi	r2,2052
 8009d48:	109a9f04 	addi	r2,r2,27260
 8009d4c:	1885883a 	add	r2,r3,r2
 8009d50:	10bffe04 	addi	r2,r2,-8
 8009d54:	e0bff615 	stw	r2,-40(fp)
 8009d58:	e0bff617 	ldw	r2,-40(fp)
 8009d5c:	10800217 	ldw	r2,8(r2)
 8009d60:	e0bff715 	stw	r2,-36(fp)
 8009d64:	e0bff417 	ldw	r2,-48(fp)
 8009d68:	e0fff617 	ldw	r3,-40(fp)
 8009d6c:	10c00315 	stw	r3,12(r2)
 8009d70:	e0bff417 	ldw	r2,-48(fp)
 8009d74:	e0fff717 	ldw	r3,-36(fp)
 8009d78:	10c00215 	stw	r3,8(r2)
 8009d7c:	e0bff617 	ldw	r2,-40(fp)
 8009d80:	e0fff417 	ldw	r3,-48(fp)
 8009d84:	10c00215 	stw	r3,8(r2)
 8009d88:	e0bff617 	ldw	r2,-40(fp)
 8009d8c:	10c00217 	ldw	r3,8(r2)
 8009d90:	e0bff717 	ldw	r2,-36(fp)
 8009d94:	10c00315 	stw	r3,12(r2)
 8009d98:	00006b06 	br	8009f48 <_free_r+0x53c>
 8009d9c:	e0bff517 	ldw	r2,-44(fp)
 8009da0:	1004d27a 	srli	r2,r2,9
 8009da4:	1000031e 	bne	r2,zero,8009db4 <_free_r+0x3a8>
 8009da8:	e0bff517 	ldw	r2,-44(fp)
 8009dac:	1004d0fa 	srli	r2,r2,3
 8009db0:	00002906 	br	8009e58 <_free_r+0x44c>
 8009db4:	e0bff517 	ldw	r2,-44(fp)
 8009db8:	1004d27a 	srli	r2,r2,9
 8009dbc:	10800168 	cmpgeui	r2,r2,5
 8009dc0:	1000041e 	bne	r2,zero,8009dd4 <_free_r+0x3c8>
 8009dc4:	e0bff517 	ldw	r2,-44(fp)
 8009dc8:	1004d1ba 	srli	r2,r2,6
 8009dcc:	10800e04 	addi	r2,r2,56
 8009dd0:	00002106 	br	8009e58 <_free_r+0x44c>
 8009dd4:	e0bff517 	ldw	r2,-44(fp)
 8009dd8:	1004d27a 	srli	r2,r2,9
 8009ddc:	10800568 	cmpgeui	r2,r2,21
 8009de0:	1000041e 	bne	r2,zero,8009df4 <_free_r+0x3e8>
 8009de4:	e0bff517 	ldw	r2,-44(fp)
 8009de8:	1004d27a 	srli	r2,r2,9
 8009dec:	108016c4 	addi	r2,r2,91
 8009df0:	00001906 	br	8009e58 <_free_r+0x44c>
 8009df4:	e0bff517 	ldw	r2,-44(fp)
 8009df8:	1004d27a 	srli	r2,r2,9
 8009dfc:	10801568 	cmpgeui	r2,r2,85
 8009e00:	1000041e 	bne	r2,zero,8009e14 <_free_r+0x408>
 8009e04:	e0bff517 	ldw	r2,-44(fp)
 8009e08:	1004d33a 	srli	r2,r2,12
 8009e0c:	10801b84 	addi	r2,r2,110
 8009e10:	00001106 	br	8009e58 <_free_r+0x44c>
 8009e14:	e0bff517 	ldw	r2,-44(fp)
 8009e18:	1004d27a 	srli	r2,r2,9
 8009e1c:	10805568 	cmpgeui	r2,r2,341
 8009e20:	1000041e 	bne	r2,zero,8009e34 <_free_r+0x428>
 8009e24:	e0bff517 	ldw	r2,-44(fp)
 8009e28:	1004d3fa 	srli	r2,r2,15
 8009e2c:	10801dc4 	addi	r2,r2,119
 8009e30:	00000906 	br	8009e58 <_free_r+0x44c>
 8009e34:	e0bff517 	ldw	r2,-44(fp)
 8009e38:	1004d27a 	srli	r2,r2,9
 8009e3c:	10815568 	cmpgeui	r2,r2,1365
 8009e40:	1000041e 	bne	r2,zero,8009e54 <_free_r+0x448>
 8009e44:	e0bff517 	ldw	r2,-44(fp)
 8009e48:	1004d4ba 	srli	r2,r2,18
 8009e4c:	10801f04 	addi	r2,r2,124
 8009e50:	00000106 	br	8009e58 <_free_r+0x44c>
 8009e54:	00801f84 	movi	r2,126
 8009e58:	e0bffd15 	stw	r2,-12(fp)
 8009e5c:	e0bffd17 	ldw	r2,-12(fp)
 8009e60:	10800044 	addi	r2,r2,1
 8009e64:	1085883a 	add	r2,r2,r2
 8009e68:	1085883a 	add	r2,r2,r2
 8009e6c:	1087883a 	add	r3,r2,r2
 8009e70:	00820134 	movhi	r2,2052
 8009e74:	109a9f04 	addi	r2,r2,27260
 8009e78:	1885883a 	add	r2,r3,r2
 8009e7c:	10bffe04 	addi	r2,r2,-8
 8009e80:	e0bff615 	stw	r2,-40(fp)
 8009e84:	e0bff617 	ldw	r2,-40(fp)
 8009e88:	10800217 	ldw	r2,8(r2)
 8009e8c:	e0bff715 	stw	r2,-36(fp)
 8009e90:	e0fff717 	ldw	r3,-36(fp)
 8009e94:	e0bff617 	ldw	r2,-40(fp)
 8009e98:	1880121e 	bne	r3,r2,8009ee4 <_free_r+0x4d8>
 8009e9c:	00c20134 	movhi	r3,2052
 8009ea0:	18da9f04 	addi	r3,r3,27260
 8009ea4:	00820134 	movhi	r2,2052
 8009ea8:	109a9f04 	addi	r2,r2,27260
 8009eac:	11000117 	ldw	r4,4(r2)
 8009eb0:	e0bffd17 	ldw	r2,-12(fp)
 8009eb4:	1000010e 	bge	r2,zero,8009ebc <_free_r+0x4b0>
 8009eb8:	108000c4 	addi	r2,r2,3
 8009ebc:	1005d0ba 	srai	r2,r2,2
 8009ec0:	100b883a 	mov	r5,r2
 8009ec4:	00800044 	movi	r2,1
 8009ec8:	1144983a 	sll	r2,r2,r5
 8009ecc:	2084b03a 	or	r2,r4,r2
 8009ed0:	18800115 	stw	r2,4(r3)
 8009ed4:	00000f06 	br	8009f14 <_free_r+0x508>
 8009ed8:	e0bff717 	ldw	r2,-36(fp)
 8009edc:	10800217 	ldw	r2,8(r2)
 8009ee0:	e0bff715 	stw	r2,-36(fp)
 8009ee4:	e0fff717 	ldw	r3,-36(fp)
 8009ee8:	e0bff617 	ldw	r2,-40(fp)
 8009eec:	18800626 	beq	r3,r2,8009f08 <_free_r+0x4fc>
 8009ef0:	e0bff717 	ldw	r2,-36(fp)
 8009ef4:	10c00117 	ldw	r3,4(r2)
 8009ef8:	00bfff04 	movi	r2,-4
 8009efc:	1884703a 	and	r2,r3,r2
 8009f00:	e0fff517 	ldw	r3,-44(fp)
 8009f04:	18bff436 	bltu	r3,r2,8009ed8 <_free_r+0x4cc>
 8009f08:	e0bff717 	ldw	r2,-36(fp)
 8009f0c:	10800317 	ldw	r2,12(r2)
 8009f10:	e0bff615 	stw	r2,-40(fp)
 8009f14:	e0bff417 	ldw	r2,-48(fp)
 8009f18:	e0fff617 	ldw	r3,-40(fp)
 8009f1c:	10c00315 	stw	r3,12(r2)
 8009f20:	e0bff417 	ldw	r2,-48(fp)
 8009f24:	e0fff717 	ldw	r3,-36(fp)
 8009f28:	10c00215 	stw	r3,8(r2)
 8009f2c:	e0bff617 	ldw	r2,-40(fp)
 8009f30:	e0fff417 	ldw	r3,-48(fp)
 8009f34:	10c00215 	stw	r3,8(r2)
 8009f38:	e0bff617 	ldw	r2,-40(fp)
 8009f3c:	10c00217 	ldw	r3,8(r2)
 8009f40:	e0bff717 	ldw	r2,-36(fp)
 8009f44:	10c00315 	stw	r3,12(r2)

  MALLOC_UNLOCK;
 8009f48:	e13ffe17 	ldw	r4,-8(fp)
 8009f4c:	800aa900 	call	800aa90 <__malloc_unlock>
 8009f50:	00000106 	br	8009f58 <_free_r+0x54c>
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;
 8009f54:	0001883a 	nop
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
 8009f58:	e037883a 	mov	sp,fp
 8009f5c:	dfc00117 	ldw	ra,4(sp)
 8009f60:	df000017 	ldw	fp,0(sp)
 8009f64:	dec00204 	addi	sp,sp,8
 8009f68:	f800283a 	ret

08009f6c <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
 8009f6c:	defff704 	addi	sp,sp,-36
 8009f70:	dfc00815 	stw	ra,32(sp)
 8009f74:	df000715 	stw	fp,28(sp)
 8009f78:	df000704 	addi	fp,sp,28
 8009f7c:	e13ffe15 	stw	r4,-8(fp)
 8009f80:	e17fff15 	stw	r5,-4(fp)
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
 8009f84:	00840004 	movi	r2,4096
 8009f88:	e0bff915 	stw	r2,-28(fp)

  MALLOC_LOCK;
 8009f8c:	e13ffe17 	ldw	r4,-8(fp)
 8009f90:	800aa6c0 	call	800aa6c <__malloc_lock>

  top_size = chunksize(top);
 8009f94:	00820134 	movhi	r2,2052
 8009f98:	109a9f04 	addi	r2,r2,27260
 8009f9c:	10800217 	ldw	r2,8(r2)
 8009fa0:	10800117 	ldw	r2,4(r2)
 8009fa4:	1007883a 	mov	r3,r2
 8009fa8:	00bfff04 	movi	r2,-4
 8009fac:	1884703a 	and	r2,r3,r2
 8009fb0:	e0bffa15 	stw	r2,-24(fp)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
 8009fb4:	e0fffa17 	ldw	r3,-24(fp)
 8009fb8:	e0bfff17 	ldw	r2,-4(fp)
 8009fbc:	1887c83a 	sub	r3,r3,r2
 8009fc0:	e0bff917 	ldw	r2,-28(fp)
 8009fc4:	1885883a 	add	r2,r3,r2
 8009fc8:	10bffbc4 	addi	r2,r2,-17
 8009fcc:	e17ff917 	ldw	r5,-28(fp)
 8009fd0:	1009883a 	mov	r4,r2
 8009fd4:	800400c0 	call	800400c <__udivsi3>
 8009fd8:	10ffffc4 	addi	r3,r2,-1
 8009fdc:	e0bff917 	ldw	r2,-28(fp)
 8009fe0:	1885383a 	mul	r2,r3,r2
 8009fe4:	e0bffb15 	stw	r2,-20(fp)

  if (extra < (long)pagesz)  /* Not enough memory to release */
 8009fe8:	e0bff917 	ldw	r2,-28(fp)
 8009fec:	e0fffb17 	ldw	r3,-20(fp)
 8009ff0:	1880040e 	bge	r3,r2,800a004 <_malloc_trim_r+0x98>
  {
    MALLOC_UNLOCK;
 8009ff4:	e13ffe17 	ldw	r4,-8(fp)
 8009ff8:	800aa900 	call	800aa90 <__malloc_unlock>
    return 0;
 8009ffc:	0005883a 	mov	r2,zero
 800a000:	00004806 	br	800a124 <_malloc_trim_r+0x1b8>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
 800a004:	000b883a 	mov	r5,zero
 800a008:	e13ffe17 	ldw	r4,-8(fp)
 800a00c:	8008f840 	call	8008f84 <_sbrk_r>
 800a010:	e0bffc15 	stw	r2,-16(fp)
    if (current_brk != (char*)(top) + top_size)
 800a014:	00820134 	movhi	r2,2052
 800a018:	109a9f04 	addi	r2,r2,27260
 800a01c:	10c00217 	ldw	r3,8(r2)
 800a020:	e0bffa17 	ldw	r2,-24(fp)
 800a024:	1887883a 	add	r3,r3,r2
 800a028:	e0bffc17 	ldw	r2,-16(fp)
 800a02c:	18800426 	beq	r3,r2,800a040 <_malloc_trim_r+0xd4>
    {
      MALLOC_UNLOCK;
 800a030:	e13ffe17 	ldw	r4,-8(fp)
 800a034:	800aa900 	call	800aa90 <__malloc_unlock>
      return 0;     /* Apparently we don't own memory; must fail */
 800a038:	0005883a 	mov	r2,zero
 800a03c:	00003906 	br	800a124 <_malloc_trim_r+0x1b8>
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
 800a040:	e0bffb17 	ldw	r2,-20(fp)
 800a044:	0085c83a 	sub	r2,zero,r2
 800a048:	100b883a 	mov	r5,r2
 800a04c:	e13ffe17 	ldw	r4,-8(fp)
 800a050:	8008f840 	call	8008f84 <_sbrk_r>
 800a054:	e0bffd15 	stw	r2,-12(fp)
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
 800a058:	e0bffd17 	ldw	r2,-12(fp)
 800a05c:	10bfffd8 	cmpnei	r2,r2,-1
 800a060:	10001d1e 	bne	r2,zero,800a0d8 <_malloc_trim_r+0x16c>
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
 800a064:	000b883a 	mov	r5,zero
 800a068:	e13ffe17 	ldw	r4,-8(fp)
 800a06c:	8008f840 	call	8008f84 <_sbrk_r>
 800a070:	e0bffc15 	stw	r2,-16(fp)
        top_size = current_brk - (char*)top;
 800a074:	e0fffc17 	ldw	r3,-16(fp)
 800a078:	00820134 	movhi	r2,2052
 800a07c:	109a9f04 	addi	r2,r2,27260
 800a080:	10800217 	ldw	r2,8(r2)
 800a084:	1885c83a 	sub	r2,r3,r2
 800a088:	e0bffa15 	stw	r2,-24(fp)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
 800a08c:	e0bffa17 	ldw	r2,-24(fp)
 800a090:	10800410 	cmplti	r2,r2,16
 800a094:	10000c1e 	bne	r2,zero,800a0c8 <_malloc_trim_r+0x15c>
        {
          sbrked_mem = current_brk - sbrk_base;
 800a098:	e0bffc17 	ldw	r2,-16(fp)
 800a09c:	d0e04517 	ldw	r3,-32492(gp)
 800a0a0:	10c7c83a 	sub	r3,r2,r3
 800a0a4:	00820174 	movhi	r2,2053
 800a0a8:	10a7ce04 	addi	r2,r2,-24776
 800a0ac:	10c00015 	stw	r3,0(r2)
          set_head(top, top_size | PREV_INUSE);
 800a0b0:	00820134 	movhi	r2,2052
 800a0b4:	109a9f04 	addi	r2,r2,27260
 800a0b8:	10800217 	ldw	r2,8(r2)
 800a0bc:	e0fffa17 	ldw	r3,-24(fp)
 800a0c0:	18c00054 	ori	r3,r3,1
 800a0c4:	10c00115 	stw	r3,4(r2)
        }
        check_chunk(top);
	MALLOC_UNLOCK;
 800a0c8:	e13ffe17 	ldw	r4,-8(fp)
 800a0cc:	800aa900 	call	800aa90 <__malloc_unlock>
        return 0; 
 800a0d0:	0005883a 	mov	r2,zero
 800a0d4:	00001306 	br	800a124 <_malloc_trim_r+0x1b8>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
 800a0d8:	00820134 	movhi	r2,2052
 800a0dc:	109a9f04 	addi	r2,r2,27260
 800a0e0:	10800217 	ldw	r2,8(r2)
 800a0e4:	e13ffa17 	ldw	r4,-24(fp)
 800a0e8:	e0fffb17 	ldw	r3,-20(fp)
 800a0ec:	20c7c83a 	sub	r3,r4,r3
 800a0f0:	18c00054 	ori	r3,r3,1
 800a0f4:	10c00115 	stw	r3,4(r2)
        sbrked_mem -= extra;
 800a0f8:	00820174 	movhi	r2,2053
 800a0fc:	10a7ce04 	addi	r2,r2,-24776
 800a100:	10c00017 	ldw	r3,0(r2)
 800a104:	e0bffb17 	ldw	r2,-20(fp)
 800a108:	1887c83a 	sub	r3,r3,r2
 800a10c:	00820174 	movhi	r2,2053
 800a110:	10a7ce04 	addi	r2,r2,-24776
 800a114:	10c00015 	stw	r3,0(r2)
        check_chunk(top);
	MALLOC_UNLOCK;
 800a118:	e13ffe17 	ldw	r4,-8(fp)
 800a11c:	800aa900 	call	800aa90 <__malloc_unlock>
        return 1;
 800a120:	00800044 	movi	r2,1
      }
    }
  }
}
 800a124:	e037883a 	mov	sp,fp
 800a128:	dfc00117 	ldw	ra,4(sp)
 800a12c:	df000017 	ldw	fp,0(sp)
 800a130:	dec00204 	addi	sp,sp,8
 800a134:	f800283a 	ret

0800a138 <_lseek_r>:
_DEFUN (_lseek_r, (ptr, fd, pos, whence),
     struct _reent *ptr _AND
     int fd _AND
     _off_t pos _AND
     int whence)
{
 800a138:	defff904 	addi	sp,sp,-28
 800a13c:	dfc00615 	stw	ra,24(sp)
 800a140:	df000515 	stw	fp,20(sp)
 800a144:	df000504 	addi	fp,sp,20
 800a148:	e13ffc15 	stw	r4,-16(fp)
 800a14c:	e17ffd15 	stw	r5,-12(fp)
 800a150:	e1bffe15 	stw	r6,-8(fp)
 800a154:	e1ffff15 	stw	r7,-4(fp)
  _off_t ret;

  errno = 0;
 800a158:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
 800a15c:	e1bfff17 	ldw	r6,-4(fp)
 800a160:	e17ffe17 	ldw	r5,-8(fp)
 800a164:	e13ffd17 	ldw	r4,-12(fp)
 800a168:	800a9380 	call	800a938 <lseek>
 800a16c:	e0bffb15 	stw	r2,-20(fp)
 800a170:	e0bffb17 	ldw	r2,-20(fp)
 800a174:	10bfffd8 	cmpnei	r2,r2,-1
 800a178:	1000051e 	bne	r2,zero,800a190 <_lseek_r+0x58>
 800a17c:	d0a76a17 	ldw	r2,-25176(gp)
 800a180:	10000326 	beq	r2,zero,800a190 <_lseek_r+0x58>
    ptr->_errno = errno;
 800a184:	d0e76a17 	ldw	r3,-25176(gp)
 800a188:	e0bffc17 	ldw	r2,-16(fp)
 800a18c:	10c00015 	stw	r3,0(r2)
  return ret;
 800a190:	e0bffb17 	ldw	r2,-20(fp)
}
 800a194:	e037883a 	mov	sp,fp
 800a198:	dfc00117 	ldw	ra,4(sp)
 800a19c:	df000017 	ldw	fp,0(sp)
 800a1a0:	dec00204 	addi	sp,sp,8
 800a1a4:	f800283a 	ret

0800a1a8 <__smakebuf_r>:

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
 800a1a8:	deffea04 	addi	sp,sp,-88
 800a1ac:	dfc01515 	stw	ra,84(sp)
 800a1b0:	df001415 	stw	fp,80(sp)
 800a1b4:	dcc01315 	stw	r19,76(sp)
 800a1b8:	dc801215 	stw	r18,72(sp)
 800a1bc:	dc401115 	stw	r17,68(sp)
 800a1c0:	dc001015 	stw	r16,64(sp)
 800a1c4:	df001404 	addi	fp,sp,80
 800a1c8:	e13ffb15 	stw	r4,-20(fp)
 800a1cc:	2821883a 	mov	r16,r5
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
 800a1d0:	8080030b 	ldhu	r2,12(r16)
 800a1d4:	10bfffcc 	andi	r2,r2,65535
 800a1d8:	1080008c 	andi	r2,r2,2
 800a1dc:	10000726 	beq	r2,zero,800a1fc <__smakebuf_r+0x54>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
 800a1e0:	808010c4 	addi	r2,r16,67
 800a1e4:	80800015 	stw	r2,0(r16)
 800a1e8:	80800017 	ldw	r2,0(r16)
 800a1ec:	80800415 	stw	r2,16(r16)
      fp->_bf._size = 1;
 800a1f0:	00800044 	movi	r2,1
 800a1f4:	80800515 	stw	r2,20(r16)
 800a1f8:	00006d06 	br	800a3b0 <__smakebuf_r+0x208>
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
 800a1fc:	8080038b 	ldhu	r2,14(r16)
 800a200:	10bfffcc 	andi	r2,r2,65535
 800a204:	10a0001c 	xori	r2,r2,32768
 800a208:	10a00004 	addi	r2,r2,-32768
 800a20c:	10000916 	blt	r2,zero,800a234 <__smakebuf_r+0x8c>
 800a210:	8080038b 	ldhu	r2,14(r16)
 800a214:	10bfffcc 	andi	r2,r2,65535
 800a218:	10a0001c 	xori	r2,r2,32768
 800a21c:	10a00004 	addi	r2,r2,-32768
 800a220:	e1bfec04 	addi	r6,fp,-80
 800a224:	100b883a 	mov	r5,r2
 800a228:	e13ffb17 	ldw	r4,-20(fp)
 800a22c:	800a4440 	call	800a444 <_fstat_r>
 800a230:	10000c0e 	bge	r2,zero,800a264 <__smakebuf_r+0xbc>
#endif
    {
      couldbetty = 0;
 800a234:	0025883a 	mov	r18,zero
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
 800a238:	8080030b 	ldhu	r2,12(r16)
 800a23c:	10bfffcc 	andi	r2,r2,65535
 800a240:	1080200c 	andi	r2,r2,128
 800a244:	10000226 	beq	r2,zero,800a250 <__smakebuf_r+0xa8>
        size = _DEFAULT_ASPRINTF_BUFSIZE;
 800a248:	04401004 	movi	r17,64
 800a24c:	00000106 	br	800a254 <__smakebuf_r+0xac>
      else
        size = BUFSIZ;
 800a250:	04410004 	movi	r17,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
 800a254:	8080030b 	ldhu	r2,12(r16)
 800a258:	10820014 	ori	r2,r2,2048
 800a25c:	8080030d 	sth	r2,12(r16)
 800a260:	00001606 	br	800a2bc <__smakebuf_r+0x114>
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
 800a264:	e0bfed17 	ldw	r2,-76(fp)
 800a268:	10bc000c 	andi	r2,r2,61440
 800a26c:	10880020 	cmpeqi	r2,r2,8192
 800a270:	14803fcc 	andi	r18,r2,255
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
 800a274:	04410004 	movi	r17,1024
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
 800a278:	e0bfed17 	ldw	r2,-76(fp)
 800a27c:	10fc000c 	andi	r3,r2,61440
 800a280:	00a00014 	movui	r2,32768
 800a284:	18800a1e 	bne	r3,r2,800a2b0 <__smakebuf_r+0x108>
 800a288:	80c00a17 	ldw	r3,40(r16)
 800a28c:	00820074 	movhi	r2,2049
 800a290:	10a45904 	addi	r2,r2,-28316
 800a294:	1880061e 	bne	r3,r2,800a2b0 <__smakebuf_r+0x108>
	{
	  fp->_flags |= __SOPT;
 800a298:	8080030b 	ldhu	r2,12(r16)
 800a29c:	10810014 	ori	r2,r2,1024
 800a2a0:	8080030d 	sth	r2,12(r16)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
 800a2a4:	00810004 	movi	r2,1024
 800a2a8:	80801315 	stw	r2,76(r16)
 800a2ac:	00000306 	br	800a2bc <__smakebuf_r+0x114>
#endif
	}
      else
	fp->_flags |= __SNPT;
 800a2b0:	8080030b 	ldhu	r2,12(r16)
 800a2b4:	10820014 	ori	r2,r2,2048
 800a2b8:	8080030d 	sth	r2,12(r16)
#endif
    }

  /* Make unbuffered by default: */			/* AlteraSpecific */
  if (couldbetty && _isatty_r (ptr, fp->_file))		/* AlteraSpecific */
 800a2bc:	90001126 	beq	r18,zero,800a304 <__smakebuf_r+0x15c>
 800a2c0:	8080038b 	ldhu	r2,14(r16)
 800a2c4:	10bfffcc 	andi	r2,r2,65535
 800a2c8:	10a0001c 	xori	r2,r2,32768
 800a2cc:	10a00004 	addi	r2,r2,-32768
 800a2d0:	100b883a 	mov	r5,r2
 800a2d4:	e13ffb17 	ldw	r4,-20(fp)
 800a2d8:	800a4ac0 	call	800a4ac <_isatty_r>
 800a2dc:	10000926 	beq	r2,zero,800a304 <__smakebuf_r+0x15c>
  {							/* AlteraSpecific */
    fp->_flags |= __SLBF;				/* AlteraSpecific __SLBF == "line buffered */
 800a2e0:	8080030b 	ldhu	r2,12(r16)
 800a2e4:	10800054 	ori	r2,r2,1
 800a2e8:	8080030d 	sth	r2,12(r16)
    fp->_bf._base = fp->_p = fp->_nbuf;			/* AlteraSpecific (see newlib/libc/include/stdio.h) */
 800a2ec:	808010c4 	addi	r2,r16,67
 800a2f0:	80800015 	stw	r2,0(r16)
 800a2f4:	80800017 	ldw	r2,0(r16)
 800a2f8:	80800415 	stw	r2,16(r16)
    fp->_bf._size = 1;					/* AlteraSpecific */
 800a2fc:	00800044 	movi	r2,1
 800a300:	80800515 	stw	r2,20(r16)
  }							/* AlteraSpecific */

  if ((p = _malloc_r (ptr, size)) == NULL)
 800a304:	880b883a 	mov	r5,r17
 800a308:	e13ffb17 	ldw	r4,-20(fp)
 800a30c:	80071080 	call	8007108 <_malloc_r>
 800a310:	1027883a 	mov	r19,r2
 800a314:	98000e1e 	bne	r19,zero,800a350 <__smakebuf_r+0x1a8>
    {
      if (!(fp->_flags & __SSTR))
 800a318:	8080030b 	ldhu	r2,12(r16)
 800a31c:	10bfffcc 	andi	r2,r2,65535
 800a320:	1080800c 	andi	r2,r2,512
 800a324:	1000221e 	bne	r2,zero,800a3b0 <__smakebuf_r+0x208>
	{
	  fp->_flags |= __SNBF;
 800a328:	8080030b 	ldhu	r2,12(r16)
 800a32c:	10800094 	ori	r2,r2,2
 800a330:	8080030d 	sth	r2,12(r16)
	  fp->_bf._base = fp->_p = fp->_nbuf;
 800a334:	808010c4 	addi	r2,r16,67
 800a338:	80800015 	stw	r2,0(r16)
 800a33c:	80800017 	ldw	r2,0(r16)
 800a340:	80800415 	stw	r2,16(r16)
	  fp->_bf._size = 1;
 800a344:	00800044 	movi	r2,1
 800a348:	80800515 	stw	r2,20(r16)
 800a34c:	00001806 	br	800a3b0 <__smakebuf_r+0x208>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
 800a350:	e0fffb17 	ldw	r3,-20(fp)
 800a354:	00820034 	movhi	r2,2048
 800a358:	1098cb04 	addi	r2,r2,25388
 800a35c:	18800f15 	stw	r2,60(r3)
      fp->_flags |= __SMBF;
 800a360:	8080030b 	ldhu	r2,12(r16)
 800a364:	10802014 	ori	r2,r2,128
 800a368:	8080030d 	sth	r2,12(r16)
      fp->_bf._base = fp->_p = (unsigned char *) p;
 800a36c:	84c00015 	stw	r19,0(r16)
 800a370:	80800017 	ldw	r2,0(r16)
 800a374:	80800415 	stw	r2,16(r16)
      fp->_bf._size = size;
 800a378:	8805883a 	mov	r2,r17
 800a37c:	80800515 	stw	r2,20(r16)
      if (couldbetty && _isatty_r (ptr, fp->_file))
 800a380:	90000b26 	beq	r18,zero,800a3b0 <__smakebuf_r+0x208>
 800a384:	8080038b 	ldhu	r2,14(r16)
 800a388:	10bfffcc 	andi	r2,r2,65535
 800a38c:	10a0001c 	xori	r2,r2,32768
 800a390:	10a00004 	addi	r2,r2,-32768
 800a394:	100b883a 	mov	r5,r2
 800a398:	e13ffb17 	ldw	r4,-20(fp)
 800a39c:	800a4ac0 	call	800a4ac <_isatty_r>
 800a3a0:	10000326 	beq	r2,zero,800a3b0 <__smakebuf_r+0x208>
	fp->_flags |= __SLBF;
 800a3a4:	8080030b 	ldhu	r2,12(r16)
 800a3a8:	10800054 	ori	r2,r2,1
 800a3ac:	8080030d 	sth	r2,12(r16)
    }
}
 800a3b0:	e6fffc04 	addi	sp,fp,-16
 800a3b4:	dfc00517 	ldw	ra,20(sp)
 800a3b8:	df000417 	ldw	fp,16(sp)
 800a3bc:	dcc00317 	ldw	r19,12(sp)
 800a3c0:	dc800217 	ldw	r18,8(sp)
 800a3c4:	dc400117 	ldw	r17,4(sp)
 800a3c8:	dc000017 	ldw	r16,0(sp)
 800a3cc:	dec00604 	addi	sp,sp,24
 800a3d0:	f800283a 	ret

0800a3d4 <_read_r>:
_DEFUN (_read_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _PTR buf _AND
     size_t cnt)
{
 800a3d4:	defff904 	addi	sp,sp,-28
 800a3d8:	dfc00615 	stw	ra,24(sp)
 800a3dc:	df000515 	stw	fp,20(sp)
 800a3e0:	df000504 	addi	fp,sp,20
 800a3e4:	e13ffc15 	stw	r4,-16(fp)
 800a3e8:	e17ffd15 	stw	r5,-12(fp)
 800a3ec:	e1bffe15 	stw	r6,-8(fp)
 800a3f0:	e1ffff15 	stw	r7,-4(fp)
  _ssize_t ret;

  errno = 0;
 800a3f4:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
 800a3f8:	e1bfff17 	ldw	r6,-4(fp)
 800a3fc:	e17ffe17 	ldw	r5,-8(fp)
 800a400:	e13ffd17 	ldw	r4,-12(fp)
 800a404:	800aaf00 	call	800aaf0 <read>
 800a408:	e0bffb15 	stw	r2,-20(fp)
 800a40c:	e0bffb17 	ldw	r2,-20(fp)
 800a410:	10bfffd8 	cmpnei	r2,r2,-1
 800a414:	1000051e 	bne	r2,zero,800a42c <_read_r+0x58>
 800a418:	d0a76a17 	ldw	r2,-25176(gp)
 800a41c:	10000326 	beq	r2,zero,800a42c <_read_r+0x58>
    ptr->_errno = errno;
 800a420:	d0e76a17 	ldw	r3,-25176(gp)
 800a424:	e0bffc17 	ldw	r2,-16(fp)
 800a428:	10c00015 	stw	r3,0(r2)
  return ret;
 800a42c:	e0bffb17 	ldw	r2,-20(fp)
}
 800a430:	e037883a 	mov	sp,fp
 800a434:	dfc00117 	ldw	ra,4(sp)
 800a438:	df000017 	ldw	fp,0(sp)
 800a43c:	dec00204 	addi	sp,sp,8
 800a440:	f800283a 	ret

0800a444 <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
 800a444:	defffa04 	addi	sp,sp,-24
 800a448:	dfc00515 	stw	ra,20(sp)
 800a44c:	df000415 	stw	fp,16(sp)
 800a450:	df000404 	addi	fp,sp,16
 800a454:	e13ffd15 	stw	r4,-12(fp)
 800a458:	e17ffe15 	stw	r5,-8(fp)
 800a45c:	e1bfff15 	stw	r6,-4(fp)
  int ret;

  errno = 0;
 800a460:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
 800a464:	e17fff17 	ldw	r5,-4(fp)
 800a468:	e13ffe17 	ldw	r4,-8(fp)
 800a46c:	800a6800 	call	800a680 <fstat>
 800a470:	e0bffc15 	stw	r2,-16(fp)
 800a474:	e0bffc17 	ldw	r2,-16(fp)
 800a478:	10bfffd8 	cmpnei	r2,r2,-1
 800a47c:	1000051e 	bne	r2,zero,800a494 <_fstat_r+0x50>
 800a480:	d0a76a17 	ldw	r2,-25176(gp)
 800a484:	10000326 	beq	r2,zero,800a494 <_fstat_r+0x50>
    ptr->_errno = errno;
 800a488:	d0e76a17 	ldw	r3,-25176(gp)
 800a48c:	e0bffd17 	ldw	r2,-12(fp)
 800a490:	10c00015 	stw	r3,0(r2)
  return ret;
 800a494:	e0bffc17 	ldw	r2,-16(fp)
}
 800a498:	e037883a 	mov	sp,fp
 800a49c:	dfc00117 	ldw	ra,4(sp)
 800a4a0:	df000017 	ldw	fp,0(sp)
 800a4a4:	dec00204 	addi	sp,sp,8
 800a4a8:	f800283a 	ret

0800a4ac <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 800a4ac:	defffb04 	addi	sp,sp,-20
 800a4b0:	dfc00415 	stw	ra,16(sp)
 800a4b4:	df000315 	stw	fp,12(sp)
 800a4b8:	df000304 	addi	fp,sp,12
 800a4bc:	e13ffe15 	stw	r4,-8(fp)
 800a4c0:	e17fff15 	stw	r5,-4(fp)
  int ret;

  errno = 0;
 800a4c4:	d0276a15 	stw	zero,-25176(gp)
  if ((ret = _isatty (fd)) == -1 && errno != 0)
 800a4c8:	e13fff17 	ldw	r4,-4(fp)
 800a4cc:	800a76c0 	call	800a76c <isatty>
 800a4d0:	e0bffd15 	stw	r2,-12(fp)
 800a4d4:	e0bffd17 	ldw	r2,-12(fp)
 800a4d8:	10bfffd8 	cmpnei	r2,r2,-1
 800a4dc:	1000051e 	bne	r2,zero,800a4f4 <_isatty_r+0x48>
 800a4e0:	d0a76a17 	ldw	r2,-25176(gp)
 800a4e4:	10000326 	beq	r2,zero,800a4f4 <_isatty_r+0x48>
    ptr->_errno = errno;
 800a4e8:	d0e76a17 	ldw	r3,-25176(gp)
 800a4ec:	e0bffe17 	ldw	r2,-8(fp)
 800a4f0:	10c00015 	stw	r3,0(r2)
  return ret;
 800a4f4:	e0bffd17 	ldw	r2,-12(fp)
}
 800a4f8:	e037883a 	mov	sp,fp
 800a4fc:	dfc00117 	ldw	ra,4(sp)
 800a500:	df000017 	ldw	fp,0(sp)
 800a504:	dec00204 	addi	sp,sp,8
 800a508:	f800283a 	ret

0800a50c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a50c:	defffe04 	addi	sp,sp,-8
 800a510:	dfc00115 	stw	ra,4(sp)
 800a514:	df000015 	stw	fp,0(sp)
 800a518:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a51c:	d0a04b17 	ldw	r2,-32468(gp)
 800a520:	10000326 	beq	r2,zero,800a530 <alt_get_errno+0x24>
 800a524:	d0a04b17 	ldw	r2,-32468(gp)
 800a528:	103ee83a 	callr	r2
 800a52c:	00000106 	br	800a534 <alt_get_errno+0x28>
 800a530:	d0a76a04 	addi	r2,gp,-25176
}
 800a534:	e037883a 	mov	sp,fp
 800a538:	dfc00117 	ldw	ra,4(sp)
 800a53c:	df000017 	ldw	fp,0(sp)
 800a540:	dec00204 	addi	sp,sp,8
 800a544:	f800283a 	ret

0800a548 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 800a548:	defffb04 	addi	sp,sp,-20
 800a54c:	dfc00415 	stw	ra,16(sp)
 800a550:	df000315 	stw	fp,12(sp)
 800a554:	df000304 	addi	fp,sp,12
 800a558:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 800a55c:	e0bfff17 	ldw	r2,-4(fp)
 800a560:	10000616 	blt	r2,zero,800a57c <close+0x34>
 800a564:	e0bfff17 	ldw	r2,-4(fp)
 800a568:	10c00324 	muli	r3,r2,12
 800a56c:	00820134 	movhi	r2,2052
 800a570:	109bab04 	addi	r2,r2,28332
 800a574:	1885883a 	add	r2,r3,r2
 800a578:	00000106 	br	800a580 <close+0x38>
 800a57c:	0005883a 	mov	r2,zero
 800a580:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 800a584:	e0bffd17 	ldw	r2,-12(fp)
 800a588:	10001926 	beq	r2,zero,800a5f0 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 800a58c:	e0bffd17 	ldw	r2,-12(fp)
 800a590:	10800017 	ldw	r2,0(r2)
 800a594:	10800417 	ldw	r2,16(r2)
 800a598:	10000626 	beq	r2,zero,800a5b4 <close+0x6c>
 800a59c:	e0bffd17 	ldw	r2,-12(fp)
 800a5a0:	10800017 	ldw	r2,0(r2)
 800a5a4:	10800417 	ldw	r2,16(r2)
 800a5a8:	e13ffd17 	ldw	r4,-12(fp)
 800a5ac:	103ee83a 	callr	r2
 800a5b0:	00000106 	br	800a5b8 <close+0x70>
 800a5b4:	0005883a 	mov	r2,zero
 800a5b8:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 800a5bc:	e13fff17 	ldw	r4,-4(fp)
 800a5c0:	800abec0 	call	800abec <alt_release_fd>
    if (rval < 0)
 800a5c4:	e0bffe17 	ldw	r2,-8(fp)
 800a5c8:	1000070e 	bge	r2,zero,800a5e8 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 800a5cc:	800a50c0 	call	800a50c <alt_get_errno>
 800a5d0:	1007883a 	mov	r3,r2
 800a5d4:	e0bffe17 	ldw	r2,-8(fp)
 800a5d8:	0085c83a 	sub	r2,zero,r2
 800a5dc:	18800015 	stw	r2,0(r3)
      return -1;
 800a5e0:	00bfffc4 	movi	r2,-1
 800a5e4:	00000706 	br	800a604 <close+0xbc>
    }
    return 0;
 800a5e8:	0005883a 	mov	r2,zero
 800a5ec:	00000506 	br	800a604 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 800a5f0:	800a50c0 	call	800a50c <alt_get_errno>
 800a5f4:	1007883a 	mov	r3,r2
 800a5f8:	00801444 	movi	r2,81
 800a5fc:	18800015 	stw	r2,0(r3)
    return -1;
 800a600:	00bfffc4 	movi	r2,-1
  }
}
 800a604:	e037883a 	mov	sp,fp
 800a608:	dfc00117 	ldw	ra,4(sp)
 800a60c:	df000017 	ldw	fp,0(sp)
 800a610:	dec00204 	addi	sp,sp,8
 800a614:	f800283a 	ret

0800a618 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 800a618:	defffc04 	addi	sp,sp,-16
 800a61c:	df000315 	stw	fp,12(sp)
 800a620:	df000304 	addi	fp,sp,12
 800a624:	e13ffd15 	stw	r4,-12(fp)
 800a628:	e17ffe15 	stw	r5,-8(fp)
 800a62c:	e1bfff15 	stw	r6,-4(fp)
  return len;
 800a630:	e0bfff17 	ldw	r2,-4(fp)
}
 800a634:	e037883a 	mov	sp,fp
 800a638:	df000017 	ldw	fp,0(sp)
 800a63c:	dec00104 	addi	sp,sp,4
 800a640:	f800283a 	ret

0800a644 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a644:	defffe04 	addi	sp,sp,-8
 800a648:	dfc00115 	stw	ra,4(sp)
 800a64c:	df000015 	stw	fp,0(sp)
 800a650:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a654:	d0a04b17 	ldw	r2,-32468(gp)
 800a658:	10000326 	beq	r2,zero,800a668 <alt_get_errno+0x24>
 800a65c:	d0a04b17 	ldw	r2,-32468(gp)
 800a660:	103ee83a 	callr	r2
 800a664:	00000106 	br	800a66c <alt_get_errno+0x28>
 800a668:	d0a76a04 	addi	r2,gp,-25176
}
 800a66c:	e037883a 	mov	sp,fp
 800a670:	dfc00117 	ldw	ra,4(sp)
 800a674:	df000017 	ldw	fp,0(sp)
 800a678:	dec00204 	addi	sp,sp,8
 800a67c:	f800283a 	ret

0800a680 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 800a680:	defffb04 	addi	sp,sp,-20
 800a684:	dfc00415 	stw	ra,16(sp)
 800a688:	df000315 	stw	fp,12(sp)
 800a68c:	df000304 	addi	fp,sp,12
 800a690:	e13ffe15 	stw	r4,-8(fp)
 800a694:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a698:	e0bffe17 	ldw	r2,-8(fp)
 800a69c:	10000616 	blt	r2,zero,800a6b8 <fstat+0x38>
 800a6a0:	e0bffe17 	ldw	r2,-8(fp)
 800a6a4:	10c00324 	muli	r3,r2,12
 800a6a8:	00820134 	movhi	r2,2052
 800a6ac:	109bab04 	addi	r2,r2,28332
 800a6b0:	1885883a 	add	r2,r3,r2
 800a6b4:	00000106 	br	800a6bc <fstat+0x3c>
 800a6b8:	0005883a 	mov	r2,zero
 800a6bc:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 800a6c0:	e0bffd17 	ldw	r2,-12(fp)
 800a6c4:	10001026 	beq	r2,zero,800a708 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 800a6c8:	e0bffd17 	ldw	r2,-12(fp)
 800a6cc:	10800017 	ldw	r2,0(r2)
 800a6d0:	10800817 	ldw	r2,32(r2)
 800a6d4:	10000726 	beq	r2,zero,800a6f4 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 800a6d8:	e0bffd17 	ldw	r2,-12(fp)
 800a6dc:	10800017 	ldw	r2,0(r2)
 800a6e0:	10800817 	ldw	r2,32(r2)
 800a6e4:	e17fff17 	ldw	r5,-4(fp)
 800a6e8:	e13ffd17 	ldw	r4,-12(fp)
 800a6ec:	103ee83a 	callr	r2
 800a6f0:	00000a06 	br	800a71c <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 800a6f4:	e0bfff17 	ldw	r2,-4(fp)
 800a6f8:	00c80004 	movi	r3,8192
 800a6fc:	10c00115 	stw	r3,4(r2)
      return 0;
 800a700:	0005883a 	mov	r2,zero
 800a704:	00000506 	br	800a71c <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 800a708:	800a6440 	call	800a644 <alt_get_errno>
 800a70c:	1007883a 	mov	r3,r2
 800a710:	00801444 	movi	r2,81
 800a714:	18800015 	stw	r2,0(r3)
    return -1;
 800a718:	00bfffc4 	movi	r2,-1
  }
}
 800a71c:	e037883a 	mov	sp,fp
 800a720:	dfc00117 	ldw	ra,4(sp)
 800a724:	df000017 	ldw	fp,0(sp)
 800a728:	dec00204 	addi	sp,sp,8
 800a72c:	f800283a 	ret

0800a730 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a730:	defffe04 	addi	sp,sp,-8
 800a734:	dfc00115 	stw	ra,4(sp)
 800a738:	df000015 	stw	fp,0(sp)
 800a73c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a740:	d0a04b17 	ldw	r2,-32468(gp)
 800a744:	10000326 	beq	r2,zero,800a754 <alt_get_errno+0x24>
 800a748:	d0a04b17 	ldw	r2,-32468(gp)
 800a74c:	103ee83a 	callr	r2
 800a750:	00000106 	br	800a758 <alt_get_errno+0x28>
 800a754:	d0a76a04 	addi	r2,gp,-25176
}
 800a758:	e037883a 	mov	sp,fp
 800a75c:	dfc00117 	ldw	ra,4(sp)
 800a760:	df000017 	ldw	fp,0(sp)
 800a764:	dec00204 	addi	sp,sp,8
 800a768:	f800283a 	ret

0800a76c <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 800a76c:	deffed04 	addi	sp,sp,-76
 800a770:	dfc01215 	stw	ra,72(sp)
 800a774:	df001115 	stw	fp,68(sp)
 800a778:	df001104 	addi	fp,sp,68
 800a77c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a780:	e0bfff17 	ldw	r2,-4(fp)
 800a784:	10000616 	blt	r2,zero,800a7a0 <isatty+0x34>
 800a788:	e0bfff17 	ldw	r2,-4(fp)
 800a78c:	10c00324 	muli	r3,r2,12
 800a790:	00820134 	movhi	r2,2052
 800a794:	109bab04 	addi	r2,r2,28332
 800a798:	1885883a 	add	r2,r3,r2
 800a79c:	00000106 	br	800a7a4 <isatty+0x38>
 800a7a0:	0005883a 	mov	r2,zero
 800a7a4:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 800a7a8:	e0bfef17 	ldw	r2,-68(fp)
 800a7ac:	10000e26 	beq	r2,zero,800a7e8 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 800a7b0:	e0bfef17 	ldw	r2,-68(fp)
 800a7b4:	10800017 	ldw	r2,0(r2)
 800a7b8:	10800817 	ldw	r2,32(r2)
 800a7bc:	1000021e 	bne	r2,zero,800a7c8 <isatty+0x5c>
    {
      return 1;
 800a7c0:	00800044 	movi	r2,1
 800a7c4:	00000d06 	br	800a7fc <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 800a7c8:	e0bff004 	addi	r2,fp,-64
 800a7cc:	100b883a 	mov	r5,r2
 800a7d0:	e13fff17 	ldw	r4,-4(fp)
 800a7d4:	800a6800 	call	800a680 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 800a7d8:	e0bff117 	ldw	r2,-60(fp)
 800a7dc:	10880020 	cmpeqi	r2,r2,8192
 800a7e0:	10803fcc 	andi	r2,r2,255
 800a7e4:	00000506 	br	800a7fc <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 800a7e8:	800a7300 	call	800a730 <alt_get_errno>
 800a7ec:	1007883a 	mov	r3,r2
 800a7f0:	00801444 	movi	r2,81
 800a7f4:	18800015 	stw	r2,0(r3)
    return 0;
 800a7f8:	0005883a 	mov	r2,zero
  }
}
 800a7fc:	e037883a 	mov	sp,fp
 800a800:	dfc00117 	ldw	ra,4(sp)
 800a804:	df000017 	ldw	fp,0(sp)
 800a808:	dec00204 	addi	sp,sp,8
 800a80c:	f800283a 	ret

0800a810 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 800a810:	defffc04 	addi	sp,sp,-16
 800a814:	df000315 	stw	fp,12(sp)
 800a818:	df000304 	addi	fp,sp,12
 800a81c:	e13ffd15 	stw	r4,-12(fp)
 800a820:	e17ffe15 	stw	r5,-8(fp)
 800a824:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 800a828:	e0fffe17 	ldw	r3,-8(fp)
 800a82c:	e0bffd17 	ldw	r2,-12(fp)
 800a830:	18800c26 	beq	r3,r2,800a864 <alt_load_section+0x54>
  {
    while( to != end )
 800a834:	00000806 	br	800a858 <alt_load_section+0x48>
    {
      *to++ = *from++;
 800a838:	e0bffe17 	ldw	r2,-8(fp)
 800a83c:	10c00104 	addi	r3,r2,4
 800a840:	e0fffe15 	stw	r3,-8(fp)
 800a844:	e0fffd17 	ldw	r3,-12(fp)
 800a848:	19000104 	addi	r4,r3,4
 800a84c:	e13ffd15 	stw	r4,-12(fp)
 800a850:	18c00017 	ldw	r3,0(r3)
 800a854:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 800a858:	e0fffe17 	ldw	r3,-8(fp)
 800a85c:	e0bfff17 	ldw	r2,-4(fp)
 800a860:	18bff51e 	bne	r3,r2,800a838 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 800a864:	0001883a 	nop
 800a868:	e037883a 	mov	sp,fp
 800a86c:	df000017 	ldw	fp,0(sp)
 800a870:	dec00104 	addi	sp,sp,4
 800a874:	f800283a 	ret

0800a878 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 800a878:	defffe04 	addi	sp,sp,-8
 800a87c:	dfc00115 	stw	ra,4(sp)
 800a880:	df000015 	stw	fp,0(sp)
 800a884:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 800a888:	01820174 	movhi	r6,2053
 800a88c:	31a0ab04 	addi	r6,r6,-32084
 800a890:	01420134 	movhi	r5,2052
 800a894:	29599604 	addi	r5,r5,26200
 800a898:	01020174 	movhi	r4,2053
 800a89c:	2120ab04 	addi	r4,r4,-32084
 800a8a0:	800a8100 	call	800a810 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 800a8a4:	01820034 	movhi	r6,2048
 800a8a8:	31809104 	addi	r6,r6,580
 800a8ac:	01420034 	movhi	r5,2048
 800a8b0:	29400804 	addi	r5,r5,32
 800a8b4:	01020034 	movhi	r4,2048
 800a8b8:	21000804 	addi	r4,r4,32
 800a8bc:	800a8100 	call	800a810 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 800a8c0:	01820134 	movhi	r6,2052
 800a8c4:	31999604 	addi	r6,r6,26200
 800a8c8:	01420074 	movhi	r5,2049
 800a8cc:	29779304 	addi	r5,r5,-8628
 800a8d0:	01020074 	movhi	r4,2049
 800a8d4:	21379304 	addi	r4,r4,-8628
 800a8d8:	800a8100 	call	800a810 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 800a8dc:	800d1280 	call	800d128 <alt_dcache_flush_all>
  alt_icache_flush_all();
 800a8e0:	800d3a00 	call	800d3a0 <alt_icache_flush_all>
}
 800a8e4:	0001883a 	nop
 800a8e8:	e037883a 	mov	sp,fp
 800a8ec:	dfc00117 	ldw	ra,4(sp)
 800a8f0:	df000017 	ldw	fp,0(sp)
 800a8f4:	dec00204 	addi	sp,sp,8
 800a8f8:	f800283a 	ret

0800a8fc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a8fc:	defffe04 	addi	sp,sp,-8
 800a900:	dfc00115 	stw	ra,4(sp)
 800a904:	df000015 	stw	fp,0(sp)
 800a908:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a90c:	d0a04b17 	ldw	r2,-32468(gp)
 800a910:	10000326 	beq	r2,zero,800a920 <alt_get_errno+0x24>
 800a914:	d0a04b17 	ldw	r2,-32468(gp)
 800a918:	103ee83a 	callr	r2
 800a91c:	00000106 	br	800a924 <alt_get_errno+0x28>
 800a920:	d0a76a04 	addi	r2,gp,-25176
}
 800a924:	e037883a 	mov	sp,fp
 800a928:	dfc00117 	ldw	ra,4(sp)
 800a92c:	df000017 	ldw	fp,0(sp)
 800a930:	dec00204 	addi	sp,sp,8
 800a934:	f800283a 	ret

0800a938 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 800a938:	defff904 	addi	sp,sp,-28
 800a93c:	dfc00615 	stw	ra,24(sp)
 800a940:	df000515 	stw	fp,20(sp)
 800a944:	df000504 	addi	fp,sp,20
 800a948:	e13ffd15 	stw	r4,-12(fp)
 800a94c:	e17ffe15 	stw	r5,-8(fp)
 800a950:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 800a954:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a958:	e0bffd17 	ldw	r2,-12(fp)
 800a95c:	10000616 	blt	r2,zero,800a978 <lseek+0x40>
 800a960:	e0bffd17 	ldw	r2,-12(fp)
 800a964:	10c00324 	muli	r3,r2,12
 800a968:	00820134 	movhi	r2,2052
 800a96c:	109bab04 	addi	r2,r2,28332
 800a970:	1885883a 	add	r2,r3,r2
 800a974:	00000106 	br	800a97c <lseek+0x44>
 800a978:	0005883a 	mov	r2,zero
 800a97c:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 800a980:	e0bffc17 	ldw	r2,-16(fp)
 800a984:	10001026 	beq	r2,zero,800a9c8 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 800a988:	e0bffc17 	ldw	r2,-16(fp)
 800a98c:	10800017 	ldw	r2,0(r2)
 800a990:	10800717 	ldw	r2,28(r2)
 800a994:	10000926 	beq	r2,zero,800a9bc <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 800a998:	e0bffc17 	ldw	r2,-16(fp)
 800a99c:	10800017 	ldw	r2,0(r2)
 800a9a0:	10800717 	ldw	r2,28(r2)
 800a9a4:	e1bfff17 	ldw	r6,-4(fp)
 800a9a8:	e17ffe17 	ldw	r5,-8(fp)
 800a9ac:	e13ffc17 	ldw	r4,-16(fp)
 800a9b0:	103ee83a 	callr	r2
 800a9b4:	e0bffb15 	stw	r2,-20(fp)
 800a9b8:	00000506 	br	800a9d0 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 800a9bc:	00bfde84 	movi	r2,-134
 800a9c0:	e0bffb15 	stw	r2,-20(fp)
 800a9c4:	00000206 	br	800a9d0 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 800a9c8:	00bfebc4 	movi	r2,-81
 800a9cc:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 800a9d0:	e0bffb17 	ldw	r2,-20(fp)
 800a9d4:	1000070e 	bge	r2,zero,800a9f4 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 800a9d8:	800a8fc0 	call	800a8fc <alt_get_errno>
 800a9dc:	1007883a 	mov	r3,r2
 800a9e0:	e0bffb17 	ldw	r2,-20(fp)
 800a9e4:	0085c83a 	sub	r2,zero,r2
 800a9e8:	18800015 	stw	r2,0(r3)
    rc = -1;
 800a9ec:	00bfffc4 	movi	r2,-1
 800a9f0:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 800a9f4:	e0bffb17 	ldw	r2,-20(fp)
}
 800a9f8:	e037883a 	mov	sp,fp
 800a9fc:	dfc00117 	ldw	ra,4(sp)
 800aa00:	df000017 	ldw	fp,0(sp)
 800aa04:	dec00204 	addi	sp,sp,8
 800aa08:	f800283a 	ret

0800aa0c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 800aa0c:	defffd04 	addi	sp,sp,-12
 800aa10:	dfc00215 	stw	ra,8(sp)
 800aa14:	df000115 	stw	fp,4(sp)
 800aa18:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 800aa1c:	0009883a 	mov	r4,zero
 800aa20:	800b00c0 	call	800b00c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 800aa24:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 800aa28:	800b0440 	call	800b044 <alt_sys_init>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 800aa2c:	800d2500 	call	800d250 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 800aa30:	01020074 	movhi	r4,2049
 800aa34:	2134ac04 	addi	r4,r4,-11600
 800aa38:	800d7c40 	call	800d7c4 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 800aa3c:	d0a76b17 	ldw	r2,-25172(gp)
 800aa40:	d0e76c17 	ldw	r3,-25168(gp)
 800aa44:	d1276d17 	ldw	r4,-25164(gp)
 800aa48:	200d883a 	mov	r6,r4
 800aa4c:	180b883a 	mov	r5,r3
 800aa50:	1009883a 	mov	r4,r2
 800aa54:	80006f40 	call	80006f4 <main>
 800aa58:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 800aa5c:	01000044 	movi	r4,1
 800aa60:	800a5480 	call	800a548 <close>
  exit (result);
 800aa64:	e13fff17 	ldw	r4,-4(fp)
 800aa68:	800d8000 	call	800d800 <exit>

0800aa6c <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 800aa6c:	defffe04 	addi	sp,sp,-8
 800aa70:	df000115 	stw	fp,4(sp)
 800aa74:	df000104 	addi	fp,sp,4
 800aa78:	e13fff15 	stw	r4,-4(fp)
}
 800aa7c:	0001883a 	nop
 800aa80:	e037883a 	mov	sp,fp
 800aa84:	df000017 	ldw	fp,0(sp)
 800aa88:	dec00104 	addi	sp,sp,4
 800aa8c:	f800283a 	ret

0800aa90 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 800aa90:	defffe04 	addi	sp,sp,-8
 800aa94:	df000115 	stw	fp,4(sp)
 800aa98:	df000104 	addi	fp,sp,4
 800aa9c:	e13fff15 	stw	r4,-4(fp)
}
 800aaa0:	0001883a 	nop
 800aaa4:	e037883a 	mov	sp,fp
 800aaa8:	df000017 	ldw	fp,0(sp)
 800aaac:	dec00104 	addi	sp,sp,4
 800aab0:	f800283a 	ret

0800aab4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800aab4:	defffe04 	addi	sp,sp,-8
 800aab8:	dfc00115 	stw	ra,4(sp)
 800aabc:	df000015 	stw	fp,0(sp)
 800aac0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800aac4:	d0a04b17 	ldw	r2,-32468(gp)
 800aac8:	10000326 	beq	r2,zero,800aad8 <alt_get_errno+0x24>
 800aacc:	d0a04b17 	ldw	r2,-32468(gp)
 800aad0:	103ee83a 	callr	r2
 800aad4:	00000106 	br	800aadc <alt_get_errno+0x28>
 800aad8:	d0a76a04 	addi	r2,gp,-25176
}
 800aadc:	e037883a 	mov	sp,fp
 800aae0:	dfc00117 	ldw	ra,4(sp)
 800aae4:	df000017 	ldw	fp,0(sp)
 800aae8:	dec00204 	addi	sp,sp,8
 800aaec:	f800283a 	ret

0800aaf0 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 800aaf0:	defff904 	addi	sp,sp,-28
 800aaf4:	dfc00615 	stw	ra,24(sp)
 800aaf8:	df000515 	stw	fp,20(sp)
 800aafc:	df000504 	addi	fp,sp,20
 800ab00:	e13ffd15 	stw	r4,-12(fp)
 800ab04:	e17ffe15 	stw	r5,-8(fp)
 800ab08:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800ab0c:	e0bffd17 	ldw	r2,-12(fp)
 800ab10:	10000616 	blt	r2,zero,800ab2c <read+0x3c>
 800ab14:	e0bffd17 	ldw	r2,-12(fp)
 800ab18:	10c00324 	muli	r3,r2,12
 800ab1c:	00820134 	movhi	r2,2052
 800ab20:	109bab04 	addi	r2,r2,28332
 800ab24:	1885883a 	add	r2,r3,r2
 800ab28:	00000106 	br	800ab30 <read+0x40>
 800ab2c:	0005883a 	mov	r2,zero
 800ab30:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 800ab34:	e0bffb17 	ldw	r2,-20(fp)
 800ab38:	10002226 	beq	r2,zero,800abc4 <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 800ab3c:	e0bffb17 	ldw	r2,-20(fp)
 800ab40:	10800217 	ldw	r2,8(r2)
 800ab44:	108000cc 	andi	r2,r2,3
 800ab48:	10800060 	cmpeqi	r2,r2,1
 800ab4c:	1000181e 	bne	r2,zero,800abb0 <read+0xc0>
        (fd->dev->read))
 800ab50:	e0bffb17 	ldw	r2,-20(fp)
 800ab54:	10800017 	ldw	r2,0(r2)
 800ab58:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 800ab5c:	10001426 	beq	r2,zero,800abb0 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 800ab60:	e0bffb17 	ldw	r2,-20(fp)
 800ab64:	10800017 	ldw	r2,0(r2)
 800ab68:	10800517 	ldw	r2,20(r2)
 800ab6c:	e0ffff17 	ldw	r3,-4(fp)
 800ab70:	180d883a 	mov	r6,r3
 800ab74:	e17ffe17 	ldw	r5,-8(fp)
 800ab78:	e13ffb17 	ldw	r4,-20(fp)
 800ab7c:	103ee83a 	callr	r2
 800ab80:	e0bffc15 	stw	r2,-16(fp)
 800ab84:	e0bffc17 	ldw	r2,-16(fp)
 800ab88:	1000070e 	bge	r2,zero,800aba8 <read+0xb8>
        {
          ALT_ERRNO = -rval;
 800ab8c:	800aab40 	call	800aab4 <alt_get_errno>
 800ab90:	1007883a 	mov	r3,r2
 800ab94:	e0bffc17 	ldw	r2,-16(fp)
 800ab98:	0085c83a 	sub	r2,zero,r2
 800ab9c:	18800015 	stw	r2,0(r3)
          return -1;
 800aba0:	00bfffc4 	movi	r2,-1
 800aba4:	00000c06 	br	800abd8 <read+0xe8>
        }
        return rval;
 800aba8:	e0bffc17 	ldw	r2,-16(fp)
 800abac:	00000a06 	br	800abd8 <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 800abb0:	800aab40 	call	800aab4 <alt_get_errno>
 800abb4:	1007883a 	mov	r3,r2
 800abb8:	00800344 	movi	r2,13
 800abbc:	18800015 	stw	r2,0(r3)
 800abc0:	00000406 	br	800abd4 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 800abc4:	800aab40 	call	800aab4 <alt_get_errno>
 800abc8:	1007883a 	mov	r3,r2
 800abcc:	00801444 	movi	r2,81
 800abd0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 800abd4:	00bfffc4 	movi	r2,-1
}
 800abd8:	e037883a 	mov	sp,fp
 800abdc:	dfc00117 	ldw	ra,4(sp)
 800abe0:	df000017 	ldw	fp,0(sp)
 800abe4:	dec00204 	addi	sp,sp,8
 800abe8:	f800283a 	ret

0800abec <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 800abec:	defffe04 	addi	sp,sp,-8
 800abf0:	df000115 	stw	fp,4(sp)
 800abf4:	df000104 	addi	fp,sp,4
 800abf8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 800abfc:	e0bfff17 	ldw	r2,-4(fp)
 800ac00:	108000d0 	cmplti	r2,r2,3
 800ac04:	10000d1e 	bne	r2,zero,800ac3c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 800ac08:	00820134 	movhi	r2,2052
 800ac0c:	109bab04 	addi	r2,r2,28332
 800ac10:	e0ffff17 	ldw	r3,-4(fp)
 800ac14:	18c00324 	muli	r3,r3,12
 800ac18:	10c5883a 	add	r2,r2,r3
 800ac1c:	10800204 	addi	r2,r2,8
 800ac20:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 800ac24:	00820134 	movhi	r2,2052
 800ac28:	109bab04 	addi	r2,r2,28332
 800ac2c:	e0ffff17 	ldw	r3,-4(fp)
 800ac30:	18c00324 	muli	r3,r3,12
 800ac34:	10c5883a 	add	r2,r2,r3
 800ac38:	10000015 	stw	zero,0(r2)
  }
}
 800ac3c:	0001883a 	nop
 800ac40:	e037883a 	mov	sp,fp
 800ac44:	df000017 	ldw	fp,0(sp)
 800ac48:	dec00104 	addi	sp,sp,4
 800ac4c:	f800283a 	ret

0800ac50 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 800ac50:	defff904 	addi	sp,sp,-28
 800ac54:	df000615 	stw	fp,24(sp)
 800ac58:	df000604 	addi	fp,sp,24
 800ac5c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800ac60:	0005303a 	rdctl	r2,status
 800ac64:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800ac68:	e0fffe17 	ldw	r3,-8(fp)
 800ac6c:	00bfff84 	movi	r2,-2
 800ac70:	1884703a 	and	r2,r3,r2
 800ac74:	1001703a 	wrctl	status,r2
  
  return context;
 800ac78:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 800ac7c:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 800ac80:	d0a04c17 	ldw	r2,-32464(gp)
 800ac84:	10c000c4 	addi	r3,r2,3
 800ac88:	00bfff04 	movi	r2,-4
 800ac8c:	1884703a 	and	r2,r3,r2
 800ac90:	d0a04c15 	stw	r2,-32464(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 800ac94:	d0e04c17 	ldw	r3,-32464(gp)
 800ac98:	e0bfff17 	ldw	r2,-4(fp)
 800ac9c:	1887883a 	add	r3,r3,r2
 800aca0:	00840034 	movhi	r2,4096
 800aca4:	10800004 	addi	r2,r2,0
 800aca8:	10c0062e 	bgeu	r2,r3,800acc4 <sbrk+0x74>
 800acac:	e0bffb17 	ldw	r2,-20(fp)
 800acb0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800acb4:	e0bffa17 	ldw	r2,-24(fp)
 800acb8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 800acbc:	00bfffc4 	movi	r2,-1
 800acc0:	00000b06 	br	800acf0 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 800acc4:	d0a04c17 	ldw	r2,-32464(gp)
 800acc8:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 800accc:	d0e04c17 	ldw	r3,-32464(gp)
 800acd0:	e0bfff17 	ldw	r2,-4(fp)
 800acd4:	1885883a 	add	r2,r3,r2
 800acd8:	d0a04c15 	stw	r2,-32464(gp)
 800acdc:	e0bffb17 	ldw	r2,-20(fp)
 800ace0:	e0bffc15 	stw	r2,-16(fp)
 800ace4:	e0bffc17 	ldw	r2,-16(fp)
 800ace8:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 800acec:	e0bffd17 	ldw	r2,-12(fp)
} 
 800acf0:	e037883a 	mov	sp,fp
 800acf4:	df000017 	ldw	fp,0(sp)
 800acf8:	dec00104 	addi	sp,sp,4
 800acfc:	f800283a 	ret

0800ad00 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 800ad00:	defffa04 	addi	sp,sp,-24
 800ad04:	df000515 	stw	fp,20(sp)
 800ad08:	df000504 	addi	fp,sp,20
 800ad0c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800ad10:	0005303a 	rdctl	r2,status
 800ad14:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800ad18:	e0fffc17 	ldw	r3,-16(fp)
 800ad1c:	00bfff84 	movi	r2,-2
 800ad20:	1884703a 	and	r2,r3,r2
 800ad24:	1001703a 	wrctl	status,r2
  
  return context;
 800ad28:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 800ad2c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 800ad30:	e0bfff17 	ldw	r2,-4(fp)
 800ad34:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 800ad38:	e0bffd17 	ldw	r2,-12(fp)
 800ad3c:	10800017 	ldw	r2,0(r2)
 800ad40:	e0fffd17 	ldw	r3,-12(fp)
 800ad44:	18c00117 	ldw	r3,4(r3)
 800ad48:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 800ad4c:	e0bffd17 	ldw	r2,-12(fp)
 800ad50:	10800117 	ldw	r2,4(r2)
 800ad54:	e0fffd17 	ldw	r3,-12(fp)
 800ad58:	18c00017 	ldw	r3,0(r3)
 800ad5c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 800ad60:	e0bffd17 	ldw	r2,-12(fp)
 800ad64:	e0fffd17 	ldw	r3,-12(fp)
 800ad68:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 800ad6c:	e0bffd17 	ldw	r2,-12(fp)
 800ad70:	e0fffd17 	ldw	r3,-12(fp)
 800ad74:	10c00015 	stw	r3,0(r2)
 800ad78:	e0bffb17 	ldw	r2,-20(fp)
 800ad7c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800ad80:	e0bffe17 	ldw	r2,-8(fp)
 800ad84:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 800ad88:	0001883a 	nop
 800ad8c:	e037883a 	mov	sp,fp
 800ad90:	df000017 	ldw	fp,0(sp)
 800ad94:	dec00104 	addi	sp,sp,4
 800ad98:	f800283a 	ret

0800ad9c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 800ad9c:	defffb04 	addi	sp,sp,-20
 800ada0:	dfc00415 	stw	ra,16(sp)
 800ada4:	df000315 	stw	fp,12(sp)
 800ada8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 800adac:	d0a04d17 	ldw	r2,-32460(gp)
 800adb0:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 800adb4:	d0a76f17 	ldw	r2,-25156(gp)
 800adb8:	10800044 	addi	r2,r2,1
 800adbc:	d0a76f15 	stw	r2,-25156(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 800adc0:	00002e06 	br	800ae7c <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 800adc4:	e0bffd17 	ldw	r2,-12(fp)
 800adc8:	10800017 	ldw	r2,0(r2)
 800adcc:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 800add0:	e0bffd17 	ldw	r2,-12(fp)
 800add4:	10800403 	ldbu	r2,16(r2)
 800add8:	10803fcc 	andi	r2,r2,255
 800addc:	10000426 	beq	r2,zero,800adf0 <alt_tick+0x54>
 800ade0:	d0a76f17 	ldw	r2,-25156(gp)
 800ade4:	1000021e 	bne	r2,zero,800adf0 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 800ade8:	e0bffd17 	ldw	r2,-12(fp)
 800adec:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 800adf0:	e0bffd17 	ldw	r2,-12(fp)
 800adf4:	10800217 	ldw	r2,8(r2)
 800adf8:	d0e76f17 	ldw	r3,-25156(gp)
 800adfc:	18801d36 	bltu	r3,r2,800ae74 <alt_tick+0xd8>
 800ae00:	e0bffd17 	ldw	r2,-12(fp)
 800ae04:	10800403 	ldbu	r2,16(r2)
 800ae08:	10803fcc 	andi	r2,r2,255
 800ae0c:	1000191e 	bne	r2,zero,800ae74 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 800ae10:	e0bffd17 	ldw	r2,-12(fp)
 800ae14:	10800317 	ldw	r2,12(r2)
 800ae18:	e0fffd17 	ldw	r3,-12(fp)
 800ae1c:	18c00517 	ldw	r3,20(r3)
 800ae20:	1809883a 	mov	r4,r3
 800ae24:	103ee83a 	callr	r2
 800ae28:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 800ae2c:	e0bfff17 	ldw	r2,-4(fp)
 800ae30:	1000031e 	bne	r2,zero,800ae40 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 800ae34:	e13ffd17 	ldw	r4,-12(fp)
 800ae38:	800ad000 	call	800ad00 <alt_alarm_stop>
 800ae3c:	00000d06 	br	800ae74 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 800ae40:	e0bffd17 	ldw	r2,-12(fp)
 800ae44:	10c00217 	ldw	r3,8(r2)
 800ae48:	e0bfff17 	ldw	r2,-4(fp)
 800ae4c:	1887883a 	add	r3,r3,r2
 800ae50:	e0bffd17 	ldw	r2,-12(fp)
 800ae54:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 800ae58:	e0bffd17 	ldw	r2,-12(fp)
 800ae5c:	10c00217 	ldw	r3,8(r2)
 800ae60:	d0a76f17 	ldw	r2,-25156(gp)
 800ae64:	1880032e 	bgeu	r3,r2,800ae74 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 800ae68:	e0bffd17 	ldw	r2,-12(fp)
 800ae6c:	00c00044 	movi	r3,1
 800ae70:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 800ae74:	e0bffe17 	ldw	r2,-8(fp)
 800ae78:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 800ae7c:	e0fffd17 	ldw	r3,-12(fp)
 800ae80:	d0a04d04 	addi	r2,gp,-32460
 800ae84:	18bfcf1e 	bne	r3,r2,800adc4 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 800ae88:	0001883a 	nop
}
 800ae8c:	0001883a 	nop
 800ae90:	e037883a 	mov	sp,fp
 800ae94:	dfc00117 	ldw	ra,4(sp)
 800ae98:	df000017 	ldw	fp,0(sp)
 800ae9c:	dec00204 	addi	sp,sp,8
 800aea0:	f800283a 	ret

0800aea4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800aea4:	defffe04 	addi	sp,sp,-8
 800aea8:	dfc00115 	stw	ra,4(sp)
 800aeac:	df000015 	stw	fp,0(sp)
 800aeb0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800aeb4:	d0a04b17 	ldw	r2,-32468(gp)
 800aeb8:	10000326 	beq	r2,zero,800aec8 <alt_get_errno+0x24>
 800aebc:	d0a04b17 	ldw	r2,-32468(gp)
 800aec0:	103ee83a 	callr	r2
 800aec4:	00000106 	br	800aecc <alt_get_errno+0x28>
 800aec8:	d0a76a04 	addi	r2,gp,-25176
}
 800aecc:	e037883a 	mov	sp,fp
 800aed0:	dfc00117 	ldw	ra,4(sp)
 800aed4:	df000017 	ldw	fp,0(sp)
 800aed8:	dec00204 	addi	sp,sp,8
 800aedc:	f800283a 	ret

0800aee0 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 800aee0:	defff904 	addi	sp,sp,-28
 800aee4:	dfc00615 	stw	ra,24(sp)
 800aee8:	df000515 	stw	fp,20(sp)
 800aeec:	df000504 	addi	fp,sp,20
 800aef0:	e13ffd15 	stw	r4,-12(fp)
 800aef4:	e17ffe15 	stw	r5,-8(fp)
 800aef8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800aefc:	e0bffd17 	ldw	r2,-12(fp)
 800af00:	10000616 	blt	r2,zero,800af1c <write+0x3c>
 800af04:	e0bffd17 	ldw	r2,-12(fp)
 800af08:	10c00324 	muli	r3,r2,12
 800af0c:	00820134 	movhi	r2,2052
 800af10:	109bab04 	addi	r2,r2,28332
 800af14:	1885883a 	add	r2,r3,r2
 800af18:	00000106 	br	800af20 <write+0x40>
 800af1c:	0005883a 	mov	r2,zero
 800af20:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 800af24:	e0bffb17 	ldw	r2,-20(fp)
 800af28:	10002126 	beq	r2,zero,800afb0 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 800af2c:	e0bffb17 	ldw	r2,-20(fp)
 800af30:	10800217 	ldw	r2,8(r2)
 800af34:	108000cc 	andi	r2,r2,3
 800af38:	10001826 	beq	r2,zero,800af9c <write+0xbc>
 800af3c:	e0bffb17 	ldw	r2,-20(fp)
 800af40:	10800017 	ldw	r2,0(r2)
 800af44:	10800617 	ldw	r2,24(r2)
 800af48:	10001426 	beq	r2,zero,800af9c <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 800af4c:	e0bffb17 	ldw	r2,-20(fp)
 800af50:	10800017 	ldw	r2,0(r2)
 800af54:	10800617 	ldw	r2,24(r2)
 800af58:	e0ffff17 	ldw	r3,-4(fp)
 800af5c:	180d883a 	mov	r6,r3
 800af60:	e17ffe17 	ldw	r5,-8(fp)
 800af64:	e13ffb17 	ldw	r4,-20(fp)
 800af68:	103ee83a 	callr	r2
 800af6c:	e0bffc15 	stw	r2,-16(fp)
 800af70:	e0bffc17 	ldw	r2,-16(fp)
 800af74:	1000070e 	bge	r2,zero,800af94 <write+0xb4>
      {
        ALT_ERRNO = -rval;
 800af78:	800aea40 	call	800aea4 <alt_get_errno>
 800af7c:	1007883a 	mov	r3,r2
 800af80:	e0bffc17 	ldw	r2,-16(fp)
 800af84:	0085c83a 	sub	r2,zero,r2
 800af88:	18800015 	stw	r2,0(r3)
        return -1;
 800af8c:	00bfffc4 	movi	r2,-1
 800af90:	00000c06 	br	800afc4 <write+0xe4>
      }
      return rval;
 800af94:	e0bffc17 	ldw	r2,-16(fp)
 800af98:	00000a06 	br	800afc4 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 800af9c:	800aea40 	call	800aea4 <alt_get_errno>
 800afa0:	1007883a 	mov	r3,r2
 800afa4:	00800344 	movi	r2,13
 800afa8:	18800015 	stw	r2,0(r3)
 800afac:	00000406 	br	800afc0 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 800afb0:	800aea40 	call	800aea4 <alt_get_errno>
 800afb4:	1007883a 	mov	r3,r2
 800afb8:	00801444 	movi	r2,81
 800afbc:	18800015 	stw	r2,0(r3)
  }
  return -1;
 800afc0:	00bfffc4 	movi	r2,-1
}
 800afc4:	e037883a 	mov	sp,fp
 800afc8:	dfc00117 	ldw	ra,4(sp)
 800afcc:	df000017 	ldw	fp,0(sp)
 800afd0:	dec00204 	addi	sp,sp,8
 800afd4:	f800283a 	ret

0800afd8 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 800afd8:	defffd04 	addi	sp,sp,-12
 800afdc:	dfc00215 	stw	ra,8(sp)
 800afe0:	df000115 	stw	fp,4(sp)
 800afe4:	df000104 	addi	fp,sp,4
 800afe8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 800afec:	d1604804 	addi	r5,gp,-32480
 800aff0:	e13fff17 	ldw	r4,-4(fp)
 800aff4:	800d1ac0 	call	800d1ac <alt_dev_llist_insert>
}
 800aff8:	e037883a 	mov	sp,fp
 800affc:	dfc00117 	ldw	ra,4(sp)
 800b000:	df000017 	ldw	fp,0(sp)
 800b004:	dec00204 	addi	sp,sp,8
 800b008:	f800283a 	ret

0800b00c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 800b00c:	defffd04 	addi	sp,sp,-12
 800b010:	dfc00215 	stw	ra,8(sp)
 800b014:	df000115 	stw	fp,4(sp)
 800b018:	df000104 	addi	fp,sp,4
 800b01c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
 800b020:	800d6740 	call	800d674 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 800b024:	00800044 	movi	r2,1
 800b028:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 800b02c:	0001883a 	nop
 800b030:	e037883a 	mov	sp,fp
 800b034:	dfc00117 	ldw	ra,4(sp)
 800b038:	df000017 	ldw	fp,0(sp)
 800b03c:	dec00204 	addi	sp,sp,8
 800b040:	f800283a 	ret

0800b044 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 800b044:	defffd04 	addi	sp,sp,-12
 800b048:	dfc00215 	stw	ra,8(sp)
 800b04c:	df000115 	stw	fp,4(sp)
 800b050:	df000104 	addi	fp,sp,4
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 800b054:	000d883a 	mov	r6,zero
 800b058:	000b883a 	mov	r5,zero
 800b05c:	01020134 	movhi	r4,2052
 800b060:	211c1504 	addi	r4,r4,28756
 800b064:	800b5640 	call	800b564 <altera_avalon_jtag_uart_init>
 800b068:	01020134 	movhi	r4,2052
 800b06c:	211c0b04 	addi	r4,r4,28716
 800b070:	800afd80 	call	800afd8 <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_CHARACTER_BUFFER_WITH_DMA_INIT ( VIDEO_CHARACTER_BUFFER_WITH_DMA_0, video_character_buffer_with_dma_0);
 800b074:	00820174 	movhi	r2,2053
 800b078:	10a02304 	addi	r2,r2,-32628
 800b07c:	10800a17 	ldw	r2,40(r2)
 800b080:	10800104 	addi	r2,r2,4
 800b084:	10800017 	ldw	r2,0(r2)
 800b088:	10ffffcc 	andi	r3,r2,65535
 800b08c:	00820174 	movhi	r2,2053
 800b090:	10a02304 	addi	r2,r2,-32628
 800b094:	10c00c15 	stw	r3,48(r2)
 800b098:	00820174 	movhi	r2,2053
 800b09c:	10a02304 	addi	r2,r2,-32628
 800b0a0:	10800a17 	ldw	r2,40(r2)
 800b0a4:	10800104 	addi	r2,r2,4
 800b0a8:	10800017 	ldw	r2,0(r2)
 800b0ac:	1006d43a 	srli	r3,r2,16
 800b0b0:	00820174 	movhi	r2,2053
 800b0b4:	10a02304 	addi	r2,r2,-32628
 800b0b8:	10c00d15 	stw	r3,52(r2)
 800b0bc:	00820174 	movhi	r2,2053
 800b0c0:	10a02304 	addi	r2,r2,-32628
 800b0c4:	10800c17 	ldw	r2,48(r2)
 800b0c8:	10801068 	cmpgeui	r2,r2,65
 800b0cc:	1000081e 	bne	r2,zero,800b0f0 <alt_sys_init+0xac>
 800b0d0:	00820174 	movhi	r2,2053
 800b0d4:	10a02304 	addi	r2,r2,-32628
 800b0d8:	00c00fc4 	movi	r3,63
 800b0dc:	10c00f15 	stw	r3,60(r2)
 800b0e0:	00820174 	movhi	r2,2053
 800b0e4:	10a02304 	addi	r2,r2,-32628
 800b0e8:	00c00184 	movi	r3,6
 800b0ec:	10c01015 	stw	r3,64(r2)
 800b0f0:	00820174 	movhi	r2,2053
 800b0f4:	10a02304 	addi	r2,r2,-32628
 800b0f8:	10800d17 	ldw	r2,52(r2)
 800b0fc:	10800868 	cmpgeui	r2,r2,33
 800b100:	1000041e 	bne	r2,zero,800b114 <alt_sys_init+0xd0>
 800b104:	00820174 	movhi	r2,2053
 800b108:	10a02304 	addi	r2,r2,-32628
 800b10c:	00c007c4 	movi	r3,31
 800b110:	10c01115 	stw	r3,68(r2)
 800b114:	01020174 	movhi	r4,2053
 800b118:	21202304 	addi	r4,r4,-32628
 800b11c:	800be680 	call	800be68 <alt_up_char_buffer_init>
 800b120:	01020174 	movhi	r4,2053
 800b124:	21202304 	addi	r4,r4,-32628
 800b128:	800afd80 	call	800afd8 <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_PIXEL_BUFFER_DMA_INIT ( VIDEO_PIXEL_BUFFER_DMA_0, video_pixel_buffer_dma_0);
 800b12c:	00820174 	movhi	r2,2053
 800b130:	10a03504 	addi	r2,r2,-32556
 800b134:	10800a17 	ldw	r2,40(r2)
 800b138:	10800017 	ldw	r2,0(r2)
 800b13c:	1007883a 	mov	r3,r2
 800b140:	00820174 	movhi	r2,2053
 800b144:	10a03504 	addi	r2,r2,-32556
 800b148:	10c00b15 	stw	r3,44(r2)
 800b14c:	00820174 	movhi	r2,2053
 800b150:	10a03504 	addi	r2,r2,-32556
 800b154:	10800a17 	ldw	r2,40(r2)
 800b158:	10800104 	addi	r2,r2,4
 800b15c:	10800017 	ldw	r2,0(r2)
 800b160:	1007883a 	mov	r3,r2
 800b164:	00820174 	movhi	r2,2053
 800b168:	10a03504 	addi	r2,r2,-32556
 800b16c:	10c00c15 	stw	r3,48(r2)
 800b170:	00820174 	movhi	r2,2053
 800b174:	10a03504 	addi	r2,r2,-32556
 800b178:	10800a17 	ldw	r2,40(r2)
 800b17c:	10800204 	addi	r2,r2,8
 800b180:	10800017 	ldw	r2,0(r2)
 800b184:	10ffffcc 	andi	r3,r2,65535
 800b188:	00820174 	movhi	r2,2053
 800b18c:	10a03504 	addi	r2,r2,-32556
 800b190:	10c00f15 	stw	r3,60(r2)
 800b194:	00820174 	movhi	r2,2053
 800b198:	10a03504 	addi	r2,r2,-32556
 800b19c:	10800a17 	ldw	r2,40(r2)
 800b1a0:	10800204 	addi	r2,r2,8
 800b1a4:	10800017 	ldw	r2,0(r2)
 800b1a8:	1006d43a 	srli	r3,r2,16
 800b1ac:	00820174 	movhi	r2,2053
 800b1b0:	10a03504 	addi	r2,r2,-32556
 800b1b4:	10c01015 	stw	r3,64(r2)
 800b1b8:	00820174 	movhi	r2,2053
 800b1bc:	10a03504 	addi	r2,r2,-32556
 800b1c0:	10800a17 	ldw	r2,40(r2)
 800b1c4:	10800304 	addi	r2,r2,12
 800b1c8:	10800017 	ldw	r2,0(r2)
 800b1cc:	1005d07a 	srai	r2,r2,1
 800b1d0:	10c0004c 	andi	r3,r2,1
 800b1d4:	00820174 	movhi	r2,2053
 800b1d8:	10a03504 	addi	r2,r2,-32556
 800b1dc:	10c00d15 	stw	r3,52(r2)
 800b1e0:	00820174 	movhi	r2,2053
 800b1e4:	10a03504 	addi	r2,r2,-32556
 800b1e8:	10800a17 	ldw	r2,40(r2)
 800b1ec:	10800304 	addi	r2,r2,12
 800b1f0:	10800017 	ldw	r2,0(r2)
 800b1f4:	1005d13a 	srai	r2,r2,4
 800b1f8:	10c003cc 	andi	r3,r2,15
 800b1fc:	00820174 	movhi	r2,2053
 800b200:	10a03504 	addi	r2,r2,-32556
 800b204:	10c00e15 	stw	r3,56(r2)
 800b208:	00820174 	movhi	r2,2053
 800b20c:	10a03504 	addi	r2,r2,-32556
 800b210:	10800a17 	ldw	r2,40(r2)
 800b214:	10800304 	addi	r2,r2,12
 800b218:	10800017 	ldw	r2,0(r2)
 800b21c:	1005d43a 	srai	r2,r2,16
 800b220:	e0bfff05 	stb	r2,-4(fp)
 800b224:	00820174 	movhi	r2,2053
 800b228:	10a03504 	addi	r2,r2,-32556
 800b22c:	10800a17 	ldw	r2,40(r2)
 800b230:	10800304 	addi	r2,r2,12
 800b234:	10800017 	ldw	r2,0(r2)
 800b238:	1004d63a 	srli	r2,r2,24
 800b23c:	e0bfff45 	stb	r2,-3(fp)
 800b240:	00820174 	movhi	r2,2053
 800b244:	10a03504 	addi	r2,r2,-32556
 800b248:	10800e17 	ldw	r2,56(r2)
 800b24c:	10800058 	cmpnei	r2,r2,1
 800b250:	1000041e 	bne	r2,zero,800b264 <alt_sys_init+0x220>
 800b254:	00820174 	movhi	r2,2053
 800b258:	10a03504 	addi	r2,r2,-32556
 800b25c:	10001115 	stw	zero,68(r2)
 800b260:	00000e06 	br	800b29c <alt_sys_init+0x258>
 800b264:	00820174 	movhi	r2,2053
 800b268:	10a03504 	addi	r2,r2,-32556
 800b26c:	10800e17 	ldw	r2,56(r2)
 800b270:	10800098 	cmpnei	r2,r2,2
 800b274:	1000051e 	bne	r2,zero,800b28c <alt_sys_init+0x248>
 800b278:	00820174 	movhi	r2,2053
 800b27c:	10a03504 	addi	r2,r2,-32556
 800b280:	00c00044 	movi	r3,1
 800b284:	10c01115 	stw	r3,68(r2)
 800b288:	00000406 	br	800b29c <alt_sys_init+0x258>
 800b28c:	00820174 	movhi	r2,2053
 800b290:	10a03504 	addi	r2,r2,-32556
 800b294:	00c00084 	movi	r3,2
 800b298:	10c01115 	stw	r3,68(r2)
 800b29c:	e0bfff03 	ldbu	r2,-4(fp)
 800b2a0:	00c00804 	movi	r3,32
 800b2a4:	1885c83a 	sub	r2,r3,r2
 800b2a8:	00ffffc4 	movi	r3,-1
 800b2ac:	1886d83a 	srl	r3,r3,r2
 800b2b0:	00820174 	movhi	r2,2053
 800b2b4:	10a03504 	addi	r2,r2,-32556
 800b2b8:	10c01215 	stw	r3,72(r2)
 800b2bc:	e0ffff03 	ldbu	r3,-4(fp)
 800b2c0:	00820174 	movhi	r2,2053
 800b2c4:	10a03504 	addi	r2,r2,-32556
 800b2c8:	10801117 	ldw	r2,68(r2)
 800b2cc:	1887883a 	add	r3,r3,r2
 800b2d0:	00820174 	movhi	r2,2053
 800b2d4:	10a03504 	addi	r2,r2,-32556
 800b2d8:	10c01315 	stw	r3,76(r2)
 800b2dc:	e0bfff43 	ldbu	r2,-3(fp)
 800b2e0:	00c00804 	movi	r3,32
 800b2e4:	1885c83a 	sub	r2,r3,r2
 800b2e8:	00ffffc4 	movi	r3,-1
 800b2ec:	1886d83a 	srl	r3,r3,r2
 800b2f0:	00820174 	movhi	r2,2053
 800b2f4:	10a03504 	addi	r2,r2,-32556
 800b2f8:	10c01415 	stw	r3,80(r2)
 800b2fc:	01020174 	movhi	r4,2053
 800b300:	21203504 	addi	r4,r4,-32556
 800b304:	800afd80 	call	800afd8 <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_RGB_RESAMPLER_INIT ( VIDEO_RGB_RESAMPLER_0, video_rgb_resampler_0);
 800b308:	00820174 	movhi	r2,2053
 800b30c:	10a04a04 	addi	r2,r2,-32472
 800b310:	10800a17 	ldw	r2,40(r2)
 800b314:	10800017 	ldw	r2,0(r2)
 800b318:	10c003cc 	andi	r3,r2,15
 800b31c:	00820174 	movhi	r2,2053
 800b320:	10a04a04 	addi	r2,r2,-32472
 800b324:	10c00b15 	stw	r3,44(r2)
 800b328:	00820174 	movhi	r2,2053
 800b32c:	10a04a04 	addi	r2,r2,-32472
 800b330:	10800a17 	ldw	r2,40(r2)
 800b334:	10800017 	ldw	r2,0(r2)
 800b338:	1005d13a 	srai	r2,r2,4
 800b33c:	10c0004c 	andi	r3,r2,1
 800b340:	00820174 	movhi	r2,2053
 800b344:	10a04a04 	addi	r2,r2,-32472
 800b348:	10c00c15 	stw	r3,48(r2)
 800b34c:	00820174 	movhi	r2,2053
 800b350:	10a04a04 	addi	r2,r2,-32472
 800b354:	10800a17 	ldw	r2,40(r2)
 800b358:	10800017 	ldw	r2,0(r2)
 800b35c:	1005d17a 	srai	r2,r2,5
 800b360:	10c0004c 	andi	r3,r2,1
 800b364:	00820174 	movhi	r2,2053
 800b368:	10a04a04 	addi	r2,r2,-32472
 800b36c:	10c00d15 	stw	r3,52(r2)
 800b370:	00820174 	movhi	r2,2053
 800b374:	10a04a04 	addi	r2,r2,-32472
 800b378:	10800a17 	ldw	r2,40(r2)
 800b37c:	10800017 	ldw	r2,0(r2)
 800b380:	1005d43a 	srai	r2,r2,16
 800b384:	10c003cc 	andi	r3,r2,15
 800b388:	00820174 	movhi	r2,2053
 800b38c:	10a04a04 	addi	r2,r2,-32472
 800b390:	10c00e15 	stw	r3,56(r2)
 800b394:	00820174 	movhi	r2,2053
 800b398:	10a04a04 	addi	r2,r2,-32472
 800b39c:	10800a17 	ldw	r2,40(r2)
 800b3a0:	10800017 	ldw	r2,0(r2)
 800b3a4:	1005d53a 	srai	r2,r2,20
 800b3a8:	10c0004c 	andi	r3,r2,1
 800b3ac:	00820174 	movhi	r2,2053
 800b3b0:	10a04a04 	addi	r2,r2,-32472
 800b3b4:	10c00f15 	stw	r3,60(r2)
 800b3b8:	00820174 	movhi	r2,2053
 800b3bc:	10a04a04 	addi	r2,r2,-32472
 800b3c0:	10800a17 	ldw	r2,40(r2)
 800b3c4:	10800017 	ldw	r2,0(r2)
 800b3c8:	1005d57a 	srai	r2,r2,21
 800b3cc:	10c0004c 	andi	r3,r2,1
 800b3d0:	00820174 	movhi	r2,2053
 800b3d4:	10a04a04 	addi	r2,r2,-32472
 800b3d8:	10c01015 	stw	r3,64(r2)
 800b3dc:	01020174 	movhi	r4,2053
 800b3e0:	21204a04 	addi	r4,r4,-32472
 800b3e4:	800afd80 	call	800afd8 <alt_dev_reg>
}
 800b3e8:	0001883a 	nop
 800b3ec:	e037883a 	mov	sp,fp
 800b3f0:	dfc00117 	ldw	ra,4(sp)
 800b3f4:	df000017 	ldw	fp,0(sp)
 800b3f8:	dec00204 	addi	sp,sp,8
 800b3fc:	f800283a 	ret

0800b400 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 800b400:	defffa04 	addi	sp,sp,-24
 800b404:	dfc00515 	stw	ra,20(sp)
 800b408:	df000415 	stw	fp,16(sp)
 800b40c:	df000404 	addi	fp,sp,16
 800b410:	e13ffd15 	stw	r4,-12(fp)
 800b414:	e17ffe15 	stw	r5,-8(fp)
 800b418:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800b41c:	e0bffd17 	ldw	r2,-12(fp)
 800b420:	10800017 	ldw	r2,0(r2)
 800b424:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 800b428:	e0bffc17 	ldw	r2,-16(fp)
 800b42c:	10c00a04 	addi	r3,r2,40
 800b430:	e0bffd17 	ldw	r2,-12(fp)
 800b434:	10800217 	ldw	r2,8(r2)
 800b438:	100f883a 	mov	r7,r2
 800b43c:	e1bfff17 	ldw	r6,-4(fp)
 800b440:	e17ffe17 	ldw	r5,-8(fp)
 800b444:	1809883a 	mov	r4,r3
 800b448:	800ba280 	call	800ba28 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 800b44c:	e037883a 	mov	sp,fp
 800b450:	dfc00117 	ldw	ra,4(sp)
 800b454:	df000017 	ldw	fp,0(sp)
 800b458:	dec00204 	addi	sp,sp,8
 800b45c:	f800283a 	ret

0800b460 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 800b460:	defffa04 	addi	sp,sp,-24
 800b464:	dfc00515 	stw	ra,20(sp)
 800b468:	df000415 	stw	fp,16(sp)
 800b46c:	df000404 	addi	fp,sp,16
 800b470:	e13ffd15 	stw	r4,-12(fp)
 800b474:	e17ffe15 	stw	r5,-8(fp)
 800b478:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800b47c:	e0bffd17 	ldw	r2,-12(fp)
 800b480:	10800017 	ldw	r2,0(r2)
 800b484:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 800b488:	e0bffc17 	ldw	r2,-16(fp)
 800b48c:	10c00a04 	addi	r3,r2,40
 800b490:	e0bffd17 	ldw	r2,-12(fp)
 800b494:	10800217 	ldw	r2,8(r2)
 800b498:	100f883a 	mov	r7,r2
 800b49c:	e1bfff17 	ldw	r6,-4(fp)
 800b4a0:	e17ffe17 	ldw	r5,-8(fp)
 800b4a4:	1809883a 	mov	r4,r3
 800b4a8:	800bc440 	call	800bc44 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 800b4ac:	e037883a 	mov	sp,fp
 800b4b0:	dfc00117 	ldw	ra,4(sp)
 800b4b4:	df000017 	ldw	fp,0(sp)
 800b4b8:	dec00204 	addi	sp,sp,8
 800b4bc:	f800283a 	ret

0800b4c0 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 800b4c0:	defffc04 	addi	sp,sp,-16
 800b4c4:	dfc00315 	stw	ra,12(sp)
 800b4c8:	df000215 	stw	fp,8(sp)
 800b4cc:	df000204 	addi	fp,sp,8
 800b4d0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800b4d4:	e0bfff17 	ldw	r2,-4(fp)
 800b4d8:	10800017 	ldw	r2,0(r2)
 800b4dc:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 800b4e0:	e0bffe17 	ldw	r2,-8(fp)
 800b4e4:	10c00a04 	addi	r3,r2,40
 800b4e8:	e0bfff17 	ldw	r2,-4(fp)
 800b4ec:	10800217 	ldw	r2,8(r2)
 800b4f0:	100b883a 	mov	r5,r2
 800b4f4:	1809883a 	mov	r4,r3
 800b4f8:	800b8d00 	call	800b8d0 <altera_avalon_jtag_uart_close>
}
 800b4fc:	e037883a 	mov	sp,fp
 800b500:	dfc00117 	ldw	ra,4(sp)
 800b504:	df000017 	ldw	fp,0(sp)
 800b508:	dec00204 	addi	sp,sp,8
 800b50c:	f800283a 	ret

0800b510 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 800b510:	defffa04 	addi	sp,sp,-24
 800b514:	dfc00515 	stw	ra,20(sp)
 800b518:	df000415 	stw	fp,16(sp)
 800b51c:	df000404 	addi	fp,sp,16
 800b520:	e13ffd15 	stw	r4,-12(fp)
 800b524:	e17ffe15 	stw	r5,-8(fp)
 800b528:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 800b52c:	e0bffd17 	ldw	r2,-12(fp)
 800b530:	10800017 	ldw	r2,0(r2)
 800b534:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 800b538:	e0bffc17 	ldw	r2,-16(fp)
 800b53c:	10800a04 	addi	r2,r2,40
 800b540:	e1bfff17 	ldw	r6,-4(fp)
 800b544:	e17ffe17 	ldw	r5,-8(fp)
 800b548:	1009883a 	mov	r4,r2
 800b54c:	800b9380 	call	800b938 <altera_avalon_jtag_uart_ioctl>
}
 800b550:	e037883a 	mov	sp,fp
 800b554:	dfc00117 	ldw	ra,4(sp)
 800b558:	df000017 	ldw	fp,0(sp)
 800b55c:	dec00204 	addi	sp,sp,8
 800b560:	f800283a 	ret

0800b564 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 800b564:	defffa04 	addi	sp,sp,-24
 800b568:	dfc00515 	stw	ra,20(sp)
 800b56c:	df000415 	stw	fp,16(sp)
 800b570:	df000404 	addi	fp,sp,16
 800b574:	e13ffd15 	stw	r4,-12(fp)
 800b578:	e17ffe15 	stw	r5,-8(fp)
 800b57c:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800b580:	e0bffd17 	ldw	r2,-12(fp)
 800b584:	00c00044 	movi	r3,1
 800b588:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 800b58c:	e0bffd17 	ldw	r2,-12(fp)
 800b590:	10800017 	ldw	r2,0(r2)
 800b594:	10800104 	addi	r2,r2,4
 800b598:	1007883a 	mov	r3,r2
 800b59c:	e0bffd17 	ldw	r2,-12(fp)
 800b5a0:	10800817 	ldw	r2,32(r2)
 800b5a4:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 800b5a8:	e0bffe17 	ldw	r2,-8(fp)
 800b5ac:	e0ffff17 	ldw	r3,-4(fp)
 800b5b0:	d8000015 	stw	zero,0(sp)
 800b5b4:	e1fffd17 	ldw	r7,-12(fp)
 800b5b8:	01820074 	movhi	r6,2049
 800b5bc:	31ad8904 	addi	r6,r6,-18908
 800b5c0:	180b883a 	mov	r5,r3
 800b5c4:	1009883a 	mov	r4,r2
 800b5c8:	800d3d40 	call	800d3d4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 800b5cc:	e0bffd17 	ldw	r2,-12(fp)
 800b5d0:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 800b5d4:	e0bffd17 	ldw	r2,-12(fp)
 800b5d8:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 800b5dc:	d0e76e17 	ldw	r3,-25160(gp)
 800b5e0:	e1fffd17 	ldw	r7,-12(fp)
 800b5e4:	01820074 	movhi	r6,2049
 800b5e8:	31ae0c04 	addi	r6,r6,-18384
 800b5ec:	180b883a 	mov	r5,r3
 800b5f0:	1009883a 	mov	r4,r2
 800b5f4:	800cffc0 	call	800cffc <alt_alarm_start>
 800b5f8:	1000040e 	bge	r2,zero,800b60c <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 800b5fc:	e0fffd17 	ldw	r3,-12(fp)
 800b600:	00a00034 	movhi	r2,32768
 800b604:	10bfffc4 	addi	r2,r2,-1
 800b608:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 800b60c:	0001883a 	nop
 800b610:	e037883a 	mov	sp,fp
 800b614:	dfc00117 	ldw	ra,4(sp)
 800b618:	df000017 	ldw	fp,0(sp)
 800b61c:	dec00204 	addi	sp,sp,8
 800b620:	f800283a 	ret

0800b624 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 800b624:	defff804 	addi	sp,sp,-32
 800b628:	df000715 	stw	fp,28(sp)
 800b62c:	df000704 	addi	fp,sp,28
 800b630:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 800b634:	e0bfff17 	ldw	r2,-4(fp)
 800b638:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 800b63c:	e0bffb17 	ldw	r2,-20(fp)
 800b640:	10800017 	ldw	r2,0(r2)
 800b644:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800b648:	e0bffc17 	ldw	r2,-16(fp)
 800b64c:	10800104 	addi	r2,r2,4
 800b650:	10800037 	ldwio	r2,0(r2)
 800b654:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 800b658:	e0bffd17 	ldw	r2,-12(fp)
 800b65c:	1080c00c 	andi	r2,r2,768
 800b660:	10006d26 	beq	r2,zero,800b818 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 800b664:	e0bffd17 	ldw	r2,-12(fp)
 800b668:	1080400c 	andi	r2,r2,256
 800b66c:	10003526 	beq	r2,zero,800b744 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 800b670:	00800074 	movhi	r2,1
 800b674:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800b678:	e0bffb17 	ldw	r2,-20(fp)
 800b67c:	10800a17 	ldw	r2,40(r2)
 800b680:	10800044 	addi	r2,r2,1
 800b684:	1081ffcc 	andi	r2,r2,2047
 800b688:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 800b68c:	e0bffb17 	ldw	r2,-20(fp)
 800b690:	10c00b17 	ldw	r3,44(r2)
 800b694:	e0bffe17 	ldw	r2,-8(fp)
 800b698:	18801526 	beq	r3,r2,800b6f0 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 800b69c:	e0bffc17 	ldw	r2,-16(fp)
 800b6a0:	10800037 	ldwio	r2,0(r2)
 800b6a4:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 800b6a8:	e0bff917 	ldw	r2,-28(fp)
 800b6ac:	10a0000c 	andi	r2,r2,32768
 800b6b0:	10001126 	beq	r2,zero,800b6f8 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 800b6b4:	e0bffb17 	ldw	r2,-20(fp)
 800b6b8:	10800a17 	ldw	r2,40(r2)
 800b6bc:	e0fff917 	ldw	r3,-28(fp)
 800b6c0:	1809883a 	mov	r4,r3
 800b6c4:	e0fffb17 	ldw	r3,-20(fp)
 800b6c8:	1885883a 	add	r2,r3,r2
 800b6cc:	10800e04 	addi	r2,r2,56
 800b6d0:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800b6d4:	e0bffb17 	ldw	r2,-20(fp)
 800b6d8:	10800a17 	ldw	r2,40(r2)
 800b6dc:	10800044 	addi	r2,r2,1
 800b6e0:	10c1ffcc 	andi	r3,r2,2047
 800b6e4:	e0bffb17 	ldw	r2,-20(fp)
 800b6e8:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 800b6ec:	003fe206 	br	800b678 <altera_avalon_jtag_uart_irq+0x54>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 800b6f0:	0001883a 	nop
 800b6f4:	00000106 	br	800b6fc <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 800b6f8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 800b6fc:	e0bff917 	ldw	r2,-28(fp)
 800b700:	10bfffec 	andhi	r2,r2,65535
 800b704:	10000f26 	beq	r2,zero,800b744 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800b708:	e0bffb17 	ldw	r2,-20(fp)
 800b70c:	10c00817 	ldw	r3,32(r2)
 800b710:	00bfff84 	movi	r2,-2
 800b714:	1886703a 	and	r3,r3,r2
 800b718:	e0bffb17 	ldw	r2,-20(fp)
 800b71c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 800b720:	e0bffc17 	ldw	r2,-16(fp)
 800b724:	10800104 	addi	r2,r2,4
 800b728:	1007883a 	mov	r3,r2
 800b72c:	e0bffb17 	ldw	r2,-20(fp)
 800b730:	10800817 	ldw	r2,32(r2)
 800b734:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800b738:	e0bffc17 	ldw	r2,-16(fp)
 800b73c:	10800104 	addi	r2,r2,4
 800b740:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 800b744:	e0bffd17 	ldw	r2,-12(fp)
 800b748:	1080800c 	andi	r2,r2,512
 800b74c:	103fbe26 	beq	r2,zero,800b648 <altera_avalon_jtag_uart_irq+0x24>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 800b750:	e0bffd17 	ldw	r2,-12(fp)
 800b754:	1004d43a 	srli	r2,r2,16
 800b758:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 800b75c:	00001406 	br	800b7b0 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 800b760:	e0bffc17 	ldw	r2,-16(fp)
 800b764:	e0fffb17 	ldw	r3,-20(fp)
 800b768:	18c00d17 	ldw	r3,52(r3)
 800b76c:	e13ffb17 	ldw	r4,-20(fp)
 800b770:	20c7883a 	add	r3,r4,r3
 800b774:	18c20e04 	addi	r3,r3,2104
 800b778:	18c00003 	ldbu	r3,0(r3)
 800b77c:	18c03fcc 	andi	r3,r3,255
 800b780:	18c0201c 	xori	r3,r3,128
 800b784:	18ffe004 	addi	r3,r3,-128
 800b788:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800b78c:	e0bffb17 	ldw	r2,-20(fp)
 800b790:	10800d17 	ldw	r2,52(r2)
 800b794:	10800044 	addi	r2,r2,1
 800b798:	10c1ffcc 	andi	r3,r2,2047
 800b79c:	e0bffb17 	ldw	r2,-20(fp)
 800b7a0:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 800b7a4:	e0bffa17 	ldw	r2,-24(fp)
 800b7a8:	10bfffc4 	addi	r2,r2,-1
 800b7ac:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 800b7b0:	e0bffa17 	ldw	r2,-24(fp)
 800b7b4:	10000526 	beq	r2,zero,800b7cc <altera_avalon_jtag_uart_irq+0x1a8>
 800b7b8:	e0bffb17 	ldw	r2,-20(fp)
 800b7bc:	10c00d17 	ldw	r3,52(r2)
 800b7c0:	e0bffb17 	ldw	r2,-20(fp)
 800b7c4:	10800c17 	ldw	r2,48(r2)
 800b7c8:	18bfe51e 	bne	r3,r2,800b760 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 800b7cc:	e0bffa17 	ldw	r2,-24(fp)
 800b7d0:	103f9d26 	beq	r2,zero,800b648 <altera_avalon_jtag_uart_irq+0x24>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 800b7d4:	e0bffb17 	ldw	r2,-20(fp)
 800b7d8:	10c00817 	ldw	r3,32(r2)
 800b7dc:	00bfff44 	movi	r2,-3
 800b7e0:	1886703a 	and	r3,r3,r2
 800b7e4:	e0bffb17 	ldw	r2,-20(fp)
 800b7e8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800b7ec:	e0bffb17 	ldw	r2,-20(fp)
 800b7f0:	10800017 	ldw	r2,0(r2)
 800b7f4:	10800104 	addi	r2,r2,4
 800b7f8:	1007883a 	mov	r3,r2
 800b7fc:	e0bffb17 	ldw	r2,-20(fp)
 800b800:	10800817 	ldw	r2,32(r2)
 800b804:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800b808:	e0bffc17 	ldw	r2,-16(fp)
 800b80c:	10800104 	addi	r2,r2,4
 800b810:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 800b814:	003f8c06 	br	800b648 <altera_avalon_jtag_uart_irq+0x24>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 800b818:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 800b81c:	0001883a 	nop
 800b820:	e037883a 	mov	sp,fp
 800b824:	df000017 	ldw	fp,0(sp)
 800b828:	dec00104 	addi	sp,sp,4
 800b82c:	f800283a 	ret

0800b830 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 800b830:	defff804 	addi	sp,sp,-32
 800b834:	df000715 	stw	fp,28(sp)
 800b838:	df000704 	addi	fp,sp,28
 800b83c:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 800b840:	e0bffb17 	ldw	r2,-20(fp)
 800b844:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 800b848:	e0bff917 	ldw	r2,-28(fp)
 800b84c:	10800017 	ldw	r2,0(r2)
 800b850:	10800104 	addi	r2,r2,4
 800b854:	10800037 	ldwio	r2,0(r2)
 800b858:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 800b85c:	e0bffa17 	ldw	r2,-24(fp)
 800b860:	1081000c 	andi	r2,r2,1024
 800b864:	10000b26 	beq	r2,zero,800b894 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 800b868:	e0bff917 	ldw	r2,-28(fp)
 800b86c:	10800017 	ldw	r2,0(r2)
 800b870:	10800104 	addi	r2,r2,4
 800b874:	1007883a 	mov	r3,r2
 800b878:	e0bff917 	ldw	r2,-28(fp)
 800b87c:	10800817 	ldw	r2,32(r2)
 800b880:	10810014 	ori	r2,r2,1024
 800b884:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 800b888:	e0bff917 	ldw	r2,-28(fp)
 800b88c:	10000915 	stw	zero,36(r2)
 800b890:	00000a06 	br	800b8bc <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 800b894:	e0bff917 	ldw	r2,-28(fp)
 800b898:	10c00917 	ldw	r3,36(r2)
 800b89c:	00a00034 	movhi	r2,32768
 800b8a0:	10bfff04 	addi	r2,r2,-4
 800b8a4:	10c00536 	bltu	r2,r3,800b8bc <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 800b8a8:	e0bff917 	ldw	r2,-28(fp)
 800b8ac:	10800917 	ldw	r2,36(r2)
 800b8b0:	10c00044 	addi	r3,r2,1
 800b8b4:	e0bff917 	ldw	r2,-28(fp)
 800b8b8:	10c00915 	stw	r3,36(r2)
 800b8bc:	d0a76e17 	ldw	r2,-25160(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 800b8c0:	e037883a 	mov	sp,fp
 800b8c4:	df000017 	ldw	fp,0(sp)
 800b8c8:	dec00104 	addi	sp,sp,4
 800b8cc:	f800283a 	ret

0800b8d0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 800b8d0:	defffd04 	addi	sp,sp,-12
 800b8d4:	df000215 	stw	fp,8(sp)
 800b8d8:	df000204 	addi	fp,sp,8
 800b8dc:	e13ffe15 	stw	r4,-8(fp)
 800b8e0:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 800b8e4:	00000506 	br	800b8fc <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 800b8e8:	e0bfff17 	ldw	r2,-4(fp)
 800b8ec:	1090000c 	andi	r2,r2,16384
 800b8f0:	10000226 	beq	r2,zero,800b8fc <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 800b8f4:	00bffd44 	movi	r2,-11
 800b8f8:	00000b06 	br	800b928 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 800b8fc:	e0bffe17 	ldw	r2,-8(fp)
 800b900:	10c00d17 	ldw	r3,52(r2)
 800b904:	e0bffe17 	ldw	r2,-8(fp)
 800b908:	10800c17 	ldw	r2,48(r2)
 800b90c:	18800526 	beq	r3,r2,800b924 <altera_avalon_jtag_uart_close+0x54>
 800b910:	e0bffe17 	ldw	r2,-8(fp)
 800b914:	10c00917 	ldw	r3,36(r2)
 800b918:	e0bffe17 	ldw	r2,-8(fp)
 800b91c:	10800117 	ldw	r2,4(r2)
 800b920:	18bff136 	bltu	r3,r2,800b8e8 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 800b924:	0005883a 	mov	r2,zero
}
 800b928:	e037883a 	mov	sp,fp
 800b92c:	df000017 	ldw	fp,0(sp)
 800b930:	dec00104 	addi	sp,sp,4
 800b934:	f800283a 	ret

0800b938 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 800b938:	defffa04 	addi	sp,sp,-24
 800b93c:	df000515 	stw	fp,20(sp)
 800b940:	df000504 	addi	fp,sp,20
 800b944:	e13ffd15 	stw	r4,-12(fp)
 800b948:	e17ffe15 	stw	r5,-8(fp)
 800b94c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 800b950:	00bff9c4 	movi	r2,-25
 800b954:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 800b958:	e0bffe17 	ldw	r2,-8(fp)
 800b95c:	10da8060 	cmpeqi	r3,r2,27137
 800b960:	1800031e 	bne	r3,zero,800b970 <altera_avalon_jtag_uart_ioctl+0x38>
 800b964:	109a80a0 	cmpeqi	r2,r2,27138
 800b968:	1000181e 	bne	r2,zero,800b9cc <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 800b96c:	00002906 	br	800ba14 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 800b970:	e0bffd17 	ldw	r2,-12(fp)
 800b974:	10c00117 	ldw	r3,4(r2)
 800b978:	00a00034 	movhi	r2,32768
 800b97c:	10bfffc4 	addi	r2,r2,-1
 800b980:	18802126 	beq	r3,r2,800ba08 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 800b984:	e0bfff17 	ldw	r2,-4(fp)
 800b988:	10800017 	ldw	r2,0(r2)
 800b98c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 800b990:	e0bffc17 	ldw	r2,-16(fp)
 800b994:	10800090 	cmplti	r2,r2,2
 800b998:	1000061e 	bne	r2,zero,800b9b4 <altera_avalon_jtag_uart_ioctl+0x7c>
 800b99c:	e0fffc17 	ldw	r3,-16(fp)
 800b9a0:	00a00034 	movhi	r2,32768
 800b9a4:	10bfffc4 	addi	r2,r2,-1
 800b9a8:	18800226 	beq	r3,r2,800b9b4 <altera_avalon_jtag_uart_ioctl+0x7c>
 800b9ac:	e0bffc17 	ldw	r2,-16(fp)
 800b9b0:	00000206 	br	800b9bc <altera_avalon_jtag_uart_ioctl+0x84>
 800b9b4:	00a00034 	movhi	r2,32768
 800b9b8:	10bfff84 	addi	r2,r2,-2
 800b9bc:	e0fffd17 	ldw	r3,-12(fp)
 800b9c0:	18800115 	stw	r2,4(r3)
      rc = 0;
 800b9c4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 800b9c8:	00000f06 	br	800ba08 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 800b9cc:	e0bffd17 	ldw	r2,-12(fp)
 800b9d0:	10c00117 	ldw	r3,4(r2)
 800b9d4:	00a00034 	movhi	r2,32768
 800b9d8:	10bfffc4 	addi	r2,r2,-1
 800b9dc:	18800c26 	beq	r3,r2,800ba10 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 800b9e0:	e0bffd17 	ldw	r2,-12(fp)
 800b9e4:	10c00917 	ldw	r3,36(r2)
 800b9e8:	e0bffd17 	ldw	r2,-12(fp)
 800b9ec:	10800117 	ldw	r2,4(r2)
 800b9f0:	1885803a 	cmpltu	r2,r3,r2
 800b9f4:	10c03fcc 	andi	r3,r2,255
 800b9f8:	e0bfff17 	ldw	r2,-4(fp)
 800b9fc:	10c00015 	stw	r3,0(r2)
      rc = 0;
 800ba00:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 800ba04:	00000206 	br	800ba10 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 800ba08:	0001883a 	nop
 800ba0c:	00000106 	br	800ba14 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 800ba10:	0001883a 	nop

  default:
    break;
  }

  return rc;
 800ba14:	e0bffb17 	ldw	r2,-20(fp)
}
 800ba18:	e037883a 	mov	sp,fp
 800ba1c:	df000017 	ldw	fp,0(sp)
 800ba20:	dec00104 	addi	sp,sp,4
 800ba24:	f800283a 	ret

0800ba28 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 800ba28:	defff304 	addi	sp,sp,-52
 800ba2c:	dfc00c15 	stw	ra,48(sp)
 800ba30:	df000b15 	stw	fp,44(sp)
 800ba34:	df000b04 	addi	fp,sp,44
 800ba38:	e13ffc15 	stw	r4,-16(fp)
 800ba3c:	e17ffd15 	stw	r5,-12(fp)
 800ba40:	e1bffe15 	stw	r6,-8(fp)
 800ba44:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 800ba48:	e0bffd17 	ldw	r2,-12(fp)
 800ba4c:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 800ba50:	00004706 	br	800bb70 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 800ba54:	e0bffc17 	ldw	r2,-16(fp)
 800ba58:	10800a17 	ldw	r2,40(r2)
 800ba5c:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 800ba60:	e0bffc17 	ldw	r2,-16(fp)
 800ba64:	10800b17 	ldw	r2,44(r2)
 800ba68:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 800ba6c:	e0fff717 	ldw	r3,-36(fp)
 800ba70:	e0bff817 	ldw	r2,-32(fp)
 800ba74:	18800536 	bltu	r3,r2,800ba8c <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 800ba78:	e0fff717 	ldw	r3,-36(fp)
 800ba7c:	e0bff817 	ldw	r2,-32(fp)
 800ba80:	1885c83a 	sub	r2,r3,r2
 800ba84:	e0bff615 	stw	r2,-40(fp)
 800ba88:	00000406 	br	800ba9c <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 800ba8c:	00c20004 	movi	r3,2048
 800ba90:	e0bff817 	ldw	r2,-32(fp)
 800ba94:	1885c83a 	sub	r2,r3,r2
 800ba98:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 800ba9c:	e0bff617 	ldw	r2,-40(fp)
 800baa0:	10001e26 	beq	r2,zero,800bb1c <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 800baa4:	e0fffe17 	ldw	r3,-8(fp)
 800baa8:	e0bff617 	ldw	r2,-40(fp)
 800baac:	1880022e 	bgeu	r3,r2,800bab8 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 800bab0:	e0bffe17 	ldw	r2,-8(fp)
 800bab4:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 800bab8:	e0bffc17 	ldw	r2,-16(fp)
 800babc:	10c00e04 	addi	r3,r2,56
 800bac0:	e0bff817 	ldw	r2,-32(fp)
 800bac4:	1885883a 	add	r2,r3,r2
 800bac8:	e1bff617 	ldw	r6,-40(fp)
 800bacc:	100b883a 	mov	r5,r2
 800bad0:	e13ff517 	ldw	r4,-44(fp)
 800bad4:	8007e400 	call	8007e40 <memcpy>
      ptr   += n;
 800bad8:	e0fff517 	ldw	r3,-44(fp)
 800badc:	e0bff617 	ldw	r2,-40(fp)
 800bae0:	1885883a 	add	r2,r3,r2
 800bae4:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 800bae8:	e0fffe17 	ldw	r3,-8(fp)
 800baec:	e0bff617 	ldw	r2,-40(fp)
 800baf0:	1885c83a 	sub	r2,r3,r2
 800baf4:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800baf8:	e0fff817 	ldw	r3,-32(fp)
 800bafc:	e0bff617 	ldw	r2,-40(fp)
 800bb00:	1885883a 	add	r2,r3,r2
 800bb04:	10c1ffcc 	andi	r3,r2,2047
 800bb08:	e0bffc17 	ldw	r2,-16(fp)
 800bb0c:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 800bb10:	e0bffe17 	ldw	r2,-8(fp)
 800bb14:	00bfcf16 	blt	zero,r2,800ba54 <altera_avalon_jtag_uart_read+0x2c>
 800bb18:	00000106 	br	800bb20 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 800bb1c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 800bb20:	e0fff517 	ldw	r3,-44(fp)
 800bb24:	e0bffd17 	ldw	r2,-12(fp)
 800bb28:	1880141e 	bne	r3,r2,800bb7c <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 800bb2c:	e0bfff17 	ldw	r2,-4(fp)
 800bb30:	1090000c 	andi	r2,r2,16384
 800bb34:	1000131e 	bne	r2,zero,800bb84 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 800bb38:	0001883a 	nop
 800bb3c:	e0bffc17 	ldw	r2,-16(fp)
 800bb40:	10c00a17 	ldw	r3,40(r2)
 800bb44:	e0bff717 	ldw	r2,-36(fp)
 800bb48:	1880051e 	bne	r3,r2,800bb60 <altera_avalon_jtag_uart_read+0x138>
 800bb4c:	e0bffc17 	ldw	r2,-16(fp)
 800bb50:	10c00917 	ldw	r3,36(r2)
 800bb54:	e0bffc17 	ldw	r2,-16(fp)
 800bb58:	10800117 	ldw	r2,4(r2)
 800bb5c:	18bff736 	bltu	r3,r2,800bb3c <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 800bb60:	e0bffc17 	ldw	r2,-16(fp)
 800bb64:	10c00a17 	ldw	r3,40(r2)
 800bb68:	e0bff717 	ldw	r2,-36(fp)
 800bb6c:	18800726 	beq	r3,r2,800bb8c <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 800bb70:	e0bffe17 	ldw	r2,-8(fp)
 800bb74:	00bfb716 	blt	zero,r2,800ba54 <altera_avalon_jtag_uart_read+0x2c>
 800bb78:	00000506 	br	800bb90 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 800bb7c:	0001883a 	nop
 800bb80:	00000306 	br	800bb90 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 800bb84:	0001883a 	nop
 800bb88:	00000106 	br	800bb90 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 800bb8c:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 800bb90:	e0fff517 	ldw	r3,-44(fp)
 800bb94:	e0bffd17 	ldw	r2,-12(fp)
 800bb98:	18801826 	beq	r3,r2,800bbfc <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800bb9c:	0005303a 	rdctl	r2,status
 800bba0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800bba4:	e0fffb17 	ldw	r3,-20(fp)
 800bba8:	00bfff84 	movi	r2,-2
 800bbac:	1884703a 	and	r2,r3,r2
 800bbb0:	1001703a 	wrctl	status,r2
  
  return context;
 800bbb4:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 800bbb8:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800bbbc:	e0bffc17 	ldw	r2,-16(fp)
 800bbc0:	10800817 	ldw	r2,32(r2)
 800bbc4:	10c00054 	ori	r3,r2,1
 800bbc8:	e0bffc17 	ldw	r2,-16(fp)
 800bbcc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800bbd0:	e0bffc17 	ldw	r2,-16(fp)
 800bbd4:	10800017 	ldw	r2,0(r2)
 800bbd8:	10800104 	addi	r2,r2,4
 800bbdc:	1007883a 	mov	r3,r2
 800bbe0:	e0bffc17 	ldw	r2,-16(fp)
 800bbe4:	10800817 	ldw	r2,32(r2)
 800bbe8:	18800035 	stwio	r2,0(r3)
 800bbec:	e0bffa17 	ldw	r2,-24(fp)
 800bbf0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800bbf4:	e0bff917 	ldw	r2,-28(fp)
 800bbf8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 800bbfc:	e0fff517 	ldw	r3,-44(fp)
 800bc00:	e0bffd17 	ldw	r2,-12(fp)
 800bc04:	18800426 	beq	r3,r2,800bc18 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 800bc08:	e0fff517 	ldw	r3,-44(fp)
 800bc0c:	e0bffd17 	ldw	r2,-12(fp)
 800bc10:	1885c83a 	sub	r2,r3,r2
 800bc14:	00000606 	br	800bc30 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 800bc18:	e0bfff17 	ldw	r2,-4(fp)
 800bc1c:	1090000c 	andi	r2,r2,16384
 800bc20:	10000226 	beq	r2,zero,800bc2c <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 800bc24:	00bffd44 	movi	r2,-11
 800bc28:	00000106 	br	800bc30 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 800bc2c:	00bffec4 	movi	r2,-5
}
 800bc30:	e037883a 	mov	sp,fp
 800bc34:	dfc00117 	ldw	ra,4(sp)
 800bc38:	df000017 	ldw	fp,0(sp)
 800bc3c:	dec00204 	addi	sp,sp,8
 800bc40:	f800283a 	ret

0800bc44 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 800bc44:	defff304 	addi	sp,sp,-52
 800bc48:	dfc00c15 	stw	ra,48(sp)
 800bc4c:	df000b15 	stw	fp,44(sp)
 800bc50:	df000b04 	addi	fp,sp,44
 800bc54:	e13ffc15 	stw	r4,-16(fp)
 800bc58:	e17ffd15 	stw	r5,-12(fp)
 800bc5c:	e1bffe15 	stw	r6,-8(fp)
 800bc60:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 800bc64:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 800bc68:	e0bffd17 	ldw	r2,-12(fp)
 800bc6c:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 800bc70:	00003706 	br	800bd50 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 800bc74:	e0bffc17 	ldw	r2,-16(fp)
 800bc78:	10800c17 	ldw	r2,48(r2)
 800bc7c:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 800bc80:	e0bffc17 	ldw	r2,-16(fp)
 800bc84:	10800d17 	ldw	r2,52(r2)
 800bc88:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 800bc8c:	e0fff917 	ldw	r3,-28(fp)
 800bc90:	e0bff517 	ldw	r2,-44(fp)
 800bc94:	1880062e 	bgeu	r3,r2,800bcb0 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 800bc98:	e0fff517 	ldw	r3,-44(fp)
 800bc9c:	e0bff917 	ldw	r2,-28(fp)
 800bca0:	1885c83a 	sub	r2,r3,r2
 800bca4:	10bfffc4 	addi	r2,r2,-1
 800bca8:	e0bff615 	stw	r2,-40(fp)
 800bcac:	00000b06 	br	800bcdc <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 800bcb0:	e0bff517 	ldw	r2,-44(fp)
 800bcb4:	10000526 	beq	r2,zero,800bccc <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 800bcb8:	00c20004 	movi	r3,2048
 800bcbc:	e0bff917 	ldw	r2,-28(fp)
 800bcc0:	1885c83a 	sub	r2,r3,r2
 800bcc4:	e0bff615 	stw	r2,-40(fp)
 800bcc8:	00000406 	br	800bcdc <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 800bccc:	00c1ffc4 	movi	r3,2047
 800bcd0:	e0bff917 	ldw	r2,-28(fp)
 800bcd4:	1885c83a 	sub	r2,r3,r2
 800bcd8:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 800bcdc:	e0bff617 	ldw	r2,-40(fp)
 800bce0:	10001e26 	beq	r2,zero,800bd5c <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 800bce4:	e0fffe17 	ldw	r3,-8(fp)
 800bce8:	e0bff617 	ldw	r2,-40(fp)
 800bcec:	1880022e 	bgeu	r3,r2,800bcf8 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 800bcf0:	e0bffe17 	ldw	r2,-8(fp)
 800bcf4:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 800bcf8:	e0bffc17 	ldw	r2,-16(fp)
 800bcfc:	10c20e04 	addi	r3,r2,2104
 800bd00:	e0bff917 	ldw	r2,-28(fp)
 800bd04:	1885883a 	add	r2,r3,r2
 800bd08:	e1bff617 	ldw	r6,-40(fp)
 800bd0c:	e17ffd17 	ldw	r5,-12(fp)
 800bd10:	1009883a 	mov	r4,r2
 800bd14:	8007e400 	call	8007e40 <memcpy>
      ptr   += n;
 800bd18:	e0fffd17 	ldw	r3,-12(fp)
 800bd1c:	e0bff617 	ldw	r2,-40(fp)
 800bd20:	1885883a 	add	r2,r3,r2
 800bd24:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 800bd28:	e0fffe17 	ldw	r3,-8(fp)
 800bd2c:	e0bff617 	ldw	r2,-40(fp)
 800bd30:	1885c83a 	sub	r2,r3,r2
 800bd34:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800bd38:	e0fff917 	ldw	r3,-28(fp)
 800bd3c:	e0bff617 	ldw	r2,-40(fp)
 800bd40:	1885883a 	add	r2,r3,r2
 800bd44:	10c1ffcc 	andi	r3,r2,2047
 800bd48:	e0bffc17 	ldw	r2,-16(fp)
 800bd4c:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 800bd50:	e0bffe17 	ldw	r2,-8(fp)
 800bd54:	00bfc716 	blt	zero,r2,800bc74 <altera_avalon_jtag_uart_write+0x30>
 800bd58:	00000106 	br	800bd60 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 800bd5c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800bd60:	0005303a 	rdctl	r2,status
 800bd64:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800bd68:	e0fffb17 	ldw	r3,-20(fp)
 800bd6c:	00bfff84 	movi	r2,-2
 800bd70:	1884703a 	and	r2,r3,r2
 800bd74:	1001703a 	wrctl	status,r2
  
  return context;
 800bd78:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 800bd7c:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 800bd80:	e0bffc17 	ldw	r2,-16(fp)
 800bd84:	10800817 	ldw	r2,32(r2)
 800bd88:	10c00094 	ori	r3,r2,2
 800bd8c:	e0bffc17 	ldw	r2,-16(fp)
 800bd90:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800bd94:	e0bffc17 	ldw	r2,-16(fp)
 800bd98:	10800017 	ldw	r2,0(r2)
 800bd9c:	10800104 	addi	r2,r2,4
 800bda0:	1007883a 	mov	r3,r2
 800bda4:	e0bffc17 	ldw	r2,-16(fp)
 800bda8:	10800817 	ldw	r2,32(r2)
 800bdac:	18800035 	stwio	r2,0(r3)
 800bdb0:	e0bffa17 	ldw	r2,-24(fp)
 800bdb4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800bdb8:	e0bff817 	ldw	r2,-32(fp)
 800bdbc:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 800bdc0:	e0bffe17 	ldw	r2,-8(fp)
 800bdc4:	0080100e 	bge	zero,r2,800be08 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 800bdc8:	e0bfff17 	ldw	r2,-4(fp)
 800bdcc:	1090000c 	andi	r2,r2,16384
 800bdd0:	1000101e 	bne	r2,zero,800be14 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 800bdd4:	0001883a 	nop
 800bdd8:	e0bffc17 	ldw	r2,-16(fp)
 800bddc:	10c00d17 	ldw	r3,52(r2)
 800bde0:	e0bff517 	ldw	r2,-44(fp)
 800bde4:	1880051e 	bne	r3,r2,800bdfc <altera_avalon_jtag_uart_write+0x1b8>
 800bde8:	e0bffc17 	ldw	r2,-16(fp)
 800bdec:	10c00917 	ldw	r3,36(r2)
 800bdf0:	e0bffc17 	ldw	r2,-16(fp)
 800bdf4:	10800117 	ldw	r2,4(r2)
 800bdf8:	18bff736 	bltu	r3,r2,800bdd8 <altera_avalon_jtag_uart_write+0x194>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 800bdfc:	e0bffc17 	ldw	r2,-16(fp)
 800be00:	10800917 	ldw	r2,36(r2)
 800be04:	1000051e 	bne	r2,zero,800be1c <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 800be08:	e0bffe17 	ldw	r2,-8(fp)
 800be0c:	00bfd016 	blt	zero,r2,800bd50 <altera_avalon_jtag_uart_write+0x10c>
 800be10:	00000306 	br	800be20 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 800be14:	0001883a 	nop
 800be18:	00000106 	br	800be20 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 800be1c:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 800be20:	e0fffd17 	ldw	r3,-12(fp)
 800be24:	e0bff717 	ldw	r2,-36(fp)
 800be28:	18800426 	beq	r3,r2,800be3c <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 800be2c:	e0fffd17 	ldw	r3,-12(fp)
 800be30:	e0bff717 	ldw	r2,-36(fp)
 800be34:	1885c83a 	sub	r2,r3,r2
 800be38:	00000606 	br	800be54 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 800be3c:	e0bfff17 	ldw	r2,-4(fp)
 800be40:	1090000c 	andi	r2,r2,16384
 800be44:	10000226 	beq	r2,zero,800be50 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 800be48:	00bffd44 	movi	r2,-11
 800be4c:	00000106 	br	800be54 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 800be50:	00bffec4 	movi	r2,-5
}
 800be54:	e037883a 	mov	sp,fp
 800be58:	dfc00117 	ldw	ra,4(sp)
 800be5c:	df000017 	ldw	fp,0(sp)
 800be60:	dec00204 	addi	sp,sp,8
 800be64:	f800283a 	ret

0800be68 <alt_up_char_buffer_init>:
#include <priv/alt_file.h>

#include "altera_up_avalon_video_character_buffer_with_dma.h"
#include "altera_up_avalon_video_character_buffer_with_dma_regs.h"

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
 800be68:	defffc04 	addi	sp,sp,-16
 800be6c:	dfc00315 	stw	ra,12(sp)
 800be70:	df000215 	stw	fp,8(sp)
 800be74:	df000204 	addi	fp,sp,8
 800be78:	e13fff15 	stw	r4,-4(fp)
	char * name;
	name = (char *) char_buffer->dev.name;
 800be7c:	e0bfff17 	ldw	r2,-4(fp)
 800be80:	10800217 	ldw	r2,8(r2)
 800be84:	e0bffe15 	stw	r2,-8(fp)

	for ( ; (*name) != '\0'; name++) {
 800be88:	00000b06 	br	800beb8 <alt_up_char_buffer_init+0x50>
		if (strcmp(name, "_avalon_char_buffer_slave") == 0) {
 800be8c:	01420134 	movhi	r5,2052
 800be90:	29598f04 	addi	r5,r5,26172
 800be94:	e13ffe17 	ldw	r4,-8(fp)
 800be98:	800d97c0 	call	800d97c <strcmp>
 800be9c:	1000031e 	bne	r2,zero,800beac <alt_up_char_buffer_init+0x44>
			(*name) = '\0';
 800bea0:	e0bffe17 	ldw	r2,-8(fp)
 800bea4:	10000005 	stb	zero,0(r2)
			break;
 800bea8:	00000906 	br	800bed0 <alt_up_char_buffer_init+0x68>

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
	char * name;
	name = (char *) char_buffer->dev.name;

	for ( ; (*name) != '\0'; name++) {
 800beac:	e0bffe17 	ldw	r2,-8(fp)
 800beb0:	10800044 	addi	r2,r2,1
 800beb4:	e0bffe15 	stw	r2,-8(fp)
 800beb8:	e0bffe17 	ldw	r2,-8(fp)
 800bebc:	10800003 	ldbu	r2,0(r2)
 800bec0:	10803fcc 	andi	r2,r2,255
 800bec4:	1080201c 	xori	r2,r2,128
 800bec8:	10bfe004 	addi	r2,r2,-128
 800becc:	103fef1e 	bne	r2,zero,800be8c <alt_up_char_buffer_init+0x24>
			(*name) = '\0';
			break;
		}
	}
	
	return;
 800bed0:	0001883a 	nop
}
 800bed4:	e037883a 	mov	sp,fp
 800bed8:	dfc00117 	ldw	ra,4(sp)
 800bedc:	df000017 	ldw	fp,0(sp)
 800bee0:	dec00204 	addi	sp,sp,8
 800bee4:	f800283a 	ret

0800bee8 <alt_up_char_buffer_open_dev>:

alt_up_char_buffer_dev* alt_up_char_buffer_open_dev(const char* name) {
 800bee8:	defffc04 	addi	sp,sp,-16
 800beec:	dfc00315 	stw	ra,12(sp)
 800bef0:	df000215 	stw	fp,8(sp)
 800bef4:	df000204 	addi	fp,sp,8
 800bef8:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_char_buffer_dev *dev = (alt_up_char_buffer_dev *)alt_find_dev(name, &alt_dev_list);
 800befc:	d1604804 	addi	r5,gp,-32480
 800bf00:	e13fff17 	ldw	r4,-4(fp)
 800bf04:	800d3100 	call	800d310 <alt_find_dev>
 800bf08:	e0bffe15 	stw	r2,-8(fp)

  return dev;
 800bf0c:	e0bffe17 	ldw	r2,-8(fp)
}
 800bf10:	e037883a 	mov	sp,fp
 800bf14:	dfc00117 	ldw	ra,4(sp)
 800bf18:	df000017 	ldw	fp,0(sp)
 800bf1c:	dec00204 	addi	sp,sp,8
 800bf20:	f800283a 	ret

0800bf24 <alt_up_char_buffer_draw>:

int alt_up_char_buffer_draw(alt_up_char_buffer_dev *char_buffer, unsigned char ch, 
	unsigned int x, unsigned int y) {
 800bf24:	defffa04 	addi	sp,sp,-24
 800bf28:	df000515 	stw	fp,20(sp)
 800bf2c:	df000504 	addi	fp,sp,20
 800bf30:	e13ffc15 	stw	r4,-16(fp)
 800bf34:	2805883a 	mov	r2,r5
 800bf38:	e1bffe15 	stw	r6,-8(fp)
 800bf3c:	e1ffff15 	stw	r7,-4(fp)
 800bf40:	e0bffd05 	stb	r2,-12(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
 800bf44:	e0bffc17 	ldw	r2,-16(fp)
 800bf48:	10800c17 	ldw	r2,48(r2)
 800bf4c:	e0fffe17 	ldw	r3,-8(fp)
 800bf50:	1880042e 	bgeu	r3,r2,800bf64 <alt_up_char_buffer_draw+0x40>
 800bf54:	e0bffc17 	ldw	r2,-16(fp)
 800bf58:	10800d17 	ldw	r2,52(r2)
 800bf5c:	e0ffff17 	ldw	r3,-4(fp)
 800bf60:	18800236 	bltu	r3,r2,800bf6c <alt_up_char_buffer_draw+0x48>
		return -1;
 800bf64:	00bfffc4 	movi	r2,-1
 800bf68:	00001d06 	br	800bfe0 <alt_up_char_buffer_draw+0xbc>
	
	unsigned int addr = 0;
 800bf6c:	e03ffb15 	stw	zero,-20(fp)
	addr |= ((x & char_buffer->x_coord_mask) << char_buffer->x_coord_offset);
 800bf70:	e0bffc17 	ldw	r2,-16(fp)
 800bf74:	10c00f17 	ldw	r3,60(r2)
 800bf78:	e0bffe17 	ldw	r2,-8(fp)
 800bf7c:	1886703a 	and	r3,r3,r2
 800bf80:	e0bffc17 	ldw	r2,-16(fp)
 800bf84:	10800e17 	ldw	r2,56(r2)
 800bf88:	1884983a 	sll	r2,r3,r2
 800bf8c:	e0fffb17 	ldw	r3,-20(fp)
 800bf90:	1884b03a 	or	r2,r3,r2
 800bf94:	e0bffb15 	stw	r2,-20(fp)
	addr |= ((y & char_buffer->y_coord_mask) << char_buffer->y_coord_offset);
 800bf98:	e0bffc17 	ldw	r2,-16(fp)
 800bf9c:	10c01117 	ldw	r3,68(r2)
 800bfa0:	e0bfff17 	ldw	r2,-4(fp)
 800bfa4:	1886703a 	and	r3,r3,r2
 800bfa8:	e0bffc17 	ldw	r2,-16(fp)
 800bfac:	10801017 	ldw	r2,64(r2)
 800bfb0:	1884983a 	sll	r2,r3,r2
 800bfb4:	e0fffb17 	ldw	r3,-20(fp)
 800bfb8:	1884b03a 	or	r2,r3,r2
 800bfbc:	e0bffb15 	stw	r2,-20(fp)
	IOWR_8DIRECT(char_buffer->buffer_base, addr, ch);
 800bfc0:	e0bffc17 	ldw	r2,-16(fp)
 800bfc4:	10c00b17 	ldw	r3,44(r2)
 800bfc8:	e0bffb17 	ldw	r2,-20(fp)
 800bfcc:	1885883a 	add	r2,r3,r2
 800bfd0:	1007883a 	mov	r3,r2
 800bfd4:	e0bffd03 	ldbu	r2,-12(fp)
 800bfd8:	18800025 	stbio	r2,0(r3)

	return 0;
 800bfdc:	0005883a 	mov	r2,zero
}
 800bfe0:	e037883a 	mov	sp,fp
 800bfe4:	df000017 	ldw	fp,0(sp)
 800bfe8:	dec00104 	addi	sp,sp,4
 800bfec:	f800283a 	ret

0800bff0 <alt_up_char_buffer_string>:

int alt_up_char_buffer_string(alt_up_char_buffer_dev *char_buffer, const char *ptr, 
	unsigned int x, unsigned int y) {
 800bff0:	defffa04 	addi	sp,sp,-24
 800bff4:	df000515 	stw	fp,20(sp)
 800bff8:	df000504 	addi	fp,sp,20
 800bffc:	e13ffc15 	stw	r4,-16(fp)
 800c000:	e17ffd15 	stw	r5,-12(fp)
 800c004:	e1bffe15 	stw	r6,-8(fp)
 800c008:	e1ffff15 	stw	r7,-4(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
 800c00c:	e0bffc17 	ldw	r2,-16(fp)
 800c010:	10800c17 	ldw	r2,48(r2)
 800c014:	e0fffe17 	ldw	r3,-8(fp)
 800c018:	1880042e 	bgeu	r3,r2,800c02c <alt_up_char_buffer_string+0x3c>
 800c01c:	e0bffc17 	ldw	r2,-16(fp)
 800c020:	10800d17 	ldw	r2,52(r2)
 800c024:	e0ffff17 	ldw	r3,-4(fp)
 800c028:	18800236 	bltu	r3,r2,800c034 <alt_up_char_buffer_string+0x44>
		return -1;
 800c02c:	00bfffc4 	movi	r2,-1
 800c030:	00002a06 	br	800c0dc <alt_up_char_buffer_string+0xec>
	
	unsigned int offset = 0;
 800c034:	e03ffb15 	stw	zero,-20(fp)
	offset = (y << char_buffer->y_coord_offset) + x;
 800c038:	e0bffc17 	ldw	r2,-16(fp)
 800c03c:	10801017 	ldw	r2,64(r2)
 800c040:	e0ffff17 	ldw	r3,-4(fp)
 800c044:	1886983a 	sll	r3,r3,r2
 800c048:	e0bffe17 	ldw	r2,-8(fp)
 800c04c:	1885883a 	add	r2,r3,r2
 800c050:	e0bffb15 	stw	r2,-20(fp)

	while ( *ptr )
 800c054:	00001a06 	br	800c0c0 <alt_up_char_buffer_string+0xd0>
	{
		IOWR_8DIRECT(char_buffer->buffer_base, offset, *ptr);
 800c058:	e0bffc17 	ldw	r2,-16(fp)
 800c05c:	10c00b17 	ldw	r3,44(r2)
 800c060:	e0bffb17 	ldw	r2,-20(fp)
 800c064:	1885883a 	add	r2,r3,r2
 800c068:	1007883a 	mov	r3,r2
 800c06c:	e0bffd17 	ldw	r2,-12(fp)
 800c070:	10800003 	ldbu	r2,0(r2)
 800c074:	10803fcc 	andi	r2,r2,255
 800c078:	1080201c 	xori	r2,r2,128
 800c07c:	10bfe004 	addi	r2,r2,-128
 800c080:	18800025 	stbio	r2,0(r3)
		++ptr;
 800c084:	e0bffd17 	ldw	r2,-12(fp)
 800c088:	10800044 	addi	r2,r2,1
 800c08c:	e0bffd15 	stw	r2,-12(fp)
		if (++x >= char_buffer->x_resolution)
 800c090:	e0bffe17 	ldw	r2,-8(fp)
 800c094:	10800044 	addi	r2,r2,1
 800c098:	e0bffe15 	stw	r2,-8(fp)
 800c09c:	e0bffc17 	ldw	r2,-16(fp)
 800c0a0:	10800c17 	ldw	r2,48(r2)
 800c0a4:	e0fffe17 	ldw	r3,-8(fp)
 800c0a8:	18800236 	bltu	r3,r2,800c0b4 <alt_up_char_buffer_string+0xc4>
			return -1;
 800c0ac:	00bfffc4 	movi	r2,-1
 800c0b0:	00000a06 	br	800c0dc <alt_up_char_buffer_string+0xec>
		++offset;
 800c0b4:	e0bffb17 	ldw	r2,-20(fp)
 800c0b8:	10800044 	addi	r2,r2,1
 800c0bc:	e0bffb15 	stw	r2,-20(fp)
		return -1;
	
	unsigned int offset = 0;
	offset = (y << char_buffer->y_coord_offset) + x;

	while ( *ptr )
 800c0c0:	e0bffd17 	ldw	r2,-12(fp)
 800c0c4:	10800003 	ldbu	r2,0(r2)
 800c0c8:	10803fcc 	andi	r2,r2,255
 800c0cc:	1080201c 	xori	r2,r2,128
 800c0d0:	10bfe004 	addi	r2,r2,-128
 800c0d4:	103fe01e 	bne	r2,zero,800c058 <alt_up_char_buffer_string+0x68>
		++ptr;
		if (++x >= char_buffer->x_resolution)
			return -1;
		++offset;
	}
	return 0;
 800c0d8:	0005883a 	mov	r2,zero
}
 800c0dc:	e037883a 	mov	sp,fp
 800c0e0:	df000017 	ldw	fp,0(sp)
 800c0e4:	dec00104 	addi	sp,sp,4
 800c0e8:	f800283a 	ret

0800c0ec <alt_up_char_buffer_clear>:

int alt_up_char_buffer_clear(alt_up_char_buffer_dev *char_buffer) {
 800c0ec:	defffe04 	addi	sp,sp,-8
 800c0f0:	df000115 	stw	fp,4(sp)
 800c0f4:	df000104 	addi	fp,sp,4
 800c0f8:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base, 1);
 800c0fc:	e0bfff17 	ldw	r2,-4(fp)
 800c100:	10800a17 	ldw	r2,40(r2)
 800c104:	10800084 	addi	r2,r2,2
 800c108:	1007883a 	mov	r3,r2
 800c10c:	00800044 	movi	r2,1
 800c110:	18800025 	stbio	r2,0(r3)
	while ((IORD_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base) & ALT_UP_CHAR_BUFFER_CLR_SCRN_MSK) >> ALT_UP_CHAR_BUFFER_CLR_SCRN_OFST);
 800c114:	0001883a 	nop
 800c118:	e0bfff17 	ldw	r2,-4(fp)
 800c11c:	10800a17 	ldw	r2,40(r2)
 800c120:	10800084 	addi	r2,r2,2
 800c124:	10800023 	ldbuio	r2,0(r2)
 800c128:	10803fcc 	andi	r2,r2,255
 800c12c:	1080004c 	andi	r2,r2,1
 800c130:	103ff91e 	bne	r2,zero,800c118 <alt_up_char_buffer_clear+0x2c>
	return 0;
 800c134:	0005883a 	mov	r2,zero
}
 800c138:	e037883a 	mov	sp,fp
 800c13c:	df000017 	ldw	fp,0(sp)
 800c140:	dec00104 	addi	sp,sp,4
 800c144:	f800283a 	ret

0800c148 <alt_up_pixel_buffer_dma_open_dev>:

#include "altera_up_avalon_video_pixel_buffer_dma.h"

#define ABS(x)	((x >= 0) ? (x) : (-(x)))

alt_up_pixel_buffer_dma_dev* alt_up_pixel_buffer_dma_open_dev(const char* name) {
 800c148:	defffc04 	addi	sp,sp,-16
 800c14c:	dfc00315 	stw	ra,12(sp)
 800c150:	df000215 	stw	fp,8(sp)
 800c154:	df000204 	addi	fp,sp,8
 800c158:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_pixel_buffer_dma_dev *dev = (alt_up_pixel_buffer_dma_dev*)alt_find_dev(name, &alt_dev_list);
 800c15c:	d1604804 	addi	r5,gp,-32480
 800c160:	e13fff17 	ldw	r4,-4(fp)
 800c164:	800d3100 	call	800d310 <alt_find_dev>
 800c168:	e0bffe15 	stw	r2,-8(fp)

  return dev;
 800c16c:	e0bffe17 	ldw	r2,-8(fp)
}
 800c170:	e037883a 	mov	sp,fp
 800c174:	dfc00117 	ldw	ra,4(sp)
 800c178:	df000017 	ldw	fp,0(sp)
 800c17c:	dec00204 	addi	sp,sp,8
 800c180:	f800283a 	ret

0800c184 <alt_up_pixel_buffer_dma_draw>:

int alt_up_pixel_buffer_dma_draw(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int color, unsigned int x, unsigned int y)
/* This function draws a pixel to the back buffer.
 */
{
 800c184:	defffa04 	addi	sp,sp,-24
 800c188:	df000515 	stw	fp,20(sp)
 800c18c:	df000504 	addi	fp,sp,20
 800c190:	e13ffc15 	stw	r4,-16(fp)
 800c194:	e17ffd15 	stw	r5,-12(fp)
 800c198:	e1bffe15 	stw	r6,-8(fp)
 800c19c:	e1ffff15 	stw	r7,-4(fp)
	// boundary check
	if (x >= pixel_buffer->x_resolution || y >= pixel_buffer->y_resolution )
 800c1a0:	e0bffc17 	ldw	r2,-16(fp)
 800c1a4:	10800f17 	ldw	r2,60(r2)
 800c1a8:	e0fffe17 	ldw	r3,-8(fp)
 800c1ac:	1880042e 	bgeu	r3,r2,800c1c0 <alt_up_pixel_buffer_dma_draw+0x3c>
 800c1b0:	e0bffc17 	ldw	r2,-16(fp)
 800c1b4:	10801017 	ldw	r2,64(r2)
 800c1b8:	e0ffff17 	ldw	r3,-4(fp)
 800c1bc:	18800236 	bltu	r3,r2,800c1c8 <alt_up_pixel_buffer_dma_draw+0x44>
		return -1;
 800c1c0:	00bfffc4 	movi	r2,-1
 800c1c4:	00005006 	br	800c308 <alt_up_pixel_buffer_dma_draw+0x184>

	unsigned int addr = 0;
 800c1c8:	e03ffb15 	stw	zero,-20(fp)
	/* Check the mode VGA Pixel Buffer is using. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c1cc:	e0bffc17 	ldw	r2,-16(fp)
 800c1d0:	10800d17 	ldw	r2,52(r2)
 800c1d4:	1000151e 	bne	r2,zero,800c22c <alt_up_pixel_buffer_dma_draw+0xa8>
		/* For X-Y addressing mode, the address format is | unused | Y | X |. So shift bits for coordinates X and Y into their respective locations. */
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
 800c1d8:	e0bffc17 	ldw	r2,-16(fp)
 800c1dc:	10c01217 	ldw	r3,72(r2)
 800c1e0:	e0bffe17 	ldw	r2,-8(fp)
 800c1e4:	1886703a 	and	r3,r3,r2
 800c1e8:	e0bffc17 	ldw	r2,-16(fp)
 800c1ec:	10801117 	ldw	r2,68(r2)
 800c1f0:	1884983a 	sll	r2,r3,r2
 800c1f4:	e0fffb17 	ldw	r3,-20(fp)
 800c1f8:	1885883a 	add	r2,r3,r2
 800c1fc:	e0bffb15 	stw	r2,-20(fp)
		addr += ((y & pixel_buffer->y_coord_mask) << pixel_buffer->y_coord_offset);
 800c200:	e0bffc17 	ldw	r2,-16(fp)
 800c204:	10c01417 	ldw	r3,80(r2)
 800c208:	e0bfff17 	ldw	r2,-4(fp)
 800c20c:	1886703a 	and	r3,r3,r2
 800c210:	e0bffc17 	ldw	r2,-16(fp)
 800c214:	10801317 	ldw	r2,76(r2)
 800c218:	1884983a 	sll	r2,r3,r2
 800c21c:	e0fffb17 	ldw	r3,-20(fp)
 800c220:	1885883a 	add	r2,r3,r2
 800c224:	e0bffb15 	stw	r2,-20(fp)
 800c228:	00001706 	br	800c288 <alt_up_pixel_buffer_dma_draw+0x104>
	} else {
		/* In a consecutive addressing mode, the pixels are stored in consecutive memory locations. So the address of a pixel at (x,y) can be computed as
		 * (y*x_resolution + x).*/
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
 800c22c:	e0bffc17 	ldw	r2,-16(fp)
 800c230:	10c01217 	ldw	r3,72(r2)
 800c234:	e0bffe17 	ldw	r2,-8(fp)
 800c238:	1886703a 	and	r3,r3,r2
 800c23c:	e0bffc17 	ldw	r2,-16(fp)
 800c240:	10801117 	ldw	r2,68(r2)
 800c244:	1884983a 	sll	r2,r3,r2
 800c248:	e0fffb17 	ldw	r3,-20(fp)
 800c24c:	1885883a 	add	r2,r3,r2
 800c250:	e0bffb15 	stw	r2,-20(fp)
		addr += (((y & pixel_buffer->y_coord_mask) * pixel_buffer->x_resolution) << pixel_buffer->x_coord_offset);
 800c254:	e0bffc17 	ldw	r2,-16(fp)
 800c258:	10c01417 	ldw	r3,80(r2)
 800c25c:	e0bfff17 	ldw	r2,-4(fp)
 800c260:	1886703a 	and	r3,r3,r2
 800c264:	e0bffc17 	ldw	r2,-16(fp)
 800c268:	10800f17 	ldw	r2,60(r2)
 800c26c:	1887383a 	mul	r3,r3,r2
 800c270:	e0bffc17 	ldw	r2,-16(fp)
 800c274:	10801117 	ldw	r2,68(r2)
 800c278:	1884983a 	sll	r2,r3,r2
 800c27c:	e0fffb17 	ldw	r3,-20(fp)
 800c280:	1885883a 	add	r2,r3,r2
 800c284:	e0bffb15 	stw	r2,-20(fp)
	}
	/* Now, depending on the color depth, write the pixel color to the specified memory location. */
	if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c288:	e0bffc17 	ldw	r2,-16(fp)
 800c28c:	10800e17 	ldw	r2,56(r2)
 800c290:	10800058 	cmpnei	r2,r2,1
 800c294:	1000081e 	bne	r2,zero,800c2b8 <alt_up_pixel_buffer_dma_draw+0x134>
		IOWR_8DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 800c298:	e0bffc17 	ldw	r2,-16(fp)
 800c29c:	10c00c17 	ldw	r3,48(r2)
 800c2a0:	e0bffb17 	ldw	r2,-20(fp)
 800c2a4:	1885883a 	add	r2,r3,r2
 800c2a8:	1007883a 	mov	r3,r2
 800c2ac:	e0bffd17 	ldw	r2,-12(fp)
 800c2b0:	18800025 	stbio	r2,0(r3)
 800c2b4:	00001306 	br	800c304 <alt_up_pixel_buffer_dma_draw+0x180>
	} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c2b8:	e0bffc17 	ldw	r2,-16(fp)
 800c2bc:	10800e17 	ldw	r2,56(r2)
 800c2c0:	10800098 	cmpnei	r2,r2,2
 800c2c4:	1000081e 	bne	r2,zero,800c2e8 <alt_up_pixel_buffer_dma_draw+0x164>
		IOWR_16DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 800c2c8:	e0bffc17 	ldw	r2,-16(fp)
 800c2cc:	10c00c17 	ldw	r3,48(r2)
 800c2d0:	e0bffb17 	ldw	r2,-20(fp)
 800c2d4:	1885883a 	add	r2,r3,r2
 800c2d8:	1007883a 	mov	r3,r2
 800c2dc:	e0bffd17 	ldw	r2,-12(fp)
 800c2e0:	1880002d 	sthio	r2,0(r3)
 800c2e4:	00000706 	br	800c304 <alt_up_pixel_buffer_dma_draw+0x180>
	} else {
		IOWR_32DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
 800c2e8:	e0bffc17 	ldw	r2,-16(fp)
 800c2ec:	10c00c17 	ldw	r3,48(r2)
 800c2f0:	e0bffb17 	ldw	r2,-20(fp)
 800c2f4:	1885883a 	add	r2,r3,r2
 800c2f8:	1007883a 	mov	r3,r2
 800c2fc:	e0bffd17 	ldw	r2,-12(fp)
 800c300:	18800035 	stwio	r2,0(r3)
	}

	return 0;
 800c304:	0005883a 	mov	r2,zero
}
 800c308:	e037883a 	mov	sp,fp
 800c30c:	df000017 	ldw	fp,0(sp)
 800c310:	dec00104 	addi	sp,sp,4
 800c314:	f800283a 	ret

0800c318 <alt_up_pixel_buffer_dma_change_back_buffer_address>:

int alt_up_pixel_buffer_dma_change_back_buffer_address(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int new_address)
/* This function changes the memory address for the back buffer. */
{
 800c318:	defffd04 	addi	sp,sp,-12
 800c31c:	df000215 	stw	fp,8(sp)
 800c320:	df000204 	addi	fp,sp,8
 800c324:	e13ffe15 	stw	r4,-8(fp)
 800c328:	e17fff15 	stw	r5,-4(fp)
	IOWR_32DIRECT(pixel_buffer->base, 4, new_address);
 800c32c:	e0bffe17 	ldw	r2,-8(fp)
 800c330:	10800a17 	ldw	r2,40(r2)
 800c334:	10800104 	addi	r2,r2,4
 800c338:	1007883a 	mov	r3,r2
 800c33c:	e0bfff17 	ldw	r2,-4(fp)
 800c340:	18800035 	stwio	r2,0(r3)
	pixel_buffer->back_buffer_start_address = IORD_32DIRECT(pixel_buffer->base, 4);
 800c344:	e0bffe17 	ldw	r2,-8(fp)
 800c348:	10800a17 	ldw	r2,40(r2)
 800c34c:	10800104 	addi	r2,r2,4
 800c350:	10800037 	ldwio	r2,0(r2)
 800c354:	1007883a 	mov	r3,r2
 800c358:	e0bffe17 	ldw	r2,-8(fp)
 800c35c:	10c00c15 	stw	r3,48(r2)
	return 0;
 800c360:	0005883a 	mov	r2,zero
}
 800c364:	e037883a 	mov	sp,fp
 800c368:	df000017 	ldw	fp,0(sp)
 800c36c:	dec00104 	addi	sp,sp,4
 800c370:	f800283a 	ret

0800c374 <alt_up_pixel_buffer_dma_swap_buffers>:

int alt_up_pixel_buffer_dma_swap_buffers(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function swaps the front and back buffers. At the next refresh cycle the back buffer will be drawn on the screen
 * and will become the front buffer. */
{
 800c374:	defffd04 	addi	sp,sp,-12
 800c378:	df000215 	stw	fp,8(sp)
 800c37c:	dc000115 	stw	r16,4(sp)
 800c380:	df000204 	addi	fp,sp,8
 800c384:	e13ffe15 	stw	r4,-8(fp)
	register unsigned int temp = pixel_buffer->back_buffer_start_address;
 800c388:	e0bffe17 	ldw	r2,-8(fp)
 800c38c:	14000c17 	ldw	r16,48(r2)
	IOWR_32DIRECT(pixel_buffer->base, 0, 1);
 800c390:	e0bffe17 	ldw	r2,-8(fp)
 800c394:	10800a17 	ldw	r2,40(r2)
 800c398:	1007883a 	mov	r3,r2
 800c39c:	00800044 	movi	r2,1
 800c3a0:	18800035 	stwio	r2,0(r3)
	pixel_buffer->back_buffer_start_address = pixel_buffer->buffer_start_address;
 800c3a4:	e0bffe17 	ldw	r2,-8(fp)
 800c3a8:	10c00b17 	ldw	r3,44(r2)
 800c3ac:	e0bffe17 	ldw	r2,-8(fp)
 800c3b0:	10c00c15 	stw	r3,48(r2)
	pixel_buffer->buffer_start_address = temp;
 800c3b4:	e0bffe17 	ldw	r2,-8(fp)
 800c3b8:	14000b15 	stw	r16,44(r2)
	return 0;
 800c3bc:	0005883a 	mov	r2,zero
}
 800c3c0:	e6ffff04 	addi	sp,fp,-4
 800c3c4:	df000117 	ldw	fp,4(sp)
 800c3c8:	dc000017 	ldw	r16,0(sp)
 800c3cc:	dec00204 	addi	sp,sp,8
 800c3d0:	f800283a 	ret

0800c3d4 <alt_up_pixel_buffer_dma_check_swap_buffers_status>:
int alt_up_pixel_buffer_dma_check_swap_buffers_status(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function checks if the buffer swap has occured. Since the buffer swap only happens after an entire screen is drawn,
 * it is important to wait for this function to return 0 before proceeding to draw on either buffer. When both front and the back buffers
 * have the same address calling the alt_up_pixel_buffer_dma_swap_buffers(...) function and then waiting for this function to return 0, causes your program to
 * wait for the screen to refresh. */
{
 800c3d4:	defffe04 	addi	sp,sp,-8
 800c3d8:	df000115 	stw	fp,4(sp)
 800c3dc:	df000104 	addi	fp,sp,4
 800c3e0:	e13fff15 	stw	r4,-4(fp)
	return (IORD_32DIRECT(pixel_buffer->base, 12) & 0x1);
 800c3e4:	e0bfff17 	ldw	r2,-4(fp)
 800c3e8:	10800a17 	ldw	r2,40(r2)
 800c3ec:	10800304 	addi	r2,r2,12
 800c3f0:	10800037 	ldwio	r2,0(r2)
 800c3f4:	1080004c 	andi	r2,r2,1
}
 800c3f8:	e037883a 	mov	sp,fp
 800c3fc:	df000017 	ldw	fp,0(sp)
 800c400:	dec00104 	addi	sp,sp,4
 800c404:	f800283a 	ret

0800c408 <alt_up_pixel_buffer_dma_clear_screen>:

void alt_up_pixel_buffer_dma_clear_screen(alt_up_pixel_buffer_dma_dev *pixel_buffer, int backbuffer)
/* This function clears the screen by setting each pixel to a black color. */
{
 800c408:	defff704 	addi	sp,sp,-36
 800c40c:	df000815 	stw	fp,32(sp)
 800c410:	dd400715 	stw	r21,28(sp)
 800c414:	dd000615 	stw	r20,24(sp)
 800c418:	dcc00515 	stw	r19,20(sp)
 800c41c:	dc800415 	stw	r18,16(sp)
 800c420:	dc400315 	stw	r17,12(sp)
 800c424:	dc000215 	stw	r16,8(sp)
 800c428:	df000804 	addi	fp,sp,32
 800c42c:	e13ff815 	stw	r4,-32(fp)
 800c430:	e17ff915 	stw	r5,-28(fp)
	register unsigned int addr;
	register unsigned int limit_x, limit_y;
	
	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800c434:	e0bff917 	ldw	r2,-28(fp)
 800c438:	10800058 	cmpnei	r2,r2,1
 800c43c:	1000031e 	bne	r2,zero,800c44c <alt_up_pixel_buffer_dma_clear_screen+0x44>
		addr = pixel_buffer->back_buffer_start_address;
 800c440:	e0bff817 	ldw	r2,-32(fp)
 800c444:	14400c17 	ldw	r17,48(r2)
 800c448:	00000206 	br	800c454 <alt_up_pixel_buffer_dma_clear_screen+0x4c>
	else
		addr = pixel_buffer->buffer_start_address;
 800c44c:	e0bff817 	ldw	r2,-32(fp)
 800c450:	14400b17 	ldw	r17,44(r2)
	limit_x = pixel_buffer->x_resolution;
 800c454:	e0bff817 	ldw	r2,-32(fp)
 800c458:	14000f17 	ldw	r16,60(r2)
	/* In 16 and 32-bit color modes we use twice or four times more memory for the display buffer.*/
	if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c45c:	e0bff817 	ldw	r2,-32(fp)
 800c460:	10800e17 	ldw	r2,56(r2)
 800c464:	10800098 	cmpnei	r2,r2,2
 800c468:	1000031e 	bne	r2,zero,800c478 <alt_up_pixel_buffer_dma_clear_screen+0x70>
		limit_x = limit_x << 1;
 800c46c:	8405883a 	add	r2,r16,r16
 800c470:	1021883a 	mov	r16,r2
 800c474:	00000306 	br	800c484 <alt_up_pixel_buffer_dma_clear_screen+0x7c>
	} else {
		limit_x = limit_x << 2;
 800c478:	8405883a 	add	r2,r16,r16
 800c47c:	1085883a 	add	r2,r2,r2
 800c480:	1021883a 	mov	r16,r2
	}	
	limit_y = pixel_buffer->y_resolution;
 800c484:	e0bff817 	ldw	r2,-32(fp)
 800c488:	14801017 	ldw	r18,64(r2)

	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c48c:	e0bff817 	ldw	r2,-32(fp)
 800c490:	10800d17 	ldw	r2,52(r2)
 800c494:	1000111e 	bne	r2,zero,800c4dc <alt_up_pixel_buffer_dma_clear_screen+0xd4>
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 800c498:	e0bff817 	ldw	r2,-32(fp)
 800c49c:	15401317 	ldw	r21,76(r2)

		for (y = 0; y < limit_y; y++)
 800c4a0:	0029883a 	mov	r20,zero
 800c4a4:	00000b06 	br	800c4d4 <alt_up_pixel_buffer_dma_clear_screen+0xcc>
		{
			for (x = 0; x < limit_x; x = x + 4)
 800c4a8:	0027883a 	mov	r19,zero
 800c4ac:	00000406 	br	800c4c0 <alt_up_pixel_buffer_dma_clear_screen+0xb8>
			{
				IOWR_32DIRECT(addr, x, 0);
 800c4b0:	9c45883a 	add	r2,r19,r17
 800c4b4:	0007883a 	mov	r3,zero
 800c4b8:	10c00035 	stwio	r3,0(r2)
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
		{
			for (x = 0; x < limit_x; x = x + 4)
 800c4bc:	9cc00104 	addi	r19,r19,4
 800c4c0:	9c3ffb36 	bltu	r19,r16,800c4b0 <alt_up_pixel_buffer_dma_clear_screen+0xa8>
			{
				IOWR_32DIRECT(addr, x, 0);
			}
			addr = addr + (1 << offset_y);
 800c4c4:	00800044 	movi	r2,1
 800c4c8:	1544983a 	sll	r2,r2,r21
 800c4cc:	88a3883a 	add	r17,r17,r2
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
 800c4d0:	a5000044 	addi	r20,r20,1
 800c4d4:	a4bff436 	bltu	r20,r18,800c4a8 <alt_up_pixel_buffer_dma_clear_screen+0xa0>
		for (x = 0; x < limit_y; x = x + 4)
		{
			IOWR_32DIRECT(addr, x, 0);
		}
	}
}
 800c4d8:	00000a06 	br	800c504 <alt_up_pixel_buffer_dma_clear_screen+0xfc>
			addr = addr + (1 << offset_y);
		}
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	
 800c4dc:	9425383a 	mul	r18,r18,r16

		for (x = 0; x < limit_y; x = x + 4)
 800c4e0:	0021883a 	mov	r16,zero
 800c4e4:	00000506 	br	800c4fc <alt_up_pixel_buffer_dma_clear_screen+0xf4>
		{
			IOWR_32DIRECT(addr, x, 0);
 800c4e8:	8005883a 	mov	r2,r16
 800c4ec:	1445883a 	add	r2,r2,r17
 800c4f0:	0007883a 	mov	r3,zero
 800c4f4:	10c00035 	stwio	r3,0(r2)
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	

		for (x = 0; x < limit_y; x = x + 4)
 800c4f8:	84000104 	addi	r16,r16,4
 800c4fc:	8005883a 	mov	r2,r16
 800c500:	14bff936 	bltu	r2,r18,800c4e8 <alt_up_pixel_buffer_dma_clear_screen+0xe0>
		{
			IOWR_32DIRECT(addr, x, 0);
		}
	}
}
 800c504:	0001883a 	nop
 800c508:	e6fffa04 	addi	sp,fp,-24
 800c50c:	df000617 	ldw	fp,24(sp)
 800c510:	dd400517 	ldw	r21,20(sp)
 800c514:	dd000417 	ldw	r20,16(sp)
 800c518:	dcc00317 	ldw	r19,12(sp)
 800c51c:	dc800217 	ldw	r18,8(sp)
 800c520:	dc400117 	ldw	r17,4(sp)
 800c524:	dc000017 	ldw	r16,0(sp)
 800c528:	dec00704 	addi	sp,sp,28
 800c52c:	f800283a 	ret

0800c530 <alt_up_pixel_buffer_dma_draw_box>:

void alt_up_pixel_buffer_dma_draw_box(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a filled box. */
{
 800c530:	defff304 	addi	sp,sp,-52
 800c534:	df000c15 	stw	fp,48(sp)
 800c538:	ddc00b15 	stw	r23,44(sp)
 800c53c:	dd800a15 	stw	r22,40(sp)
 800c540:	dd400915 	stw	r21,36(sp)
 800c544:	dd000815 	stw	r20,32(sp)
 800c548:	dcc00715 	stw	r19,28(sp)
 800c54c:	dc800615 	stw	r18,24(sp)
 800c550:	dc400515 	stw	r17,20(sp)
 800c554:	dc000415 	stw	r16,16(sp)
 800c558:	df000c04 	addi	fp,sp,48
 800c55c:	e13ff415 	stw	r4,-48(fp)
 800c560:	e17ff515 	stw	r5,-44(fp)
 800c564:	e1bff615 	stw	r6,-40(fp)
 800c568:	e1fff715 	stw	r7,-36(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 800c56c:	e0bff417 	ldw	r2,-48(fp)
 800c570:	14800f17 	ldw	r18,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 800c574:	e0bff417 	ldw	r2,-48(fp)
 800c578:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int l_x = x0;
 800c57c:	e5bff517 	ldw	r22,-44(fp)
	register unsigned int r_x = x1;
 800c580:	e53ff717 	ldw	r20,-36(fp)
	register unsigned int t_y = y0;
 800c584:	e47ff617 	ldw	r17,-40(fp)
	register unsigned int b_y = y1;
 800c588:	e4c00117 	ldw	r19,4(fp)
	register unsigned int local_color = color;
 800c58c:	e5c00217 	ldw	r23,8(fp)
	
	/* Check coordinates */
	if (l_x > r_x)
 800c590:	a580032e 	bgeu	r20,r22,800c5a0 <alt_up_pixel_buffer_dma_draw_box+0x70>
	{
		temp = l_x;
 800c594:	b02b883a 	mov	r21,r22
		l_x = r_x;
 800c598:	a02d883a 	mov	r22,r20
		r_x = temp;
 800c59c:	a829883a 	mov	r20,r21
	}
	if (t_y > b_y)
 800c5a0:	9c40032e 	bgeu	r19,r17,800c5b0 <alt_up_pixel_buffer_dma_draw_box+0x80>
	{
		temp = t_y;
 800c5a4:	882b883a 	mov	r21,r17
		t_y = b_y;
 800c5a8:	9823883a 	mov	r17,r19
		b_y = temp;
 800c5ac:	a827883a 	mov	r19,r21
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
 800c5b0:	b480892e 	bgeu	r22,r18,800c7d8 <alt_up_pixel_buffer_dma_draw_box+0x2a8>
 800c5b4:	8c00882e 	bgeu	r17,r16,800c7d8 <alt_up_pixel_buffer_dma_draw_box+0x2a8>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
 800c5b8:	a4800136 	bltu	r20,r18,800c5c0 <alt_up_pixel_buffer_dma_draw_box+0x90>
	{
		r_x = limit_x - 1;
 800c5bc:	953fffc4 	addi	r20,r18,-1
	}
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
 800c5c0:	9c000136 	bltu	r19,r16,800c5c8 <alt_up_pixel_buffer_dma_draw_box+0x98>
	{
		b_y = limit_y - 1;
 800c5c4:	84ffffc4 	addi	r19,r16,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800c5c8:	e0800317 	ldw	r2,12(fp)
 800c5cc:	10800058 	cmpnei	r2,r2,1
 800c5d0:	1000031e 	bne	r2,zero,800c5e0 <alt_up_pixel_buffer_dma_draw_box+0xb0>
		addr = pixel_buffer->back_buffer_start_address;
 800c5d4:	e0bff417 	ldw	r2,-48(fp)
 800c5d8:	14000c17 	ldw	r16,48(r2)
 800c5dc:	00000206 	br	800c5e8 <alt_up_pixel_buffer_dma_draw_box+0xb8>
	else
		addr = pixel_buffer->buffer_start_address;
 800c5e0:	e0bff417 	ldw	r2,-48(fp)
 800c5e4:	14000b17 	ldw	r16,44(r2)

	/* Draw the box using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c5e8:	e0bff417 	ldw	r2,-48(fp)
 800c5ec:	10800d17 	ldw	r2,52(r2)
 800c5f0:	10003c1e 	bne	r2,zero,800c6e4 <alt_up_pixel_buffer_dma_draw_box+0x1b4>
		/* Draw a box of a given color on the screen using the XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 800c5f4:	e0bff417 	ldw	r2,-48(fp)
 800c5f8:	15401317 	ldw	r21,76(r2)
		addr = addr + (t_y << offset_y);
 800c5fc:	8d44983a 	sll	r2,r17,r21
 800c600:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c604:	e0bff417 	ldw	r2,-48(fp)
 800c608:	10800e17 	ldw	r2,56(r2)
 800c60c:	10800058 	cmpnei	r2,r2,1
 800c610:	10000f1e 	bne	r2,zero,800c650 <alt_up_pixel_buffer_dma_draw_box+0x120>
			for (y = t_y; y <= b_y; y++)
 800c614:	8825883a 	mov	r18,r17
 800c618:	00000b06 	br	800c648 <alt_up_pixel_buffer_dma_draw_box+0x118>
			{
				for (x = l_x; x <= r_x; x++)
 800c61c:	b023883a 	mov	r17,r22
 800c620:	00000406 	br	800c634 <alt_up_pixel_buffer_dma_draw_box+0x104>
				{
					IOWR_8DIRECT(addr, x, local_color);
 800c624:	8c05883a 	add	r2,r17,r16
 800c628:	b807883a 	mov	r3,r23
 800c62c:	10c00025 	stbio	r3,0(r2)
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c630:	8c400044 	addi	r17,r17,1
 800c634:	a47ffb2e 	bgeu	r20,r17,800c624 <alt_up_pixel_buffer_dma_draw_box+0xf4>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
 800c638:	00800044 	movi	r2,1
 800c63c:	1544983a 	sll	r2,r2,r21
 800c640:	80a1883a 	add	r16,r16,r2
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 800c644:	94800044 	addi	r18,r18,1
 800c648:	9cbff42e 	bgeu	r19,r18,800c61c <alt_up_pixel_buffer_dma_draw_box+0xec>
 800c64c:	00006306 	br	800c7dc <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c650:	e0bff417 	ldw	r2,-48(fp)
 800c654:	10800e17 	ldw	r2,56(r2)
 800c658:	10800098 	cmpnei	r2,r2,2
 800c65c:	1000101e 	bne	r2,zero,800c6a0 <alt_up_pixel_buffer_dma_draw_box+0x170>
			for (y = t_y; y <= b_y; y++)
 800c660:	8825883a 	mov	r18,r17
 800c664:	00000c06 	br	800c698 <alt_up_pixel_buffer_dma_draw_box+0x168>
			{
				for (x = l_x; x <= r_x; x++)
 800c668:	b023883a 	mov	r17,r22
 800c66c:	00000506 	br	800c684 <alt_up_pixel_buffer_dma_draw_box+0x154>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
 800c670:	8c45883a 	add	r2,r17,r17
 800c674:	1405883a 	add	r2,r2,r16
 800c678:	b807883a 	mov	r3,r23
 800c67c:	10c0002d 	sthio	r3,0(r2)
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c680:	8c400044 	addi	r17,r17,1
 800c684:	a47ffa2e 	bgeu	r20,r17,800c670 <alt_up_pixel_buffer_dma_draw_box+0x140>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + (1 << offset_y);
 800c688:	00800044 	movi	r2,1
 800c68c:	1544983a 	sll	r2,r2,r21
 800c690:	80a1883a 	add	r16,r16,r2
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 800c694:	94800044 	addi	r18,r18,1
 800c698:	9cbff32e 	bgeu	r19,r18,800c668 <alt_up_pixel_buffer_dma_draw_box+0x138>
 800c69c:	00004f06 	br	800c7dc <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800c6a0:	8825883a 	mov	r18,r17
 800c6a4:	00000d06 	br	800c6dc <alt_up_pixel_buffer_dma_draw_box+0x1ac>
			{
				for (x = l_x; x <= r_x; x++)
 800c6a8:	b023883a 	mov	r17,r22
 800c6ac:	00000606 	br	800c6c8 <alt_up_pixel_buffer_dma_draw_box+0x198>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
 800c6b0:	8c45883a 	add	r2,r17,r17
 800c6b4:	1085883a 	add	r2,r2,r2
 800c6b8:	1405883a 	add	r2,r2,r16
 800c6bc:	b807883a 	mov	r3,r23
 800c6c0:	10c00035 	stwio	r3,0(r2)
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c6c4:	8c400044 	addi	r17,r17,1
 800c6c8:	a47ff92e 	bgeu	r20,r17,800c6b0 <alt_up_pixel_buffer_dma_draw_box+0x180>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + (1 << offset_y);
 800c6cc:	00800044 	movi	r2,1
 800c6d0:	1544983a 	sll	r2,r2,r21
 800c6d4:	80a1883a 	add	r16,r16,r2
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800c6d8:	94800044 	addi	r18,r18,1
 800c6dc:	9cbff22e 	bgeu	r19,r18,800c6a8 <alt_up_pixel_buffer_dma_draw_box+0x178>
 800c6e0:	00003e06 	br	800c7dc <alt_up_pixel_buffer_dma_draw_box+0x2ac>
	} else {
		/* Draw a box of a given color on the screen using the linear addressing mode. */
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c6e4:	e0bff417 	ldw	r2,-48(fp)
 800c6e8:	10800e17 	ldw	r2,56(r2)
 800c6ec:	10800058 	cmpnei	r2,r2,1
 800c6f0:	10000f1e 	bne	r2,zero,800c730 <alt_up_pixel_buffer_dma_draw_box+0x200>
			addr = addr + t_y * limit_x;
 800c6f4:	8c85383a 	mul	r2,r17,r18
 800c6f8:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800c6fc:	882b883a 	mov	r21,r17
 800c700:	00000906 	br	800c728 <alt_up_pixel_buffer_dma_draw_box+0x1f8>
			{
				for (x = l_x; x <= r_x; x++)
 800c704:	b023883a 	mov	r17,r22
 800c708:	00000406 	br	800c71c <alt_up_pixel_buffer_dma_draw_box+0x1ec>
				{
					IOWR_8DIRECT(addr, x, local_color);
 800c70c:	8c05883a 	add	r2,r17,r16
 800c710:	b807883a 	mov	r3,r23
 800c714:	10c00025 	stbio	r3,0(r2)
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c718:	8c400044 	addi	r17,r17,1
 800c71c:	a47ffb2e 	bgeu	r20,r17,800c70c <alt_up_pixel_buffer_dma_draw_box+0x1dc>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
 800c720:	84a1883a 	add	r16,r16,r18
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800c724:	ad400044 	addi	r21,r21,1
 800c728:	9d7ff62e 	bgeu	r19,r21,800c704 <alt_up_pixel_buffer_dma_draw_box+0x1d4>
 800c72c:	00002b06 	br	800c7dc <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c730:	e0bff417 	ldw	r2,-48(fp)
 800c734:	10800e17 	ldw	r2,56(r2)
 800c738:	10800098 	cmpnei	r2,r2,2
 800c73c:	1000121e 	bne	r2,zero,800c788 <alt_up_pixel_buffer_dma_draw_box+0x258>
			limit_x = limit_x << 1;
 800c740:	9485883a 	add	r2,r18,r18
 800c744:	1025883a 	mov	r18,r2
			addr = addr + t_y * limit_x;
 800c748:	8c85383a 	mul	r2,r17,r18
 800c74c:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800c750:	882b883a 	mov	r21,r17
 800c754:	00000a06 	br	800c780 <alt_up_pixel_buffer_dma_draw_box+0x250>
			{
				for (x = l_x; x <= r_x; x++)
 800c758:	b023883a 	mov	r17,r22
 800c75c:	00000506 	br	800c774 <alt_up_pixel_buffer_dma_draw_box+0x244>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
 800c760:	8c45883a 	add	r2,r17,r17
 800c764:	1405883a 	add	r2,r2,r16
 800c768:	b807883a 	mov	r3,r23
 800c76c:	10c0002d 	sthio	r3,0(r2)
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c770:	8c400044 	addi	r17,r17,1
 800c774:	a47ffa2e 	bgeu	r20,r17,800c760 <alt_up_pixel_buffer_dma_draw_box+0x230>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + limit_x;
 800c778:	84a1883a 	add	r16,r16,r18
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800c77c:	ad400044 	addi	r21,r21,1
 800c780:	9d7ff52e 	bgeu	r19,r21,800c758 <alt_up_pixel_buffer_dma_draw_box+0x228>
 800c784:	00001506 	br	800c7dc <alt_up_pixel_buffer_dma_draw_box+0x2ac>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
 800c788:	9485883a 	add	r2,r18,r18
 800c78c:	1085883a 	add	r2,r2,r2
 800c790:	1025883a 	mov	r18,r2
			addr = addr + t_y * limit_x;
 800c794:	8c85383a 	mul	r2,r17,r18
 800c798:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800c79c:	882b883a 	mov	r21,r17
 800c7a0:	00000b06 	br	800c7d0 <alt_up_pixel_buffer_dma_draw_box+0x2a0>
			{
				for (x = l_x; x <= r_x; x++)
 800c7a4:	b023883a 	mov	r17,r22
 800c7a8:	00000606 	br	800c7c4 <alt_up_pixel_buffer_dma_draw_box+0x294>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
 800c7ac:	8c45883a 	add	r2,r17,r17
 800c7b0:	1085883a 	add	r2,r2,r2
 800c7b4:	1405883a 	add	r2,r2,r16
 800c7b8:	b807883a 	mov	r3,r23
 800c7bc:	10c00035 	stwio	r3,0(r2)
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
 800c7c0:	8c400044 	addi	r17,r17,1
 800c7c4:	a47ff92e 	bgeu	r20,r17,800c7ac <alt_up_pixel_buffer_dma_draw_box+0x27c>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + limit_x;
 800c7c8:	84a1883a 	add	r16,r16,r18
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800c7cc:	ad400044 	addi	r21,r21,1
 800c7d0:	9d7ff42e 	bgeu	r19,r21,800c7a4 <alt_up_pixel_buffer_dma_draw_box+0x274>
 800c7d4:	00000106 	br	800c7dc <alt_up_pixel_buffer_dma_draw_box+0x2ac>
		b_y = temp;
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 800c7d8:	0001883a 	nop
				}
				addr = addr + limit_x;
			}
		}
	}
}
 800c7dc:	e6fff804 	addi	sp,fp,-32
 800c7e0:	df000817 	ldw	fp,32(sp)
 800c7e4:	ddc00717 	ldw	r23,28(sp)
 800c7e8:	dd800617 	ldw	r22,24(sp)
 800c7ec:	dd400517 	ldw	r21,20(sp)
 800c7f0:	dd000417 	ldw	r20,16(sp)
 800c7f4:	dcc00317 	ldw	r19,12(sp)
 800c7f8:	dc800217 	ldw	r18,8(sp)
 800c7fc:	dc400117 	ldw	r17,4(sp)
 800c800:	dc000017 	ldw	r16,0(sp)
 800c804:	dec00904 	addi	sp,sp,36
 800c808:	f800283a 	ret

0800c80c <alt_up_pixel_buffer_dma_draw_hline>:

void alt_up_pixel_buffer_dma_draw_hline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int x1, int y, int color, int backbuffer)
/* This method draws a horizontal line. This method is faster than using the line method because we know the direction of the line. */
{
 800c80c:	defff404 	addi	sp,sp,-48
 800c810:	df000b15 	stw	fp,44(sp)
 800c814:	dd800a15 	stw	r22,40(sp)
 800c818:	dd400915 	stw	r21,36(sp)
 800c81c:	dd000815 	stw	r20,32(sp)
 800c820:	dcc00715 	stw	r19,28(sp)
 800c824:	dc800615 	stw	r18,24(sp)
 800c828:	dc400515 	stw	r17,20(sp)
 800c82c:	dc000415 	stw	r16,16(sp)
 800c830:	df000b04 	addi	fp,sp,44
 800c834:	e13ff515 	stw	r4,-44(fp)
 800c838:	e17ff615 	stw	r5,-40(fp)
 800c83c:	e1bff715 	stw	r6,-36(fp)
 800c840:	e1fff815 	stw	r7,-32(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 800c844:	e0bff517 	ldw	r2,-44(fp)
 800c848:	14800f17 	ldw	r18,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 800c84c:	e0bff517 	ldw	r2,-44(fp)
 800c850:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int l_x = x0;
 800c854:	e47ff617 	ldw	r17,-40(fp)
	register unsigned int r_x = x1;
 800c858:	e4fff717 	ldw	r19,-36(fp)
	register unsigned int line_y = y;
 800c85c:	e53ff817 	ldw	r20,-32(fp)
	register unsigned int local_color = color;
 800c860:	e5400117 	ldw	r21,4(fp)
	
	/* Check coordinates */
	if (l_x > r_x)
 800c864:	9c40032e 	bgeu	r19,r17,800c874 <alt_up_pixel_buffer_dma_draw_hline+0x68>
	{
		temp = l_x;
 800c868:	882d883a 	mov	r22,r17
		l_x = r_x;
 800c86c:	9823883a 	mov	r17,r19
		r_x = temp;
 800c870:	b027883a 	mov	r19,r22
	}
	if ((l_x >= limit_x) || (line_y >= limit_y) || (r_x < 0) || (line_y < 0))
 800c874:	8c805d2e 	bgeu	r17,r18,800c9ec <alt_up_pixel_buffer_dma_draw_hline+0x1e0>
 800c878:	a4005c2e 	bgeu	r20,r16,800c9ec <alt_up_pixel_buffer_dma_draw_hline+0x1e0>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
 800c87c:	9c800136 	bltu	r19,r18,800c884 <alt_up_pixel_buffer_dma_draw_hline+0x78>
	{
		r_x = limit_x - 1;
 800c880:	94ffffc4 	addi	r19,r18,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800c884:	e0800217 	ldw	r2,8(fp)
 800c888:	10800058 	cmpnei	r2,r2,1
 800c88c:	1000031e 	bne	r2,zero,800c89c <alt_up_pixel_buffer_dma_draw_hline+0x90>
		addr = pixel_buffer->back_buffer_start_address;
 800c890:	e0bff517 	ldw	r2,-44(fp)
 800c894:	14000c17 	ldw	r16,48(r2)
 800c898:	00000206 	br	800c8a4 <alt_up_pixel_buffer_dma_draw_hline+0x98>
	else
		addr = pixel_buffer->buffer_start_address;
 800c89c:	e0bff517 	ldw	r2,-44(fp)
 800c8a0:	14000b17 	ldw	r16,44(r2)

	/* Draw a horizontal line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800c8a4:	e0bff517 	ldw	r2,-44(fp)
 800c8a8:	10800d17 	ldw	r2,52(r2)
 800c8ac:	1000231e 	bne	r2,zero,800c93c <alt_up_pixel_buffer_dma_draw_hline+0x130>
		/* Draw a horizontal line of a given color on the screen using the XY addressing mode. */
		register unsigned int x;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 800c8b0:	e0bff517 	ldw	r2,-44(fp)
 800c8b4:	14801317 	ldw	r18,76(r2)
		addr = addr + (line_y << offset_y);
 800c8b8:	a484983a 	sll	r2,r20,r18
 800c8bc:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c8c0:	e0bff517 	ldw	r2,-44(fp)
 800c8c4:	10800e17 	ldw	r2,56(r2)
 800c8c8:	10800058 	cmpnei	r2,r2,1
 800c8cc:	1000071e 	bne	r2,zero,800c8ec <alt_up_pixel_buffer_dma_draw_hline+0xe0>
			for (x = l_x; x <= r_x; x++)
 800c8d0:	00000406 	br	800c8e4 <alt_up_pixel_buffer_dma_draw_hline+0xd8>
			{
				IOWR_8DIRECT(addr, x, local_color);
 800c8d4:	8c05883a 	add	r2,r17,r16
 800c8d8:	a807883a 	mov	r3,r21
 800c8dc:	10c00025 	stbio	r3,0(r2)
		addr = addr + (line_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
 800c8e0:	8c400044 	addi	r17,r17,1
 800c8e4:	9c7ffb2e 	bgeu	r19,r17,800c8d4 <alt_up_pixel_buffer_dma_draw_hline+0xc8>
 800c8e8:	00004106 	br	800c9f0 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c8ec:	e0bff517 	ldw	r2,-44(fp)
 800c8f0:	10800e17 	ldw	r2,56(r2)
 800c8f4:	10800098 	cmpnei	r2,r2,2
 800c8f8:	10000e1e 	bne	r2,zero,800c934 <alt_up_pixel_buffer_dma_draw_hline+0x128>
			for (x = l_x; x <= r_x; x++)
 800c8fc:	00000506 	br	800c914 <alt_up_pixel_buffer_dma_draw_hline+0x108>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
 800c900:	8c45883a 	add	r2,r17,r17
 800c904:	1405883a 	add	r2,r2,r16
 800c908:	a807883a 	mov	r3,r21
 800c90c:	10c0002d 	sthio	r3,0(r2)
			for (x = l_x; x <= r_x; x++)
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
 800c910:	8c400044 	addi	r17,r17,1
 800c914:	9c7ffa2e 	bgeu	r19,r17,800c900 <alt_up_pixel_buffer_dma_draw_hline+0xf4>
 800c918:	00003506 	br	800c9f0 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
 800c91c:	8c45883a 	add	r2,r17,r17
 800c920:	1085883a 	add	r2,r2,r2
 800c924:	1405883a 	add	r2,r2,r16
 800c928:	a807883a 	mov	r3,r21
 800c92c:	10c00035 	stwio	r3,0(r2)
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
 800c930:	8c400044 	addi	r17,r17,1
 800c934:	9c7ff92e 	bgeu	r19,r17,800c91c <alt_up_pixel_buffer_dma_draw_hline+0x110>
 800c938:	00002d06 	br	800c9f0 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
	} else {
		/* Draw a horizontal line of a given color on the screen using the linear addressing mode. */
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800c93c:	e0bff517 	ldw	r2,-44(fp)
 800c940:	10800e17 	ldw	r2,56(r2)
 800c944:	10800058 	cmpnei	r2,r2,1
 800c948:	1000091e 	bne	r2,zero,800c970 <alt_up_pixel_buffer_dma_draw_hline+0x164>
			addr = addr + line_y * limit_x;
 800c94c:	a485383a 	mul	r2,r20,r18
 800c950:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 800c954:	00000406 	br	800c968 <alt_up_pixel_buffer_dma_draw_hline+0x15c>
			{
				IOWR_8DIRECT(addr, x, local_color);
 800c958:	8c05883a 	add	r2,r17,r16
 800c95c:	a807883a 	mov	r3,r21
 800c960:	10c00025 	stbio	r3,0(r2)
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 800c964:	8c400044 	addi	r17,r17,1
 800c968:	9c7ffb2e 	bgeu	r19,r17,800c958 <alt_up_pixel_buffer_dma_draw_hline+0x14c>
 800c96c:	00002006 	br	800c9f0 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800c970:	e0bff517 	ldw	r2,-44(fp)
 800c974:	10800e17 	ldw	r2,56(r2)
 800c978:	10800098 	cmpnei	r2,r2,2
 800c97c:	10000c1e 	bne	r2,zero,800c9b0 <alt_up_pixel_buffer_dma_draw_hline+0x1a4>
			limit_x = limit_x << 1;
 800c980:	9485883a 	add	r2,r18,r18
 800c984:	1025883a 	mov	r18,r2
			addr = addr + line_y * limit_x;
 800c988:	a485383a 	mul	r2,r20,r18
 800c98c:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 800c990:	00000506 	br	800c9a8 <alt_up_pixel_buffer_dma_draw_hline+0x19c>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
 800c994:	8c45883a 	add	r2,r17,r17
 800c998:	1405883a 	add	r2,r2,r16
 800c99c:	a807883a 	mov	r3,r21
 800c9a0:	10c0002d 	sthio	r3,0(r2)
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 800c9a4:	8c400044 	addi	r17,r17,1
 800c9a8:	9c7ffa2e 	bgeu	r19,r17,800c994 <alt_up_pixel_buffer_dma_draw_hline+0x188>
 800c9ac:	00001006 	br	800c9f0 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			limit_x = limit_x << 2;
 800c9b0:	9485883a 	add	r2,r18,r18
 800c9b4:	1085883a 	add	r2,r2,r2
 800c9b8:	1025883a 	mov	r18,r2
			addr = addr + line_y * limit_x;
 800c9bc:	a485383a 	mul	r2,r20,r18
 800c9c0:	80a1883a 	add	r16,r16,r2
			for (x = l_x; x <= r_x; x++)
 800c9c4:	00000606 	br	800c9e0 <alt_up_pixel_buffer_dma_draw_hline+0x1d4>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
 800c9c8:	8c45883a 	add	r2,r17,r17
 800c9cc:	1085883a 	add	r2,r2,r2
 800c9d0:	1405883a 	add	r2,r2,r16
 800c9d4:	a807883a 	mov	r3,r21
 800c9d8:	10c00035 	stwio	r3,0(r2)
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
 800c9dc:	8c400044 	addi	r17,r17,1
 800c9e0:	9c7ff92e 	bgeu	r19,r17,800c9c8 <alt_up_pixel_buffer_dma_draw_hline+0x1bc>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
			}
			addr = addr + limit_x;
 800c9e4:	84a1883a 	add	r16,r16,r18
 800c9e8:	00000106 	br	800c9f0 <alt_up_pixel_buffer_dma_draw_hline+0x1e4>
		r_x = temp;
	}
	if ((l_x >= limit_x) || (line_y >= limit_y) || (r_x < 0) || (line_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 800c9ec:	0001883a 	nop
				IOWR_32DIRECT(addr, x << 2, local_color);
			}
			addr = addr + limit_x;
		}
	}
}
 800c9f0:	e6fff904 	addi	sp,fp,-28
 800c9f4:	df000717 	ldw	fp,28(sp)
 800c9f8:	dd800617 	ldw	r22,24(sp)
 800c9fc:	dd400517 	ldw	r21,20(sp)
 800ca00:	dd000417 	ldw	r20,16(sp)
 800ca04:	dcc00317 	ldw	r19,12(sp)
 800ca08:	dc800217 	ldw	r18,8(sp)
 800ca0c:	dc400117 	ldw	r17,4(sp)
 800ca10:	dc000017 	ldw	r16,0(sp)
 800ca14:	dec00804 	addi	sp,sp,32
 800ca18:	f800283a 	ret

0800ca1c <alt_up_pixel_buffer_dma_draw_vline>:


void alt_up_pixel_buffer_dma_draw_vline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x, int y0, int y1, int color, int backbuffer)
/* This method draws a vertical line. This method is faster than using the line method because we know the direction of the line. */

{
 800ca1c:	defff404 	addi	sp,sp,-48
 800ca20:	df000b15 	stw	fp,44(sp)
 800ca24:	dd800a15 	stw	r22,40(sp)
 800ca28:	dd400915 	stw	r21,36(sp)
 800ca2c:	dd000815 	stw	r20,32(sp)
 800ca30:	dcc00715 	stw	r19,28(sp)
 800ca34:	dc800615 	stw	r18,24(sp)
 800ca38:	dc400515 	stw	r17,20(sp)
 800ca3c:	dc000415 	stw	r16,16(sp)
 800ca40:	df000b04 	addi	fp,sp,44
 800ca44:	e13ff515 	stw	r4,-44(fp)
 800ca48:	e17ff615 	stw	r5,-40(fp)
 800ca4c:	e1bff715 	stw	r6,-36(fp)
 800ca50:	e1fff815 	stw	r7,-32(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
 800ca54:	e0bff517 	ldw	r2,-44(fp)
 800ca58:	14400f17 	ldw	r17,60(r2)
	register unsigned int limit_y = pixel_buffer->y_resolution;
 800ca5c:	e0bff517 	ldw	r2,-44(fp)
 800ca60:	14001017 	ldw	r16,64(r2)
	register unsigned int temp;
	register unsigned int line_x = x;
 800ca64:	e4bff617 	ldw	r18,-40(fp)
	register unsigned int t_y = y0;
 800ca68:	e53ff717 	ldw	r20,-36(fp)
	register unsigned int b_y = y1;
 800ca6c:	e4fff817 	ldw	r19,-32(fp)
	register unsigned int local_color = color;
 800ca70:	e5800117 	ldw	r22,4(fp)
	
	/* Check coordinates */
	if (t_y > b_y)
 800ca74:	9d00032e 	bgeu	r19,r20,800ca84 <alt_up_pixel_buffer_dma_draw_vline+0x68>
	{
		temp = t_y;
 800ca78:	a02b883a 	mov	r21,r20
		t_y = b_y;
 800ca7c:	9829883a 	mov	r20,r19
		b_y = temp;
 800ca80:	a827883a 	mov	r19,r21
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
 800ca84:	94406c2e 	bgeu	r18,r17,800cc38 <alt_up_pixel_buffer_dma_draw_vline+0x21c>
 800ca88:	a4006b2e 	bgeu	r20,r16,800cc38 <alt_up_pixel_buffer_dma_draw_vline+0x21c>
	/* Clip the box and draw only within the confines of the screen. */
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
 800ca8c:	9c000136 	bltu	r19,r16,800ca94 <alt_up_pixel_buffer_dma_draw_vline+0x78>
	{
		b_y = limit_y - 1;
 800ca90:	84ffffc4 	addi	r19,r16,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
 800ca94:	e0800217 	ldw	r2,8(fp)
 800ca98:	10800058 	cmpnei	r2,r2,1
 800ca9c:	1000031e 	bne	r2,zero,800caac <alt_up_pixel_buffer_dma_draw_vline+0x90>
		addr = pixel_buffer->back_buffer_start_address;
 800caa0:	e0bff517 	ldw	r2,-44(fp)
 800caa4:	14000c17 	ldw	r16,48(r2)
 800caa8:	00000206 	br	800cab4 <alt_up_pixel_buffer_dma_draw_vline+0x98>
	else
		addr = pixel_buffer->buffer_start_address;
 800caac:	e0bff517 	ldw	r2,-44(fp)
 800cab0:	14000b17 	ldw	r16,44(r2)

	/* Draw the vertical line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
 800cab4:	e0bff517 	ldw	r2,-44(fp)
 800cab8:	10800d17 	ldw	r2,52(r2)
 800cabc:	1000301e 	bne	r2,zero,800cb80 <alt_up_pixel_buffer_dma_draw_vline+0x164>
		/* Draw a vertical line of a given color on the screen using the XY addressing mode. */
		register unsigned int y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
 800cac0:	e0bff517 	ldw	r2,-44(fp)
 800cac4:	15401317 	ldw	r21,76(r2)
		addr = addr + (t_y << offset_y);
 800cac8:	a544983a 	sll	r2,r20,r21
 800cacc:	80a1883a 	add	r16,r16,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800cad0:	e0bff517 	ldw	r2,-44(fp)
 800cad4:	10800e17 	ldw	r2,56(r2)
 800cad8:	10800058 	cmpnei	r2,r2,1
 800cadc:	10000b1e 	bne	r2,zero,800cb0c <alt_up_pixel_buffer_dma_draw_vline+0xf0>
			for (y = t_y; y <= b_y; y++)
 800cae0:	a023883a 	mov	r17,r20
 800cae4:	00000706 	br	800cb04 <alt_up_pixel_buffer_dma_draw_vline+0xe8>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
 800cae8:	9405883a 	add	r2,r18,r16
 800caec:	b007883a 	mov	r3,r22
 800caf0:	10c00025 	stbio	r3,0(r2)
				addr = addr + (1 << offset_y);
 800caf4:	00800044 	movi	r2,1
 800caf8:	1544983a 	sll	r2,r2,r21
 800cafc:	80a1883a 	add	r16,r16,r2
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 800cb00:	8c400044 	addi	r17,r17,1
 800cb04:	9c7ff82e 	bgeu	r19,r17,800cae8 <alt_up_pixel_buffer_dma_draw_vline+0xcc>
 800cb08:	00004c06 	br	800cc3c <alt_up_pixel_buffer_dma_draw_vline+0x220>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800cb0c:	e0bff517 	ldw	r2,-44(fp)
 800cb10:	10800e17 	ldw	r2,56(r2)
 800cb14:	10800098 	cmpnei	r2,r2,2
 800cb18:	10000c1e 	bne	r2,zero,800cb4c <alt_up_pixel_buffer_dma_draw_vline+0x130>
			for (y = t_y; y <= b_y; y++)
 800cb1c:	a023883a 	mov	r17,r20
 800cb20:	00000806 	br	800cb44 <alt_up_pixel_buffer_dma_draw_vline+0x128>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
 800cb24:	9485883a 	add	r2,r18,r18
 800cb28:	1405883a 	add	r2,r2,r16
 800cb2c:	b007883a 	mov	r3,r22
 800cb30:	10c0002d 	sthio	r3,0(r2)
				addr = addr + (1 << offset_y);
 800cb34:	00800044 	movi	r2,1
 800cb38:	1544983a 	sll	r2,r2,r21
 800cb3c:	80a1883a 	add	r16,r16,r2
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
 800cb40:	8c400044 	addi	r17,r17,1
 800cb44:	9c7ff72e 	bgeu	r19,r17,800cb24 <alt_up_pixel_buffer_dma_draw_vline+0x108>
 800cb48:	00003c06 	br	800cc3c <alt_up_pixel_buffer_dma_draw_vline+0x220>
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800cb4c:	a023883a 	mov	r17,r20
 800cb50:	00000906 	br	800cb78 <alt_up_pixel_buffer_dma_draw_vline+0x15c>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
 800cb54:	9485883a 	add	r2,r18,r18
 800cb58:	1085883a 	add	r2,r2,r2
 800cb5c:	1405883a 	add	r2,r2,r16
 800cb60:	b007883a 	mov	r3,r22
 800cb64:	10c00035 	stwio	r3,0(r2)
				addr = addr + (1 << offset_y);
 800cb68:	00800044 	movi	r2,1
 800cb6c:	1544983a 	sll	r2,r2,r21
 800cb70:	80a1883a 	add	r16,r16,r2
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
 800cb74:	8c400044 	addi	r17,r17,1
 800cb78:	9c7ff62e 	bgeu	r19,r17,800cb54 <alt_up_pixel_buffer_dma_draw_vline+0x138>
 800cb7c:	00002f06 	br	800cc3c <alt_up_pixel_buffer_dma_draw_vline+0x220>
	} else {
		/* Draw a vertical line of a given color on the screen using the linear addressing mode. */
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
 800cb80:	e0bff517 	ldw	r2,-44(fp)
 800cb84:	10800e17 	ldw	r2,56(r2)
 800cb88:	10800058 	cmpnei	r2,r2,1
 800cb8c:	10000a1e 	bne	r2,zero,800cbb8 <alt_up_pixel_buffer_dma_draw_vline+0x19c>
			addr = addr + t_y * limit_x;
 800cb90:	a445383a 	mul	r2,r20,r17
 800cb94:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800cb98:	00000506 	br	800cbb0 <alt_up_pixel_buffer_dma_draw_vline+0x194>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
 800cb9c:	9405883a 	add	r2,r18,r16
 800cba0:	b007883a 	mov	r3,r22
 800cba4:	10c00025 	stbio	r3,0(r2)
				addr = addr + limit_x;
 800cba8:	8461883a 	add	r16,r16,r17
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800cbac:	a5000044 	addi	r20,r20,1
 800cbb0:	9d3ffa2e 	bgeu	r19,r20,800cb9c <alt_up_pixel_buffer_dma_draw_vline+0x180>
 800cbb4:	00002106 	br	800cc3c <alt_up_pixel_buffer_dma_draw_vline+0x220>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
 800cbb8:	e0bff517 	ldw	r2,-44(fp)
 800cbbc:	10800e17 	ldw	r2,56(r2)
 800cbc0:	10800098 	cmpnei	r2,r2,2
 800cbc4:	10000d1e 	bne	r2,zero,800cbfc <alt_up_pixel_buffer_dma_draw_vline+0x1e0>
			limit_x = limit_x << 1;
 800cbc8:	8c45883a 	add	r2,r17,r17
 800cbcc:	1023883a 	mov	r17,r2
			addr = addr + t_y * limit_x;
 800cbd0:	a445383a 	mul	r2,r20,r17
 800cbd4:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800cbd8:	00000606 	br	800cbf4 <alt_up_pixel_buffer_dma_draw_vline+0x1d8>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
 800cbdc:	9485883a 	add	r2,r18,r18
 800cbe0:	1405883a 	add	r2,r2,r16
 800cbe4:	b007883a 	mov	r3,r22
 800cbe8:	10c0002d 	sthio	r3,0(r2)
				addr = addr + limit_x;
 800cbec:	8461883a 	add	r16,r16,r17
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800cbf0:	a5000044 	addi	r20,r20,1
 800cbf4:	9d3ff92e 	bgeu	r19,r20,800cbdc <alt_up_pixel_buffer_dma_draw_vline+0x1c0>
 800cbf8:	00001006 	br	800cc3c <alt_up_pixel_buffer_dma_draw_vline+0x220>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
 800cbfc:	8c45883a 	add	r2,r17,r17
 800cc00:	1085883a 	add	r2,r2,r2
 800cc04:	1023883a 	mov	r17,r2
			addr = addr + t_y * limit_x;
 800cc08:	a445383a 	mul	r2,r20,r17
 800cc0c:	80a1883a 	add	r16,r16,r2
			for (y = t_y; y <= b_y; y++)
 800cc10:	00000706 	br	800cc30 <alt_up_pixel_buffer_dma_draw_vline+0x214>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
 800cc14:	9485883a 	add	r2,r18,r18
 800cc18:	1085883a 	add	r2,r2,r2
 800cc1c:	1405883a 	add	r2,r2,r16
 800cc20:	b007883a 	mov	r3,r22
 800cc24:	10c00035 	stwio	r3,0(r2)
				addr = addr + limit_x;
 800cc28:	8461883a 	add	r16,r16,r17
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
 800cc2c:	a5000044 	addi	r20,r20,1
 800cc30:	9d3ff82e 	bgeu	r19,r20,800cc14 <alt_up_pixel_buffer_dma_draw_vline+0x1f8>
 800cc34:	00000106 	br	800cc3c <alt_up_pixel_buffer_dma_draw_vline+0x220>
		b_y = temp;
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
	{
		/* Drawing outside of the window, so don't bother. */
		return;
 800cc38:	0001883a 	nop
				IOWR_32DIRECT(addr, line_x << 2, local_color);
				addr = addr + limit_x;
			}
		}
	}
}
 800cc3c:	e6fff904 	addi	sp,fp,-28
 800cc40:	df000717 	ldw	fp,28(sp)
 800cc44:	dd800617 	ldw	r22,24(sp)
 800cc48:	dd400517 	ldw	r21,20(sp)
 800cc4c:	dd000417 	ldw	r20,16(sp)
 800cc50:	dcc00317 	ldw	r19,12(sp)
 800cc54:	dc800217 	ldw	r18,8(sp)
 800cc58:	dc400117 	ldw	r17,4(sp)
 800cc5c:	dc000017 	ldw	r16,0(sp)
 800cc60:	dec00804 	addi	sp,sp,32
 800cc64:	f800283a 	ret

0800cc68 <alt_up_pixel_buffer_dma_draw_rectangle>:

void alt_up_pixel_buffer_dma_draw_rectangle(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
{
 800cc68:	defff804 	addi	sp,sp,-32
 800cc6c:	dfc00715 	stw	ra,28(sp)
 800cc70:	df000615 	stw	fp,24(sp)
 800cc74:	df000604 	addi	fp,sp,24
 800cc78:	e13ffc15 	stw	r4,-16(fp)
 800cc7c:	e17ffd15 	stw	r5,-12(fp)
 800cc80:	e1bffe15 	stw	r6,-8(fp)
 800cc84:	e1ffff15 	stw	r7,-4(fp)
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y0, color, backbuffer);
 800cc88:	e0800417 	ldw	r2,16(fp)
 800cc8c:	d8800115 	stw	r2,4(sp)
 800cc90:	e0800317 	ldw	r2,12(fp)
 800cc94:	d8800015 	stw	r2,0(sp)
 800cc98:	e1fffe17 	ldw	r7,-8(fp)
 800cc9c:	e1bfff17 	ldw	r6,-4(fp)
 800cca0:	e17ffd17 	ldw	r5,-12(fp)
 800cca4:	e13ffc17 	ldw	r4,-16(fp)
 800cca8:	800c80c0 	call	800c80c <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y1, color, backbuffer);
 800ccac:	e0800417 	ldw	r2,16(fp)
 800ccb0:	d8800115 	stw	r2,4(sp)
 800ccb4:	e0800317 	ldw	r2,12(fp)
 800ccb8:	d8800015 	stw	r2,0(sp)
 800ccbc:	e1c00217 	ldw	r7,8(fp)
 800ccc0:	e1bfff17 	ldw	r6,-4(fp)
 800ccc4:	e17ffd17 	ldw	r5,-12(fp)
 800ccc8:	e13ffc17 	ldw	r4,-16(fp)
 800cccc:	800c80c0 	call	800c80c <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x0, y0, y1, color, backbuffer);
 800ccd0:	e0800417 	ldw	r2,16(fp)
 800ccd4:	d8800115 	stw	r2,4(sp)
 800ccd8:	e0800317 	ldw	r2,12(fp)
 800ccdc:	d8800015 	stw	r2,0(sp)
 800cce0:	e1c00217 	ldw	r7,8(fp)
 800cce4:	e1bffe17 	ldw	r6,-8(fp)
 800cce8:	e17ffd17 	ldw	r5,-12(fp)
 800ccec:	e13ffc17 	ldw	r4,-16(fp)
 800ccf0:	800ca1c0 	call	800ca1c <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x1, y0, y1, color, backbuffer);
 800ccf4:	e0800417 	ldw	r2,16(fp)
 800ccf8:	d8800115 	stw	r2,4(sp)
 800ccfc:	e0800317 	ldw	r2,12(fp)
 800cd00:	d8800015 	stw	r2,0(sp)
 800cd04:	e1c00217 	ldw	r7,8(fp)
 800cd08:	e1bffe17 	ldw	r6,-8(fp)
 800cd0c:	e17fff17 	ldw	r5,-4(fp)
 800cd10:	e13ffc17 	ldw	r4,-16(fp)
 800cd14:	800ca1c0 	call	800ca1c <alt_up_pixel_buffer_dma_draw_vline>
}
 800cd18:	0001883a 	nop
 800cd1c:	e037883a 	mov	sp,fp
 800cd20:	dfc00117 	ldw	ra,4(sp)
 800cd24:	df000017 	ldw	fp,0(sp)
 800cd28:	dec00204 	addi	sp,sp,8
 800cd2c:	f800283a 	ret

0800cd30 <helper_plot_pixel>:

void helper_plot_pixel(register unsigned int buffer_start, register int line_size, register int x, register int y, register int color, register int mode)
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
 800cd30:	deffff04 	addi	sp,sp,-4
 800cd34:	df000015 	stw	fp,0(sp)
 800cd38:	d839883a 	mov	fp,sp
 800cd3c:	2005883a 	mov	r2,r4
 800cd40:	3007883a 	mov	r3,r6
 800cd44:	3809883a 	mov	r4,r7
 800cd48:	e1800117 	ldw	r6,4(fp)
 800cd4c:	e1c00217 	ldw	r7,8(fp)
	if (mode == 0)
 800cd50:	3800051e 	bne	r7,zero,800cd68 <helper_plot_pixel+0x38>
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
 800cd54:	2909383a 	mul	r4,r5,r4
 800cd58:	20c7883a 	add	r3,r4,r3
 800cd5c:	1885883a 	add	r2,r3,r2
 800cd60:	11800025 	stbio	r6,0(r2)
	else if (mode == 1)
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
}
 800cd64:	00000e06 	br	800cda0 <helper_plot_pixel+0x70>
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
	if (mode == 0)
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
	else if (mode == 1)
 800cd68:	39c00058 	cmpnei	r7,r7,1
 800cd6c:	3800061e 	bne	r7,zero,800cd88 <helper_plot_pixel+0x58>
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
 800cd70:	2909383a 	mul	r4,r5,r4
 800cd74:	20c7883a 	add	r3,r4,r3
 800cd78:	18c7883a 	add	r3,r3,r3
 800cd7c:	1885883a 	add	r2,r3,r2
 800cd80:	1180002d 	sthio	r6,0(r2)
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
}
 800cd84:	00000606 	br	800cda0 <helper_plot_pixel+0x70>
	if (mode == 0)
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
	else if (mode == 1)
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
 800cd88:	2909383a 	mul	r4,r5,r4
 800cd8c:	20c7883a 	add	r3,r4,r3
 800cd90:	18c7883a 	add	r3,r3,r3
 800cd94:	18c7883a 	add	r3,r3,r3
 800cd98:	1885883a 	add	r2,r3,r2
 800cd9c:	11800035 	stwio	r6,0(r2)
}
 800cda0:	0001883a 	nop
 800cda4:	e037883a 	mov	sp,fp
 800cda8:	df000017 	ldw	fp,0(sp)
 800cdac:	dec00104 	addi	sp,sp,4
 800cdb0:	f800283a 	ret

0800cdb4 <alt_up_pixel_buffer_dma_draw_line>:

void alt_up_pixel_buffer_dma_draw_line(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a line between points (x0, y0) and (x1, y1). The function does not check if it draws a pixel within screen boundaries.
 * users should ensure that the line is drawn within the screen boundaries. */
{
 800cdb4:	deffeb04 	addi	sp,sp,-84
 800cdb8:	dfc01415 	stw	ra,80(sp)
 800cdbc:	df001315 	stw	fp,76(sp)
 800cdc0:	ddc01215 	stw	r23,72(sp)
 800cdc4:	dd801115 	stw	r22,68(sp)
 800cdc8:	dd401015 	stw	r21,64(sp)
 800cdcc:	dd000f15 	stw	r20,60(sp)
 800cdd0:	dcc00e15 	stw	r19,56(sp)
 800cdd4:	dc800d15 	stw	r18,52(sp)
 800cdd8:	dc400c15 	stw	r17,48(sp)
 800cddc:	dc000b15 	stw	r16,44(sp)
 800cde0:	df001304 	addi	fp,sp,76
 800cde4:	e13fef15 	stw	r4,-68(fp)
 800cde8:	e17ff015 	stw	r5,-64(fp)
 800cdec:	e1bff115 	stw	r6,-60(fp)
 800cdf0:	e1fff215 	stw	r7,-56(fp)
	register int x_0 = x0;
 800cdf4:	e47ff017 	ldw	r17,-64(fp)
	register int y_0 = y0;
 800cdf8:	e4fff117 	ldw	r19,-60(fp)
	register int x_1 = x1;
 800cdfc:	e4bff217 	ldw	r18,-56(fp)
	register int y_1 = y1;
 800ce00:	e5000217 	ldw	r20,8(fp)
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
 800ce04:	a4c5c83a 	sub	r2,r20,r19
 800ce08:	1000010e 	bge	r2,zero,800ce10 <alt_up_pixel_buffer_dma_draw_line+0x5c>
 800ce0c:	0085c83a 	sub	r2,zero,r2
 800ce10:	1007883a 	mov	r3,r2
 800ce14:	9445c83a 	sub	r2,r18,r17
 800ce18:	1000010e 	bge	r2,zero,800ce20 <alt_up_pixel_buffer_dma_draw_line+0x6c>
 800ce1c:	0085c83a 	sub	r2,zero,r2
 800ce20:	10c4803a 	cmplt	r2,r2,r3
 800ce24:	e0bff305 	stb	r2,-52(fp)
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
 800ce28:	e0bfef17 	ldw	r2,-68(fp)
 800ce2c:	10800e17 	ldw	r2,56(r2)
 800ce30:	10800060 	cmpeqi	r2,r2,1
 800ce34:	1000081e 	bne	r2,zero,800ce58 <alt_up_pixel_buffer_dma_draw_line+0xa4>
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
 800ce38:	e0bfef17 	ldw	r2,-68(fp)
 800ce3c:	10800e17 	ldw	r2,56(r2)
 800ce40:	10800098 	cmpnei	r2,r2,2
 800ce44:	1000021e 	bne	r2,zero,800ce50 <alt_up_pixel_buffer_dma_draw_line+0x9c>
 800ce48:	00800044 	movi	r2,1
 800ce4c:	00000306 	br	800ce5c <alt_up_pixel_buffer_dma_draw_line+0xa8>
 800ce50:	00800084 	movi	r2,2
 800ce54:	00000106 	br	800ce5c <alt_up_pixel_buffer_dma_draw_line+0xa8>
	register int y_0 = y0;
	register int x_1 = x1;
	register int y_1 = y1;
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
 800ce58:	0005883a 	mov	r2,zero
 800ce5c:	e0bff415 	stw	r2,-48(fp)
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
	register int line_color = color;
 800ce60:	e0800317 	ldw	r2,12(fp)
 800ce64:	e0bff515 	stw	r2,-44(fp)
	register unsigned int buffer_start;
	register int line_size = (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) ? (1 << (pixel_buffer->y_coord_offset-color_mode)) : pixel_buffer->x_resolution;
 800ce68:	e0bfef17 	ldw	r2,-68(fp)
 800ce6c:	10800d17 	ldw	r2,52(r2)
 800ce70:	1000071e 	bne	r2,zero,800ce90 <alt_up_pixel_buffer_dma_draw_line+0xdc>
 800ce74:	e0bfef17 	ldw	r2,-68(fp)
 800ce78:	10801317 	ldw	r2,76(r2)
 800ce7c:	e0fff417 	ldw	r3,-48(fp)
 800ce80:	10c5c83a 	sub	r2,r2,r3
 800ce84:	00c00044 	movi	r3,1
 800ce88:	1884983a 	sll	r2,r3,r2
 800ce8c:	00000206 	br	800ce98 <alt_up_pixel_buffer_dma_draw_line+0xe4>
 800ce90:	e0bfef17 	ldw	r2,-68(fp)
 800ce94:	10800f17 	ldw	r2,60(r2)
 800ce98:	e0bff615 	stw	r2,-40(fp)

	if (backbuffer == 1)
 800ce9c:	e0800417 	ldw	r2,16(fp)
 800cea0:	10800058 	cmpnei	r2,r2,1
 800cea4:	1000031e 	bne	r2,zero,800ceb4 <alt_up_pixel_buffer_dma_draw_line+0x100>
		buffer_start = pixel_buffer->back_buffer_start_address;
 800cea8:	e0bfef17 	ldw	r2,-68(fp)
 800ceac:	15c00c17 	ldw	r23,48(r2)
 800ceb0:	00000206 	br	800cebc <alt_up_pixel_buffer_dma_draw_line+0x108>
	else
		buffer_start = pixel_buffer->buffer_start_address;
 800ceb4:	e0bfef17 	ldw	r2,-68(fp)
 800ceb8:	15c00b17 	ldw	r23,44(r2)

	/* Preprocessing inputs */
	if (steep > 0) {
 800cebc:	e0bff307 	ldb	r2,-52(fp)
 800cec0:	0080060e 	bge	zero,r2,800cedc <alt_up_pixel_buffer_dma_draw_line+0x128>
		// Swap x_0 and y_0
		error = x_0;
 800cec4:	8821883a 	mov	r16,r17
		x_0 = y_0;
 800cec8:	9823883a 	mov	r17,r19
		y_0 = error;
 800cecc:	8027883a 	mov	r19,r16
		// Swap x_1 and y_1
		error = x_1;
 800ced0:	9021883a 	mov	r16,r18
		x_1 = y_1;
 800ced4:	a025883a 	mov	r18,r20
		y_1 = error;
 800ced8:	8029883a 	mov	r20,r16
	}
	if (x_0 > x_1) {
 800cedc:	9440060e 	bge	r18,r17,800cef8 <alt_up_pixel_buffer_dma_draw_line+0x144>
		// Swap x_0 and x_1
		error = x_0;
 800cee0:	8821883a 	mov	r16,r17
		x_0 = x_1;
 800cee4:	9023883a 	mov	r17,r18
		x_1 = error;
 800cee8:	8025883a 	mov	r18,r16
		// Swap y_0 and y_1
		error = y_0;
 800ceec:	9821883a 	mov	r16,r19
		y_0 = y_1;
 800cef0:	a027883a 	mov	r19,r20
		y_1 = error;
 800cef4:	8029883a 	mov	r20,r16
	}

	/* Setup local variables */
	deltax = x_1 - x_0;
 800cef8:	946bc83a 	sub	r21,r18,r17
	deltay = ABS(y_1 - y_0);
 800cefc:	a4c5c83a 	sub	r2,r20,r19
 800cf00:	1000010e 	bge	r2,zero,800cf08 <alt_up_pixel_buffer_dma_draw_line+0x154>
 800cf04:	0085c83a 	sub	r2,zero,r2
 800cf08:	e0bff715 	stw	r2,-36(fp)
	error = -(deltax / 2); 
 800cf0c:	a804d7fa 	srli	r2,r21,31
 800cf10:	1545883a 	add	r2,r2,r21
 800cf14:	1005d07a 	srai	r2,r2,1
 800cf18:	00a1c83a 	sub	r16,zero,r2
	y = y_0;
 800cf1c:	982d883a 	mov	r22,r19
	if (y_0 < y_1)
 800cf20:	9d00020e 	bge	r19,r20,800cf2c <alt_up_pixel_buffer_dma_draw_line+0x178>
		ystep = 1;
 800cf24:	04c00044 	movi	r19,1
 800cf28:	00000106 	br	800cf30 <alt_up_pixel_buffer_dma_draw_line+0x17c>
	else
		ystep = -1;
 800cf2c:	04ffffc4 	movi	r19,-1

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
 800cf30:	e0bff307 	ldb	r2,-52(fp)
 800cf34:	10800058 	cmpnei	r2,r2,1
 800cf38:	1000211e 	bne	r2,zero,800cfc0 <alt_up_pixel_buffer_dma_draw_line+0x20c>
	{
		for (x=x_0; x <= x_1; x++) {
 800cf3c:	00000f06 	br	800cf7c <alt_up_pixel_buffer_dma_draw_line+0x1c8>
			helper_plot_pixel(buffer_start, line_size, y, x, line_color, color_mode);
 800cf40:	e0bff417 	ldw	r2,-48(fp)
 800cf44:	d8800115 	stw	r2,4(sp)
 800cf48:	e0bff517 	ldw	r2,-44(fp)
 800cf4c:	d8800015 	stw	r2,0(sp)
 800cf50:	880f883a 	mov	r7,r17
 800cf54:	b00d883a 	mov	r6,r22
 800cf58:	e17ff617 	ldw	r5,-40(fp)
 800cf5c:	b809883a 	mov	r4,r23
 800cf60:	800cd300 	call	800cd30 <helper_plot_pixel>
			error = error + deltay;
 800cf64:	e0bff717 	ldw	r2,-36(fp)
 800cf68:	80a1883a 	add	r16,r16,r2
			if (error > 0) {
 800cf6c:	0400020e 	bge	zero,r16,800cf78 <alt_up_pixel_buffer_dma_draw_line+0x1c4>
				y = y + ystep;
 800cf70:	b4ed883a 	add	r22,r22,r19
				error = error - deltax;
 800cf74:	8561c83a 	sub	r16,r16,r21

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
	{
		for (x=x_0; x <= x_1; x++) {
 800cf78:	8c400044 	addi	r17,r17,1
 800cf7c:	947ff00e 	bge	r18,r17,800cf40 <alt_up_pixel_buffer_dma_draw_line+0x18c>
				y = y + ystep;
				error = error - deltax;
			}
		}
	}
}
 800cf80:	00001006 	br	800cfc4 <alt_up_pixel_buffer_dma_draw_line+0x210>
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
			helper_plot_pixel(buffer_start, line_size, x, y, line_color, color_mode);
 800cf84:	e0bff417 	ldw	r2,-48(fp)
 800cf88:	d8800115 	stw	r2,4(sp)
 800cf8c:	e0bff517 	ldw	r2,-44(fp)
 800cf90:	d8800015 	stw	r2,0(sp)
 800cf94:	b00f883a 	mov	r7,r22
 800cf98:	880d883a 	mov	r6,r17
 800cf9c:	e17ff617 	ldw	r5,-40(fp)
 800cfa0:	b809883a 	mov	r4,r23
 800cfa4:	800cd300 	call	800cd30 <helper_plot_pixel>
			error = error + deltay;
 800cfa8:	e0bff717 	ldw	r2,-36(fp)
 800cfac:	80a1883a 	add	r16,r16,r2
			if (error > 0) {
 800cfb0:	0400020e 	bge	zero,r16,800cfbc <alt_up_pixel_buffer_dma_draw_line+0x208>
				y = y + ystep;
 800cfb4:	b4ed883a 	add	r22,r22,r19
				error = error - deltax;
 800cfb8:	8561c83a 	sub	r16,r16,r21
			}
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
 800cfbc:	8c400044 	addi	r17,r17,1
 800cfc0:	947ff00e 	bge	r18,r17,800cf84 <alt_up_pixel_buffer_dma_draw_line+0x1d0>
				y = y + ystep;
				error = error - deltax;
			}
		}
	}
}
 800cfc4:	0001883a 	nop
 800cfc8:	e6fff804 	addi	sp,fp,-32
 800cfcc:	dfc00917 	ldw	ra,36(sp)
 800cfd0:	df000817 	ldw	fp,32(sp)
 800cfd4:	ddc00717 	ldw	r23,28(sp)
 800cfd8:	dd800617 	ldw	r22,24(sp)
 800cfdc:	dd400517 	ldw	r21,20(sp)
 800cfe0:	dd000417 	ldw	r20,16(sp)
 800cfe4:	dcc00317 	ldw	r19,12(sp)
 800cfe8:	dc800217 	ldw	r18,8(sp)
 800cfec:	dc400117 	ldw	r17,4(sp)
 800cff0:	dc000017 	ldw	r16,0(sp)
 800cff4:	dec00a04 	addi	sp,sp,40
 800cff8:	f800283a 	ret

0800cffc <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 800cffc:	defff504 	addi	sp,sp,-44
 800d000:	df000a15 	stw	fp,40(sp)
 800d004:	df000a04 	addi	fp,sp,40
 800d008:	e13ffc15 	stw	r4,-16(fp)
 800d00c:	e17ffd15 	stw	r5,-12(fp)
 800d010:	e1bffe15 	stw	r6,-8(fp)
 800d014:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 800d018:	e03ff615 	stw	zero,-40(fp)
 800d01c:	d0a76e17 	ldw	r2,-25160(gp)
  
  if (alt_ticks_per_second ())
 800d020:	10003c26 	beq	r2,zero,800d114 <alt_alarm_start+0x118>
  {
    if (alarm)
 800d024:	e0bffc17 	ldw	r2,-16(fp)
 800d028:	10003826 	beq	r2,zero,800d10c <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 800d02c:	e0bffc17 	ldw	r2,-16(fp)
 800d030:	e0fffe17 	ldw	r3,-8(fp)
 800d034:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 800d038:	e0bffc17 	ldw	r2,-16(fp)
 800d03c:	e0ffff17 	ldw	r3,-4(fp)
 800d040:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800d044:	0005303a 	rdctl	r2,status
 800d048:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800d04c:	e0fff917 	ldw	r3,-28(fp)
 800d050:	00bfff84 	movi	r2,-2
 800d054:	1884703a 	and	r2,r3,r2
 800d058:	1001703a 	wrctl	status,r2
  
  return context;
 800d05c:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 800d060:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 800d064:	d0a76f17 	ldw	r2,-25156(gp)
      
      current_nticks = alt_nticks();
 800d068:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 800d06c:	e0fffd17 	ldw	r3,-12(fp)
 800d070:	e0bff617 	ldw	r2,-40(fp)
 800d074:	1885883a 	add	r2,r3,r2
 800d078:	10c00044 	addi	r3,r2,1
 800d07c:	e0bffc17 	ldw	r2,-16(fp)
 800d080:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 800d084:	e0bffc17 	ldw	r2,-16(fp)
 800d088:	10c00217 	ldw	r3,8(r2)
 800d08c:	e0bff617 	ldw	r2,-40(fp)
 800d090:	1880042e 	bgeu	r3,r2,800d0a4 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 800d094:	e0bffc17 	ldw	r2,-16(fp)
 800d098:	00c00044 	movi	r3,1
 800d09c:	10c00405 	stb	r3,16(r2)
 800d0a0:	00000206 	br	800d0ac <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 800d0a4:	e0bffc17 	ldw	r2,-16(fp)
 800d0a8:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 800d0ac:	e0bffc17 	ldw	r2,-16(fp)
 800d0b0:	d0e04d04 	addi	r3,gp,-32460
 800d0b4:	e0fffa15 	stw	r3,-24(fp)
 800d0b8:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 800d0bc:	e0bffb17 	ldw	r2,-20(fp)
 800d0c0:	e0fffa17 	ldw	r3,-24(fp)
 800d0c4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 800d0c8:	e0bffa17 	ldw	r2,-24(fp)
 800d0cc:	10c00017 	ldw	r3,0(r2)
 800d0d0:	e0bffb17 	ldw	r2,-20(fp)
 800d0d4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 800d0d8:	e0bffa17 	ldw	r2,-24(fp)
 800d0dc:	10800017 	ldw	r2,0(r2)
 800d0e0:	e0fffb17 	ldw	r3,-20(fp)
 800d0e4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 800d0e8:	e0bffa17 	ldw	r2,-24(fp)
 800d0ec:	e0fffb17 	ldw	r3,-20(fp)
 800d0f0:	10c00015 	stw	r3,0(r2)
 800d0f4:	e0bff817 	ldw	r2,-32(fp)
 800d0f8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800d0fc:	e0bff717 	ldw	r2,-36(fp)
 800d100:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 800d104:	0005883a 	mov	r2,zero
 800d108:	00000306 	br	800d118 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 800d10c:	00bffa84 	movi	r2,-22
 800d110:	00000106 	br	800d118 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 800d114:	00bfde84 	movi	r2,-134
  }
}
 800d118:	e037883a 	mov	sp,fp
 800d11c:	df000017 	ldw	fp,0(sp)
 800d120:	dec00104 	addi	sp,sp,4
 800d124:	f800283a 	ret

0800d128 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 800d128:	defffe04 	addi	sp,sp,-8
 800d12c:	df000115 	stw	fp,4(sp)
 800d130:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 800d134:	e03fff15 	stw	zero,-4(fp)
 800d138:	00000506 	br	800d150 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 800d13c:	e0bfff17 	ldw	r2,-4(fp)
 800d140:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 800d144:	e0bfff17 	ldw	r2,-4(fp)
 800d148:	10800804 	addi	r2,r2,32
 800d14c:	e0bfff15 	stw	r2,-4(fp)
 800d150:	e0bfff17 	ldw	r2,-4(fp)
 800d154:	10820030 	cmpltui	r2,r2,2048
 800d158:	103ff81e 	bne	r2,zero,800d13c <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 800d15c:	0001883a 	nop
 800d160:	e037883a 	mov	sp,fp
 800d164:	df000017 	ldw	fp,0(sp)
 800d168:	dec00104 	addi	sp,sp,4
 800d16c:	f800283a 	ret

0800d170 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800d170:	defffe04 	addi	sp,sp,-8
 800d174:	dfc00115 	stw	ra,4(sp)
 800d178:	df000015 	stw	fp,0(sp)
 800d17c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800d180:	d0a04b17 	ldw	r2,-32468(gp)
 800d184:	10000326 	beq	r2,zero,800d194 <alt_get_errno+0x24>
 800d188:	d0a04b17 	ldw	r2,-32468(gp)
 800d18c:	103ee83a 	callr	r2
 800d190:	00000106 	br	800d198 <alt_get_errno+0x28>
 800d194:	d0a76a04 	addi	r2,gp,-25176
}
 800d198:	e037883a 	mov	sp,fp
 800d19c:	dfc00117 	ldw	ra,4(sp)
 800d1a0:	df000017 	ldw	fp,0(sp)
 800d1a4:	dec00204 	addi	sp,sp,8
 800d1a8:	f800283a 	ret

0800d1ac <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 800d1ac:	defffa04 	addi	sp,sp,-24
 800d1b0:	dfc00515 	stw	ra,20(sp)
 800d1b4:	df000415 	stw	fp,16(sp)
 800d1b8:	df000404 	addi	fp,sp,16
 800d1bc:	e13ffe15 	stw	r4,-8(fp)
 800d1c0:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 800d1c4:	e0bffe17 	ldw	r2,-8(fp)
 800d1c8:	10000326 	beq	r2,zero,800d1d8 <alt_dev_llist_insert+0x2c>
 800d1cc:	e0bffe17 	ldw	r2,-8(fp)
 800d1d0:	10800217 	ldw	r2,8(r2)
 800d1d4:	1000061e 	bne	r2,zero,800d1f0 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 800d1d8:	800d1700 	call	800d170 <alt_get_errno>
 800d1dc:	1007883a 	mov	r3,r2
 800d1e0:	00800584 	movi	r2,22
 800d1e4:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 800d1e8:	00bffa84 	movi	r2,-22
 800d1ec:	00001306 	br	800d23c <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 800d1f0:	e0bffe17 	ldw	r2,-8(fp)
 800d1f4:	e0ffff17 	ldw	r3,-4(fp)
 800d1f8:	e0fffc15 	stw	r3,-16(fp)
 800d1fc:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 800d200:	e0bffd17 	ldw	r2,-12(fp)
 800d204:	e0fffc17 	ldw	r3,-16(fp)
 800d208:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 800d20c:	e0bffc17 	ldw	r2,-16(fp)
 800d210:	10c00017 	ldw	r3,0(r2)
 800d214:	e0bffd17 	ldw	r2,-12(fp)
 800d218:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 800d21c:	e0bffc17 	ldw	r2,-16(fp)
 800d220:	10800017 	ldw	r2,0(r2)
 800d224:	e0fffd17 	ldw	r3,-12(fp)
 800d228:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 800d22c:	e0bffc17 	ldw	r2,-16(fp)
 800d230:	e0fffd17 	ldw	r3,-12(fp)
 800d234:	10c00015 	stw	r3,0(r2)

  return 0;  
 800d238:	0005883a 	mov	r2,zero
}
 800d23c:	e037883a 	mov	sp,fp
 800d240:	dfc00117 	ldw	ra,4(sp)
 800d244:	df000017 	ldw	fp,0(sp)
 800d248:	dec00204 	addi	sp,sp,8
 800d24c:	f800283a 	ret

0800d250 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 800d250:	defffd04 	addi	sp,sp,-12
 800d254:	dfc00215 	stw	ra,8(sp)
 800d258:	df000115 	stw	fp,4(sp)
 800d25c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 800d260:	00820074 	movhi	r2,2049
 800d264:	10b79204 	addi	r2,r2,-8632
 800d268:	e0bfff15 	stw	r2,-4(fp)
 800d26c:	00000606 	br	800d288 <_do_ctors+0x38>
        (*ctor) (); 
 800d270:	e0bfff17 	ldw	r2,-4(fp)
 800d274:	10800017 	ldw	r2,0(r2)
 800d278:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 800d27c:	e0bfff17 	ldw	r2,-4(fp)
 800d280:	10bfff04 	addi	r2,r2,-4
 800d284:	e0bfff15 	stw	r2,-4(fp)
 800d288:	e0ffff17 	ldw	r3,-4(fp)
 800d28c:	00820074 	movhi	r2,2049
 800d290:	10b79304 	addi	r2,r2,-8628
 800d294:	18bff62e 	bgeu	r3,r2,800d270 <_do_ctors+0x20>
        (*ctor) (); 
}
 800d298:	0001883a 	nop
 800d29c:	e037883a 	mov	sp,fp
 800d2a0:	dfc00117 	ldw	ra,4(sp)
 800d2a4:	df000017 	ldw	fp,0(sp)
 800d2a8:	dec00204 	addi	sp,sp,8
 800d2ac:	f800283a 	ret

0800d2b0 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 800d2b0:	defffd04 	addi	sp,sp,-12
 800d2b4:	dfc00215 	stw	ra,8(sp)
 800d2b8:	df000115 	stw	fp,4(sp)
 800d2bc:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 800d2c0:	00820074 	movhi	r2,2049
 800d2c4:	10b79204 	addi	r2,r2,-8632
 800d2c8:	e0bfff15 	stw	r2,-4(fp)
 800d2cc:	00000606 	br	800d2e8 <_do_dtors+0x38>
        (*dtor) (); 
 800d2d0:	e0bfff17 	ldw	r2,-4(fp)
 800d2d4:	10800017 	ldw	r2,0(r2)
 800d2d8:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 800d2dc:	e0bfff17 	ldw	r2,-4(fp)
 800d2e0:	10bfff04 	addi	r2,r2,-4
 800d2e4:	e0bfff15 	stw	r2,-4(fp)
 800d2e8:	e0ffff17 	ldw	r3,-4(fp)
 800d2ec:	00820074 	movhi	r2,2049
 800d2f0:	10b79304 	addi	r2,r2,-8628
 800d2f4:	18bff62e 	bgeu	r3,r2,800d2d0 <_do_dtors+0x20>
        (*dtor) (); 
}
 800d2f8:	0001883a 	nop
 800d2fc:	e037883a 	mov	sp,fp
 800d300:	dfc00117 	ldw	ra,4(sp)
 800d304:	df000017 	ldw	fp,0(sp)
 800d308:	dec00204 	addi	sp,sp,8
 800d30c:	f800283a 	ret

0800d310 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 800d310:	defffa04 	addi	sp,sp,-24
 800d314:	dfc00515 	stw	ra,20(sp)
 800d318:	df000415 	stw	fp,16(sp)
 800d31c:	df000404 	addi	fp,sp,16
 800d320:	e13ffe15 	stw	r4,-8(fp)
 800d324:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 800d328:	e0bfff17 	ldw	r2,-4(fp)
 800d32c:	10800017 	ldw	r2,0(r2)
 800d330:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 800d334:	e13ffe17 	ldw	r4,-8(fp)
 800d338:	8005f0c0 	call	8005f0c <strlen>
 800d33c:	10800044 	addi	r2,r2,1
 800d340:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 800d344:	00000d06 	br	800d37c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 800d348:	e0bffc17 	ldw	r2,-16(fp)
 800d34c:	10800217 	ldw	r2,8(r2)
 800d350:	e0fffd17 	ldw	r3,-12(fp)
 800d354:	180d883a 	mov	r6,r3
 800d358:	e17ffe17 	ldw	r5,-8(fp)
 800d35c:	1009883a 	mov	r4,r2
 800d360:	800d8480 	call	800d848 <memcmp>
 800d364:	1000021e 	bne	r2,zero,800d370 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 800d368:	e0bffc17 	ldw	r2,-16(fp)
 800d36c:	00000706 	br	800d38c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 800d370:	e0bffc17 	ldw	r2,-16(fp)
 800d374:	10800017 	ldw	r2,0(r2)
 800d378:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 800d37c:	e0fffc17 	ldw	r3,-16(fp)
 800d380:	e0bfff17 	ldw	r2,-4(fp)
 800d384:	18bff01e 	bne	r3,r2,800d348 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 800d388:	0005883a 	mov	r2,zero
}
 800d38c:	e037883a 	mov	sp,fp
 800d390:	dfc00117 	ldw	ra,4(sp)
 800d394:	df000017 	ldw	fp,0(sp)
 800d398:	dec00204 	addi	sp,sp,8
 800d39c:	f800283a 	ret

0800d3a0 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 800d3a0:	defffe04 	addi	sp,sp,-8
 800d3a4:	dfc00115 	stw	ra,4(sp)
 800d3a8:	df000015 	stw	fp,0(sp)
 800d3ac:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 800d3b0:	01440004 	movi	r5,4096
 800d3b4:	0009883a 	mov	r4,zero
 800d3b8:	800d6980 	call	800d698 <alt_icache_flush>
#endif
}
 800d3bc:	0001883a 	nop
 800d3c0:	e037883a 	mov	sp,fp
 800d3c4:	dfc00117 	ldw	ra,4(sp)
 800d3c8:	df000017 	ldw	fp,0(sp)
 800d3cc:	dec00204 	addi	sp,sp,8
 800d3d0:	f800283a 	ret

0800d3d4 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 800d3d4:	defff904 	addi	sp,sp,-28
 800d3d8:	dfc00615 	stw	ra,24(sp)
 800d3dc:	df000515 	stw	fp,20(sp)
 800d3e0:	df000504 	addi	fp,sp,20
 800d3e4:	e13ffc15 	stw	r4,-16(fp)
 800d3e8:	e17ffd15 	stw	r5,-12(fp)
 800d3ec:	e1bffe15 	stw	r6,-8(fp)
 800d3f0:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 800d3f4:	e0800217 	ldw	r2,8(fp)
 800d3f8:	d8800015 	stw	r2,0(sp)
 800d3fc:	e1ffff17 	ldw	r7,-4(fp)
 800d400:	e1bffe17 	ldw	r6,-8(fp)
 800d404:	e17ffd17 	ldw	r5,-12(fp)
 800d408:	e13ffc17 	ldw	r4,-16(fp)
 800d40c:	800d5840 	call	800d584 <alt_iic_isr_register>
}  
 800d410:	e037883a 	mov	sp,fp
 800d414:	dfc00117 	ldw	ra,4(sp)
 800d418:	df000017 	ldw	fp,0(sp)
 800d41c:	dec00204 	addi	sp,sp,8
 800d420:	f800283a 	ret

0800d424 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 800d424:	defff904 	addi	sp,sp,-28
 800d428:	df000615 	stw	fp,24(sp)
 800d42c:	df000604 	addi	fp,sp,24
 800d430:	e13ffe15 	stw	r4,-8(fp)
 800d434:	e17fff15 	stw	r5,-4(fp)
 800d438:	e0bfff17 	ldw	r2,-4(fp)
 800d43c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800d440:	0005303a 	rdctl	r2,status
 800d444:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800d448:	e0fffb17 	ldw	r3,-20(fp)
 800d44c:	00bfff84 	movi	r2,-2
 800d450:	1884703a 	and	r2,r3,r2
 800d454:	1001703a 	wrctl	status,r2
  
  return context;
 800d458:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 800d45c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 800d460:	00c00044 	movi	r3,1
 800d464:	e0bffa17 	ldw	r2,-24(fp)
 800d468:	1884983a 	sll	r2,r3,r2
 800d46c:	1007883a 	mov	r3,r2
 800d470:	d0a77017 	ldw	r2,-25152(gp)
 800d474:	1884b03a 	or	r2,r3,r2
 800d478:	d0a77015 	stw	r2,-25152(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 800d47c:	d0a77017 	ldw	r2,-25152(gp)
 800d480:	100170fa 	wrctl	ienable,r2
 800d484:	e0bffc17 	ldw	r2,-16(fp)
 800d488:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800d48c:	e0bffd17 	ldw	r2,-12(fp)
 800d490:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 800d494:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 800d498:	0001883a 	nop
}
 800d49c:	e037883a 	mov	sp,fp
 800d4a0:	df000017 	ldw	fp,0(sp)
 800d4a4:	dec00104 	addi	sp,sp,4
 800d4a8:	f800283a 	ret

0800d4ac <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 800d4ac:	defff904 	addi	sp,sp,-28
 800d4b0:	df000615 	stw	fp,24(sp)
 800d4b4:	df000604 	addi	fp,sp,24
 800d4b8:	e13ffe15 	stw	r4,-8(fp)
 800d4bc:	e17fff15 	stw	r5,-4(fp)
 800d4c0:	e0bfff17 	ldw	r2,-4(fp)
 800d4c4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800d4c8:	0005303a 	rdctl	r2,status
 800d4cc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800d4d0:	e0fffb17 	ldw	r3,-20(fp)
 800d4d4:	00bfff84 	movi	r2,-2
 800d4d8:	1884703a 	and	r2,r3,r2
 800d4dc:	1001703a 	wrctl	status,r2
  
  return context;
 800d4e0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 800d4e4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 800d4e8:	00c00044 	movi	r3,1
 800d4ec:	e0bffa17 	ldw	r2,-24(fp)
 800d4f0:	1884983a 	sll	r2,r3,r2
 800d4f4:	0084303a 	nor	r2,zero,r2
 800d4f8:	1007883a 	mov	r3,r2
 800d4fc:	d0a77017 	ldw	r2,-25152(gp)
 800d500:	1884703a 	and	r2,r3,r2
 800d504:	d0a77015 	stw	r2,-25152(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 800d508:	d0a77017 	ldw	r2,-25152(gp)
 800d50c:	100170fa 	wrctl	ienable,r2
 800d510:	e0bffc17 	ldw	r2,-16(fp)
 800d514:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800d518:	e0bffd17 	ldw	r2,-12(fp)
 800d51c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 800d520:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 800d524:	0001883a 	nop
}
 800d528:	e037883a 	mov	sp,fp
 800d52c:	df000017 	ldw	fp,0(sp)
 800d530:	dec00104 	addi	sp,sp,4
 800d534:	f800283a 	ret

0800d538 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 800d538:	defffc04 	addi	sp,sp,-16
 800d53c:	df000315 	stw	fp,12(sp)
 800d540:	df000304 	addi	fp,sp,12
 800d544:	e13ffe15 	stw	r4,-8(fp)
 800d548:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 800d54c:	000530fa 	rdctl	r2,ienable
 800d550:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 800d554:	00c00044 	movi	r3,1
 800d558:	e0bfff17 	ldw	r2,-4(fp)
 800d55c:	1884983a 	sll	r2,r3,r2
 800d560:	1007883a 	mov	r3,r2
 800d564:	e0bffd17 	ldw	r2,-12(fp)
 800d568:	1884703a 	and	r2,r3,r2
 800d56c:	1004c03a 	cmpne	r2,r2,zero
 800d570:	10803fcc 	andi	r2,r2,255
}
 800d574:	e037883a 	mov	sp,fp
 800d578:	df000017 	ldw	fp,0(sp)
 800d57c:	dec00104 	addi	sp,sp,4
 800d580:	f800283a 	ret

0800d584 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 800d584:	defff504 	addi	sp,sp,-44
 800d588:	dfc00a15 	stw	ra,40(sp)
 800d58c:	df000915 	stw	fp,36(sp)
 800d590:	df000904 	addi	fp,sp,36
 800d594:	e13ffc15 	stw	r4,-16(fp)
 800d598:	e17ffd15 	stw	r5,-12(fp)
 800d59c:	e1bffe15 	stw	r6,-8(fp)
 800d5a0:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 800d5a4:	00bffa84 	movi	r2,-22
 800d5a8:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 800d5ac:	e0bffd17 	ldw	r2,-12(fp)
 800d5b0:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 800d5b4:	e0bff817 	ldw	r2,-32(fp)
 800d5b8:	10800808 	cmpgei	r2,r2,32
 800d5bc:	1000271e 	bne	r2,zero,800d65c <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800d5c0:	0005303a 	rdctl	r2,status
 800d5c4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800d5c8:	e0fffb17 	ldw	r3,-20(fp)
 800d5cc:	00bfff84 	movi	r2,-2
 800d5d0:	1884703a 	and	r2,r3,r2
 800d5d4:	1001703a 	wrctl	status,r2
  
  return context;
 800d5d8:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 800d5dc:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 800d5e0:	00820174 	movhi	r2,2053
 800d5e4:	10a7d804 	addi	r2,r2,-24736
 800d5e8:	e0fff817 	ldw	r3,-32(fp)
 800d5ec:	180690fa 	slli	r3,r3,3
 800d5f0:	10c5883a 	add	r2,r2,r3
 800d5f4:	e0fffe17 	ldw	r3,-8(fp)
 800d5f8:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 800d5fc:	00820174 	movhi	r2,2053
 800d600:	10a7d804 	addi	r2,r2,-24736
 800d604:	e0fff817 	ldw	r3,-32(fp)
 800d608:	180690fa 	slli	r3,r3,3
 800d60c:	10c5883a 	add	r2,r2,r3
 800d610:	10800104 	addi	r2,r2,4
 800d614:	e0ffff17 	ldw	r3,-4(fp)
 800d618:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 800d61c:	e0bffe17 	ldw	r2,-8(fp)
 800d620:	10000526 	beq	r2,zero,800d638 <alt_iic_isr_register+0xb4>
 800d624:	e0bff817 	ldw	r2,-32(fp)
 800d628:	100b883a 	mov	r5,r2
 800d62c:	e13ffc17 	ldw	r4,-16(fp)
 800d630:	800d4240 	call	800d424 <alt_ic_irq_enable>
 800d634:	00000406 	br	800d648 <alt_iic_isr_register+0xc4>
 800d638:	e0bff817 	ldw	r2,-32(fp)
 800d63c:	100b883a 	mov	r5,r2
 800d640:	e13ffc17 	ldw	r4,-16(fp)
 800d644:	800d4ac0 	call	800d4ac <alt_ic_irq_disable>
 800d648:	e0bff715 	stw	r2,-36(fp)
 800d64c:	e0bffa17 	ldw	r2,-24(fp)
 800d650:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800d654:	e0bff917 	ldw	r2,-28(fp)
 800d658:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 800d65c:	e0bff717 	ldw	r2,-36(fp)
}
 800d660:	e037883a 	mov	sp,fp
 800d664:	dfc00117 	ldw	ra,4(sp)
 800d668:	df000017 	ldw	fp,0(sp)
 800d66c:	dec00204 	addi	sp,sp,8
 800d670:	f800283a 	ret

0800d674 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 800d674:	deffff04 	addi	sp,sp,-4
 800d678:	df000015 	stw	fp,0(sp)
 800d67c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 800d680:	000170fa 	wrctl	ienable,zero
}
 800d684:	0001883a 	nop
 800d688:	e037883a 	mov	sp,fp
 800d68c:	df000017 	ldw	fp,0(sp)
 800d690:	dec00104 	addi	sp,sp,4
 800d694:	f800283a 	ret

0800d698 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 800d698:	defffb04 	addi	sp,sp,-20
 800d69c:	df000415 	stw	fp,16(sp)
 800d6a0:	df000404 	addi	fp,sp,16
 800d6a4:	e13ffe15 	stw	r4,-8(fp)
 800d6a8:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 800d6ac:	e0bfff17 	ldw	r2,-4(fp)
 800d6b0:	10840070 	cmpltui	r2,r2,4097
 800d6b4:	1000021e 	bne	r2,zero,800d6c0 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 800d6b8:	00840004 	movi	r2,4096
 800d6bc:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 800d6c0:	e0fffe17 	ldw	r3,-8(fp)
 800d6c4:	e0bfff17 	ldw	r2,-4(fp)
 800d6c8:	1885883a 	add	r2,r3,r2
 800d6cc:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 800d6d0:	e0bffe17 	ldw	r2,-8(fp)
 800d6d4:	e0bffc15 	stw	r2,-16(fp)
 800d6d8:	00000506 	br	800d6f0 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 800d6dc:	e0bffc17 	ldw	r2,-16(fp)
 800d6e0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 800d6e4:	e0bffc17 	ldw	r2,-16(fp)
 800d6e8:	10800804 	addi	r2,r2,32
 800d6ec:	e0bffc15 	stw	r2,-16(fp)
 800d6f0:	e0fffc17 	ldw	r3,-16(fp)
 800d6f4:	e0bffd17 	ldw	r2,-12(fp)
 800d6f8:	18bff836 	bltu	r3,r2,800d6dc <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 800d6fc:	e0bffe17 	ldw	r2,-8(fp)
 800d700:	108007cc 	andi	r2,r2,31
 800d704:	10000226 	beq	r2,zero,800d710 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 800d708:	e0bffc17 	ldw	r2,-16(fp)
 800d70c:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 800d710:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 800d714:	0001883a 	nop
 800d718:	e037883a 	mov	sp,fp
 800d71c:	df000017 	ldw	fp,0(sp)
 800d720:	dec00104 	addi	sp,sp,4
 800d724:	f800283a 	ret

0800d728 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 800d728:	defffe04 	addi	sp,sp,-8
 800d72c:	df000115 	stw	fp,4(sp)
 800d730:	df000104 	addi	fp,sp,4
 800d734:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 800d738:	e0bfff17 	ldw	r2,-4(fp)
 800d73c:	10bffe84 	addi	r2,r2,-6
 800d740:	10c00428 	cmpgeui	r3,r2,16
 800d744:	18001a1e 	bne	r3,zero,800d7b0 <alt_exception_cause_generated_bad_addr+0x88>
 800d748:	100690ba 	slli	r3,r2,2
 800d74c:	00820074 	movhi	r2,2049
 800d750:	10b5d804 	addi	r2,r2,-10400
 800d754:	1885883a 	add	r2,r3,r2
 800d758:	10800017 	ldw	r2,0(r2)
 800d75c:	1000683a 	jmp	r2
 800d760:	0800d7a0 	cmpeqi	zero,at,862
 800d764:	0800d7a0 	cmpeqi	zero,at,862
 800d768:	0800d7b0 	cmpltui	zero,at,862
 800d76c:	0800d7b0 	cmpltui	zero,at,862
 800d770:	0800d7b0 	cmpltui	zero,at,862
 800d774:	0800d7a0 	cmpeqi	zero,at,862
 800d778:	0800d7a8 	cmpgeui	zero,at,862
 800d77c:	0800d7b0 	cmpltui	zero,at,862
 800d780:	0800d7a0 	cmpeqi	zero,at,862
 800d784:	0800d7a0 	cmpeqi	zero,at,862
 800d788:	0800d7b0 	cmpltui	zero,at,862
 800d78c:	0800d7a0 	cmpeqi	zero,at,862
 800d790:	0800d7a8 	cmpgeui	zero,at,862
 800d794:	0800d7b0 	cmpltui	zero,at,862
 800d798:	0800d7b0 	cmpltui	zero,at,862
 800d79c:	0800d7a0 	cmpeqi	zero,at,862
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 800d7a0:	00800044 	movi	r2,1
 800d7a4:	00000306 	br	800d7b4 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 800d7a8:	0005883a 	mov	r2,zero
 800d7ac:	00000106 	br	800d7b4 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
 800d7b0:	0005883a 	mov	r2,zero
  }
}
 800d7b4:	e037883a 	mov	sp,fp
 800d7b8:	df000017 	ldw	fp,0(sp)
 800d7bc:	dec00104 	addi	sp,sp,4
 800d7c0:	f800283a 	ret

0800d7c4 <atexit>:

int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
 800d7c4:	defffd04 	addi	sp,sp,-12
 800d7c8:	dfc00215 	stw	ra,8(sp)
 800d7cc:	df000115 	stw	fp,4(sp)
 800d7d0:	df000104 	addi	fp,sp,4
 800d7d4:	e13fff15 	stw	r4,-4(fp)
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
 800d7d8:	000f883a 	mov	r7,zero
 800d7dc:	000d883a 	mov	r6,zero
 800d7e0:	e17fff17 	ldw	r5,-4(fp)
 800d7e4:	0009883a 	mov	r4,zero
 800d7e8:	800dabc0 	call	800dabc <__register_exitproc>
}
 800d7ec:	e037883a 	mov	sp,fp
 800d7f0:	dfc00117 	ldw	ra,4(sp)
 800d7f4:	df000017 	ldw	fp,0(sp)
 800d7f8:	dec00204 	addi	sp,sp,8
 800d7fc:	f800283a 	ret

0800d800 <exit>:
 */

void
_DEFUN (exit, (code),
	int code)
{
 800d800:	defffd04 	addi	sp,sp,-12
 800d804:	dfc00215 	stw	ra,8(sp)
 800d808:	df000115 	stw	fp,4(sp)
 800d80c:	df000104 	addi	fp,sp,4
 800d810:	e13fff15 	stw	r4,-4(fp)
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs _PARAMS ((int, _PTR)) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
 800d814:	000b883a 	mov	r5,zero
 800d818:	e13fff17 	ldw	r4,-4(fp)
 800d81c:	800dc2c0 	call	800dc2c <__call_exitprocs>

#ifndef WANT_SMALL_STDIO				/* AlteraSpecific */
  if (_GLOBAL_REENT->__cleanup)
 800d820:	d0a04317 	ldw	r2,-32500(gp)
 800d824:	10800f17 	ldw	r2,60(r2)
 800d828:	10000526 	beq	r2,zero,800d840 <exit+0x40>
    (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
 800d82c:	d0a04317 	ldw	r2,-32500(gp)
 800d830:	10800f17 	ldw	r2,60(r2)
 800d834:	d0e04317 	ldw	r3,-32500(gp)
 800d838:	1809883a 	mov	r4,r3
 800d83c:	103ee83a 	callr	r2
#endif							/* AlteraSpecific */
  _exit (code);
 800d840:	e13fff17 	ldw	r4,-4(fp)
 800d844:	800de180 	call	800de18 <_exit>

0800d848 <memcmp>:
int
_DEFUN (memcmp, (m1, m2, n),
	_CONST _PTR m1 _AND
	_CONST _PTR m2 _AND
	size_t n)
{
 800d848:	defff804 	addi	sp,sp,-32
 800d84c:	df000715 	stw	fp,28(sp)
 800d850:	df000704 	addi	fp,sp,28
 800d854:	e13ffd15 	stw	r4,-12(fp)
 800d858:	e17ffe15 	stw	r5,-8(fp)
 800d85c:	e1bfff15 	stw	r6,-4(fp)
      s1++;
      s2++;
    }
  return 0;
#else  
  unsigned char *s1 = (unsigned char *) m1;
 800d860:	e0bffd17 	ldw	r2,-12(fp)
 800d864:	e0bff915 	stw	r2,-28(fp)
  unsigned char *s2 = (unsigned char *) m2;
 800d868:	e0bffe17 	ldw	r2,-8(fp)
 800d86c:	e0bffa15 	stw	r2,-24(fp)
  unsigned long *a2;

  /* If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.  */
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
 800d870:	e0bfff17 	ldw	r2,-4(fp)
 800d874:	10800130 	cmpltui	r2,r2,4
 800d878:	1000371e 	bne	r2,zero,800d958 <memcmp+0x110>
 800d87c:	e0fff917 	ldw	r3,-28(fp)
 800d880:	e0bffa17 	ldw	r2,-24(fp)
 800d884:	1884b03a 	or	r2,r3,r2
 800d888:	108000cc 	andi	r2,r2,3
 800d88c:	1000321e 	bne	r2,zero,800d958 <memcmp+0x110>
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
 800d890:	e0bff917 	ldw	r2,-28(fp)
 800d894:	e0bffb15 	stw	r2,-20(fp)
      a2 = (unsigned long*) s2;
 800d898:	e0bffa17 	ldw	r2,-24(fp)
 800d89c:	e0bffc15 	stw	r2,-16(fp)
      while (n >= LBLOCKSIZE)
 800d8a0:	00000e06 	br	800d8dc <memcmp+0x94>
        {
          if (*a1 != *a2) 
 800d8a4:	e0bffb17 	ldw	r2,-20(fp)
 800d8a8:	10c00017 	ldw	r3,0(r2)
 800d8ac:	e0bffc17 	ldw	r2,-16(fp)
 800d8b0:	10800017 	ldw	r2,0(r2)
 800d8b4:	18800d1e 	bne	r3,r2,800d8ec <memcmp+0xa4>
   	    break;
          a1++;
 800d8b8:	e0bffb17 	ldw	r2,-20(fp)
 800d8bc:	10800104 	addi	r2,r2,4
 800d8c0:	e0bffb15 	stw	r2,-20(fp)
          a2++;
 800d8c4:	e0bffc17 	ldw	r2,-16(fp)
 800d8c8:	10800104 	addi	r2,r2,4
 800d8cc:	e0bffc15 	stw	r2,-16(fp)
          n -= LBLOCKSIZE;
 800d8d0:	e0bfff17 	ldw	r2,-4(fp)
 800d8d4:	10bfff04 	addi	r2,r2,-4
 800d8d8:	e0bfff15 	stw	r2,-4(fp)
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
      a2 = (unsigned long*) s2;
      while (n >= LBLOCKSIZE)
 800d8dc:	e0bfff17 	ldw	r2,-4(fp)
 800d8e0:	10800128 	cmpgeui	r2,r2,4
 800d8e4:	103fef1e 	bne	r2,zero,800d8a4 <memcmp+0x5c>
 800d8e8:	00000106 	br	800d8f0 <memcmp+0xa8>
        {
          if (*a1 != *a2) 
   	    break;
 800d8ec:	0001883a 	nop
          n -= LBLOCKSIZE;
        }

      /* check m mod LBLOCKSIZE remaining characters */

      s1 = (unsigned char*)a1;
 800d8f0:	e0bffb17 	ldw	r2,-20(fp)
 800d8f4:	e0bff915 	stw	r2,-28(fp)
      s2 = (unsigned char*)a2;
 800d8f8:	e0bffc17 	ldw	r2,-16(fp)
 800d8fc:	e0bffa15 	stw	r2,-24(fp)
    }

  while (n--)
 800d900:	00001506 	br	800d958 <memcmp+0x110>
    {
      if (*s1 != *s2)
 800d904:	e0bff917 	ldw	r2,-28(fp)
 800d908:	10c00003 	ldbu	r3,0(r2)
 800d90c:	e0bffa17 	ldw	r2,-24(fp)
 800d910:	10800003 	ldbu	r2,0(r2)
 800d914:	18c03fcc 	andi	r3,r3,255
 800d918:	10803fcc 	andi	r2,r2,255
 800d91c:	18800826 	beq	r3,r2,800d940 <memcmp+0xf8>
	return *s1 - *s2;
 800d920:	e0bff917 	ldw	r2,-28(fp)
 800d924:	10800003 	ldbu	r2,0(r2)
 800d928:	10c03fcc 	andi	r3,r2,255
 800d92c:	e0bffa17 	ldw	r2,-24(fp)
 800d930:	10800003 	ldbu	r2,0(r2)
 800d934:	10803fcc 	andi	r2,r2,255
 800d938:	1885c83a 	sub	r2,r3,r2
 800d93c:	00000b06 	br	800d96c <memcmp+0x124>
      s1++;
 800d940:	e0bff917 	ldw	r2,-28(fp)
 800d944:	10800044 	addi	r2,r2,1
 800d948:	e0bff915 	stw	r2,-28(fp)
      s2++;
 800d94c:	e0bffa17 	ldw	r2,-24(fp)
 800d950:	10800044 	addi	r2,r2,1
 800d954:	e0bffa15 	stw	r2,-24(fp)

      s1 = (unsigned char*)a1;
      s2 = (unsigned char*)a2;
    }

  while (n--)
 800d958:	e0bfff17 	ldw	r2,-4(fp)
 800d95c:	10ffffc4 	addi	r3,r2,-1
 800d960:	e0ffff15 	stw	r3,-4(fp)
 800d964:	103fe71e 	bne	r2,zero,800d904 <memcmp+0xbc>
	return *s1 - *s2;
      s1++;
      s2++;
    }

  return 0;
 800d968:	0005883a 	mov	r2,zero
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 800d96c:	e037883a 	mov	sp,fp
 800d970:	df000017 	ldw	fp,0(sp)
 800d974:	dec00104 	addi	sp,sp,4
 800d978:	f800283a 	ret

0800d97c <strcmp>:

int
_DEFUN (strcmp, (s1, s2),
	_CONST char *s1 _AND
	_CONST char *s2)
{ 
 800d97c:	defffb04 	addi	sp,sp,-20
 800d980:	df000415 	stw	fp,16(sp)
 800d984:	df000404 	addi	fp,sp,16
 800d988:	e13ffe15 	stw	r4,-8(fp)
 800d98c:	e17fff15 	stw	r5,-4(fp)
#else
  unsigned long *a1;
  unsigned long *a2;

  /* If s1 or s2 are unaligned, then compare bytes. */
  if (!UNALIGNED (s1, s2))
 800d990:	e0fffe17 	ldw	r3,-8(fp)
 800d994:	e0bfff17 	ldw	r2,-4(fp)
 800d998:	1884b03a 	or	r2,r3,r2
 800d99c:	108000cc 	andi	r2,r2,3
 800d9a0:	10002a1e 	bne	r2,zero,800da4c <strcmp+0xd0>
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
 800d9a4:	e0bffe17 	ldw	r2,-8(fp)
 800d9a8:	e0bffc15 	stw	r2,-16(fp)
      a2 = (unsigned long*)s2;
 800d9ac:	e0bfff17 	ldw	r2,-4(fp)
 800d9b0:	e0bffd15 	stw	r2,-12(fp)
      while (*a1 == *a2)
 800d9b4:	00001506 	br	800da0c <strcmp+0x90>
        {
          /* To get here, *a1 == *a2, thus if we find a null in *a1,
	     then the strings must be equal, so return zero.  */
          if (DETECTNULL (*a1))
 800d9b8:	e0bffc17 	ldw	r2,-16(fp)
 800d9bc:	10c00017 	ldw	r3,0(r2)
 800d9c0:	00bfbff4 	movhi	r2,65279
 800d9c4:	10bfbfc4 	addi	r2,r2,-257
 800d9c8:	1887883a 	add	r3,r3,r2
 800d9cc:	e0bffc17 	ldw	r2,-16(fp)
 800d9d0:	10800017 	ldw	r2,0(r2)
 800d9d4:	0084303a 	nor	r2,zero,r2
 800d9d8:	1886703a 	and	r3,r3,r2
 800d9dc:	00a02074 	movhi	r2,32897
 800d9e0:	10a02004 	addi	r2,r2,-32640
 800d9e4:	1884703a 	and	r2,r3,r2
 800d9e8:	10000226 	beq	r2,zero,800d9f4 <strcmp+0x78>
	    return 0;
 800d9ec:	0005883a 	mov	r2,zero
 800d9f0:	00002e06 	br	800daac <strcmp+0x130>

          a1++;
 800d9f4:	e0bffc17 	ldw	r2,-16(fp)
 800d9f8:	10800104 	addi	r2,r2,4
 800d9fc:	e0bffc15 	stw	r2,-16(fp)
          a2++;
 800da00:	e0bffd17 	ldw	r2,-12(fp)
 800da04:	10800104 	addi	r2,r2,4
 800da08:	e0bffd15 	stw	r2,-12(fp)
  if (!UNALIGNED (s1, s2))
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
      a2 = (unsigned long*)s2;
      while (*a1 == *a2)
 800da0c:	e0bffc17 	ldw	r2,-16(fp)
 800da10:	10c00017 	ldw	r3,0(r2)
 800da14:	e0bffd17 	ldw	r2,-12(fp)
 800da18:	10800017 	ldw	r2,0(r2)
 800da1c:	18bfe626 	beq	r3,r2,800d9b8 <strcmp+0x3c>
          a1++;
          a2++;
        }

      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
 800da20:	e0bffc17 	ldw	r2,-16(fp)
 800da24:	e0bffe15 	stw	r2,-8(fp)
      s2 = (char*)a2;
 800da28:	e0bffd17 	ldw	r2,-12(fp)
 800da2c:	e0bfff15 	stw	r2,-4(fp)
    }

  while (*s1 != '\0' && *s1 == *s2)
 800da30:	00000606 	br	800da4c <strcmp+0xd0>
    {
      s1++;
 800da34:	e0bffe17 	ldw	r2,-8(fp)
 800da38:	10800044 	addi	r2,r2,1
 800da3c:	e0bffe15 	stw	r2,-8(fp)
      s2++;
 800da40:	e0bfff17 	ldw	r2,-4(fp)
 800da44:	10800044 	addi	r2,r2,1
 800da48:	e0bfff15 	stw	r2,-4(fp)
      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
      s2 = (char*)a2;
    }

  while (*s1 != '\0' && *s1 == *s2)
 800da4c:	e0bffe17 	ldw	r2,-8(fp)
 800da50:	10800003 	ldbu	r2,0(r2)
 800da54:	10803fcc 	andi	r2,r2,255
 800da58:	1080201c 	xori	r2,r2,128
 800da5c:	10bfe004 	addi	r2,r2,-128
 800da60:	10000b26 	beq	r2,zero,800da90 <strcmp+0x114>
 800da64:	e0bffe17 	ldw	r2,-8(fp)
 800da68:	10c00003 	ldbu	r3,0(r2)
 800da6c:	e0bfff17 	ldw	r2,-4(fp)
 800da70:	10800003 	ldbu	r2,0(r2)
 800da74:	18c03fcc 	andi	r3,r3,255
 800da78:	18c0201c 	xori	r3,r3,128
 800da7c:	18ffe004 	addi	r3,r3,-128
 800da80:	10803fcc 	andi	r2,r2,255
 800da84:	1080201c 	xori	r2,r2,128
 800da88:	10bfe004 	addi	r2,r2,-128
 800da8c:	18bfe926 	beq	r3,r2,800da34 <strcmp+0xb8>
    {
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 800da90:	e0bffe17 	ldw	r2,-8(fp)
 800da94:	10800003 	ldbu	r2,0(r2)
 800da98:	10c03fcc 	andi	r3,r2,255
 800da9c:	e0bfff17 	ldw	r2,-4(fp)
 800daa0:	10800003 	ldbu	r2,0(r2)
 800daa4:	10803fcc 	andi	r2,r2,255
 800daa8:	1885c83a 	sub	r2,r3,r2
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 800daac:	e037883a 	mov	sp,fp
 800dab0:	df000017 	ldw	fp,0(sp)
 800dab4:	dec00104 	addi	sp,sp,4
 800dab8:	f800283a 	ret

0800dabc <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
 800dabc:	defff804 	addi	sp,sp,-32
 800dac0:	dfc00715 	stw	ra,28(sp)
 800dac4:	df000615 	stw	fp,24(sp)
 800dac8:	dc000515 	stw	r16,20(sp)
 800dacc:	df000604 	addi	fp,sp,24
 800dad0:	e13ffb15 	stw	r4,-20(fp)
 800dad4:	e17ffc15 	stw	r5,-16(fp)
 800dad8:	e1bffd15 	stw	r6,-12(fp)
 800dadc:	e1fffe15 	stw	r7,-8(fp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
 800dae0:	d0a04317 	ldw	r2,-32500(gp)
 800dae4:	14005217 	ldw	r16,328(r2)
  if (p == NULL)
 800dae8:	8000041e 	bne	r16,zero,800dafc <__register_exitproc+0x40>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
 800daec:	d0a04317 	ldw	r2,-32500(gp)
 800daf0:	d0e04317 	ldw	r3,-32500(gp)
 800daf4:	1c005304 	addi	r16,r3,332
 800daf8:	14005215 	stw	r16,328(r2)
  if (p->_ind >= _ATEXIT_SIZE)
 800dafc:	80800117 	ldw	r2,4(r16)
 800db00:	10800810 	cmplti	r2,r2,32
 800db04:	1000131e 	bne	r2,zero,800db54 <__register_exitproc+0x98>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
 800db08:	00800034 	movhi	r2,0
 800db0c:	10800004 	addi	r2,r2,0
 800db10:	1000021e 	bne	r2,zero,800db1c <__register_exitproc+0x60>
	return -1;
 800db14:	00bfffc4 	movi	r2,-1
 800db18:	00003e06 	br	800dc14 <__register_exitproc+0x158>

      p = (struct _atexit *) malloc (sizeof *p);
 800db1c:	01006404 	movi	r4,400
 800db20:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>
 800db24:	1021883a 	mov	r16,r2
      if (p == NULL)
 800db28:	8000021e 	bne	r16,zero,800db34 <__register_exitproc+0x78>
	{
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
 800db2c:	00bfffc4 	movi	r2,-1
 800db30:	00003806 	br	800dc14 <__register_exitproc+0x158>
	}
      p->_ind = 0;
 800db34:	80000115 	stw	zero,4(r16)
      p->_next = _GLOBAL_ATEXIT;
 800db38:	d0a04317 	ldw	r2,-32500(gp)
 800db3c:	10805217 	ldw	r2,328(r2)
 800db40:	80800015 	stw	r2,0(r16)
      _GLOBAL_ATEXIT = p;
 800db44:	d0a04317 	ldw	r2,-32500(gp)
 800db48:	14005215 	stw	r16,328(r2)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
 800db4c:	80006215 	stw	zero,392(r16)
      p->_on_exit_args._is_cxa = 0;
 800db50:	80006315 	stw	zero,396(r16)
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
 800db54:	e0bffb17 	ldw	r2,-20(fp)
 800db58:	10002426 	beq	r2,zero,800dbec <__register_exitproc+0x130>
	  args->_fntypes = 0;
	  args->_is_cxa = 0;
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
 800db5c:	80802204 	addi	r2,r16,136
 800db60:	e0bffa15 	stw	r2,-24(fp)
#endif
      args->_fnargs[p->_ind] = arg;
 800db64:	80800117 	ldw	r2,4(r16)
 800db68:	e0fffa17 	ldw	r3,-24(fp)
 800db6c:	1085883a 	add	r2,r2,r2
 800db70:	1085883a 	add	r2,r2,r2
 800db74:	1885883a 	add	r2,r3,r2
 800db78:	e0fffd17 	ldw	r3,-12(fp)
 800db7c:	10c00015 	stw	r3,0(r2)
      args->_fntypes |= (1 << p->_ind);
 800db80:	e0bffa17 	ldw	r2,-24(fp)
 800db84:	10804017 	ldw	r2,256(r2)
 800db88:	80c00117 	ldw	r3,4(r16)
 800db8c:	01000044 	movi	r4,1
 800db90:	20c6983a 	sll	r3,r4,r3
 800db94:	10c6b03a 	or	r3,r2,r3
 800db98:	e0bffa17 	ldw	r2,-24(fp)
 800db9c:	10c04015 	stw	r3,256(r2)
      args->_dso_handle[p->_ind] = d;
 800dba0:	80800117 	ldw	r2,4(r16)
 800dba4:	e0fffa17 	ldw	r3,-24(fp)
 800dba8:	10800804 	addi	r2,r2,32
 800dbac:	1085883a 	add	r2,r2,r2
 800dbb0:	1085883a 	add	r2,r2,r2
 800dbb4:	1885883a 	add	r2,r3,r2
 800dbb8:	e0fffe17 	ldw	r3,-8(fp)
 800dbbc:	10c00015 	stw	r3,0(r2)
      if (type == __et_cxa)
 800dbc0:	e0bffb17 	ldw	r2,-20(fp)
 800dbc4:	10800098 	cmpnei	r2,r2,2
 800dbc8:	1000081e 	bne	r2,zero,800dbec <__register_exitproc+0x130>
	args->_is_cxa |= (1 << p->_ind);
 800dbcc:	e0bffa17 	ldw	r2,-24(fp)
 800dbd0:	10804117 	ldw	r2,260(r2)
 800dbd4:	80c00117 	ldw	r3,4(r16)
 800dbd8:	01000044 	movi	r4,1
 800dbdc:	20c6983a 	sll	r3,r4,r3
 800dbe0:	10c6b03a 	or	r3,r2,r3
 800dbe4:	e0bffa17 	ldw	r2,-24(fp)
 800dbe8:	10c04115 	stw	r3,260(r2)
    }
  p->_fns[p->_ind++] = fn;
 800dbec:	80800117 	ldw	r2,4(r16)
 800dbf0:	10c00044 	addi	r3,r2,1
 800dbf4:	80c00115 	stw	r3,4(r16)
 800dbf8:	10800084 	addi	r2,r2,2
 800dbfc:	1085883a 	add	r2,r2,r2
 800dc00:	1085883a 	add	r2,r2,r2
 800dc04:	8085883a 	add	r2,r16,r2
 800dc08:	e0fffc17 	ldw	r3,-16(fp)
 800dc0c:	10c00015 	stw	r3,0(r2)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
 800dc10:	0005883a 	mov	r2,zero
}
 800dc14:	e6ffff04 	addi	sp,fp,-4
 800dc18:	dfc00217 	ldw	ra,8(sp)
 800dc1c:	df000117 	ldw	fp,4(sp)
 800dc20:	dc000017 	ldw	r16,0(sp)
 800dc24:	dec00304 	addi	sp,sp,12
 800dc28:	f800283a 	ret

0800dc2c <__call_exitprocs>:
 */

void 
_DEFUN (__call_exitprocs, (code, d),
	int code _AND _PTR d)
{
 800dc2c:	defff504 	addi	sp,sp,-44
 800dc30:	dfc00a15 	stw	ra,40(sp)
 800dc34:	df000915 	stw	fp,36(sp)
 800dc38:	dc800815 	stw	r18,32(sp)
 800dc3c:	dc400715 	stw	r17,28(sp)
 800dc40:	dc000615 	stw	r16,24(sp)
 800dc44:	df000904 	addi	fp,sp,36
 800dc48:	e13ffb15 	stw	r4,-20(fp)
 800dc4c:	e17ffc15 	stw	r5,-16(fp)
  __lock_acquire_recursive(__atexit_lock);
#endif

 restart:

  p = _GLOBAL_ATEXIT;
 800dc50:	d0a04317 	ldw	r2,-32500(gp)
 800dc54:	14005217 	ldw	r16,328(r2)
  lastp = &_GLOBAL_ATEXIT;
 800dc58:	d0a04317 	ldw	r2,-32500(gp)
 800dc5c:	10805204 	addi	r2,r2,328
 800dc60:	e0bff715 	stw	r2,-36(fp)
  while (p)
 800dc64:	00006006 	br	800dde8 <__call_exitprocs+0x1bc>
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
 800dc68:	84802204 	addi	r18,r16,136
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 800dc6c:	80800117 	ldw	r2,4(r16)
 800dc70:	147fffc4 	addi	r17,r2,-1
 800dc74:	00004a06 	br	800dda0 <__call_exitprocs+0x174>
	{
	  int ind;

	  i = 1 << n;
 800dc78:	00800044 	movi	r2,1
 800dc7c:	1444983a 	sll	r2,r2,r17
 800dc80:	e0bff815 	stw	r2,-32(fp)

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
 800dc84:	e0bffc17 	ldw	r2,-16(fp)
 800dc88:	10000826 	beq	r2,zero,800dcac <__call_exitprocs+0x80>
 800dc8c:	90004026 	beq	r18,zero,800dd90 <__call_exitprocs+0x164>
 800dc90:	88800804 	addi	r2,r17,32
 800dc94:	1085883a 	add	r2,r2,r2
 800dc98:	1085883a 	add	r2,r2,r2
 800dc9c:	9085883a 	add	r2,r18,r2
 800dca0:	10c00017 	ldw	r3,0(r2)
 800dca4:	e0bffc17 	ldw	r2,-16(fp)
 800dca8:	1880391e 	bne	r3,r2,800dd90 <__call_exitprocs+0x164>
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
 800dcac:	88800084 	addi	r2,r17,2
 800dcb0:	1085883a 	add	r2,r2,r2
 800dcb4:	1085883a 	add	r2,r2,r2
 800dcb8:	8085883a 	add	r2,r16,r2
 800dcbc:	10800017 	ldw	r2,0(r2)
 800dcc0:	e0bff915 	stw	r2,-28(fp)
	  if (n == p->_ind - 1)
 800dcc4:	80800117 	ldw	r2,4(r16)
 800dcc8:	10bfffc4 	addi	r2,r2,-1
 800dccc:	1440041e 	bne	r2,r17,800dce0 <__call_exitprocs+0xb4>
	    p->_ind--;
 800dcd0:	80800117 	ldw	r2,4(r16)
 800dcd4:	10bfffc4 	addi	r2,r2,-1
 800dcd8:	80800115 	stw	r2,4(r16)
 800dcdc:	00000506 	br	800dcf4 <__call_exitprocs+0xc8>
	  else
	    p->_fns[n] = NULL;
 800dce0:	88800084 	addi	r2,r17,2
 800dce4:	1085883a 	add	r2,r2,r2
 800dce8:	1085883a 	add	r2,r2,r2
 800dcec:	8085883a 	add	r2,r16,r2
 800dcf0:	10000015 	stw	zero,0(r2)

	  /* Skip functions that have already been called.  */
	  if (!fn)
 800dcf4:	e0bff917 	ldw	r2,-28(fp)
 800dcf8:	10002726 	beq	r2,zero,800dd98 <__call_exitprocs+0x16c>
	    continue;

	  ind = p->_ind;
 800dcfc:	80800117 	ldw	r2,4(r16)
 800dd00:	e0bffa15 	stw	r2,-24(fp)

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
 800dd04:	90000426 	beq	r18,zero,800dd18 <__call_exitprocs+0xec>
 800dd08:	90c04017 	ldw	r3,256(r18)
 800dd0c:	e0bff817 	ldw	r2,-32(fp)
 800dd10:	1884703a 	and	r2,r3,r2
 800dd14:	1000031e 	bne	r2,zero,800dd24 <__call_exitprocs+0xf8>
	    fn ();
 800dd18:	e0bff917 	ldw	r2,-28(fp)
 800dd1c:	103ee83a 	callr	r2
 800dd20:	00001406 	br	800dd74 <__call_exitprocs+0x148>
	  else if ((args->_is_cxa & i) == 0)
 800dd24:	90c04117 	ldw	r3,260(r18)
 800dd28:	e0bff817 	ldw	r2,-32(fp)
 800dd2c:	1884703a 	and	r2,r3,r2
 800dd30:	1000091e 	bne	r2,zero,800dd58 <__call_exitprocs+0x12c>
	    (*((void (*)(int, _PTR)) fn))(code, args->_fnargs[n]);
 800dd34:	8c45883a 	add	r2,r17,r17
 800dd38:	1085883a 	add	r2,r2,r2
 800dd3c:	9085883a 	add	r2,r18,r2
 800dd40:	10c00017 	ldw	r3,0(r2)
 800dd44:	e0bff917 	ldw	r2,-28(fp)
 800dd48:	180b883a 	mov	r5,r3
 800dd4c:	e13ffb17 	ldw	r4,-20(fp)
 800dd50:	103ee83a 	callr	r2
 800dd54:	00000706 	br	800dd74 <__call_exitprocs+0x148>
	  else
	    (*((void (*)(_PTR)) fn))(args->_fnargs[n]);
 800dd58:	8c45883a 	add	r2,r17,r17
 800dd5c:	1085883a 	add	r2,r2,r2
 800dd60:	9085883a 	add	r2,r18,r2
 800dd64:	10c00017 	ldw	r3,0(r2)
 800dd68:	e0bff917 	ldw	r2,-28(fp)
 800dd6c:	1809883a 	mov	r4,r3
 800dd70:	103ee83a 	callr	r2

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
 800dd74:	80c00117 	ldw	r3,4(r16)
 800dd78:	e0bffa17 	ldw	r2,-24(fp)
 800dd7c:	18bfb41e 	bne	r3,r2,800dc50 <__call_exitprocs+0x24>
 800dd80:	e0bff717 	ldw	r2,-36(fp)
 800dd84:	10800017 	ldw	r2,0(r2)
 800dd88:	143fb11e 	bne	r2,r16,800dc50 <__call_exitprocs+0x24>
 800dd8c:	00000306 	br	800dd9c <__call_exitprocs+0x170>

	  i = 1 << n;

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
	    continue;
 800dd90:	0001883a 	nop
 800dd94:	00000106 	br	800dd9c <__call_exitprocs+0x170>
	  else
	    p->_fns[n] = NULL;

	  /* Skip functions that have already been called.  */
	  if (!fn)
	    continue;
 800dd98:	0001883a 	nop
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 800dd9c:	8c7fffc4 	addi	r17,r17,-1
 800dda0:	883fb50e 	bge	r17,zero,800dc78 <__call_exitprocs+0x4c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
 800dda4:	00800034 	movhi	r2,0
 800dda8:	10800004 	addi	r2,r2,0
 800ddac:	10001026 	beq	r2,zero,800ddf0 <__call_exitprocs+0x1c4>
	break;

      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
 800ddb0:	80800117 	ldw	r2,4(r16)
 800ddb4:	10000a1e 	bne	r2,zero,800dde0 <__call_exitprocs+0x1b4>
 800ddb8:	80800017 	ldw	r2,0(r16)
 800ddbc:	10000826 	beq	r2,zero,800dde0 <__call_exitprocs+0x1b4>
	{
	  /* Remove empty block from the list.  */
	  *lastp = p->_next;
 800ddc0:	80c00017 	ldw	r3,0(r16)
 800ddc4:	e0bff717 	ldw	r2,-36(fp)
 800ddc8:	10c00015 	stw	r3,0(r2)
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
 800ddcc:	8009883a 	mov	r4,r16
 800ddd0:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x8000000>
	  p = *lastp;
 800ddd4:	e0bff717 	ldw	r2,-36(fp)
 800ddd8:	14000017 	ldw	r16,0(r2)
 800dddc:	00000206 	br	800dde8 <__call_exitprocs+0x1bc>
	}
      else
	{
	  lastp = &p->_next;
 800dde0:	e43ff715 	stw	r16,-36(fp)
	  p = p->_next;
 800dde4:	84000017 	ldw	r16,0(r16)

 restart:

  p = _GLOBAL_ATEXIT;
  lastp = &_GLOBAL_ATEXIT;
  while (p)
 800dde8:	803f9f1e 	bne	r16,zero,800dc68 <__call_exitprocs+0x3c>
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
 800ddec:	00000106 	br	800ddf4 <__call_exitprocs+0x1c8>
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
	break;
 800ddf0:	0001883a 	nop
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
 800ddf4:	0001883a 	nop
 800ddf8:	e6fffd04 	addi	sp,fp,-12
 800ddfc:	dfc00417 	ldw	ra,16(sp)
 800de00:	df000317 	ldw	fp,12(sp)
 800de04:	dc800217 	ldw	r18,8(sp)
 800de08:	dc400117 	ldw	r17,4(sp)
 800de0c:	dc000017 	ldw	r16,0(sp)
 800de10:	dec00504 	addi	sp,sp,20
 800de14:	f800283a 	ret

0800de18 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 800de18:	defffd04 	addi	sp,sp,-12
 800de1c:	df000215 	stw	fp,8(sp)
 800de20:	df000204 	addi	fp,sp,8
 800de24:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 800de28:	0001883a 	nop
 800de2c:	e0bfff17 	ldw	r2,-4(fp)
 800de30:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 800de34:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 800de38:	10000226 	beq	r2,zero,800de44 <_exit+0x2c>
    ALT_SIM_FAIL();
 800de3c:	002af070 	cmpltui	zero,zero,43969
 800de40:	00000106 	br	800de48 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 800de44:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 800de48:	003fff06 	br	800de48 <_exit+0x30>
